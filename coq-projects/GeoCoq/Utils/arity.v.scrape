From Coq Require Import Arith.
-----
Require Import NArith.
-----
From Coq Require Import List.
-----
Require Import Sorting.
-----
Require Import Coq.Program.Equality.
-----
Lemma minus_n_0 : forall n, n-0 = n.
-----
Lemma minus_n_0 : forall n, n-0 = n.

*****

*****
forall n : nat, eq (Init.Nat.sub n O) n
+++++
Proof.
-----
Lemma minus_n_0 : forall n, n-0 = n.
Proof.

*****

*****
forall n : nat, eq (Init.Nat.sub n O) n
+++++
induction n.
-----
Lemma minus_n_0 : forall n, n-0 = n.
Proof.
induction n.

*****

*****
eq (Init.Nat.sub O O) O
+++++
trivial.
-----
Lemma minus_n_0 : forall n, n-0 = n.
Proof.
induction n.

*****
IHn : eq (Init.Nat.sub n O) n
n : nat
*****
eq (Init.Nat.sub (S n) O) (S n)
+++++
trivial.
-----
Lemma minus_n_0 : forall n, n-0 = n.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma plus_0_n : forall n, 0+n = n.
-----
Lemma plus_0_n : forall n, 0+n = n.

*****

*****
forall n : nat, eq (Init.Nat.add O n) n
+++++
Proof.
-----
Lemma plus_0_n : forall n, 0+n = n.
Proof.

*****

*****
forall n : nat, eq (Init.Nat.add O n) n
+++++
induction n.
-----
Lemma plus_0_n : forall n, 0+n = n.
Proof.
induction n.

*****

*****
eq (Init.Nat.add O O) O
+++++
trivial.
-----
Lemma plus_0_n : forall n, 0+n = n.
Proof.
induction n.

*****
IHn : eq (Init.Nat.add O n) n
n : nat
*****
eq (Init.Nat.add O (S n)) (S n)
+++++
trivial.
-----
Lemma plus_0_n : forall n, 0+n = n.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma plus_n_0 : forall n, n+0 = n.
-----
Lemma plus_n_0 : forall n, n+0 = n.

*****

*****
forall n : nat, eq (Init.Nat.add n O) n
+++++
Proof.
-----
Lemma plus_n_0 : forall n, n+0 = n.
Proof.

*****

*****
forall n : nat, eq (Init.Nat.add n O) n
+++++
induction n.
-----
Lemma plus_n_0 : forall n, n+0 = n.
Proof.
induction n.

*****

*****
eq (Init.Nat.add O O) O
+++++
trivial.
-----
Lemma plus_n_0 : forall n, n+0 = n.
Proof.
induction n.

*****
IHn : eq (Init.Nat.add n O) n
n : nat
*****
eq (Init.Nat.add (S n) O) (S n)
+++++
trivial.
-----
Lemma plus_n_0 : forall n, n+0 = n.
Proof.
induction n.
trivial.

*****
IHn : eq (Init.Nat.add n O) n
n : nat
*****
eq (Init.Nat.add (S n) O) (S n)
+++++
simpl.
-----
Lemma plus_n_0 : forall n, n+0 = n.
Proof.
induction n.
trivial.
simpl.

*****
IHn : eq (Init.Nat.add n O) n
n : nat
*****
eq (S (Init.Nat.add n O)) (S n)
+++++
rewrite IHn.
-----
Lemma plus_n_0 : forall n, n+0 = n.
Proof.
induction n.
trivial.
simpl.
rewrite IHn.

*****
IHn : eq (Init.Nat.add n O) n
n : nat
*****
eq (S n) (S n)
+++++
reflexivity.
-----
Lemma plus_n_0 : forall n, n+0 = n.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma plus_n_1 : forall n, n+1 = S n.
-----
Lemma plus_n_1 : forall n, n+1 = S n.

*****

*****
forall n : nat, eq (Init.Nat.add n (S O)) (S n)
+++++
Proof.
-----
Lemma plus_n_1 : forall n, n+1 = S n.
Proof.

*****

*****
forall n : nat, eq (Init.Nat.add n (S O)) (S n)
+++++
induction n.
-----
Lemma plus_n_1 : forall n, n+1 = S n.
Proof.
induction n.

*****

*****
eq (Init.Nat.add O (S O)) (S O)
+++++
trivial.
-----
Lemma plus_n_1 : forall n, n+1 = S n.
Proof.
induction n.

*****
IHn : eq (Init.Nat.add n (S O)) (S n)
n : nat
*****
eq (Init.Nat.add (S n) (S O)) (S (S n))
+++++
trivial.
-----
Lemma plus_n_1 : forall n, n+1 = S n.
Proof.
induction n.
trivial.

*****
IHn : eq (Init.Nat.add n (S O)) (S n)
n : nat
*****
eq (Init.Nat.add (S n) (S O)) (S (S n))
+++++
simpl.
-----
Lemma plus_n_1 : forall n, n+1 = S n.
Proof.
induction n.
trivial.
simpl.

*****
IHn : eq (Init.Nat.add n (S O)) (S n)
n : nat
*****
eq (S (Init.Nat.add n (S O))) (S (S n))
+++++
rewrite IHn.
-----
Lemma plus_n_1 : forall n, n+1 = S n.
Proof.
induction n.
trivial.
simpl.
rewrite IHn.

*****
IHn : eq (Init.Nat.add n (S O)) (S n)
n : nat
*****
eq (S (S n)) (S (S n))
+++++
reflexivity.
-----
Lemma plus_n_1 : forall n, n+1 = S n.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.

*****

*****
forall n1 n2 : nat, eq (Init.Nat.sub (Init.Nat.add n1 n2) O) (Init.Nat.add n1 n2)
+++++
Proof.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.
Proof.

*****

*****
forall n1 n2 : nat, eq (Init.Nat.sub (Init.Nat.add n1 n2) O) (Init.Nat.add n1 n2)
+++++
induction n1.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.
Proof.
induction n1.

*****

*****
forall n2 : nat, eq (Init.Nat.sub (Init.Nat.add O n2) O) (Init.Nat.add O n2)
+++++
induction n2.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.
Proof.
induction n1.
induction n2.

*****

*****
eq (Init.Nat.sub (Init.Nat.add O O) O) (Init.Nat.add O O)
+++++
trivial.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.
Proof.
induction n1.
induction n2.

*****
IHn2 : eq (Init.Nat.sub (Init.Nat.add O n2) O) (Init.Nat.add O n2)
n2 : nat
*****
eq (Init.Nat.sub (Init.Nat.add O (S n2)) O) (Init.Nat.add O (S n2))
+++++
trivial.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.
Proof.
induction n1.

*****
IHn1 : forall n2 : nat,\neq (Init.Nat.sub (Init.Nat.add n1 n2) O) (Init.Nat.add n1 n2)
n1 : nat
*****
forall n2 : nat, eq (Init.Nat.sub (Init.Nat.add (S n1) n2) O) (Init.Nat.add (S n1) n2)
+++++
induction n2.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.
Proof.
induction n1.
induction n2.

*****
IHn1 : forall n2 : nat,\neq (Init.Nat.sub (Init.Nat.add n1 n2) O) (Init.Nat.add n1 n2)
n1 : nat
*****
eq (Init.Nat.sub (Init.Nat.add (S n1) O) O) (Init.Nat.add (S n1) O)
+++++
trivial.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.
Proof.
induction n1.
induction n2.

*****
IHn2 : eq (Init.Nat.sub (Init.Nat.add (S n1) n2) O) (Init.Nat.add (S n1) n2)
n2 : nat
IHn1 : forall n2 : nat,\neq (Init.Nat.sub (Init.Nat.add n1 n2) O) (Init.Nat.add n1 n2)
n1 : nat
*****
eq (Init.Nat.sub (Init.Nat.add (S n1) (S n2)) O) (Init.Nat.add (S n1) (S n2))
+++++
trivial.
-----
Lemma minus_n1_n2_0 : forall n1 n2, n1+n2-0 = n1+n2.
Proof.
induction n1.

*****

*****

+++++
Defined.
-----
Fixpoint arity (T:Type) (n:nat) :=\n match n with\n | 0 => Prop\n | S p => T -> arity T p\n end.
-----
Fixpoint cartesianPowerAux (T:Type) (n:nat) :=\n match n with\n | 0 => T\n | S p => (T * cartesianPowerAux T p)%type\n end.
-----
Definition cartesianPower T n := cartesianPowerAux T (n-1).
-----
Definition headCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
-----
Definition headCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
T
+++++
Proof.
-----
Definition headCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
Proof.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
T
+++++
induction n.
-----
Definition headCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
Proof.
induction n.

*****
cp : cartesianPower T (S O)
T : Type
*****
T
+++++
exact cp.
-----
Definition headCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
Proof.
induction n.

*****
IHn : forall _ : cartesianPower T (S n), T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
T
+++++
exact (fst cp).
-----
Definition headCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Definition headCPbis {T:Type} {n:nat} (cp : cartesianPower T (S n)) : cartesianPower T 1.
-----
Definition headCPbis {T:Type} {n:nat} (cp : cartesianPower T (S n)) : cartesianPower T 1.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
cartesianPower T (S O)
+++++
Proof.
-----
Definition headCPbis {T:Type} {n:nat} (cp : cartesianPower T (S n)) : cartesianPower T 1.
Proof.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
cartesianPower T (S O)
+++++
induction n.
-----
Definition headCPbis {T:Type} {n:nat} (cp : cartesianPower T (S n)) : cartesianPower T 1.
Proof.
induction n.

*****
cp : cartesianPower T (S O)
T : Type
*****
cartesianPower T (S O)
+++++
exact cp.
-----
Definition headCPbis {T:Type} {n:nat} (cp : cartesianPower T (S n)) : cartesianPower T 1.
Proof.
induction n.

*****
IHn : forall _ : cartesianPower T (S n), cartesianPower T (S O)
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S O)
+++++
exact (fst cp).
-----
Definition headCPbis {T:Type} {n:nat} (cp : cartesianPower T (S n)) : cartesianPower T 1.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Definition tailCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
-----
Definition tailCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
Proof.
-----
Definition tailCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
induction n.
-----
Definition tailCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
cartesianPower T (S O)
+++++
exact (snd cp).
-----
Definition tailCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.

*****
IHn : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
cartesianPower T (S (S n))
+++++
exact (snd cp).
-----
Definition tailCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Definition tailDefaultCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) (Default : cartesianPower T n) : (cartesianPower T n).
-----
Definition tailDefaultCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) (Default : cartesianPower T n) : (cartesianPower T n).

*****
Default : cartesianPower T n
cp : cartesianPower T (S n)
n : nat
T : Type
*****
cartesianPower T n
+++++
Proof.
-----
Definition tailDefaultCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) (Default : cartesianPower T n) : (cartesianPower T n).
Proof.

*****
Default : cartesianPower T n
cp : cartesianPower T (S n)
n : nat
T : Type
*****
cartesianPower T n
+++++
induction n.
-----
Definition tailDefaultCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) (Default : cartesianPower T n) : (cartesianPower T n).
Proof.
induction n.

*****
Default : cartesianPower T O
cp : cartesianPower T (S O)
T : Type
*****
cartesianPower T O
+++++
exact Default.
-----
Definition tailDefaultCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) (Default : cartesianPower T n) : (cartesianPower T n).
Proof.
induction n.

*****
IHn : forall (_ : cartesianPower T (S n)) (_ : cartesianPower T n),\ncartesianPower T n
Default : cartesianPower T (S n)
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
exact (tailCP cp).
-----
Definition tailDefaultCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) (Default : cartesianPower T n) : (cartesianPower T n).
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
Proof.
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
induction n.
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
cartesianPower T (S O)
+++++
exact (headCP cp).
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.

*****
IHn : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
cartesianPower T (S (S n))
+++++
split.
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.
split.

*****
IHn : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
T
+++++
exact (headCP cp).
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.
split.

*****
IHn : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
cartesianPowerAux T n
+++++
unfold cartesianPower in IHn.
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.
split.
unfold cartesianPower in IHn.

*****
IHn : forall _ : cartesianPowerAux T (Init.Nat.sub (S (S n)) (S O)),\ncartesianPowerAux T (Init.Nat.sub (S n) (S O))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
cartesianPowerAux T n
+++++
simpl in *.
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.
split.
unfold cartesianPower in IHn.
simpl in *.

*****
IHn : forall _ : prod T (cartesianPowerAux T n),\ncartesianPowerAux T (Init.Nat.sub n O)
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
cartesianPowerAux T n
+++++
rewrite minus_n_0 in IHn.
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.
split.
unfold cartesianPower in IHn.
simpl in *.
rewrite minus_n_0 in IHn.

*****
IHn : forall _ : prod T (cartesianPowerAux T n), cartesianPowerAux T n
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
cartesianPowerAux T n
+++++
apply IHn.
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.
split.
unfold cartesianPower in IHn.
simpl in *.
rewrite minus_n_0 in IHn.
apply IHn.

*****
IHn : forall _ : prod T (cartesianPowerAux T n), cartesianPowerAux T n
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
prod T (cartesianPowerAux T n)
+++++
exact (tailCP cp).
-----
Definition allButLastCP {T:Type} {n:nat} (cp : cartesianPower T (S (S n))) : (cartesianPower T (S n)).
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma allButLastCPTl {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S (S n)))),\n  allButLastCP (tailCP cp) = tailCP (allButLastCP cp).
-----
Lemma allButLastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S (S n)))), allButLastCP (tailCP cp) = tailCP (allButLastCP cp).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S (S n))), eq (allButLastCP (tailCP cp)) (tailCP (allButLastCP cp))
+++++
Proof.
-----
Lemma allButLastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S (S n)))), allButLastCP (tailCP cp) = tailCP (allButLastCP cp).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S (S n))), eq (allButLastCP (tailCP cp)) (tailCP (allButLastCP cp))
+++++
intro cp.
-----
Lemma allButLastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S (S n)))), allButLastCP (tailCP cp) = tailCP (allButLastCP cp).
Proof.
intro cp.

*****
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cp)) (tailCP (allButLastCP cp))
+++++
induction n.
-----
Lemma allButLastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S (S n)))), allButLastCP (tailCP cp) = tailCP (allButLastCP cp).
Proof.
intro cp.
induction n.

*****
cp : cartesianPower T (S (S (S O)))
T : Type
*****
eq (allButLastCP (tailCP cp)) (tailCP (allButLastCP cp))
+++++
simpl.
-----
Lemma allButLastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S (S n)))), allButLastCP (tailCP cp) = tailCP (allButLastCP cp).
Proof.
intro cp.
induction n.
simpl.

*****
cp : cartesianPower T (S (S (S O)))
T : Type
*****
eq (fst (snd cp)) (fst (snd cp))
+++++
reflexivity.
-----
Lemma allButLastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S (S n)))), allButLastCP (tailCP cp) = tailCP (allButLastCP cp).
Proof.
intro cp.
induction n.

*****
IHn : forall cp : cartesianPower T (S (S (S n))),\neq (allButLastCP (tailCP cp)) (tailCP (allButLastCP cp))
cp : cartesianPower T (S (S (S (S n))))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cp)) (tailCP (allButLastCP cp))
+++++
simpl.
-----
Lemma allButLastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S (S n)))), allButLastCP (tailCP cp) = tailCP (allButLastCP cp).
Proof.
intro cp.
induction n.
simpl.

*****
IHn : forall cp : cartesianPower T (S (S (S n))),\neq (allButLastCP (tailCP cp)) (tailCP (allButLastCP cp))
cp : cartesianPower T (S (S (S (S n))))
n : nat
T : Type
*****
eq (pair (fst (snd cp)) (eq_rect (Init.Nat.sub n O) (fun n0 : nat => forall _ : prod T (cartesianPowerAux T n), cartesianPowerAux T n0) ((fix F (n : nat) : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T (S (S n0)), cartesianPower T (S n0)) with | O => fun cp : cartesianPower T (S (S O)) => fst cp | S n0 => fun cp : cartesianPower T (S (S (S n0))) => pair (fst cp) (eq_rect (Init.Nat.sub n0 O) (fun n1 : nat => forall _ : prod T (cartesianPowerAux T n0), cartesianPowerAux T n1) (F n0) n0 (minus_n_0 n0) (snd cp)) end) n) n (minus_n_0 n) (snd (snd cp)))) (pair (fst (snd cp)) (eq_rect (Init.Nat.sub n O) (fun n0 : nat => forall _ : prod T (cartesianPowerAux T n), cartesianPowerAux T n0) ((fix F (n : nat) : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T (S (S n0)), cartesianPower T (S n0)) with | O => fun cp : cartesianPower T (S (S O)) => fst cp | S n0 => fun cp : cartesianPower T (S (S (S n0))) => pair (fst cp) (eq_rect (Init.Nat.sub n0 O) (fun n1 : nat => forall _ : prod T (cartesianPowerAux T n0), cartesianPowerAux T n1) (F n0) n0 (minus_n_0 n0) (snd cp)) end) n) n (minus_n_0 n) (snd (snd cp))))
+++++
reflexivity.
-----
Lemma allButLastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S (S n)))), allButLastCP (tailCP cp) = tailCP (allButLastCP cp).
Proof.
intro cp.
induction n.

*****

*****

+++++
Qed.
-----
Definition lastCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
-----
Definition lastCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
T
+++++
Proof.
-----
Definition lastCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
Proof.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
T
+++++
induction n.
-----
Definition lastCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
Proof.
induction n.

*****
cp : cartesianPower T (S O)
T : Type
*****
T
+++++
exact cp.
-----
Definition lastCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
Proof.
induction n.

*****
IHn : forall _ : cartesianPower T (S n), T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
T
+++++
apply IHn.
-----
Definition lastCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
Proof.
induction n.
apply IHn.

*****
IHn : forall _ : cartesianPower T (S n), T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
exact (tailCP cp).
-----
Definition lastCP {T:Type} {n:nat} (cp : cartesianPower T (S n)) : T.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
-----
Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (lastCP cp) (lastCP (tailCP cp))
+++++
Proof.
-----
Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (lastCP cp) (lastCP (tailCP cp))
+++++
intro cp.
-----
Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
intro cp.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (lastCP cp) (lastCP (tailCP cp))
+++++
induction n.
-----
Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
intro cp.
induction n.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (lastCP cp) (lastCP (tailCP cp))
+++++
simpl.
-----
Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
intro cp.
induction n.
simpl.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (snd cp) (snd cp)
+++++
reflexivity.
-----
Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
intro cp.
induction n.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (lastCP cp) (lastCP (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (lastCP cp) (lastCP (tailCP cp))
+++++
simpl.
-----
Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
intro cp.
induction n.
simpl.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (lastCP cp) (lastCP (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (lastCP (tailCP (snd cp))) (lastCP (tailCP (snd cp)))
+++++
reflexivity.
-----
Lemma lastCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
intro cp.
induction n.

*****

*****

+++++
Qed.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))),\n  headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.

*****
n : nat
T : Type
*****
forall (cp cp' : cartesianPower T (S (S n))) (_ : eq (headCP cp) (headCP cp')) (_ : eq (tailCP cp) (tailCP cp')), eq cp cp'
+++++
Proof.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.

*****
n : nat
T : Type
*****
forall (cp cp' : cartesianPower T (S (S n))) (_ : eq (headCP cp) (headCP cp')) (_ : eq (tailCP cp) (tailCP cp')), eq cp cp'
+++++
intros.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.

*****
H0 : eq (tailCP cp) (tailCP cp')
H : eq (headCP cp) (headCP cp')
cp,cp' : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq cp cp'
+++++
induction n.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.
induction n.

*****
H0 : eq (tailCP cp) (tailCP cp')
H : eq (headCP cp) (headCP cp')
cp,cp' : cartesianPower T (S (S O))
T : Type
*****
eq cp cp'
+++++
simpl in *.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.
induction n.
simpl in *.

*****
H0 : eq (snd cp) (snd cp')
H : eq (fst cp) (fst cp')
cp,cp' : cartesianPower T (S (S O))
T : Type
*****
eq cp cp'
+++++
apply injective_projections.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.
induction n.
simpl in *.
apply injective_projections.

*****
H0 : eq (snd cp) (snd cp')
H : eq (fst cp) (fst cp')
cp,cp' : cartesianPower T (S (S O))
T : Type
*****
eq (fst cp) (fst cp')
+++++
assumption.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.
induction n.
simpl in *.
apply injective_projections.

*****
H0 : eq (snd cp) (snd cp')
H : eq (fst cp) (fst cp')
cp,cp' : cartesianPower T (S (S O))
T : Type
*****
eq (snd cp) (snd cp')
+++++
assumption.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.
induction n.

*****
IHn : forall (cp cp' : cartesianPower T (S (S n)))\n (_ : eq (headCP cp) (headCP cp')) (_ : eq (tailCP cp) (tailCP cp')),\neq cp cp'
H0 : eq (tailCP cp) (tailCP cp')
H : eq (headCP cp) (headCP cp')
cp,cp' : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq cp cp'
+++++
simpl in *.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.
induction n.
simpl in *.

*****
IHn : forall (cp cp' : cartesianPower T (S (S n)))\n (_ : eq (fst cp) (fst cp')) (_ : eq (tailCP cp) (tailCP cp')),\neq cp cp'
H0 : eq (snd cp) (snd cp')
H : eq (fst cp) (fst cp')
cp,cp' : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq cp cp'
+++++
apply injective_projections.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.
induction n.
simpl in *.
apply injective_projections.

*****
IHn : forall (cp cp' : cartesianPower T (S (S n)))\n (_ : eq (fst cp) (fst cp')) (_ : eq (tailCP cp) (tailCP cp')),\neq cp cp'
H0 : eq (snd cp) (snd cp')
H : eq (fst cp) (fst cp')
cp,cp' : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cp) (fst cp')
+++++
assumption.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.
induction n.
simpl in *.
apply injective_projections.

*****
IHn : forall (cp cp' : cartesianPower T (S (S n)))\n (_ : eq (fst cp) (fst cp')) (_ : eq (tailCP cp) (tailCP cp')),\neq cp cp'
H0 : eq (snd cp) (snd cp')
H : eq (fst cp) (fst cp')
cp,cp' : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (snd cp) (snd cp')
+++++
assumption.
-----
Lemma CP_ind {T:Type} {n : nat} : forall (cp cp' : cartesianPower T (S (S n))), headCP cp = headCP cp' -> tailCP cp = tailCP cp' -> cp = cp'.
Proof.
intros.
induction n.

*****

*****

+++++
Qed.
-----
Definition CPPair {T : Type} :\n  forall (cp : cartesianPower T 2),\n  cp = (fst cp, snd cp).
-----
Definition CPPair {T : Type} : forall (cp : cartesianPower T 2), cp = (fst cp, snd cp).

*****
T : Type
*****
forall cp : cartesianPower T (S (S O)), eq cp (pair (fst cp) (snd cp))
+++++
Proof.
-----
Definition CPPair {T : Type} : forall (cp : cartesianPower T 2), cp = (fst cp, snd cp).
Proof.

*****
T : Type
*****
forall cp : cartesianPower T (S (S O)), eq cp (pair (fst cp) (snd cp))
+++++
intro cp.
-----
Definition CPPair {T : Type} : forall (cp : cartesianPower T 2), cp = (fst cp, snd cp).
Proof.
intro cp.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq cp (pair (fst cp) (snd cp))
+++++
apply CP_ind.
-----
Definition CPPair {T : Type} : forall (cp : cartesianPower T 2), cp = (fst cp, snd cp).
Proof.
intro cp.
apply CP_ind.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (headCP cp) (headCP (pair (fst cp) (snd cp)))
+++++
simpl.
-----
Definition CPPair {T : Type} : forall (cp : cartesianPower T 2), cp = (fst cp, snd cp).
Proof.
intro cp.
apply CP_ind.
simpl.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (fst cp) (fst cp)
+++++
reflexivity.
-----
Definition CPPair {T : Type} : forall (cp : cartesianPower T 2), cp = (fst cp, snd cp).
Proof.
intro cp.
apply CP_ind.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (tailCP cp) (tailCP (pair (fst cp) (snd cp)))
+++++
simpl.
-----
Definition CPPair {T : Type} : forall (cp : cartesianPower T 2), cp = (fst cp, snd cp).
Proof.
intro cp.
apply CP_ind.
simpl.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (snd cp) (snd cp)
+++++
reflexivity.
-----
Definition CPPair {T : Type} : forall (cp : cartesianPower T 2), cp = (fst cp, snd cp).
Proof.
intro cp.
apply CP_ind.

*****

*****

+++++
Qed.
-----
Definition tailCPbis {T:Type} {n:nat} m1 m2 (cp : cartesianPower T m1) :\n  (S (S n)) = m1 -> (S n) = m2 -> (cartesianPower T m2).
-----
Definition tailCPbis {T:Type} {n:nat} m1 m2 (cp : cartesianPower T m1) : (S (S n)) = m1 -> (S n) = m2 -> (cartesianPower T m2).

*****
cp : cartesianPower T m1
n,m1,m2 : nat
T : Type
*****
forall (_ : eq (S (S n)) m1) (_ : eq (S n) m2), cartesianPower T m2
+++++
Proof.
-----
Definition tailCPbis {T:Type} {n:nat} m1 m2 (cp : cartesianPower T m1) : (S (S n)) = m1 -> (S n) = m2 -> (cartesianPower T m2).
Proof.

*****
cp : cartesianPower T m1
n,m1,m2 : nat
T : Type
*****
forall (_ : eq (S (S n)) m1) (_ : eq (S n) m2), cartesianPower T m2
+++++
intros Hm1 Hm2.
-----
Definition tailCPbis {T:Type} {n:nat} m1 m2 (cp : cartesianPower T m1) : (S (S n)) = m1 -> (S n) = m2 -> (cartesianPower T m2).
Proof.
intros Hm1 Hm2.

*****
Hm2 : eq (S n) m2
Hm1 : eq (S (S n)) m1
cp : cartesianPower T m1
n,m1,m2 : nat
T : Type
*****
cartesianPower T m2
+++++
subst.
-----
Definition tailCPbis {T:Type} {n:nat} m1 m2 (cp : cartesianPower T m1) : (S (S n)) = m1 -> (S n) = m2 -> (cartesianPower T m2).
Proof.
intros Hm1 Hm2.
subst.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
exact (tailCP cp).
-----
Definition tailCPbis {T:Type} {n:nat} m1 m2 (cp : cartesianPower T m1) : (S (S n)) = m1 -> (S n) = m2 -> (cartesianPower T m2).
Proof.
intros Hm1 Hm2.
subst.
exact (tailCP cp).

*****

*****

+++++
Defined.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).

*****
cp : cartesianPower T n
t : T
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
Proof.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.

*****
cp : cartesianPower T n
t : T
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
induction n.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.
induction n.

*****
cp : cartesianPower T O
t : T
T : Type
*****
cartesianPower T (S O)
+++++
exact t.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.
induction n.

*****
IHn : forall _ : cartesianPower T n, cartesianPower T (S n)
cp : cartesianPower T (S n)
t : T
n : nat
T : Type
*****
cartesianPower T (S (S n))
+++++
clear IHn.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.
induction n.
clear IHn.

*****
cp : cartesianPower T (S n)
t : T
n : nat
T : Type
*****
cartesianPower T (S (S n))
+++++
split.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.
induction n.
clear IHn.
split.

*****
cp : cartesianPower T (S n)
t : T
n : nat
T : Type
*****
T
+++++
exact t.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.
induction n.
clear IHn.
split.

*****
cp : cartesianPower T (S n)
t : T
n : nat
T : Type
*****
cartesianPowerAux T n
+++++
unfold cartesianPower in cp.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.
induction n.
clear IHn.
split.
unfold cartesianPower in cp.

*****
cp : cartesianPowerAux T (Init.Nat.sub (S n) (S O))
t : T
n : nat
T : Type
*****
cartesianPowerAux T n
+++++
simpl in cp.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.
induction n.
clear IHn.
split.
unfold cartesianPower in cp.
simpl in cp.

*****
cp : cartesianPowerAux T (Init.Nat.sub n O)
t : T
n : nat
T : Type
*****
cartesianPowerAux T n
+++++
rewrite minus_n_0 in cp.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.
induction n.
clear IHn.
split.
unfold cartesianPower in cp.
simpl in cp.
rewrite minus_n_0 in cp.

*****
cp : cartesianPowerAux T n
t : T
n : nat
T : Type
*****
cartesianPowerAux T n
+++++
exact cp.
-----
Definition consHeadCP {T:Type} {n:nat} (t : T) (cp : cartesianPower T n) : (cartesianPower T (S n)).
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma consHeadCPHd {T:Type} {n:nat} :\n  forall (cp : cartesianPower T n) t,\n  headCP (consHeadCP t cp) = t.
-----
Lemma consHeadCPHd {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, headCP (consHeadCP t cp) = t.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T n) (t : T), eq (headCP (consHeadCP t cp)) t
+++++
Proof.
-----
Lemma consHeadCPHd {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, headCP (consHeadCP t cp) = t.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T n) (t : T), eq (headCP (consHeadCP t cp)) t
+++++
intro cp.
-----
Lemma consHeadCPHd {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, headCP (consHeadCP t cp) = t.
Proof.
intro cp.

*****
cp : cartesianPower T n
n : nat
T : Type
*****
forall t : T, eq (headCP (consHeadCP t cp)) t
+++++
induction n.
-----
Lemma consHeadCPHd {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, headCP (consHeadCP t cp) = t.
Proof.
intro cp.
induction n.

*****
cp : cartesianPower T O
T : Type
*****
forall t : T, eq (headCP (consHeadCP t cp)) t
+++++
simpl.
-----
Lemma consHeadCPHd {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, headCP (consHeadCP t cp) = t.
Proof.
intro cp.
induction n.
simpl.

*****
cp : cartesianPower T O
T : Type
*****
forall t : T, eq t t
+++++
reflexivity.
-----
Lemma consHeadCPHd {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, headCP (consHeadCP t cp) = t.
Proof.
intro cp.
induction n.

*****
IHn : forall (cp : cartesianPower T n) (t : T),\neq (headCP (consHeadCP t cp)) t
cp : cartesianPower T (S n)
n : nat
T : Type
*****
forall t : T, eq (headCP (consHeadCP t cp)) t
+++++
simpl.
-----
Lemma consHeadCPHd {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, headCP (consHeadCP t cp) = t.
Proof.
intro cp.
induction n.
simpl.

*****
IHn : forall (cp : cartesianPower T n) (t : T),\neq (headCP (consHeadCP t cp)) t
cp : cartesianPower T (S n)
n : nat
T : Type
*****
forall t : T, eq t t
+++++
reflexivity.
-----
Lemma consHeadCPHd {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, headCP (consHeadCP t cp) = t.
Proof.
intro cp.
induction n.

*****

*****

+++++
Qed.
-----
Lemma consHeadCPTl {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S n)) t,\n  tailCP (consHeadCP t cp) = cp.
-----
Lemma consHeadCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, tailCP (consHeadCP t cp) = cp.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t : T), eq (tailCP (consHeadCP t cp)) cp
+++++
Proof.
-----
Lemma consHeadCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, tailCP (consHeadCP t cp) = cp.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t : T), eq (tailCP (consHeadCP t cp)) cp
+++++
intro cp.
-----
Lemma consHeadCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, tailCP (consHeadCP t cp) = cp.
Proof.
intro cp.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
forall t : T, eq (tailCP (consHeadCP t cp)) cp
+++++
induction n.
-----
Lemma consHeadCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, tailCP (consHeadCP t cp) = cp.
Proof.
intro cp.
induction n.

*****
cp : cartesianPower T (S O)
T : Type
*****
forall t : T, eq (tailCP (consHeadCP t cp)) cp
+++++
simpl.
-----
Lemma consHeadCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, tailCP (consHeadCP t cp) = cp.
Proof.
intro cp.
induction n.
simpl.

*****
cp : cartesianPower T (S O)
T : Type
*****
forall _ : T, eq cp cp
+++++
reflexivity.
-----
Lemma consHeadCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, tailCP (consHeadCP t cp) = cp.
Proof.
intro cp.
induction n.

*****
IHn : forall (cp : cartesianPower T (S n)) (t : T),\neq (tailCP (consHeadCP t cp)) cp
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
forall t : T, eq (tailCP (consHeadCP t cp)) cp
+++++
simpl.
-----
Lemma consHeadCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, tailCP (consHeadCP t cp) = cp.
Proof.
intro cp.
induction n.
simpl.

*****
IHn : forall (cp : cartesianPower T (S n)) (t : T),\neq (tailCP (consHeadCP t cp)) cp
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
forall _ : T, eq cp cp
+++++
reflexivity.
-----
Lemma consHeadCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, tailCP (consHeadCP t cp) = cp.
Proof.
intro cp.
induction n.

*****

*****

+++++
Qed.
-----
Lemma consHeadCPOK {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))),\n  cp = consHeadCP (headCP cp) (tailCP cp).
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq cp (consHeadCP (headCP cp) (tailCP cp))
+++++
Proof.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq cp (consHeadCP (headCP cp) (tailCP cp))
+++++
intro cp.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.
intro cp.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq cp (consHeadCP (headCP cp) (tailCP cp))
+++++
induction n.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.
intro cp.
induction n.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq cp (consHeadCP (headCP cp) (tailCP cp))
+++++
simpl.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.
intro cp.
induction n.
simpl.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq cp (pair (fst cp) (snd cp))
+++++
apply CPPair.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.
intro cp.
induction n.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consHeadCP (headCP cp) (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq cp (consHeadCP (headCP cp) (tailCP cp))
+++++
apply CP_ind.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consHeadCP (headCP cp) (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (headCP cp) (headCP (consHeadCP (headCP cp) (tailCP cp)))
+++++
simpl.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.
simpl.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consHeadCP (headCP cp) (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cp) (fst cp)
+++++
reflexivity.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consHeadCP (headCP cp) (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (tailCP cp) (tailCP (consHeadCP (headCP cp) (tailCP cp)))
+++++
rewrite consHeadCPTl.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.
rewrite consHeadCPTl.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consHeadCP (headCP cp) (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (tailCP cp) (tailCP cp)
+++++
reflexivity.
-----
Lemma consHeadCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consHeadCP (headCP cp) (tailCP cp).
Proof.
intro cp.
induction n.

*****

*****

+++++
Qed.
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).

*****
t : T
cp : cartesianPower T n
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
Proof.
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
Proof.

*****
t : T
cp : cartesianPower T n
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
induction n.
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
Proof.
induction n.

*****
t : T
cp : cartesianPower T O
T : Type
*****
cartesianPower T (S O)
+++++
exact t.
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
Proof.
induction n.

*****
IHn : forall _ : cartesianPower T n, cartesianPower T (S n)
t : T
cp : cartesianPower T (S n)
n : nat
T : Type
*****
cartesianPower T (S (S n))
+++++
induction n.
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
Proof.
induction n.
induction n.

*****
IHn : forall _ : cartesianPower T O, cartesianPower T (S O)
t : T
cp : cartesianPower T (S O)
T : Type
*****
cartesianPower T (S (S O))
+++++
exact (cp, t).
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
Proof.
induction n.
induction n.

*****
IHn0 : forall (_ : cartesianPower T (S n))\n (_ : forall _ : cartesianPower T n, cartesianPower T (S n)),\ncartesianPower T (S (S n))
IHn : forall _ : cartesianPower T (S n), cartesianPower T (S (S n))
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S (S (S n)))
+++++
clear IHn0.
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
Proof.
induction n.
induction n.
clear IHn0.

*****
IHn : forall _ : cartesianPower T (S n), cartesianPower T (S (S n))
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S (S (S n)))
+++++
split.
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
Proof.
induction n.
induction n.
clear IHn0.
split.

*****
IHn : forall _ : cartesianPower T (S n), cartesianPower T (S (S n))
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
T
+++++
exact (headCP cp).
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
Proof.
induction n.
induction n.
clear IHn0.
split.

*****
IHn : forall _ : cartesianPower T (S n), cartesianPower T (S (S n))
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPowerAux T (S n)
+++++
exact (IHn (tailCP cp)).
-----
Definition consTailCP {T:Type} {n:nat} (cp : cartesianPower T n) (t : T) : (cartesianPower T (S n)).
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma consTailCPTl {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))) t,\n  tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.
-----
Lemma consTailCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) t, tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (t : T), eq (tailCP (consTailCP cp t)) (consTailCP (tailCP cp) t)
+++++
Proof.
-----
Lemma consTailCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) t, tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (t : T), eq (tailCP (consTailCP cp t)) (consTailCP (tailCP cp) t)
+++++
intro cp.
-----
Lemma consTailCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) t, tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.
Proof.
intro cp.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
forall t : T, eq (tailCP (consTailCP cp t)) (consTailCP (tailCP cp) t)
+++++
induction n.
-----
Lemma consTailCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) t, tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.
Proof.
intro cp.
induction n.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
forall t : T, eq (tailCP (consTailCP cp t)) (consTailCP (tailCP cp) t)
+++++
simpl.
-----
Lemma consTailCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) t, tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.
Proof.
intro cp.
induction n.
simpl.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
forall t : T, eq (pair (snd cp) t) (pair (snd cp) t)
+++++
reflexivity.
-----
Lemma consTailCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) t, tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.
Proof.
intro cp.
induction n.

*****
IHn : forall (cp : cartesianPower T (S (S n))) (t : T),\neq (tailCP (consTailCP cp t)) (consTailCP (tailCP cp) t)
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
forall t : T, eq (tailCP (consTailCP cp t)) (consTailCP (tailCP cp) t)
+++++
simpl.
-----
Lemma consTailCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) t, tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.
Proof.
intro cp.
induction n.
simpl.

*****
IHn : forall (cp : cartesianPower T (S (S n))) (t : T),\neq (tailCP (consTailCP cp t)) (consTailCP (tailCP cp) t)
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
forall t : T, eq (pair (fst (snd cp)) (nat_rect (fun n : nat => forall (_ : cartesianPower T (S n)) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)), cartesianPower T (S (S n))) (fun (cp : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp t) (fun (n : nat) (_ : forall (_ : cartesianPower T (S n)) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)), cartesianPower T (S (S n))) (cp : cartesianPower T (S (S n))) (IHn : forall _ : cartesianPower T (S n), cartesianPower T (S (S n))) => pair (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)) ((fix F (n : nat) : forall _ : cartesianPower T n, cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T n0, cartesianPower T (S n0)) with | O => fun _ : cartesianPower T O => t | S n0 => fun cp : cartesianPower T (S n0) => nat_rect (fun n1 : nat => forall (_ : cartesianPower T (S n1)) (_ : forall _ : cartesianPower T n1, cartesianPower T (S n1)), cartesianPower T (S (S n1))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 t) (fun (n1 : nat) (_ : forall (_ : cartesianPower T (S n1)) (_ : forall _ : cartesianPower T n1, cartesianPower T (S n1)), cartesianPower T (S (S n1))) (cp0 : cartesianPower T (S (S n1))) (IHn : forall _ : cartesianPower T (S n1), cartesianPower T (S (S n1))) => pair (fst cp0) (IHn (tailCP cp0))) n0 cp (F n0) end) n))) (pair (fst (snd cp)) (nat_rect (fun n : nat => forall (_ : cartesianPower T (S n)) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)), cartesianPower T (S (S n))) (fun (cp : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp t) (fun (n : nat) (_ : forall (_ : cartesianPower T (S n)) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)), cartesianPower T (S (S n))) (cp : cartesianPower T (S (S n))) (IHn : forall _ : cartesianPower T (S n), cartesianPower T (S (S n))) => pair (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)) ((fix F (n : nat) : forall _ : cartesianPower T n, cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T n0, cartesianPower T (S n0)) with | O => fun _ : cartesianPower T O => t | S n0 => fun cp : cartesianPower T (S n0) => nat_rect (fun n1 : nat => forall (_ : cartesianPower T (S n1)) (_ : forall _ : cartesianPower T n1, cartesianPower T (S n1)), cartesianPower T (S (S n1))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 t) (fun (n1 : nat) (_ : forall (_ : cartesianPower T (S n1)) (_ : forall _ : cartesianPower T n1, cartesianPower T (S n1)), cartesianPower T (S (S n1))) (cp0 : cartesianPower T (S (S n1))) (IHn : forall _ : cartesianPower T (S n1), cartesianPower T (S (S n1))) => pair (fst cp0) (IHn (tailCP cp0))) n0 cp (F n0) end) n)))
+++++
reflexivity.
-----
Lemma consTailCPTl {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) t, tailCP (consTailCP cp t) = consTailCP (tailCP cp) t.
Proof.
intro cp.
induction n.

*****

*****

+++++
Qed.
-----
Lemma consTailCPOK {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))),\n  cp = consTailCP (allButLastCP cp) (lastCP cp).
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq cp (consTailCP (allButLastCP cp) (lastCP cp))
+++++
Proof.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq cp (consTailCP (allButLastCP cp) (lastCP cp))
+++++
intro cp.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq cp (consTailCP (allButLastCP cp) (lastCP cp))
+++++
induction n.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq cp (consTailCP (allButLastCP cp) (lastCP cp))
+++++
simpl.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.
simpl.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq cp (pair (fst cp) (snd cp))
+++++
apply CPPair.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consTailCP (allButLastCP cp) (lastCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq cp (consTailCP (allButLastCP cp) (lastCP cp))
+++++
apply CP_ind.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consTailCP (allButLastCP cp) (lastCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (headCP cp) (headCP (consTailCP (allButLastCP cp) (lastCP cp)))
+++++
simpl.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.
simpl.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consTailCP (allButLastCP cp) (lastCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cp) (fst cp)
+++++
reflexivity.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consTailCP (allButLastCP cp) (lastCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (tailCP cp) (tailCP (consTailCP (allButLastCP cp) (lastCP cp)))
+++++
assert (H := IHn (tailCP cp)).
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.
assert (H := IHn (tailCP cp)).

*****
H : eq (tailCP cp)\n (consTailCP (allButLastCP (tailCP cp)) (lastCP (tailCP cp)))
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consTailCP (allButLastCP cp) (lastCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (tailCP cp) (tailCP (consTailCP (allButLastCP cp) (lastCP cp)))
+++++
rewrite <- lastCPTl in H.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.
assert (H := IHn (tailCP cp)).
rewrite <- lastCPTl in H.

*****
H : eq (tailCP cp) (consTailCP (allButLastCP (tailCP cp)) (lastCP cp))
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consTailCP (allButLastCP cp) (lastCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (tailCP cp) (tailCP (consTailCP (allButLastCP cp) (lastCP cp)))
+++++
rewrite allButLastCPTl in H.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.
assert (H := IHn (tailCP cp)).
rewrite <- lastCPTl in H.
rewrite allButLastCPTl in H.

*****
H : eq (tailCP cp) (consTailCP (tailCP (allButLastCP cp)) (lastCP cp))
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consTailCP (allButLastCP cp) (lastCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (tailCP cp) (tailCP (consTailCP (allButLastCP cp) (lastCP cp)))
+++++
rewrite <- consTailCPTl in H.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.
apply CP_ind.
assert (H := IHn (tailCP cp)).
rewrite <- lastCPTl in H.
rewrite allButLastCPTl in H.
rewrite <- consTailCPTl in H.

*****
H : eq (tailCP cp) (tailCP (consTailCP (allButLastCP cp) (lastCP cp)))
IHn : forall cp : cartesianPower T (S (S n)),\neq cp (consTailCP (allButLastCP cp) (lastCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (tailCP cp) (tailCP (consTailCP (allButLastCP cp) (lastCP cp)))
+++++
assumption.
-----
Lemma consTailCPOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = consTailCP (allButLastCP cp) (lastCP cp).
Proof.
intro cp.
induction n.

*****

*****

+++++
Qed.
-----
Lemma consTailCPAbl {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S n)) t,\n  allButLastCP (consTailCP cp t) = cp.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t : T), eq (allButLastCP (consTailCP cp t)) cp
+++++
Proof.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t : T), eq (allButLastCP (consTailCP cp t)) cp
+++++
intros cp t.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.

*****
t : T
cp : cartesianPower T (S n)
n : nat
T : Type
*****
eq (allButLastCP (consTailCP cp t)) cp
+++++
induction n.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.

*****
t : T
cp : cartesianPower T (S O)
T : Type
*****
eq (allButLastCP (consTailCP cp t)) cp
+++++
try (simpl; reflexivity).
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.

*****
IHn : forall cp : cartesianPower T (S n),\neq (allButLastCP (consTailCP cp t)) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (allButLastCP (consTailCP cp t)) cp
+++++
try (simpl; reflexivity).
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).

*****
IHn : forall cp : cartesianPower T (S n),\neq (allButLastCP (consTailCP cp t)) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (allButLastCP (consTailCP cp t)) cp
+++++
apply CP_ind.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
apply CP_ind.

*****
IHn : forall cp : cartesianPower T (S n),\neq (allButLastCP (consTailCP cp t)) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (headCP (allButLastCP (consTailCP cp t))) (headCP cp)
+++++
simpl.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
apply CP_ind.
simpl.

*****
IHn : forall cp : cartesianPower T (S n),\neq (allButLastCP (consTailCP cp t)) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (fst cp) (fst cp)
+++++
reflexivity.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
apply CP_ind.

*****
IHn : forall cp : cartesianPower T (S n),\neq (allButLastCP (consTailCP cp t)) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (tailCP (allButLastCP (consTailCP cp t))) (tailCP cp)
+++++
rewrite <- IHn.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
apply CP_ind.
rewrite <- IHn.

*****
IHn : forall cp : cartesianPower T (S n),\neq (allButLastCP (consTailCP cp t)) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (tailCP (allButLastCP (consTailCP cp t))) (allButLastCP (consTailCP (tailCP cp) t))
+++++
rewrite <- consTailCPTl.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
apply CP_ind.
rewrite <- IHn.
rewrite <- consTailCPTl.

*****
IHn : forall cp : cartesianPower T (S n),\neq (allButLastCP (consTailCP cp t)) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (tailCP (allButLastCP (consTailCP cp t))) (allButLastCP (tailCP (consTailCP cp t)))
+++++
rewrite allButLastCPTl.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
apply CP_ind.
rewrite <- IHn.
rewrite <- consTailCPTl.
rewrite allButLastCPTl.

*****
IHn : forall cp : cartesianPower T (S n),\neq (allButLastCP (consTailCP cp t)) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (tailCP (allButLastCP (consTailCP cp t))) (tailCP (allButLastCP (consTailCP cp t)))
+++++
reflexivity.
-----
Lemma consTailCPAbl {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, allButLastCP (consTailCP cp t) = cp.
Proof.
intros cp t.
induction n.

*****

*****

+++++
Qed.
-----
Lemma consTailCPTlD {T:Type} {n:nat} :\n  forall (cp : cartesianPower T n) t,\n  tailDefaultCP (consHeadCP t cp) cp = cp.
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T n) (t : T), eq (tailDefaultCP (consHeadCP t cp) cp) cp
+++++
Proof.
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T n) (t : T), eq (tailDefaultCP (consHeadCP t cp) cp) cp
+++++
intros cp t.
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.
intros cp t.

*****
t : T
cp : cartesianPower T n
n : nat
T : Type
*****
eq (tailDefaultCP (consHeadCP t cp) cp) cp
+++++
induction n.
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.
intros cp t.
induction n.

*****
t : T
cp : cartesianPower T O
T : Type
*****
eq (tailDefaultCP (consHeadCP t cp) cp) cp
+++++
try (simpl; reflexivity).
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.
intros cp t.
induction n.

*****
IHn : forall cp : cartesianPower T n,\neq (tailDefaultCP (consHeadCP t cp) cp) cp
t : T
cp : cartesianPower T (S n)
n : nat
T : Type
*****
eq (tailDefaultCP (consHeadCP t cp) cp) cp
+++++
try (simpl; reflexivity).
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).

*****
IHn : forall cp : cartesianPower T n,\neq (tailDefaultCP (consHeadCP t cp) cp) cp
t : T
cp : cartesianPower T (S n)
n : nat
T : Type
*****
eq (tailDefaultCP (consHeadCP t cp) cp) cp
+++++
induction n.
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
induction n.

*****
IHn : forall cp : cartesianPower T O,\neq (tailDefaultCP (consHeadCP t cp) cp) cp
t : T
cp : cartesianPower T (S O)
T : Type
*****
eq (tailDefaultCP (consHeadCP t cp) cp) cp
+++++
simpl.
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
induction n.
simpl.

*****
IHn : forall cp : cartesianPower T O,\neq (tailDefaultCP (consHeadCP t cp) cp) cp
t : T
cp : cartesianPower T (S O)
T : Type
*****
eq cp cp
+++++
reflexivity.
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
induction n.

*****
IHn0 : forall (cp : cartesianPower T (S n))\n (_ : forall cp0 : cartesianPower T n,\n eq (tailDefaultCP (consHeadCP t cp0) cp0) cp0),\neq (tailDefaultCP (consHeadCP t cp) cp) cp
IHn : forall cp : cartesianPower T (S n),\neq (tailDefaultCP (consHeadCP t cp) cp) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (tailDefaultCP (consHeadCP t cp) cp) cp
+++++
simpl.
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
induction n.
simpl.

*****
IHn0 : forall (cp : cartesianPower T (S n))\n (_ : forall cp0 : cartesianPower T n,\n eq (tailDefaultCP (consHeadCP t cp0) cp0) cp0),\neq (tailDefaultCP (consHeadCP t cp) cp) cp
IHn : forall cp : cartesianPower T (S n),\neq (tailDefaultCP (consHeadCP t cp) cp) cp
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq cp cp
+++++
reflexivity.
-----
Lemma consTailCPTlD {T:Type} {n:nat} : forall (cp : cartesianPower T n) t, tailDefaultCP (consHeadCP t cp) cp = cp.
Proof.
intros cp t.
induction n.

*****

*****

+++++
Qed.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} :\n  forall (F L : T) (X : cartesianPower T n),\n  consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.

*****
n : nat
T : Type
*****
forall (F L : T) (X : cartesianPower T n), eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
Proof.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.

*****
n : nat
T : Type
*****
forall (F L : T) (X : cartesianPower T n), eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
induction n.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.

*****
T : Type
*****
forall (F L : T) (X : cartesianPower T O), eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
intros F L X.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
intros F L X.

*****
X : cartesianPower T O
F,L : T
T : Type
*****
eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
unfold consHeadCP.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
intros F L X.
unfold consHeadCP.

*****
X : cartesianPower T O
F,L : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => F) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair F (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) (consTailCP X L)) (consTailCP (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => F) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair F (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) O X) L)
+++++
unfold consTailCP.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
intros F L X.
unfold consHeadCP.
unfold consTailCP.

*****
X : cartesianPower T O
F,L : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => F) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair F (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => L) (fun (n : nat) (IHn : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 L) (fun (n0 : nat) (_ : forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) (IHn1 : forall _ : cartesianPower T (S n0), cartesianPower T (S (S n0))) => pair (headCP cp0) (IHn1 (tailCP cp0))) n cp IHn) O X)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => L) (fun (n : nat) (IHn : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 L) (fun (n0 : nat) (_ : forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) (IHn1 : forall _ : cartesianPower T (S n0), cartesianPower T (S (S n0))) => pair (headCP cp0) (IHn1 (tailCP cp0))) n cp IHn) (S O) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => F) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair F (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) O X))
+++++
simpl.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
intros F L X.
unfold consHeadCP.
unfold consTailCP.
simpl.

*****
X : cartesianPower T O
F,L : T
T : Type
*****
eq (pair F L) (pair F L)
+++++
reflexivity.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.

*****
IHn : forall (F L : T) (X : cartesianPower T n),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
forall (F L : T) (X : cartesianPower T (S n)), eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
clear IHn.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.

*****
n : nat
T : Type
*****
forall (F L : T) (X : cartesianPower T (S n)), eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
induction n.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.

*****
T : Type
*****
forall (F L : T) (X : cartesianPower T (S O)), eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
intros F L X.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.

*****
X : cartesianPower T (S O)
F,L : T
T : Type
*****
eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
unfold consHeadCP.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
unfold consHeadCP.

*****
X : cartesianPower T (S O)
F,L : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => F) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair F (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S O)) (consTailCP X L)) (consTailCP (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => F) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair F (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) X) L)
+++++
unfold consTailCP.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
unfold consHeadCP.
unfold consTailCP.

*****
X : cartesianPower T (S O)
F,L : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => F) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair F (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S O)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => L) (fun (n : nat) (IHn : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 L) (fun (n0 : nat) (_ : forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) (IHn1 : forall _ : cartesianPower T (S n0), cartesianPower T (S (S n0))) => pair (headCP cp0) (IHn1 (tailCP cp0))) n cp IHn) (S O) X)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => L) (fun (n : nat) (IHn : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 L) (fun (n0 : nat) (_ : forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) (IHn1 : forall _ : cartesianPower T (S n0), cartesianPower T (S (S n0))) => pair (headCP cp0) (IHn1 (tailCP cp0))) n cp IHn) (S (S O)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => F) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair F (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) X))
+++++
simpl.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
unfold consHeadCP.
unfold consTailCP.
simpl.

*****
X : cartesianPower T (S O)
F,L : T
T : Type
*****
eq (pair F (pair X L)) (pair F (pair X L))
+++++
reflexivity.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.

*****
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
forall (F L : T) (X : cartesianPower T (S (S n))), eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
intros F L X.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.

*****
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
+++++
apply CP_ind.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
apply CP_ind.

*****
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq (headCP (consHeadCP F (consTailCP X L))) (headCP (consTailCP (consHeadCP F X) L))
+++++
simpl.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
apply CP_ind.
simpl.

*****
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq F F
+++++
reflexivity.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
apply CP_ind.

*****
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq (tailCP (consHeadCP F (consTailCP X L))) (tailCP (consTailCP (consHeadCP F X) L))
+++++
assert (H := consHeadCPOK X).
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
apply CP_ind.
assert (H := consHeadCPOK X).

*****
H : eq X (consHeadCP (headCP X) (tailCP X))
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq (tailCP (consHeadCP F (consTailCP X L))) (tailCP (consTailCP (consHeadCP F X) L))
+++++
rewrite H.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.

*****
H : eq X (consHeadCP (headCP X) (tailCP X))
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq (tailCP (consHeadCP F (consTailCP (consHeadCP (headCP X) (tailCP X)) L))) (tailCP (consTailCP (consHeadCP F (consHeadCP (headCP X) (tailCP X))) L))
+++++
clear H.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.

*****
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq (tailCP (consHeadCP F (consTailCP (consHeadCP (headCP X) (tailCP X)) L))) (tailCP (consTailCP (consHeadCP F (consHeadCP (headCP X) (tailCP X))) L))
+++++
rewrite consHeadCPTl.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.

*****
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq (consTailCP (consHeadCP (headCP X) (tailCP X)) L) (tailCP (consTailCP (consHeadCP F (consHeadCP (headCP X) (tailCP X))) L))
+++++
rewrite consTailCPTl.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.

*****
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq (consTailCP (consHeadCP (headCP X) (tailCP X)) L) (consTailCP (tailCP (consHeadCP F (consHeadCP (headCP X) (tailCP X)))) L)
+++++
rewrite consHeadCPTl.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.
clear IHn.
induction n.
intros F L X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.

*****
X : cartesianPower T (S (S n))
F,L : T
IHn : forall (F L : T) (X : cartesianPower T (S n)),\neq (consHeadCP F (consTailCP X L)) (consTailCP (consHeadCP F X) L)
n : nat
T : Type
*****
eq (consTailCP (consHeadCP (headCP X) (tailCP X)) L) (consTailCP (consHeadCP (headCP X) (tailCP X)) L)
+++++
reflexivity.
-----
Lemma consHdTlTlHd {T:Type} {n:nat} : forall (F L : T) (X : cartesianPower T n), consHeadCP F (consTailCP X L) = consTailCP (consHeadCP F X) L.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} :\n  forall (A B C : T) (X : cartesianPower T n),\n  consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.

*****
n : nat
T : Type
*****
forall (A B C : T) (X : cartesianPower T n), eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
Proof.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.

*****
n : nat
T : Type
*****
forall (A B C : T) (X : cartesianPower T n), eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
induction n.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.

*****
T : Type
*****
forall (A B C : T) (X : cartesianPower T O), eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
intros A B C X.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
intros A B C X.

*****
X : cartesianPower T O
A,B,C : T
T : Type
*****
eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
unfold consHeadCP.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
intros A B C X.
unfold consHeadCP.

*****
X : cartesianPower T O
A,B,C : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => A) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair A (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S O)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => B) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair B (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) (consTailCP X C))) (consTailCP (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => A) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair A (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => B) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair B (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) O X)) C)
+++++
unfold consTailCP.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
intros A B C X.
unfold consHeadCP.
unfold consTailCP.

*****
X : cartesianPower T O
A,B,C : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => A) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair A (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S O)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => B) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair B (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => C) (fun (n : nat) (IHn : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 C) (fun (n0 : nat) (_ : forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) (IHn1 : forall _ : cartesianPower T (S n0), cartesianPower T (S (S n0))) => pair (headCP cp0) (IHn1 (tailCP cp0))) n cp IHn) O X))) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => C) (fun (n : nat) (IHn : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 C) (fun (n0 : nat) (_ : forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) (IHn1 : forall _ : cartesianPower T (S n0), cartesianPower T (S (S n0))) => pair (headCP cp0) (IHn1 (tailCP cp0))) n cp IHn) (S (S O)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => A) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair A (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => B) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair B (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) O X)))
+++++
simpl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
intros A B C X.
unfold consHeadCP.
unfold consTailCP.
simpl.

*****
X : cartesianPower T O
A,B,C : T
T : Type
*****
eq (pair A (pair B C)) (pair A (pair B C))
+++++
reflexivity.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.

*****
IHn : forall (A B C : T) (X : cartesianPower T n),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
forall (A B C : T) (X : cartesianPower T (S n)), eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
clear IHn.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.

*****
n : nat
T : Type
*****
forall (A B C : T) (X : cartesianPower T (S n)), eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
induction n.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.

*****
T : Type
*****
forall (A B C : T) (X : cartesianPower T (S O)), eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
intros A B C X.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.

*****
X : cartesianPower T (S O)
A,B,C : T
T : Type
*****
eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
unfold consHeadCP.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
unfold consHeadCP.

*****
X : cartesianPower T (S O)
A,B,C : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => A) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair A (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S (S O))) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => B) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair B (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S O)) (consTailCP X C))) (consTailCP (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => A) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair A (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S O)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => B) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair B (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) X)) C)
+++++
unfold consTailCP.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
unfold consHeadCP.
unfold consTailCP.

*****
X : cartesianPower T (S O)
A,B,C : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => A) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair A (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S (S O))) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => B) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair B (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S O)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => C) (fun (n : nat) (IHn : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 C) (fun (n0 : nat) (_ : forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) (IHn1 : forall _ : cartesianPower T (S n0), cartesianPower T (S (S n0))) => pair (headCP cp0) (IHn1 (tailCP cp0))) n cp IHn) (S O) X))) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => C) (fun (n : nat) (IHn : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 C) (fun (n0 : nat) (_ : forall (_ : cartesianPower T (S n0)) (_ : forall _ : cartesianPower T n0, cartesianPower T (S n0)), cartesianPower T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) (IHn1 : forall _ : cartesianPower T (S n0), cartesianPower T (S (S n0))) => pair (headCP cp0) (IHn1 (tailCP cp0))) n cp IHn) (S (S (S O))) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => A) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair A (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S (S O)) (nat_rect (fun n : nat => forall _ : cartesianPower T n, cartesianPower T (S n)) (fun _ : cartesianPower T O => B) (fun (n : nat) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)) (cp : cartesianPower T (S n)) => pair B (eq_rect (Init.Nat.sub n O) (fun n0 : nat => cartesianPowerAux T n0) cp n (minus_n_0 n))) (S O) X)))
+++++
simpl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
unfold consHeadCP.
unfold consTailCP.
simpl.

*****
X : cartesianPower T (S O)
A,B,C : T
T : Type
*****
eq (pair A (pair B (pair X C))) (pair A (pair B (pair X C)))
+++++
reflexivity.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.

*****
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
forall (A B C : T) (X : cartesianPower T (S (S n))), eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
intros A B C X.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (consHeadCP A (consHeadCP B (consTailCP X C))) (consTailCP (consHeadCP A (consHeadCP B X)) C)
+++++
apply CP_ind.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (headCP (consHeadCP A (consHeadCP B (consTailCP X C)))) (headCP (consTailCP (consHeadCP A (consHeadCP B X)) C))
+++++
simpl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
simpl.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq A A
+++++
reflexivity.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (tailCP (consHeadCP A (consHeadCP B (consTailCP X C)))) (tailCP (consTailCP (consHeadCP A (consHeadCP B X)) C))
+++++
assert (H := consHeadCPOK X).
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).

*****
H : eq X (consHeadCP (headCP X) (tailCP X))
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (tailCP (consHeadCP A (consHeadCP B (consTailCP X C)))) (tailCP (consTailCP (consHeadCP A (consHeadCP B X)) C))
+++++
rewrite H.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.

*****
H : eq X (consHeadCP (headCP X) (tailCP X))
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (tailCP (consHeadCP A (consHeadCP B (consTailCP (consHeadCP (headCP X) (tailCP X)) C)))) (tailCP (consTailCP (consHeadCP A (consHeadCP B (consHeadCP (headCP X) (tailCP X)))) C))
+++++
clear H.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (tailCP (consHeadCP A (consHeadCP B (consTailCP (consHeadCP (headCP X) (tailCP X)) C)))) (tailCP (consTailCP (consHeadCP A (consHeadCP B (consHeadCP (headCP X) (tailCP X)))) C))
+++++
rewrite consHeadCPTl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (consHeadCP B (consTailCP (consHeadCP (headCP X) (tailCP X)) C)) (tailCP (consTailCP (consHeadCP A (consHeadCP B (consHeadCP (headCP X) (tailCP X)))) C))
+++++
rewrite consTailCPTl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (consHeadCP B (consTailCP (consHeadCP (headCP X) (tailCP X)) C)) (consTailCP (tailCP (consHeadCP A (consHeadCP B (consHeadCP (headCP X) (tailCP X))))) C)
+++++
rewrite consHeadCPTl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (consHeadCP B (consTailCP (consHeadCP (headCP X) (tailCP X)) C)) (consTailCP (consHeadCP B (consHeadCP (headCP X) (tailCP X))) C)
+++++
rewrite <- IHn.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (consHeadCP B (consTailCP (consHeadCP (headCP X) (tailCP X)) C)) (consHeadCP B (consHeadCP (headCP X) (consTailCP (tailCP X) C)))
+++++
apply CP_ind.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (headCP (consHeadCP B (consTailCP (consHeadCP (headCP X) (tailCP X)) C))) (headCP (consHeadCP B (consHeadCP (headCP X) (consTailCP (tailCP X) C))))
+++++
simpl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
simpl.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq B B
+++++
reflexivity.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (tailCP (consHeadCP B (consTailCP (consHeadCP (headCP X) (tailCP X)) C))) (tailCP (consHeadCP B (consHeadCP (headCP X) (consTailCP (tailCP X) C))))
+++++
do 2 (rewrite consHeadCPTl).
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (consTailCP (consHeadCP (headCP X) (tailCP X)) C) (consHeadCP (headCP X) (consTailCP (tailCP X) C))
+++++
apply CP_ind.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).
apply CP_ind.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (headCP (consTailCP (consHeadCP (headCP X) (tailCP X)) C)) (headCP (consHeadCP (headCP X) (consTailCP (tailCP X) C)))
+++++
simpl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).
apply CP_ind.
simpl.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (fst X) (fst X)
+++++
reflexivity.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).
apply CP_ind.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (tailCP (consTailCP (consHeadCP (headCP X) (tailCP X)) C)) (tailCP (consHeadCP (headCP X) (consTailCP (tailCP X) C)))
+++++
rewrite consHeadCPTl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).
apply CP_ind.
rewrite consHeadCPTl.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (tailCP (consTailCP (consHeadCP (headCP X) (tailCP X)) C)) (consTailCP (tailCP X) C)
+++++
rewrite consTailCPTl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).
apply CP_ind.
rewrite consHeadCPTl.
rewrite consTailCPTl.

*****
X : cartesianPower T (S (S n))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S n)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (consTailCP (tailCP (consHeadCP (headCP X) (tailCP X))) C) (consTailCP (tailCP X) C)
+++++
induction n.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).
apply CP_ind.
rewrite consHeadCPTl.
rewrite consTailCPTl.
induction n.

*****
X : cartesianPower T (S (S O))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S O)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
T : Type
*****
eq (consTailCP (tailCP (consHeadCP (headCP X) (tailCP X))) C) (consTailCP (tailCP X) C)
+++++
simpl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).
apply CP_ind.
rewrite consHeadCPTl.
rewrite consTailCPTl.
induction n.
simpl.

*****
X : cartesianPower T (S (S O))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S O)),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
T : Type
*****
eq (pair (snd X) C) (pair (snd X) C)
+++++
reflexivity.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).
apply CP_ind.
rewrite consHeadCPTl.
rewrite consTailCPTl.
induction n.

*****
IHn0 : forall\n (_ : forall (A B C : T) (X : cartesianPower T (S n)),\n eq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C))\n (X : cartesianPower T (S (S n))),\neq (consTailCP (tailCP (consHeadCP (headCP X) (tailCP X))) C)\n (consTailCP (tailCP X) C)
X : cartesianPower T (S (S (S n)))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S (S n))),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (consTailCP (tailCP (consHeadCP (headCP X) (tailCP X))) C) (consTailCP (tailCP X) C)
+++++
rewrite consHeadCPTl.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.
clear IHn.
induction n.
intros A B C X.
apply CP_ind.
assert (H := consHeadCPOK X).
rewrite H.
clear H.
rewrite consHeadCPTl.
rewrite consTailCPTl.
rewrite consHeadCPTl.
rewrite <- IHn.
apply CP_ind.
do 2 (rewrite consHeadCPTl).
apply CP_ind.
rewrite consHeadCPTl.
rewrite consTailCPTl.
induction n.
rewrite consHeadCPTl.

*****
IHn0 : forall\n (_ : forall (A B C : T) (X : cartesianPower T (S n)),\n eq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C))\n (X : cartesianPower T (S (S n))),\neq (consTailCP (tailCP (consHeadCP (headCP X) (tailCP X))) C)\n (consTailCP (tailCP X) C)
X : cartesianPower T (S (S (S n)))
A,B,C : T
IHn : forall (A B C : T) (X : cartesianPower T (S (S n))),\neq (consHeadCP A (consHeadCP B (consTailCP X C)))\n (consTailCP (consHeadCP A (consHeadCP B X)) C)
n : nat
T : Type
*****
eq (consTailCP (tailCP X) C) (consTailCP (tailCP X) C)
+++++
reflexivity.
-----
Lemma consTlHdHdTl {T:Type} {n:nat} : forall (A B C : T) (X : cartesianPower T n), consHeadCP A (consHeadCP B (consTailCP X C)) = consTailCP (consHeadCP A (consHeadCP B X)) C.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.

*****
cp : cartesianPower T n
n : nat
T : Type
*****
list T
+++++
Proof.
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.

*****
cp : cartesianPower T n
n : nat
T : Type
*****
list T
+++++
induction n.
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.
induction n.

*****
cp : cartesianPower T O
T : Type
*****
list T
+++++
exact nil.
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.
induction n.

*****
IHn : forall _ : cartesianPower T n, list T
cp : cartesianPower T (S n)
n : nat
T : Type
*****
list T
+++++
clear IHn.
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.
induction n.
clear IHn.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
list T
+++++
induction n.
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.
induction n.
clear IHn.
induction n.

*****
cp : cartesianPower T (S O)
T : Type
*****
list T
+++++
exact (cons cp nil).
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.
induction n.
clear IHn.
induction n.

*****
IHn : forall _ : cartesianPower T (S n), list T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
list T
+++++
apply cons.
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.
induction n.
clear IHn.
induction n.
apply cons.

*****
IHn : forall _ : cartesianPower T (S n), list T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
T
+++++
exact (headCP cp).
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.
induction n.
clear IHn.
induction n.
apply cons.

*****
IHn : forall _ : cartesianPower T (S n), list T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
list T
+++++
apply IHn.
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.
induction n.
clear IHn.
induction n.
apply cons.
apply IHn.

*****
IHn : forall _ : cartesianPower T (S n), list T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
cartesianPower T (S n)
+++++
exact (tailCP cp).
-----
Definition CPToList {T:Type} {n:nat} (cp : cartesianPower T n) : list T.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Definition InCP {T:Type} {n:nat} p (cp : cartesianPower T n) := In p (CPToList cp).
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))),\n  InCP p cp <-> ((p = headCP cp) \/ InCP p (tailCP cp)).
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).

*****
n : nat
T : Type
*****
forall (p : T) (cp : cartesianPower T (S (S n))), iff (InCP p cp) (or (eq p (headCP cp)) (InCP p (tailCP cp)))
+++++
Proof.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.

*****
n : nat
T : Type
*****
forall (p : T) (cp : cartesianPower T (S (S n))), iff (InCP p cp) (or (eq p (headCP cp)) (InCP p (tailCP cp)))
+++++
intros p cp.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.

*****
cp : cartesianPower T (S (S n))
p : T
n : nat
T : Type
*****
iff (InCP p cp) (or (eq p (headCP cp)) (InCP p (tailCP cp)))
+++++
unfold InCP.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.

*****
cp : cartesianPower T (S (S n))
p : T
n : nat
T : Type
*****
iff (In p (CPToList cp)) (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
+++++
induction n.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.

*****
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
iff (In p (CPToList cp)) (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
+++++
simpl.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.

*****
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
iff (or (eq (fst cp) p) (or (eq (snd cp) p) False)) (or (eq p (fst cp)) (or (eq (snd cp) p) False))
+++++
split.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.

*****
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : or (eq (fst cp) p) (or (eq (snd cp) p) False), or (eq p (fst cp)) (or (eq (snd cp) p) False)
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.

*****
H : or (eq (fst cp) p) (or (eq (snd cp) p) False)
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
or (eq p (fst cp)) (or (eq (snd cp) p) False)
+++++
elim H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.

*****
H : or (eq (fst cp) p) (or (eq (snd cp) p) False)
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : eq (fst cp) p, or (eq p (fst cp)) (or (eq (snd cp) p) False)
+++++
clear H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.

*****
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : eq (fst cp) p, or (eq p (fst cp)) (or (eq (snd cp) p) False)
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.

*****
H : eq (fst cp) p
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
or (eq p (fst cp)) (or (eq (snd cp) p) False)
+++++
left.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
left.

*****
H : eq (fst cp) p
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
eq p (fst cp)
+++++
subst.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
left.
subst.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (fst cp) (fst cp)
+++++
reflexivity.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.

*****
H : or (eq (fst cp) p) (or (eq (snd cp) p) False)
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : or (eq (snd cp) p) False, or (eq p (fst cp)) (or (eq (snd cp) p) False)
+++++
clear H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.

*****
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : or (eq (snd cp) p) False, or (eq p (fst cp)) (or (eq (snd cp) p) False)
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.

*****
H : or (eq (snd cp) p) False
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
or (eq p (fst cp)) (or (eq (snd cp) p) False)
+++++
right.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
right.

*****
H : or (eq (snd cp) p) False
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
or (eq (snd cp) p) False
+++++
assumption.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.

*****
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : or (eq p (fst cp)) (or (eq (snd cp) p) False), or (eq (fst cp) p) (or (eq (snd cp) p) False)
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.

*****
H : or (eq p (fst cp)) (or (eq (snd cp) p) False)
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
or (eq (fst cp) p) (or (eq (snd cp) p) False)
+++++
elim H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.

*****
H : or (eq p (fst cp)) (or (eq (snd cp) p) False)
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : eq p (fst cp), or (eq (fst cp) p) (or (eq (snd cp) p) False)
+++++
clear H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.

*****
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : eq p (fst cp), or (eq (fst cp) p) (or (eq (snd cp) p) False)
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.

*****
H : eq p (fst cp)
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
or (eq (fst cp) p) (or (eq (snd cp) p) False)
+++++
left.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
left.

*****
H : eq p (fst cp)
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
eq (fst cp) p
+++++
subst.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
left.
subst.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (fst cp) (fst cp)
+++++
reflexivity.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.

*****
H : or (eq p (fst cp)) (or (eq (snd cp) p) False)
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : or (eq (snd cp) p) False, or (eq (fst cp) p) (or (eq (snd cp) p) False)
+++++
clear H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.

*****
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
forall _ : or (eq (snd cp) p) False, or (eq (fst cp) p) (or (eq (snd cp) p) False)
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.

*****
H : or (eq (snd cp) p) False
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
or (eq (fst cp) p) (or (eq (snd cp) p) False)
+++++
right.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
right.

*****
H : or (eq (snd cp) p) False
cp : cartesianPower T (S (S O))
p : T
T : Type
*****
or (eq (snd cp) p) False
+++++
assumption.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.

*****
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
iff (In p (CPToList cp)) (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
+++++
simpl.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.

*****
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
iff (or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))) (or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))))
+++++
split.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.

*****
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))), or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.

*****
H : or (eq (fst cp) p)\n (or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
elim H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.

*****
H : or (eq (fst cp) p)\n (or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : eq (fst cp) p, or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
clear H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.

*****
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : eq (fst cp) p, or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.

*****
H : eq (fst cp) p
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
left.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
left.

*****
H : eq (fst cp) p
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
eq p (fst cp)
+++++
subst.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
left.
subst.

*****
IHn : forall cp0 : cartesianPower T (S (S n)),\niff (In (fst cp) (CPToList cp0))\n (or (eq (fst cp) (headCP cp0)) (In (fst cp) (CPToList (tailCP cp0))))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cp) (fst cp)
+++++
reflexivity.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.

*****
H : or (eq (fst cp) p)\n (or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))), or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
clear H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.

*****
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))), or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.

*****
H : or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
right.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
right.

*****
H : or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))
+++++
assumption.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.

*****
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : or (eq p (fst cp)) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))), or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.

*****
H : or (eq p (fst cp))\n (or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
elim H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.

*****
H : or (eq p (fst cp))\n (or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : eq p (fst cp), or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
clear H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.

*****
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : eq p (fst cp), or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.

*****
H : eq p (fst cp)
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
left.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
left.

*****
H : eq p (fst cp)
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
eq (fst cp) p
+++++
subst.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
left.
subst.

*****
IHn : forall cp0 : cartesianPower T (S (S n)),\niff (In (fst cp) (CPToList cp0))\n (or (eq (fst cp) (headCP cp0)) (In (fst cp) (CPToList (tailCP cp0))))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cp) (fst cp)
+++++
reflexivity.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.

*****
H : or (eq p (fst cp))\n (or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))), or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
clear H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.

*****
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
forall _ : or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))), or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
intro H.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.

*****
H : or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
or (eq (fst cp) p) (or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
right.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.
simpl.
split.
intro H.
elim H.
clear H.
intro H.
right.

*****
H : or (eq (fst (snd cp)) p)\n (In p\n (nat_rect\n (fun n : nat => forall _ : cartesianPower T (S n), list T)\n (fun cp : cartesianPower T (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower T (S n), list T)\n (cp : cartesianPower T (S (S n))) =>\n cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))
IHn : forall cp : cartesianPower T (S (S n)),\niff (In p (CPToList cp))\n (or (eq p (headCP cp)) (In p (CPToList (tailCP cp))))
cp : cartesianPower T (S (S (S n)))
p : T
n : nat
T : Type
*****
or (eq (fst (snd cp)) p) (In p (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))
+++++
assumption.
-----
Lemma InCPOK {T:Type} {n:nat} : forall p (cp : cartesianPower T (S (S n))), InCP p cp <-> ((p = headCP cp) \\/ InCP p (tailCP cp)).
Proof.
intros p cp.
unfold InCP.
induction n.

*****

*****

+++++
Qed.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S n), InCP (lastCP cp) cp
+++++
Proof.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S n), InCP (lastCP cp) cp
+++++
unfold InCP.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
Proof.
unfold InCP.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S n), In (lastCP cp) (CPToList cp)
+++++
intro cp.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
Proof.
unfold InCP.
intro cp.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
In (lastCP cp) (CPToList cp)
+++++
induction n.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
Proof.
unfold InCP.
intro cp.
induction n.

*****
cp : cartesianPower T (S O)
T : Type
*****
In (lastCP cp) (CPToList cp)
+++++
simpl.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
Proof.
unfold InCP.
intro cp.
induction n.
simpl.

*****
cp : cartesianPower T (S O)
T : Type
*****
or (eq cp cp) False
+++++
intuition.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
Proof.
unfold InCP.
intro cp.
induction n.

*****
IHn : forall cp : cartesianPower T (S n), In (lastCP cp) (CPToList cp)
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
In (lastCP cp) (CPToList cp)
+++++
simpl.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
Proof.
unfold InCP.
intro cp.
induction n.
simpl.

*****
IHn : forall cp : cartesianPower T (S n), In (lastCP cp) (CPToList cp)
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
or (eq (fst cp) (lastCP (tailCP cp))) (In (lastCP (tailCP cp)) (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)))
+++++
assert (H := IHn (tailCP cp)).
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
Proof.
unfold InCP.
intro cp.
induction n.
simpl.
assert (H := IHn (tailCP cp)).

*****
H : In (lastCP (tailCP cp)) (CPToList (tailCP cp))
IHn : forall cp : cartesianPower T (S n), In (lastCP cp) (CPToList cp)
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
or (eq (fst cp) (lastCP (tailCP cp))) (In (lastCP (tailCP cp)) (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)))
+++++
intuition.
-----
Lemma lastCPIn {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)), InCP (lastCP cp) cp.
Proof.
unfold InCP.
intro cp.
induction n.

*****

*****

+++++
Qed.
-----
Definition nthCP {T:Type} {m:nat} (n : nat) (cp : cartesianPower T m) (Default : T) := nth (n-1) (CPToList cp) Default.
-----
Lemma CPToListOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = cons (headCP cp) (CPToList (tailCP cp)).
-----
Lemma CPToListOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = cons (headCP cp) (CPToList (tailCP cp)).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (CPToList cp) (cons (headCP cp) (CPToList (tailCP cp)))
+++++
Proof.
-----
Lemma CPToListOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = cons (headCP cp) (CPToList (tailCP cp)).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (CPToList cp) (cons (headCP cp) (CPToList (tailCP cp)))
+++++
reflexivity.
-----
Lemma CPToListOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = cons (headCP cp) (CPToList (tailCP cp)).
Proof.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))),\n  CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (CPToList cp) (app (cons (headCP cp) nil) (CPToList (tailCP cp)))
+++++
Proof.
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (CPToList cp) (app (cons (headCP cp) nil) (CPToList (tailCP cp)))
+++++
induction n.
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).
Proof.
induction n.

*****
T : Type
*****
forall cp : cartesianPower T (S (S O)), eq (CPToList cp) (app (cons (headCP cp) nil) (CPToList (tailCP cp)))
+++++
intro cp.
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).
Proof.
induction n.
intro cp.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (CPToList cp) (app (cons (headCP cp) nil) (CPToList (tailCP cp)))
+++++
simpl.
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).
Proof.
induction n.
intro cp.
simpl.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (cons (fst cp) (cons (snd cp) nil)) (cons (fst cp) (cons (snd cp) nil))
+++++
reflexivity.
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).
Proof.
induction n.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (CPToList cp) (app (cons (headCP cp) nil) (CPToList (tailCP cp)))
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S (S n))), eq (CPToList cp) (app (cons (headCP cp) nil) (CPToList (tailCP cp)))
+++++
intro cp.
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).
Proof.
induction n.
intro cp.

*****
cp : cartesianPower T (S (S (S n)))
IHn : forall cp : cartesianPower T (S (S n)),\neq (CPToList cp) (app (cons (headCP cp) nil) (CPToList (tailCP cp)))
n : nat
T : Type
*****
eq (CPToList cp) (app (cons (headCP cp) nil) (CPToList (tailCP cp)))
+++++
simpl.
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).
Proof.
induction n.
intro cp.
simpl.

*****
cp : cartesianPower T (S (S (S n)))
IHn : forall cp : cartesianPower T (S (S n)),\neq (CPToList cp) (app (cons (headCP cp) nil) (CPToList (tailCP cp)))
n : nat
T : Type
*****
eq (cons (fst cp) (cons (fst (snd cp)) (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))) (cons (fst cp) (cons (fst (snd cp)) (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))
+++++
reflexivity.
-----
Lemma CPLHdTlOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), CPToList cp = ((headCP cp) :: nil) ++ CPToList (tailCP cp).
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t,\n  CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t : T), eq (CPToList (consTailCP cp t)) (app (CPToList cp) (cons t nil))
+++++
Proof.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t : T), eq (CPToList (consTailCP cp t)) (app (CPToList cp) (cons t nil))
+++++
induction n; intros cp t.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.
Proof.
induction n; intros cp t.

*****
t : T
cp : cartesianPower T (S O)
T : Type
*****
eq (CPToList (consTailCP cp t)) (app (CPToList cp) (cons t nil))
+++++
simpl; reflexivity.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.
Proof.
induction n; intros cp t.
simpl; reflexivity.

*****
t : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t : T),\neq (CPToList (consTailCP cp t)) (app (CPToList cp) (cons t nil))
n : nat
T : Type
*****
eq (CPToList (consTailCP cp t)) (app (CPToList cp) (cons t nil))
+++++
rewrite CPToListOK.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.
Proof.
induction n; intros cp t.
simpl; reflexivity.
rewrite CPToListOK.

*****
t : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t : T),\neq (CPToList (consTailCP cp t)) (app (CPToList cp) (cons t nil))
n : nat
T : Type
*****
eq (cons (headCP (consTailCP cp t)) (CPToList (tailCP (consTailCP cp t)))) (app (CPToList cp) (cons t nil))
+++++
assert (H : headCP (consTailCP cp t) = headCP cp) by (simpl; reflexivity); rewrite H; clear H.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.
Proof.
induction n; intros cp t.
simpl; reflexivity.
rewrite CPToListOK.
assert (H : headCP (consTailCP cp t) = headCP cp) by (simpl; reflexivity); rewrite H; clear H.

*****
t : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t : T),\neq (CPToList (consTailCP cp t)) (app (CPToList cp) (cons t nil))
n : nat
T : Type
*****
eq (cons (headCP cp) (CPToList (tailCP (consTailCP cp t)))) (app (CPToList cp) (cons t nil))
+++++
assert (H : tailCP (consTailCP cp t) = (consTailCP (tailCP cp) t)) by (simpl; reflexivity); rewrite H; clear H.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.
Proof.
induction n; intros cp t.
simpl; reflexivity.
rewrite CPToListOK.
assert (H : headCP (consTailCP cp t) = headCP cp) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consTailCP cp t) = (consTailCP (tailCP cp) t)) by (simpl; reflexivity); rewrite H; clear H.

*****
t : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t : T),\neq (CPToList (consTailCP cp t)) (app (CPToList cp) (cons t nil))
n : nat
T : Type
*****
eq (cons (headCP cp) (CPToList (consTailCP (tailCP cp) t))) (app (CPToList cp) (cons t nil))
+++++
rewrite IHn.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.
Proof.
induction n; intros cp t.
simpl; reflexivity.
rewrite CPToListOK.
assert (H : headCP (consTailCP cp t) = headCP cp) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consTailCP cp t) = (consTailCP (tailCP cp) t)) by (simpl; reflexivity); rewrite H; clear H.
rewrite IHn.

*****
t : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t : T),\neq (CPToList (consTailCP cp t)) (app (CPToList cp) (cons t nil))
n : nat
T : Type
*****
eq (cons (headCP cp) (app (CPToList (tailCP cp)) (cons t nil))) (app (CPToList cp) (cons t nil))
+++++
simpl; reflexivity.
-----
Lemma consTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, CPToList (consTailCP cp t) = CPToList cp ++ t :: nil.
Proof.
induction n; intros cp t.
simpl; reflexivity.
rewrite CPToListOK.
assert (H : headCP (consTailCP cp t) = headCP cp) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consTailCP cp t) = (consTailCP (tailCP cp) t)) by (simpl; reflexivity); rewrite H; clear H.
rewrite IHn.
simpl; reflexivity.

*****

*****

+++++
Qed.
-----
Lemma InNth {T:Type} {n:nat} :\n  forall (cp : cartesianPower T n) (t Default : T),\n  InCP t cp -> (exists id, id >= 1 /\ id <= n /\ t = nthCP id cp Default).
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T n) (t Default : T) (_ : InCP t cp), ex (fun id : nat => and (ge id (S O)) (and (le id n) (eq t (nthCP id cp Default))))
+++++
Proof.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T n) (t Default : T) (_ : InCP t cp), ex (fun id : nat => and (ge id (S O)) (and (le id n) (eq t (nthCP id cp Default))))
+++++
induction n; intros cp t Default HIn.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.

*****
HIn : InCP t cp
t,Default : T
cp : cartesianPower T O
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id O) (eq t (nthCP id cp Default))))
+++++
unfold InCP in HIn.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.

*****
HIn : In t (CPToList cp)
t,Default : T
cp : cartesianPower T O
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id O) (eq t (nthCP id cp Default))))
+++++
simpl in HIn.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.

*****
HIn : False
t,Default : T
cp : cartesianPower T O
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id O) (eq t (nthCP id cp Default))))
+++++
intuition.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.

*****
HIn : InCP t cp
t,Default : T
cp : cartesianPower T (S n)
IHn : forall (cp : cartesianPower T n) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id n) (eq t (nthCP id cp Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
+++++
induction n.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.

*****
HIn : InCP t cp
t,Default : T
cp : cartesianPower T (S O)
IHn : forall (cp : cartesianPower T O) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id O) (eq t (nthCP id cp Default))))
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S O)) (eq t (nthCP id cp Default))))
+++++
exists 1; try intuition.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.

*****
HIn : InCP t cp
t,Default : T
cp : cartesianPower T (S O)
IHn : forall (cp : cartesianPower T O) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id O) (eq t (nthCP id cp Default))))
T : Type
*****
eq t (nthCP (S O) cp Default)
+++++
unfold nthCP; simpl.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.

*****
HIn : InCP t cp
t,Default : T
cp : cartesianPower T (S O)
IHn : forall (cp : cartesianPower T O) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id O) (eq t (nthCP id cp Default))))
T : Type
*****
eq t cp
+++++
unfold InCP in HIn; simpl in HIn.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.

*****
HIn : or (eq cp t) False
t,Default : T
cp : cartesianPower T (S O)
IHn : forall (cp : cartesianPower T O) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id O) (eq t (nthCP id cp Default))))
T : Type
*****
eq t cp
+++++
intuition.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.

*****
IHn0 : forall\n (_ : forall (cp : cartesianPower T n) (t Default : T) (_ : InCP t cp),\n ex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id n) (eq t (nthCP id cp Default)))))\n (cp : cartesianPower T (S n)) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
HIn : InCP t cp
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S (S n))) (eq t (nthCP id cp Default))))
+++++
clear IHn0.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.

*****
HIn : InCP t cp
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S (S n))) (eq t (nthCP id cp Default))))
+++++
apply InCPOK in HIn.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.

*****
HIn : or (eq t (headCP cp)) (InCP t (tailCP cp))
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S (S n))) (eq t (nthCP id cp Default))))
+++++
elim HIn; clear HIn; intro HIn.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.

*****
HIn : eq t (headCP cp)
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S (S n))) (eq t (nthCP id cp Default))))
+++++
exists 1; unfold nthCP; simpl; intuition.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.

*****
HIn : InCP t (tailCP cp)
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S (S n))) (eq t (nthCP id cp Default))))
+++++
assert (H := IHn (tailCP cp) t Default).
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).

*****
H : forall _ : InCP t (tailCP cp),\nex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S n)) (eq t (nthCP id (tailCP cp) Default))))
HIn : InCP t (tailCP cp)
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S (S n))) (eq t (nthCP id cp Default))))
+++++
apply H in HIn; clear H.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.

*****
HIn : ex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S n)) (eq t (nthCP id (tailCP cp) Default))))
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S (S n))) (eq t (nthCP id cp Default))))
+++++
destruct HIn as [id [Hge [Hle HEq]]].
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.
destruct HIn as [id [Hge [Hle HEq]]].

*****
HEq : eq t (nthCP id (tailCP cp) Default)
Hle : le id (S n)
Hge : ge id (S O)
id : nat
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O)) (and (le id (S n)) (eq t (nthCP id cp Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S (S n))) (eq t (nthCP id cp Default))))
+++++
unfold nthCP in *.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.
destruct HIn as [id [Hge [Hle HEq]]].
unfold nthCP in *.

*****
HEq : eq t (nth (Init.Nat.sub id (S O)) (CPToList (tailCP cp)) Default)
Hle : le id (S n)
Hge : ge id (S O)
id : nat
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S n))\n (eq t (nth (Init.Nat.sub id (S O)) (CPToList cp) Default))))
n : nat
T : Type
*****
ex (fun id : nat => and (ge id (S O)) (and (le id (S (S n))) (eq t (nth (Init.Nat.sub id (S O)) (CPToList cp) Default))))
+++++
exists (S id); try intuition.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.
destruct HIn as [id [Hge [Hle HEq]]].
unfold nthCP in *.
exists (S id); try intuition.

*****
HEq : eq t (nth (Init.Nat.sub id (S O)) (CPToList (tailCP cp)) Default)
Hle : le id (S n)
Hge : ge id (S O)
id : nat
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S n))\n (eq t (nth (Init.Nat.sub id (S O)) (CPToList cp) Default))))
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (CPToList cp) Default)
+++++
assert (H := app_nth2 ((headCP cp) :: nil) (CPToList (tailCP cp)) Default Hge).
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.
destruct HIn as [id [Hge [Hle HEq]]].
unfold nthCP in *.
exists (S id); try intuition.
assert (H := app_nth2 ((headCP cp) :: nil) (CPToList (tailCP cp)) Default Hge).

*****
H : eq (nth id (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)\n (nth (Init.Nat.sub id (length (cons (headCP cp) nil)))\n (CPToList (tailCP cp)) Default)
HEq : eq t (nth (Init.Nat.sub id (S O)) (CPToList (tailCP cp)) Default)
Hle : le id (S n)
Hge : ge id (S O)
id : nat
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S n))\n (eq t (nth (Init.Nat.sub id (S O)) (CPToList cp) Default))))
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (CPToList cp) Default)
+++++
rewrite CPToListOK.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.
destruct HIn as [id [Hge [Hle HEq]]].
unfold nthCP in *.
exists (S id); try intuition.
assert (H := app_nth2 ((headCP cp) :: nil) (CPToList (tailCP cp)) Default Hge).
rewrite CPToListOK.

*****
H : eq (nth id (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)\n (nth (Init.Nat.sub id (length (cons (headCP cp) nil)))\n (CPToList (tailCP cp)) Default)
HEq : eq t (nth (Init.Nat.sub id (S O)) (CPToList (tailCP cp)) Default)
Hle : le id (S n)
Hge : ge id (S O)
id : nat
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S n))\n (eq t (nth (Init.Nat.sub id (S O)) (CPToList cp) Default))))
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (cons (headCP cp) (CPToList (tailCP cp))) Default)
+++++
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP cp) = (headCP cp :: CPToList (tailCP cp))) by (simpl; reflexivity); rewrite <- H'; clear H'.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.
destruct HIn as [id [Hge [Hle HEq]]].
unfold nthCP in *.
exists (S id); try intuition.
assert (H := app_nth2 ((headCP cp) :: nil) (CPToList (tailCP cp)) Default Hge).
rewrite CPToListOK.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP cp) = (headCP cp :: CPToList (tailCP cp))) by (simpl; reflexivity); rewrite <- H'; clear H'.

*****
H : eq (nth id (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)\n (nth (Init.Nat.sub id (length (cons (headCP cp) nil)))\n (CPToList (tailCP cp)) Default)
HEq : eq t (nth (Init.Nat.sub id (S O)) (CPToList (tailCP cp)) Default)
Hle : le id (S n)
Hge : ge id (S O)
id : nat
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S n))\n (eq t (nth (Init.Nat.sub id (S O)) (CPToList cp) Default))))
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)
+++++
assert (H' : (S id - 1) = id) by (simpl; rewrite minus_n_0; reflexivity); rewrite H'; clear H'.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.
destruct HIn as [id [Hge [Hle HEq]]].
unfold nthCP in *.
exists (S id); try intuition.
assert (H := app_nth2 ((headCP cp) :: nil) (CPToList (tailCP cp)) Default Hge).
rewrite CPToListOK.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP cp) = (headCP cp :: CPToList (tailCP cp))) by (simpl; reflexivity); rewrite <- H'; clear H'.
assert (H' : (S id - 1) = id) by (simpl; rewrite minus_n_0; reflexivity); rewrite H'; clear H'.

*****
H : eq (nth id (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)\n (nth (Init.Nat.sub id (length (cons (headCP cp) nil)))\n (CPToList (tailCP cp)) Default)
HEq : eq t (nth (Init.Nat.sub id (S O)) (CPToList (tailCP cp)) Default)
Hle : le id (S n)
Hge : ge id (S O)
id : nat
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S n))\n (eq t (nth (Init.Nat.sub id (S O)) (CPToList cp) Default))))
n : nat
T : Type
*****
eq t (nth id (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)
+++++
rewrite H.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.
destruct HIn as [id [Hge [Hle HEq]]].
unfold nthCP in *.
exists (S id); try intuition.
assert (H := app_nth2 ((headCP cp) :: nil) (CPToList (tailCP cp)) Default Hge).
rewrite CPToListOK.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP cp) = (headCP cp :: CPToList (tailCP cp))) by (simpl; reflexivity); rewrite <- H'; clear H'.
assert (H' : (S id - 1) = id) by (simpl; rewrite minus_n_0; reflexivity); rewrite H'; clear H'.
rewrite H.

*****
H : eq (nth id (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)\n (nth (Init.Nat.sub id (length (cons (headCP cp) nil)))\n (CPToList (tailCP cp)) Default)
HEq : eq t (nth (Init.Nat.sub id (S O)) (CPToList (tailCP cp)) Default)
Hle : le id (S n)
Hge : ge id (S O)
id : nat
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T) (_ : InCP t cp),\nex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S n))\n (eq t (nth (Init.Nat.sub id (S O)) (CPToList cp) Default))))
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub id (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
+++++
apply HEq.
-----
Lemma InNth {T:Type} {n:nat} : forall (cp : cartesianPower T n) (t Default : T), InCP t cp -> (exists id, id >= 1 /\\ id <= n /\\ t = nthCP id cp Default).
Proof.
induction n; intros cp t Default HIn.
unfold InCP in HIn.
simpl in HIn.
intuition.
induction n.
exists 1; try intuition.
unfold nthCP; simpl.
unfold InCP in HIn; simpl in HIn.
intuition.
clear IHn0.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
exists 1; unfold nthCP; simpl; intuition.
assert (H := IHn (tailCP cp) t Default).
apply H in HIn; clear H.
destruct HIn as [id [Hge [Hle HEq]]].
unfold nthCP in *.
exists (S id); try intuition.
assert (H := app_nth2 ((headCP cp) :: nil) (CPToList (tailCP cp)) Default Hge).
rewrite CPToListOK.
assert (H' : (headCP cp :: nil) ++ CPToList (tailCP cp) = (headCP cp :: CPToList (tailCP cp))) by (simpl; reflexivity); rewrite <- H'; clear H'.
assert (H' : (S id - 1) = id) by (simpl; rewrite minus_n_0; reflexivity); rewrite H'; clear H'.
rewrite H.
apply HEq.

*****

*****

+++++
Qed.
-----
Lemma nthFirst {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S n)) (t Default : T),\n  t = nthCP 1 cp Default -> t = headCP cp.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t Default : T) (_ : eq t (nthCP (S O) cp Default)), eq t (headCP cp)
+++++
Proof.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t Default : T) (_ : eq t (nthCP (S O) cp Default)), eq t (headCP cp)
+++++
induction n.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.
induction n.

*****
T : Type
*****
forall (cp : cartesianPower T (S O)) (t Default : T) (_ : eq t (nthCP (S O) cp Default)), eq t (headCP cp)
+++++
intros cp t Default Hnth.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.
induction n.
intros cp t Default Hnth.

*****
Hnth : eq t (nthCP (S O) cp Default)
t,Default : T
cp : cartesianPower T (S O)
T : Type
*****
eq t (headCP cp)
+++++
unfold nthCP in Hnth.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.
induction n.
intros cp t Default Hnth.
unfold nthCP in Hnth.

*****
Hnth : eq t (nth (Init.Nat.sub (S O) (S O)) (CPToList cp) Default)
t,Default : T
cp : cartesianPower T (S O)
T : Type
*****
eq t (headCP cp)
+++++
simpl in Hnth.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.
induction n.
intros cp t Default Hnth.
unfold nthCP in Hnth.
simpl in Hnth.

*****
Hnth : eq t cp
t,Default : T
cp : cartesianPower T (S O)
T : Type
*****
eq t (headCP cp)
+++++
assumption.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.
induction n.

*****
IHn : forall (cp : cartesianPower T (S n)) (t Default : T)\n (_ : eq t (nthCP (S O) cp Default)), eq t (headCP cp)
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (t Default : T) (_ : eq t (nthCP (S O) cp Default)), eq t (headCP cp)
+++++
intros cp t Default Hnth.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.
induction n.
intros cp t Default Hnth.

*****
Hnth : eq t (nthCP (S O) cp Default)
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T)\n (_ : eq t (nthCP (S O) cp Default)), eq t (headCP cp)
n : nat
T : Type
*****
eq t (headCP cp)
+++++
unfold nthCP in Hnth.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.
induction n.
intros cp t Default Hnth.
unfold nthCP in Hnth.

*****
Hnth : eq t (nth (Init.Nat.sub (S O) (S O)) (CPToList cp) Default)
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T)\n (_ : eq t (nthCP (S O) cp Default)), eq t (headCP cp)
n : nat
T : Type
*****
eq t (headCP cp)
+++++
simpl in Hnth.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.
induction n.
intros cp t Default Hnth.
unfold nthCP in Hnth.
simpl in Hnth.

*****
Hnth : eq t (fst cp)
t,Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t Default : T)\n (_ : eq t (nthCP (S O) cp Default)), eq t (headCP cp)
n : nat
T : Type
*****
eq t (headCP cp)
+++++
assumption.
-----
Lemma nthFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t Default : T), t = nthCP 1 cp Default -> t = headCP cp.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T n, eq n (length (CPToList cp))
+++++
Proof.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T n, eq n (length (CPToList cp))
+++++
intros.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.

*****
cp : cartesianPower T n
n : nat
T : Type
*****
eq n (length (CPToList cp))
+++++
induction n.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.
induction n.

*****
cp : cartesianPower T O
T : Type
*****
eq O (length (CPToList cp))
+++++
simpl.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.
induction n.
simpl.

*****
cp : cartesianPower T O
T : Type
*****
eq O O
+++++
reflexivity.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.
induction n.

*****
IHn : forall cp : cartesianPower T n, eq n (length (CPToList cp))
cp : cartesianPower T (S n)
n : nat
T : Type
*****
eq (S n) (length (CPToList cp))
+++++
clear IHn.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.
induction n.
clear IHn.

*****
cp : cartesianPower T (S n)
n : nat
T : Type
*****
eq (S n) (length (CPToList cp))
+++++
induction n.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.
induction n.
clear IHn.
induction n.

*****
cp : cartesianPower T (S O)
T : Type
*****
eq (S O) (length (CPToList cp))
+++++
simpl.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.
induction n.
clear IHn.
induction n.
simpl.

*****
cp : cartesianPower T (S O)
T : Type
*****
eq (S O) (S O)
+++++
reflexivity.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.
induction n.
clear IHn.
induction n.

*****
IHn : forall cp : cartesianPower T (S n), eq (S n) (length (CPToList cp))
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (S (S n)) (length (CPToList cp))
+++++
apply eq_S.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.
induction n.
clear IHn.
induction n.
apply eq_S.

*****
IHn : forall cp : cartesianPower T (S n), eq (S n) (length (CPToList cp))
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (S n) ((fix length (l : list T) : nat := match l with | nil => O | cons _ l' => S (length l') end) ((fix F (n : nat) : forall _ : cartesianPower T (S n), list T := match n as n0 return (forall _ : cartesianPower T (S n0), list T) with | O => fun cp : cartesianPower T (S O) => cons cp nil | S n0 => fun cp : cartesianPower T (S (S n0)) => cons (headCP cp) (F n0 (tailCP cp)) end) n (tailCP cp)))
+++++
apply IHn.
-----
Lemma lengthOfCPToList {T:Type} {n:nat} : forall (cp : cartesianPower T n), n = length (CPToList cp).
Proof.
intros.
induction n.

*****

*****

+++++
Defined.
-----
Lemma lastTailOK {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))),\n  lastCP cp = lastCP (tailCP cp).
-----
Lemma lastTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (lastCP cp) (lastCP (tailCP cp))
+++++
Proof.
-----
Lemma lastTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (lastCP cp) (lastCP (tailCP cp))
+++++
induction n.
-----
Lemma lastTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
induction n.

*****
T : Type
*****
forall cp : cartesianPower T (S (S O)), eq (lastCP cp) (lastCP (tailCP cp))
+++++
intro cp.
-----
Lemma lastTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
induction n.
intro cp.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (lastCP cp) (lastCP (tailCP cp))
+++++
simpl.
-----
Lemma lastTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
induction n.
intro cp.
simpl.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (snd cp) (snd cp)
+++++
reflexivity.
-----
Lemma lastTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
induction n.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (lastCP cp) (lastCP (tailCP cp))
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S (S n))), eq (lastCP cp) (lastCP (tailCP cp))
+++++
intro cp.
-----
Lemma lastTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
induction n.
intro cp.

*****
cp : cartesianPower T (S (S (S n)))
IHn : forall cp : cartesianPower T (S (S n)),\neq (lastCP cp) (lastCP (tailCP cp))
n : nat
T : Type
*****
eq (lastCP cp) (lastCP (tailCP cp))
+++++
simpl.
-----
Lemma lastTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
induction n.
intro cp.
simpl.

*****
cp : cartesianPower T (S (S (S n)))
IHn : forall cp : cartesianPower T (S (S n)),\neq (lastCP cp) (lastCP (tailCP cp))
n : nat
T : Type
*****
eq (lastCP (tailCP (snd cp))) (lastCP (tailCP (snd cp)))
+++++
reflexivity.
-----
Lemma lastTailOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), lastCP cp = lastCP (tailCP cp).
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma consTailCPLast {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S n)) t,\n  lastCP (consTailCP cp t) = t.
-----
Lemma consTailCPLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, lastCP (consTailCP cp t) = t.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t : T), eq (lastCP (consTailCP cp t)) t
+++++
Proof.
-----
Lemma consTailCPLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, lastCP (consTailCP cp t) = t.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t : T), eq (lastCP (consTailCP cp t)) t
+++++
intros cp t.
-----
Lemma consTailCPLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, lastCP (consTailCP cp t) = t.
Proof.
intros cp t.

*****
t : T
cp : cartesianPower T (S n)
n : nat
T : Type
*****
eq (lastCP (consTailCP cp t)) t
+++++
induction n.
-----
Lemma consTailCPLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, lastCP (consTailCP cp t) = t.
Proof.
intros cp t.
induction n.

*****
t : T
cp : cartesianPower T (S O)
T : Type
*****
eq (lastCP (consTailCP cp t)) t
+++++
try (simpl; reflexivity).
-----
Lemma consTailCPLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, lastCP (consTailCP cp t) = t.
Proof.
intros cp t.
induction n.

*****
IHn : forall cp : cartesianPower T (S n), eq (lastCP (consTailCP cp t)) t
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (lastCP (consTailCP cp t)) t
+++++
try (simpl; reflexivity).
-----
Lemma consTailCPLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, lastCP (consTailCP cp t) = t.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).

*****
IHn : forall cp : cartesianPower T (S n), eq (lastCP (consTailCP cp t)) t
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (lastCP (consTailCP cp t)) t
+++++
rewrite lastTailOK.
-----
Lemma consTailCPLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, lastCP (consTailCP cp t) = t.
Proof.
intros cp t.
induction n.
try (simpl; reflexivity).
rewrite lastTailOK.

*****
IHn : forall cp : cartesianPower T (S n), eq (lastCP (consTailCP cp t)) t
t : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (lastCP (tailCP (consTailCP cp t))) t
+++++
apply IHn.
-----
Lemma consTailCPLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) t, lastCP (consTailCP cp t) = t.
Proof.
intros cp t.
induction n.

*****

*****

+++++
Qed.
-----
Lemma nthLast {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S n)) (Default : T),\n  lastCP cp = nthCP (S n) cp Default.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (Default : T), eq (lastCP cp) (nthCP (S n) cp Default)
+++++
Proof.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (Default : T), eq (lastCP cp) (nthCP (S n) cp Default)
+++++
unfold nthCP.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (Default : T), eq (lastCP cp) (nth (Init.Nat.sub (S n) (S O)) (CPToList cp) Default)
+++++
induction n.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.

*****
T : Type
*****
forall (cp : cartesianPower T (S O)) (Default : T), eq (lastCP cp) (nth (Init.Nat.sub (S O) (S O)) (CPToList cp) Default)
+++++
intros cp Default.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.

*****
Default : T
cp : cartesianPower T (S O)
T : Type
*****
eq (lastCP cp) (nth (Init.Nat.sub (S O) (S O)) (CPToList cp) Default)
+++++
simpl.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.
simpl.

*****
Default : T
cp : cartesianPower T (S O)
T : Type
*****
eq cp cp
+++++
reflexivity.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.

*****
IHn : forall (cp : cartesianPower T (S n)) (Default : T),\neq (lastCP cp) (nth (Init.Nat.sub (S n) (S O)) (CPToList cp) Default)
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (Default : T), eq (lastCP cp) (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList cp) Default)
+++++
intros cp Default.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.

*****
Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (Default : T),\neq (lastCP cp) (nth (Init.Nat.sub (S n) (S O)) (CPToList cp) Default)
n : nat
T : Type
*****
eq (lastCP cp) (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList cp) Default)
+++++
rewrite lastTailOK.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.
rewrite lastTailOK.

*****
Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (Default : T),\neq (lastCP cp) (nth (Init.Nat.sub (S n) (S O)) (CPToList cp) Default)
n : nat
T : Type
*****
eq (lastCP (tailCP cp)) (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList cp) Default)
+++++
assert (H := IHn (tailCP cp) Default).
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.
rewrite lastTailOK.
assert (H := IHn (tailCP cp) Default).

*****
H : eq (lastCP (tailCP cp))\n (nth (Init.Nat.sub (S n) (S O)) (CPToList (tailCP cp)) Default)
Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (Default : T),\neq (lastCP cp) (nth (Init.Nat.sub (S n) (S O)) (CPToList cp) Default)
n : nat
T : Type
*****
eq (lastCP (tailCP cp)) (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList cp) Default)
+++++
rewrite H.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.
rewrite lastTailOK.
assert (H := IHn (tailCP cp) Default).
rewrite H.

*****
H : eq (lastCP (tailCP cp))\n (nth (Init.Nat.sub (S n) (S O)) (CPToList (tailCP cp)) Default)
Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (Default : T),\neq (lastCP cp) (nth (Init.Nat.sub (S n) (S O)) (CPToList cp) Default)
n : nat
T : Type
*****
eq (nth (Init.Nat.sub (S n) (S O)) (CPToList (tailCP cp)) Default) (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList cp) Default)
+++++
clear H.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.
rewrite lastTailOK.
assert (H := IHn (tailCP cp) Default).
rewrite H.
clear H.

*****
Default : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (Default : T),\neq (lastCP cp) (nth (Init.Nat.sub (S n) (S O)) (CPToList cp) Default)
n : nat
T : Type
*****
eq (nth (Init.Nat.sub (S n) (S O)) (CPToList (tailCP cp)) Default) (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList cp) Default)
+++++
clear IHn.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.
rewrite lastTailOK.
assert (H := IHn (tailCP cp) Default).
rewrite H.
clear H.
clear IHn.

*****
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nth (Init.Nat.sub (S n) (S O)) (CPToList (tailCP cp)) Default) (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList cp) Default)
+++++
simpl.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.
rewrite lastTailOK.
assert (H := IHn (tailCP cp) Default).
rewrite H.
clear H.
clear IHn.
simpl.

*****
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nth (Init.Nat.sub n O) (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)) Default) (nth n (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)) Default)
+++++
rewrite minus_n_0.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.
intros cp Default.
rewrite lastTailOK.
assert (H := IHn (tailCP cp) Default).
rewrite H.
clear H.
clear IHn.
simpl.
rewrite minus_n_0.

*****
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nth n (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)) Default) (nth n (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp)) Default)
+++++
reflexivity.
-----
Lemma nthLast {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (Default : T), lastCP cp = nthCP (S n) cp Default.
Proof.
unfold nthCP.
induction n.

*****

*****

+++++
Qed.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))) (t Default : T),\n  t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (t Default : T) (_ : eq t (nthCP (S O) cp Default)), eq t (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
Proof.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (t Default : T) (_ : eq t (nthCP (S O) cp Default)), eq t (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
intros cp t Default Hnth.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.

*****
Hnth : eq t (nthCP (S O) cp Default)
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
apply nthFirst in Hnth.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.

*****
Hnth : eq t (headCP cp)
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
rewrite <- Hnth.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.

*****
Hnth : eq t (headCP cp)
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t (nthCP (S (S n)) (consTailCP (tailCP cp) t) Default)
+++++
clear Hnth.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t (nthCP (S (S n)) (consTailCP (tailCP cp) t) Default)
+++++
unfold nthCP.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList (consTailCP (tailCP cp) t)) Default)
+++++
rewrite consTailOK.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.
rewrite consTailOK.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S (S n)) (S O)) (app (CPToList (tailCP cp)) (cons t nil)) Default)
+++++
rewrite app_nth2.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth2.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (Init.Nat.sub (S (S n)) (S O)) (length (CPToList (tailCP cp)))) (cons t nil) Default)
+++++
rewrite <- lengthOfCPToList.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth2.
rewrite <- lengthOfCPToList.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (Init.Nat.sub (S (S n)) (S O)) (S n)) (cons t nil) Default)
+++++
simpl.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth2.
rewrite <- lengthOfCPToList.
simpl.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t match Init.Nat.sub n n with | O => t | _ => Default end
+++++
rewrite <- Minus.minus_diag_reverse.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth2.
rewrite <- lengthOfCPToList.
simpl.
rewrite <- Minus.minus_diag_reverse.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq t t
+++++
reflexivity.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth2.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
ge (Init.Nat.sub (S (S n)) (S O)) (length (CPToList (tailCP cp)))
+++++
rewrite <- lengthOfCPToList.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth2.
rewrite <- lengthOfCPToList.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
ge (Init.Nat.sub (S (S n)) (S O)) (S n)
+++++
simpl.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth2.
rewrite <- lengthOfCPToList.
simpl.

*****
t,Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
ge (S n) (S n)
+++++
intuition.
-----
Lemma nthCircPerm1 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T), t = nthCP 1 cp Default -> t = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp t Default Hnth.
apply nthFirst in Hnth.
rewrite <- Hnth.
clear Hnth.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth2.

*****

*****

+++++
Qed.
-----
Lemma nthCircPerm1Eq {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))) (Default : T),\n  nthCP 1 cp Default = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
-----
Lemma nthCircPerm1Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (Default : T), eq (nthCP (S O) cp Default) (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
Proof.
-----
Lemma nthCircPerm1Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (Default : T), eq (nthCP (S O) cp Default) (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
intros cp Default.
-----
Lemma nthCircPerm1Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp Default.

*****
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S O) cp Default) (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
apply nthCircPerm1.
-----
Lemma nthCircPerm1Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp Default.
apply nthCircPerm1.

*****
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S O) cp Default) (nthCP (S O) cp Default)
+++++
reflexivity.
-----
Lemma nthCircPerm1Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp Default.
apply nthCircPerm1.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))) (t Default : T) id,\n  t = nthCP (S (S id)) cp Default -> id <= n ->\n  t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (t Default : T) (id : nat) (_ : eq t (nthCP (S (S id)) cp Default)) (_ : le id n), eq t (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
Proof.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (t Default : T) (id : nat) (_ : eq t (nthCP (S (S id)) cp Default)) (_ : le id n), eq t (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
induction n.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.

*****
T : Type
*****
forall (cp : cartesianPower T (S (S O))) (t Default : T) (id : nat) (_ : eq t (nthCP (S (S id)) cp Default)) (_ : le id O), eq t (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
intros cp t Default id Hnth HIn.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.

*****
HIn : le id O
Hnth : eq t (nthCP (S (S id)) cp Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq t (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
simpl in *.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
simpl in *.

*****
HIn : le id O
Hnth : eq t (nthCP (S (S id)) cp Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq t (nthCP (S id) (pair (snd cp) (fst cp)) Default)
+++++
induction id.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
simpl in *.
induction id.

*****
HIn : le O O
Hnth : eq t (nthCP (S (S O)) cp Default)
t,Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq t (nthCP (S O) (pair (snd cp) (fst cp)) Default)
+++++
unfold nthCP in *.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
simpl in *.
induction id.
unfold nthCP in *.

*****
HIn : le O O
Hnth : eq t (nth (Init.Nat.sub (S (S O)) (S O)) (CPToList cp) Default)
t,Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq t (nth (Init.Nat.sub (S O) (S O)) (CPToList (pair (snd cp) (fst cp))) Default)
+++++
simpl in Hnth.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
simpl in *.
induction id.
unfold nthCP in *.
simpl in Hnth.

*****
HIn : le O O
Hnth : eq t (snd cp)
t,Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq t (nth (Init.Nat.sub (S O) (S O)) (CPToList (pair (snd cp) (fst cp))) Default)
+++++
rewrite <- Hnth.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
simpl in *.
induction id.
unfold nthCP in *.
simpl in Hnth.
rewrite <- Hnth.

*****
HIn : le O O
Hnth : eq t (snd cp)
t,Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq t (nth (Init.Nat.sub (S O) (S O)) (CPToList (pair t (fst cp))) Default)
+++++
simpl.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
simpl in *.
induction id.
unfold nthCP in *.
simpl in Hnth.
rewrite <- Hnth.
simpl.

*****
HIn : le O O
Hnth : eq t (snd cp)
t,Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq t t
+++++
reflexivity.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
simpl in *.
induction id.

*****
IHid : forall (_ : eq t (nthCP (S (S id)) cp Default)) (_ : le id O),\neq t (nthCP (S id) (pair (snd cp) (fst cp)) Default)
HIn : le (S id) O
Hnth : eq t (nthCP (S (S (S id))) cp Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq t (nthCP (S (S id)) (pair (snd cp) (fst cp)) Default)
+++++
assert (H := Le.le_Sn_0 id).
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
simpl in *.
induction id.
assert (H := Le.le_Sn_0 id).

*****
H : not (le (S id) O)
IHid : forall (_ : eq t (nthCP (S (S id)) cp Default)) (_ : le id O),\neq t (nthCP (S id) (pair (snd cp) (fst cp)) Default)
HIn : le (S id) O
Hnth : eq t (nthCP (S (S (S id))) cp Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq t (nthCP (S (S id)) (pair (snd cp) (fst cp)) Default)
+++++
intuition.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.

*****
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat) (_ : eq t (nthCP (S (S id)) cp Default)) \n (_ : le id n),\neq t (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S (S n)))) (t Default : T) (id : nat) (_ : eq t (nthCP (S (S id)) cp Default)) (_ : le id (S n)), eq t (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
intros cp t Default id Hnth HIn.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.

*****
HIn : le id (S n)
Hnth : eq t (nthCP (S (S id)) cp Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat) (_ : eq t (nthCP (S (S id)) cp Default)) \n (_ : le id n),\neq t (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
T : Type
*****
eq t (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
unfold nthCP in *.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.

*****
HIn : le id (S n)
Hnth : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
+++++
rewrite consTailOK.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.

*****
HIn : le id (S n)
Hnth : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (app (CPToList (tailCP cp)) (cons (headCP cp) nil)) Default)
+++++
rewrite CPLHdTlOK in Hnth.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.

*****
HIn : le id (S n)
Hnth : eq t\n (nth (Init.Nat.sub (S (S id)) (S O))\n (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (app (CPToList (tailCP cp)) (cons (headCP cp) nil)) Default)
+++++
rewrite app_nth2 in Hnth.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.

*****
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (app (CPToList (tailCP cp)) (cons (headCP cp) nil)) Default)
+++++
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).

*****
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
eq (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O)) (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
+++++
simpl.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
simpl.

*****
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
eq (Init.Nat.sub id O) (Init.Nat.sub id O)
+++++
reflexivity.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).

*****
H : eq\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (app (CPToList (tailCP cp)) (cons (headCP cp) nil)) Default)
+++++
idtac.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
idtac.

*****
H : eq\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (app (CPToList (tailCP cp)) (cons (headCP cp) nil)) Default)
+++++
rewrite app_nth1.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
idtac.
rewrite app_nth1.

*****
H : eq\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
eq t (nth (Init.Nat.sub (S id) (S O)) (CPToList (tailCP cp)) Default)
+++++
try assumption.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
idtac.
rewrite app_nth1.

*****
H : eq\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
lt (Init.Nat.sub (S id) (S O)) (length (CPToList (tailCP cp)))
+++++
try assumption.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
idtac.
rewrite app_nth1.
try assumption.

*****
H : eq\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
lt (Init.Nat.sub (S id) (S O)) (length (CPToList (tailCP cp)))
+++++
rewrite <- lengthOfCPToList.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
idtac.
rewrite app_nth1.
try assumption.
rewrite <- lengthOfCPToList.

*****
H : eq\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
lt (Init.Nat.sub (S id) (S O)) (S (S n))
+++++
simpl.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
idtac.
rewrite app_nth1.
try assumption.
rewrite <- lengthOfCPToList.
simpl.

*****
H : eq\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
lt (Init.Nat.sub id O) (S (S n))
+++++
rewrite minus_n_0.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
idtac.
rewrite app_nth1.
try assumption.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.

*****
H : eq\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
lt id (S (S n))
+++++
apply Lt.le_lt_n_Sm.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
assert (H : S (S id) - 1 - length (headCP cp :: nil) = S id - 1).
idtac.
rewrite app_nth1.
try assumption.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.
apply Lt.le_lt_n_Sm.

*****
H : eq\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (Init.Nat.sub (S id) (S O))
HIn : le id (S n)
Hnth : eq t\n (nth\n (Init.Nat.sub (Init.Nat.sub (S (S id)) (S O))\n (length (cons (headCP cp) nil))) (CPToList (tailCP cp)) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
le id (S n)
+++++
assumption.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.

*****
HIn : le id (S n)
Hnth : eq t\n (nth (Init.Nat.sub (S (S id)) (S O))\n (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
ge (Init.Nat.sub (S (S id)) (S O)) (length (cons (headCP cp) nil))
+++++
simpl.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.
intros cp t Default id Hnth HIn.
unfold nthCP in *.
rewrite consTailOK.
rewrite CPLHdTlOK in Hnth.
rewrite app_nth2 in Hnth.
simpl.

*****
HIn : le id (S n)
Hnth : eq t\n (nth (Init.Nat.sub (S (S id)) (S O))\n (app (cons (headCP cp) nil) (CPToList (tailCP cp))) Default)
id : nat
t,Default : T
cp : cartesianPower T (S (S (S n)))
IHn : forall (cp : cartesianPower T (S (S n))) (t Default : T) \n (id : nat)\n (_ : eq t (nth (Init.Nat.sub (S (S id)) (S O)) (CPToList cp) Default))\n (_ : le id n),\neq t\n (nth (Init.Nat.sub (S id) (S O))\n (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
n : nat
T : Type
*****
ge (S id) (S O)
+++++
intuition.
-----
Lemma nthCircPerm2 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (t Default : T) id, t = nthCP (S (S id)) cp Default -> id <= n -> t = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma nthCircPerm2Eq {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))) (Default : T) id,\n  id <= n -> nthCP (S (S id)) cp Default = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
-----
Lemma nthCircPerm2Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T) id, id <= n -> nthCP (S (S id)) cp Default = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (Default : T) (id : nat) (_ : le id n), eq (nthCP (S (S id)) cp Default) (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
Proof.
-----
Lemma nthCircPerm2Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T) id, id <= n -> nthCP (S (S id)) cp Default = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (Default : T) (id : nat) (_ : le id n), eq (nthCP (S (S id)) cp Default) (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
intros cp Default id Hle.
-----
Lemma nthCircPerm2Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T) id, id <= n -> nthCP (S (S id)) cp Default = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp Default id Hle.

*****
Hle : le id n
id : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S (S id)) cp Default) (nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
apply nthCircPerm2.
-----
Lemma nthCircPerm2Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T) id, id <= n -> nthCP (S (S id)) cp Default = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp Default id Hle.
apply nthCircPerm2.

*****
Hle : le id n
id : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S (S id)) cp Default) (nthCP (S (S id)) cp Default)
+++++
reflexivity.
-----
Lemma nthCircPerm2Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T) id, id <= n -> nthCP (S (S id)) cp Default = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp Default id Hle.
apply nthCircPerm2.

*****
Hle : le id n
id : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le id n
+++++
assumption.
-----
Lemma nthCircPerm2Eq {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T) id, id <= n -> nthCP (S (S id)) cp Default = nthCP (S id) (consTailCP (tailCP cp) (headCP cp)) Default.
Proof.
intros cp Default id Hle.
apply nthCircPerm2.

*****

*****

+++++
Qed.
-----
Lemma nthCPTlOK {T:Type} {m:nat} :\n  forall (cp : cartesianPower T (S (S m))) (Default : T) n,\n  nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.

*****
m : nat
T : Type
*****
forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat), eq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
+++++
Proof.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.

*****
m : nat
T : Type
*****
forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat), eq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
+++++
induction m; intros cp Default n.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.

*****
n : nat
Default : T
cp : cartesianPower T (S (S O))
T : Type
*****
eq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
+++++
induction n; unfold nthCP; simpl; reflexivity.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.

*****
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
+++++
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).

*****
H : forall\n (_ : eq (nthCP (S (S n)) cp Default) (nthCP (S (S n)) cp Default))\n (_ : le n (S m)),\neq (nthCP (S (S n)) cp Default)\n (nthCP (S n) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
+++++
assert (Hnm := le_lt_dec n (S m)).
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).

*****
Hnm : sumbool (le n (S m)) (lt (S m) n)
H : forall\n (_ : eq (nthCP (S (S n)) cp Default) (nthCP (S (S n)) cp Default))\n (_ : le n (S m)),\neq (nthCP (S (S n)) cp Default)\n (nthCP (S n) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
+++++
elim Hnm; clear Hnm; intro Hnm.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.

*****
Hnm : le n (S m)
H : forall\n (_ : eq (nthCP (S (S n)) cp Default) (nthCP (S (S n)) cp Default))\n (_ : le n (S m)),\neq (nthCP (S (S n)) cp Default)\n (nthCP (S n) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
+++++
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.

*****
Hnm : le n (S m)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq (nthCP (S n) (tailCP cp) Default) (nthCP (S n) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
unfold nthCP.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.

*****
Hnm : le n (S m)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq (nth (Init.Nat.sub (S n) (S O)) (CPToList (tailCP cp)) Default) (nth (Init.Nat.sub (S n) (S O)) (CPToList (consTailCP (tailCP cp) (headCP cp))) Default)
+++++
rewrite consTailOK.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.

*****
Hnm : le n (S m)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq (nth (Init.Nat.sub (S n) (S O)) (CPToList (tailCP cp)) Default) (nth (Init.Nat.sub (S n) (S O)) (app (CPToList (tailCP cp)) (cons (headCP cp) nil)) Default)
+++++
rewrite app_nth1; try reflexivity.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.

*****
Hnm : le n (S m)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
lt (Init.Nat.sub (S n) (S O)) (length (CPToList (tailCP cp)))
+++++
rewrite <- lengthOfCPToList.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.
rewrite <- lengthOfCPToList.

*****
Hnm : le n (S m)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
lt (Init.Nat.sub (S n) (S O)) (S (S m))
+++++
simpl.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.
rewrite <- lengthOfCPToList.
simpl.

*****
Hnm : le n (S m)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
lt (Init.Nat.sub n O) (S (S m))
+++++
rewrite minus_n_0.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.

*****
Hnm : le n (S m)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
lt n (S (S m))
+++++
apply Lt.le_lt_n_Sm; assumption.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.
apply Lt.le_lt_n_Sm; assumption.

*****
Hnm : lt (S m) n
H : forall\n (_ : eq (nthCP (S (S n)) cp Default) (nthCP (S (S n)) cp Default))\n (_ : le n (S m)),\neq (nthCP (S (S n)) cp Default)\n (nthCP (S n) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
+++++
unfold nthCP.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.
apply Lt.le_lt_n_Sm; assumption.
unfold nthCP.

*****
Hnm : lt (S m) n
H : forall\n (_ : eq (nthCP (S (S n)) cp Default) (nthCP (S (S n)) cp Default))\n (_ : le n (S m)),\neq (nthCP (S (S n)) cp Default)\n (nthCP (S n) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq (nth (Init.Nat.sub (S n) (S O)) (CPToList (tailCP cp)) Default) (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList cp) Default)
+++++
rewrite nth_overflow.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.
apply Lt.le_lt_n_Sm; assumption.
unfold nthCP.
rewrite nth_overflow.

*****
Hnm : lt (S m) n
H : forall\n (_ : eq (nthCP (S (S n)) cp Default) (nthCP (S (S n)) cp Default))\n (_ : le n (S m)),\neq (nthCP (S (S n)) cp Default)\n (nthCP (S n) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
eq Default (nth (Init.Nat.sub (S (S n)) (S O)) (CPToList cp) Default)
+++++
rewrite nth_overflow; try reflexivity.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.
apply Lt.le_lt_n_Sm; assumption.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow; try reflexivity.

*****
Hnm : lt (S m) n
H : forall\n (_ : eq (nthCP (S (S n)) cp Default) (nthCP (S (S n)) cp Default))\n (_ : le n (S m)),\neq (nthCP (S (S n)) cp Default)\n (nthCP (S n) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
le (length (CPToList cp)) (Init.Nat.sub (S (S n)) (S O))
+++++
rewrite <- lengthOfCPToList; simpl; intuition.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.
apply Lt.le_lt_n_Sm; assumption.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow; try reflexivity.
rewrite <- lengthOfCPToList; simpl; intuition.

*****
Hnm : lt (S m) n
H : forall\n (_ : eq (nthCP (S (S n)) cp Default) (nthCP (S (S n)) cp Default))\n (_ : le n (S m)),\neq (nthCP (S (S n)) cp Default)\n (nthCP (S n) (consTailCP (tailCP cp) (headCP cp)) Default)
n : nat
Default : T
cp : cartesianPower T (S (S (S m)))
IHm : forall (cp : cartesianPower T (S (S m))) (Default : T) (n : nat),\neq (nthCP (S n) (tailCP cp) Default) (nthCP (S (S n)) cp Default)
m : nat
T : Type
*****
le (length (CPToList (tailCP cp))) (Init.Nat.sub (S n) (S O))
+++++
rewrite <- lengthOfCPToList; simpl; rewrite minus_n_0; intuition.
-----
Lemma nthCPTlOK {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) n, nthCP (S n) (tailCP cp) Default = nthCP (S (S n)) cp Default.
Proof.
induction m; intros cp Default n.
induction n; unfold nthCP; simpl; reflexivity.
assert (H := nthCircPerm2 cp (nthCP (S (S n)) cp Default) Default n).
assert (Hnm := le_lt_dec n (S m)).
elim Hnm; clear Hnm; intro Hnm.
assert (H' : nthCP (S (S n)) cp Default = nthCP (S (S n)) cp Default) by reflexivity; apply H in H'; try assumption; clear H; rewrite H'; clear H'.
unfold nthCP.
rewrite consTailOK.
rewrite app_nth1; try reflexivity.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.
apply Lt.le_lt_n_Sm; assumption.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow; try reflexivity.
rewrite <- lengthOfCPToList; simpl; intuition.
rewrite <- lengthOfCPToList; simpl; rewrite minus_n_0; intuition.

*****

*****

+++++
Qed.
-----
Lemma nthEqOK {T:Type} {m:nat} :\n  forall (cp1 cp2 : cartesianPower T (S m)) (Default : T),\n  (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.

*****
m : nat
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S m)) (Default : T) (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)), eq cp1 cp2
+++++
Proof.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.

*****
m : nat
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S m)) (Default : T) (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)), eq cp1 cp2
+++++
induction m.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.

*****
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S O)) (Default : T) (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)), eq cp1 cp2
+++++
intros cp1 cp2 Default Hnth.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.

*****
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S O)
T : Type
*****
eq cp1 cp2
+++++
assert (H := Hnth 1).
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
assert (H := Hnth 1).

*****
H : eq (nthCP (S O) cp1 Default) (nthCP (S O) cp2 Default)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S O)
T : Type
*****
eq cp1 cp2
+++++
unfold nthCP in H.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
assert (H := Hnth 1).
unfold nthCP in H.

*****
H : eq (nth (Init.Nat.sub (S O) (S O)) (CPToList cp1) Default)\n (nth (Init.Nat.sub (S O) (S O)) (CPToList cp2) Default)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S O)
T : Type
*****
eq cp1 cp2
+++++
simpl in H.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
assert (H := Hnth 1).
unfold nthCP in H.
simpl in H.

*****
H : eq cp1 cp2
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S O)
T : Type
*****
eq cp1 cp2
+++++
assumption.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.

*****
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S (S m))) (Default : T) (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)), eq cp1 cp2
+++++
intros cp1 cp2 Default Hnth.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.

*****
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq cp1 cp2
+++++
apply CP_ind.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.

*****
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (headCP cp1) (headCP cp2)
+++++
assert (H := Hnth 1).
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
assert (H := Hnth 1).

*****
H : eq (nthCP (S O) cp1 Default) (nthCP (S O) cp2 Default)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (headCP cp1) (headCP cp2)
+++++
unfold nthCP in H.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
assert (H := Hnth 1).
unfold nthCP in H.

*****
H : eq (nth (Init.Nat.sub (S O) (S O)) (CPToList cp1) Default)\n (nth (Init.Nat.sub (S O) (S O)) (CPToList cp2) Default)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (headCP cp1) (headCP cp2)
+++++
simpl in H.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
assert (H := Hnth 1).
unfold nthCP in H.
simpl in H.

*****
H : eq (fst cp1) (fst cp2)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (headCP cp1) (headCP cp2)
+++++
assumption.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.

*****
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (tailCP cp1) (tailCP cp2)
+++++
apply IHm with Default.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.

*****
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
forall n : nat, eq (nthCP n (tailCP cp1) Default) (nthCP n (tailCP cp2) Default)
+++++
intro n.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.
intro n.

*****
n : nat
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (nthCP n (tailCP cp1) Default) (nthCP n (tailCP cp2) Default)
+++++
induction n.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.
intro n.
induction n.

*****
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (nthCP O (tailCP cp1) Default) (nthCP O (tailCP cp2) Default)
+++++
assert (H := Hnth 2).
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.
intro n.
induction n.
assert (H := Hnth 2).

*****
H : eq (nthCP (S (S O)) cp1 Default) (nthCP (S (S O)) cp2 Default)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (nthCP O (tailCP cp1) Default) (nthCP O (tailCP cp2) Default)
+++++
unfold nthCP.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.
intro n.
induction n.
assert (H := Hnth 2).
unfold nthCP.

*****
H : eq (nthCP (S (S O)) cp1 Default) (nthCP (S (S O)) cp2 Default)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (nth (Init.Nat.sub O (S O)) (CPToList (tailCP cp1)) Default) (nth (Init.Nat.sub O (S O)) (CPToList (tailCP cp2)) Default)
+++++
unfold nthCP in H.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.
intro n.
induction n.
assert (H := Hnth 2).
unfold nthCP.
unfold nthCP in H.

*****
H : eq (nth (Init.Nat.sub (S (S O)) (S O)) (CPToList cp1) Default)\n (nth (Init.Nat.sub (S (S O)) (S O)) (CPToList cp2) Default)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (nth (Init.Nat.sub O (S O)) (CPToList (tailCP cp1)) Default) (nth (Init.Nat.sub O (S O)) (CPToList (tailCP cp2)) Default)
+++++
do 2 (rewrite CPLHdTlOK in H).
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.
intro n.
induction n.
assert (H := Hnth 2).
unfold nthCP.
unfold nthCP in H.
do 2 (rewrite CPLHdTlOK in H).

*****
H : eq\n (nth (Init.Nat.sub (S (S O)) (S O))\n (app (cons (headCP cp1) nil) (CPToList (tailCP cp1))) Default)\n (nth (Init.Nat.sub (S (S O)) (S O))\n (app (cons (headCP cp2) nil) (CPToList (tailCP cp2))) Default)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (nth (Init.Nat.sub O (S O)) (CPToList (tailCP cp1)) Default) (nth (Init.Nat.sub O (S O)) (CPToList (tailCP cp2)) Default)
+++++
simpl.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.
intro n.
induction n.
assert (H := Hnth 2).
unfold nthCP.
unfold nthCP in H.
do 2 (rewrite CPLHdTlOK in H).
simpl.

*****
H : eq\n (nth (Init.Nat.sub (S (S O)) (S O))\n (app (cons (headCP cp1) nil) (CPToList (tailCP cp1))) Default)\n (nth (Init.Nat.sub (S (S O)) (S O))\n (app (cons (headCP cp2) nil) (CPToList (tailCP cp2))) Default)
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (nth O (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) m (tailCP cp1)) Default) (nth O (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) m (tailCP cp2)) Default)
+++++
assumption.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.
intro n.
induction n.

*****
IHn : eq (nthCP n (tailCP cp1) Default) (nthCP n (tailCP cp2) Default)
n : nat
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (nthCP (S n) (tailCP cp1) Default) (nthCP (S n) (tailCP cp2) Default)
+++++
do 2 (rewrite nthCPTlOK).
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.
intros cp1 cp2 Default Hnth.
apply CP_ind.
apply IHm with Default.
intro n.
induction n.
do 2 (rewrite nthCPTlOK).

*****
IHn : eq (nthCP n (tailCP cp1) Default) (nthCP n (tailCP cp2) Default)
n : nat
Hnth : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)
Default : T
cp1,cp2 : cartesianPower T (S (S m))
IHm : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T)\n (_ : forall n : nat, eq (nthCP n cp1 Default) (nthCP n cp2 Default)),\neq cp1 cp2
m : nat
T : Type
*****
eq (nthCP (S (S n)) cp1 Default) (nthCP (S (S n)) cp2 Default)
+++++
apply Hnth.
-----
Lemma nthEqOK {T:Type} {m:nat} : forall (cp1 cp2 : cartesianPower T (S m)) (Default : T), (forall n, nthCP n cp1 Default = nthCP n cp2 Default) -> cp1 = cp2.
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Lemma consTailPerm  {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))),\n  Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp))).
-----
Lemma consTailPerm {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp))).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp)))
+++++
Proof.
-----
Lemma consTailPerm {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp))).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp)))
+++++
intro cp.
-----
Lemma consTailPerm {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp))).
Proof.
intro cp.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp)))
+++++
rewrite CPLHdTlOK.
-----
Lemma consTailPerm {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp))).
Proof.
intro cp.
rewrite CPLHdTlOK.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
Permutation.Permutation (app (cons (headCP cp) nil) (CPToList (tailCP cp))) (CPToList (consTailCP (tailCP cp) (headCP cp)))
+++++
rewrite consTailOK.
-----
Lemma consTailPerm {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp))).
Proof.
intro cp.
rewrite CPLHdTlOK.
rewrite consTailOK.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
Permutation.Permutation (app (cons (headCP cp) nil) (CPToList (tailCP cp))) (app (CPToList (tailCP cp)) (cons (headCP cp) nil))
+++++
apply Permutation.Permutation_app_comm.
-----
Lemma consTailPerm {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), Permutation.Permutation (CPToList cp) (CPToList (consTailCP (tailCP cp) (headCP cp))).
Proof.
intro cp.
rewrite CPLHdTlOK.
rewrite consTailOK.
apply Permutation.Permutation_app_comm.

*****

*****

+++++
Qed.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).

*****
Default : T
l : list T
T : Type
*****
cartesianPower T (length l)
+++++
Proof.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.

*****
Default : T
l : list T
T : Type
*****
cartesianPower T (length l)
+++++
induction l.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.

*****
Default : T
T : Type
*****
cartesianPower T (length nil)
+++++
exact Default.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.

*****
IHl : cartesianPower T (length l)
Default : T
l : list T
a : T
T : Type
*****
cartesianPower T (length (cons a l))
+++++
induction l.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.
induction l.

*****
IHl : cartesianPower T (length nil)
a,Default : T
T : Type
*****
cartesianPower T (length (cons a nil))
+++++
exact a.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.
induction l.

*****
IHl0 : forall _ : cartesianPower T (length l),\ncartesianPower T (length (cons a l))
IHl : cartesianPower T (length (cons a0 l))
Default : T
l : list T
a,a0 : T
T : Type
*****
cartesianPower T (length (cons a (cons a0 l)))
+++++
clear IHl0.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.
induction l.
clear IHl0.

*****
IHl : cartesianPower T (length (cons a0 l))
Default : T
l : list T
a,a0 : T
T : Type
*****
cartesianPower T (length (cons a (cons a0 l)))
+++++
split.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.
induction l.
clear IHl0.
split.

*****
IHl : cartesianPower T (length (cons a0 l))
Default : T
l : list T
a,a0 : T
T : Type
*****
T
+++++
exact a.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.
induction l.
clear IHl0.
split.

*****
IHl : cartesianPower T (length (cons a0 l))
Default : T
l : list T
a,a0 : T
T : Type
*****
cartesianPowerAux T (length l)
+++++
unfold cartesianPower in IHl.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.
induction l.
clear IHl0.
split.
unfold cartesianPower in IHl.

*****
IHl : cartesianPowerAux T (Init.Nat.sub (length (cons a0 l)) (S O))
Default : T
l : list T
a,a0 : T
T : Type
*****
cartesianPowerAux T (length l)
+++++
simpl in IHl.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.
induction l.
clear IHl0.
split.
unfold cartesianPower in IHl.
simpl in IHl.

*****
IHl : cartesianPowerAux T (Init.Nat.sub (length l) O)
Default : T
l : list T
a,a0 : T
T : Type
*****
cartesianPowerAux T (length l)
+++++
rewrite minus_n_0 in IHl.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.
induction l.
clear IHl0.
split.
unfold cartesianPower in IHl.
simpl in IHl.
rewrite minus_n_0 in IHl.

*****
IHl : cartesianPowerAux T (length l)
Default : T
l : list T
a,a0 : T
T : Type
*****
cartesianPowerAux T (length l)
+++++
exact IHl.
-----
Definition ListToCP {T : Type} (l : list T) (Default : T) : cartesianPower T (length l).
Proof.
induction l.

*****

*****

+++++
Defined.
-----
Fixpoint circPermNCP {T:Type} {m:nat} (n : nat) (cp : cartesianPower T (S (S m))) :=\n  match n with\n  | 0 => cp\n  | S p => circPermNCP p (consTailCP (tailCP cp) (headCP cp))\n  end.
-----
Lemma circPermNCP0 {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))),\n  cp = circPermNCP 0 cp.
-----
Lemma circPermNCP0 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = circPermNCP 0 cp.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq cp (circPermNCP O cp)
+++++
Proof.
-----
Lemma circPermNCP0 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = circPermNCP 0 cp.
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq cp (circPermNCP O cp)
+++++
simpl.
-----
Lemma circPermNCP0 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = circPermNCP 0 cp.
Proof.
simpl.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq cp cp
+++++
reflexivity.
-----
Lemma circPermNCP0 {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = circPermNCP 0 cp.
Proof.
simpl.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma circPermNCPOK {T:Type} {m:nat} :\n  forall (n : nat) (cp : cartesianPower T (S (S m))),\n  circPermNCP (S n) cp = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
-----
Lemma circPermNCPOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S n) cp = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).

*****
m : nat
T : Type
*****
forall (n : nat) (cp : cartesianPower T (S (S m))), eq (circPermNCP (S n) cp) (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
+++++
Proof.
-----
Lemma circPermNCPOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S n) cp = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.

*****
m : nat
T : Type
*****
forall (n : nat) (cp : cartesianPower T (S (S m))), eq (circPermNCP (S n) cp) (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
+++++
unfold circPermNCP.
-----
Lemma circPermNCPOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S n) cp = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
unfold circPermNCP.

*****
m : nat
T : Type
*****
forall (n : nat) (cp : cartesianPower T (S (S m))), eq ((fix circPermNCP (T : Type) (m n0 : nat) (cp0 : cartesianPower T (S (S m))) {struct n0} : cartesianPower T (S (S m)) := match n0 with | O => cp0 | S p => circPermNCP T m p (consTailCP (tailCP cp0) (headCP cp0)) end) T m n (consTailCP (tailCP cp) (headCP cp))) ((fix circPermNCP (T : Type) (m n0 : nat) (cp0 : cartesianPower T (S (S m))) {struct n0} : cartesianPower T (S (S m)) := match n0 with | O => cp0 | S p => circPermNCP T m p (consTailCP (tailCP cp0) (headCP cp0)) end) T m n (consTailCP (tailCP cp) (headCP cp)))
+++++
reflexivity.
-----
Lemma circPermNCPOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S n) cp = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
unfold circPermNCP.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} :\n  forall (cp : cartesianPower T (S (S m))) (Default : T) id n,\n  id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.

*****
m : nat
T : Type
*****
forall (cp : cartesianPower T (S (S m))) (Default : T) (id n : nat) (_ : le (Init.Nat.add id n) (S m)), eq (nthCP (Init.Nat.add (S id) n) cp Default) (nthCP (S id) (circPermNCP n cp) Default)
+++++
Proof.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.

*****
m : nat
T : Type
*****
forall (cp : cartesianPower T (S (S m))) (Default : T) (id n : nat) (_ : le (Init.Nat.add id n) (S m)), eq (nthCP (Init.Nat.add (S id) n) cp Default) (nthCP (S id) (circPermNCP n cp) Default)
+++++
intros cp Default id n Hle.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.

*****
Hle : le (Init.Nat.add id n) (S m)
id,n : nat
Default : T
cp : cartesianPower T (S (S m))
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) n) cp Default) (nthCP (S id) (circPermNCP n cp) Default)
+++++
revert cp.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.

*****
Hle : le (Init.Nat.add id n) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
forall cp : cartesianPower T (S (S m)), eq (nthCP (Init.Nat.add (S id) n) cp Default) (nthCP (S id) (circPermNCP n cp) Default)
+++++
induction n.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.

*****
Hle : le (Init.Nat.add id O) (S m)
id : nat
Default : T
m : nat
T : Type
*****
forall cp : cartesianPower T (S (S m)), eq (nthCP (Init.Nat.add (S id) O) cp Default) (nthCP (S id) (circPermNCP O cp) Default)
+++++
intro cp.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.

*****
cp : cartesianPower T (S (S m))
Hle : le (Init.Nat.add id O) (S m)
id : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) O) cp Default) (nthCP (S id) (circPermNCP O cp) Default)
+++++
rewrite plus_n_0.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite plus_n_0.

*****
cp : cartesianPower T (S (S m))
Hle : le (Init.Nat.add id O) (S m)
id : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (S id) cp Default) (nthCP (S id) (circPermNCP O cp) Default)
+++++
simpl.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite plus_n_0.
simpl.

*****
cp : cartesianPower T (S (S m))
Hle : le (Init.Nat.add id O) (S m)
id : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (S id) cp Default) (nthCP (S id) cp Default)
+++++
reflexivity.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.

*****
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
forall cp : cartesianPower T (S (S m)), eq (nthCP (Init.Nat.add (S id) (S n)) cp Default) (nthCP (S id) (circPermNCP (S n) cp) Default)
+++++
intro cp.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.

*****
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) (S n)) cp Default) (nthCP (S id) (circPermNCP (S n) cp) Default)
+++++
rewrite circPermNCPOK.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.

*****
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) (S n)) cp Default) (nthCP (S id) (circPermNCP n (consTailCP (tailCP cp) (headCP cp))) Default)
+++++
assert (H : id + n <= S m).
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).

*****
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
le (Init.Nat.add id n) (S m)
+++++
apply le_Sn_le.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
apply le_Sn_le.

*****
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
le (S (Init.Nat.add id n)) (S m)
+++++
rewrite plus_n_Sm.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
apply le_Sn_le.
rewrite plus_n_Sm.

*****
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
le (Init.Nat.add id (S n)) (S m)
+++++
assumption.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).

*****
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) (S n)) cp Default) (nthCP (S id) (circPermNCP n (consTailCP (tailCP cp) (headCP cp))) Default)
+++++
idtac.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.

*****
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) (S n)) cp Default) (nthCP (S id) (circPermNCP n (consTailCP (tailCP cp) (headCP cp))) Default)
+++++
assert (H' : id + n <= m).
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).

*****
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
le (Init.Nat.add id n) m
+++++
apply le_S_n.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).
apply le_S_n.

*****
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
le (S (Init.Nat.add id n)) (S m)
+++++
transitivity (id + S n).
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).
apply le_S_n.
transitivity (id + S n).

*****
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
le (S (Init.Nat.add id n)) (Init.Nat.add id (S n))
+++++
intuition.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).
apply le_S_n.
transitivity (id + S n).

*****
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
le (Init.Nat.add id (S n)) (S m)
+++++
intuition.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).

*****
H' : le (Init.Nat.add id n) m
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) (S n)) cp Default) (nthCP (S id) (circPermNCP n (consTailCP (tailCP cp) (headCP cp))) Default)
+++++
idtac.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).
idtac.

*****
H' : le (Init.Nat.add id n) m
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) (S n)) cp Default) (nthCP (S id) (circPermNCP n (consTailCP (tailCP cp) (headCP cp))) Default)
+++++
rewrite <- IHn.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).
idtac.
rewrite <- IHn.

*****
H' : le (Init.Nat.add id n) m
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) (S n)) cp Default) (nthCP (Init.Nat.add (S id) n) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
try assumption.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).
idtac.
rewrite <- IHn.
try assumption.

*****
H' : le (Init.Nat.add id n) m
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S id) (S n)) cp Default) (nthCP (Init.Nat.add (S id) n) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
rewrite <- plus_n_Sm.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).
idtac.
rewrite <- IHn.
try assumption.
rewrite <- plus_n_Sm.

*****
H' : le (Init.Nat.add id n) m
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
eq (nthCP (S (Init.Nat.add (S id) n)) cp Default) (nthCP (Init.Nat.add (S id) n) (consTailCP (tailCP cp) (headCP cp)) Default)
+++++
apply nthCircPerm2Eq.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).
idtac.
rewrite <- IHn.
try assumption.
rewrite <- plus_n_Sm.
apply nthCircPerm2Eq.

*****
H' : le (Init.Nat.add id n) m
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
le ((fix add (n m : nat) {struct n} : nat := match n with | O => m | S p => S (add p m) end) id n) m
+++++
assumption.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.
intro cp.
rewrite circPermNCPOK.
assert (H : id + n <= S m).
idtac.
assert (H' : id + n <= m).
idtac.
rewrite <- IHn.

*****
H' : le (Init.Nat.add id n) m
H : le (Init.Nat.add id n) (S m)
cp : cartesianPower T (S (S m))
IHn : forall (_ : le (Init.Nat.add id n) (S m))\n (cp : cartesianPower T (S (S m))),\neq (nthCP (Init.Nat.add (S id) n) cp Default)\n (nthCP (S id) (circPermNCP n cp) Default)
Hle : le (Init.Nat.add id (S n)) (S m)
id,n : nat
Default : T
m : nat
T : Type
*****
le (Init.Nat.add id n) (S m)
+++++
try assumption.
-----
Lemma nthCircPermNAny {T:Type} {m:nat} : forall (cp : cartesianPower T (S (S m))) (Default : T) id n, id + n <= S m -> nthCP (S id + n) cp Default = nthCP (S id) (circPermNCP n cp) Default.
Proof.
intros cp Default id n Hle.
revert cp.
induction n.

*****

*****

+++++
Qed.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))) (Default : T),\n  nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (Default : T), eq (nthCP (S O) cp Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
Proof.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (Default : T), eq (nthCP (S O) cp Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
intros cp Default.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
Proof.
intros cp Default.

*****
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S O) cp Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
rewrite nthCircPerm1Eq.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
Proof.
intros cp Default.
rewrite nthCircPerm1Eq.

*****
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
assert (H : 0 + S n <= S n) by intuition.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
Proof.
intros cp Default.
rewrite nthCircPerm1Eq.
assert (H : 0 + S n <= S n) by intuition.

*****
H : le (Init.Nat.add O (S n)) (S n)
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
assert (H' := nthCircPermNAny (consTailCP (tailCP cp) (headCP cp)) Default 0 (S n) H); clear H.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
Proof.
intros cp Default.
rewrite nthCircPerm1Eq.
assert (H : 0 + S n <= S n) by intuition.
assert (H' := nthCircPermNAny (consTailCP (tailCP cp) (headCP cp)) Default 0 (S n) H); clear H.

*****
H' : eq\n (nthCP (Init.Nat.add (S O) (S n))\n (consTailCP (tailCP cp) (headCP cp)) Default)\n (nthCP (S O) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp)))\n Default)
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
assert (H : 1 + S n = S (S n)) by intuition; rewrite H in H'; clear H; rewrite H'.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
Proof.
intros cp Default.
rewrite nthCircPerm1Eq.
assert (H : 0 + S n <= S n) by intuition.
assert (H' := nthCircPermNAny (consTailCP (tailCP cp) (headCP cp)) Default 0 (S n) H); clear H.
assert (H : 1 + S n = S (S n)) by intuition; rewrite H in H'; clear H; rewrite H'.

*****
H' : eq (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)\n (nthCP (S O) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp)))\n Default)
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S O) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp))) Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
apply eq_sym.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
Proof.
intros cp Default.
rewrite nthCircPerm1Eq.
assert (H : 0 + S n <= S n) by intuition.
assert (H' := nthCircPermNAny (consTailCP (tailCP cp) (headCP cp)) Default 0 (S n) H); clear H.
assert (H : 1 + S n = S (S n)) by intuition; rewrite H in H'; clear H; rewrite H'.
apply eq_sym.

*****
H' : eq (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)\n (nthCP (S O) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp)))\n Default)
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S O) (circPermNCP (S (S n)) cp) Default) (nthCP (S O) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp))) Default)
+++++
rewrite circPermNCPOK.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
Proof.
intros cp Default.
rewrite nthCircPerm1Eq.
assert (H : 0 + S n <= S n) by intuition.
assert (H' := nthCircPermNAny (consTailCP (tailCP cp) (headCP cp)) Default 0 (S n) H); clear H.
assert (H : 1 + S n = S (S n)) by intuition; rewrite H in H'; clear H; rewrite H'.
apply eq_sym.
rewrite circPermNCPOK.

*****
H' : eq (nthCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)) Default)\n (nthCP (S O) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp)))\n Default)
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S O) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp))) Default) (nthCP (S O) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp))) Default)
+++++
reflexivity.
-----
Lemma circPermNIdFirst {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), nthCP 1 cp Default = nthCP 1 (circPermNCP (S (S n)) cp) Default.
Proof.
intros cp Default.
rewrite nthCircPerm1Eq.
assert (H : 0 + S n <= S n) by intuition.
assert (H' := nthCircPermNAny (consTailCP (tailCP cp) (headCP cp)) Default 0 (S n) H); clear H.
assert (H : 1 + S n = S (S n)) by intuition; rewrite H in H'; clear H; rewrite H'.
apply eq_sym.
rewrite circPermNCPOK.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} :\n  forall (n : nat) (cp : cartesianPower T (S (S m))),\n  consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).

*****
m : nat
T : Type
*****
forall (n : nat) (cp : cartesianPower T (S (S m))), eq (consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp))) (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
+++++
Proof.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.

*****
m : nat
T : Type
*****
forall (n : nat) (cp : cartesianPower T (S (S m))), eq (consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp))) (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
+++++
intros n.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.

*****
m,n : nat
T : Type
*****
forall cp : cartesianPower T (S (S m)), eq (consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp))) (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
+++++
induction n.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.

*****
m : nat
T : Type
*****
forall cp : cartesianPower T (S (S m)), eq (consTailCP (tailCP (circPermNCP O cp)) (headCP (circPermNCP O cp))) (circPermNCP O (consTailCP (tailCP cp) (headCP cp)))
+++++
intro cp.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.
intro cp.

*****
cp : cartesianPower T (S (S m))
m : nat
T : Type
*****
eq (consTailCP (tailCP (circPermNCP O cp)) (headCP (circPermNCP O cp))) (circPermNCP O (consTailCP (tailCP cp) (headCP cp)))
+++++
simpl.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.
intro cp.
simpl.

*****
cp : cartesianPower T (S (S m))
m : nat
T : Type
*****
eq (nat_rect (fun n : nat => forall (_ : cartesianPower T (S n)) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)), cartesianPower T (S (S n))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 (fst cp)) (fun (n : nat) (_ : forall (_ : cartesianPower T (S n)) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)), cartesianPower T (S (S n))) (cp : cartesianPower T (S (S n))) (IHn : forall _ : cartesianPower T (S n), cartesianPower T (S (S n))) => pair (fst cp) (IHn (tailCP cp))) m (tailCP cp) ((fix F (n : nat) : forall _ : cartesianPower T n, cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T n0, cartesianPower T (S n0)) with | O => fun _ : cartesianPower T O => fst cp | S n0 => fun cp0 : cartesianPower T (S n0) => nat_rect (fun n1 : nat => forall (_ : cartesianPower T (S n1)) (_ : forall _ : cartesianPower T n1, cartesianPower T (S n1)), cartesianPower T (S (S n1))) (fun (cp1 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp1 (fst cp)) (fun (n1 : nat) (_ : forall (_ : cartesianPower T (S n1)) (_ : forall _ : cartesianPower T n1, cartesianPower T (S n1)), cartesianPower T (S (S n1))) (cp : cartesianPower T (S (S n1))) (IHn : forall _ : cartesianPower T (S n1), cartesianPower T (S (S n1))) => pair (fst cp) (IHn (tailCP cp))) n0 cp0 (F n0) end) m)) (nat_rect (fun n : nat => forall (_ : cartesianPower T (S n)) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)), cartesianPower T (S (S n))) (fun (cp0 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp0 (fst cp)) (fun (n : nat) (_ : forall (_ : cartesianPower T (S n)) (_ : forall _ : cartesianPower T n, cartesianPower T (S n)), cartesianPower T (S (S n))) (cp : cartesianPower T (S (S n))) (IHn : forall _ : cartesianPower T (S n), cartesianPower T (S (S n))) => pair (fst cp) (IHn (tailCP cp))) m (tailCP cp) ((fix F (n : nat) : forall _ : cartesianPower T n, cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T n0, cartesianPower T (S n0)) with | O => fun _ : cartesianPower T O => fst cp | S n0 => fun cp0 : cartesianPower T (S n0) => nat_rect (fun n1 : nat => forall (_ : cartesianPower T (S n1)) (_ : forall _ : cartesianPower T n1, cartesianPower T (S n1)), cartesianPower T (S (S n1))) (fun (cp1 : cartesianPower T (S O)) (_ : forall _ : cartesianPower T O, cartesianPower T (S O)) => pair cp1 (fst cp)) (fun (n1 : nat) (_ : forall (_ : cartesianPower T (S n1)) (_ : forall _ : cartesianPower T n1, cartesianPower T (S n1)), cartesianPower T (S (S n1))) (cp : cartesianPower T (S (S n1))) (IHn : forall _ : cartesianPower T (S n1), cartesianPower T (S (S n1))) => pair (fst cp) (IHn (tailCP cp))) n0 cp0 (F n0) end) m))
+++++
reflexivity.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.

*****
IHn : forall cp : cartesianPower T (S (S m)),\neq (consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)))\n (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
m,n : nat
T : Type
*****
forall cp : cartesianPower T (S (S m)), eq (consTailCP (tailCP (circPermNCP (S n) cp)) (headCP (circPermNCP (S n) cp))) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp)))
+++++
intro cp.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.
intro cp.

*****
cp : cartesianPower T (S (S m))
IHn : forall cp : cartesianPower T (S (S m)),\neq (consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)))\n (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
m,n : nat
T : Type
*****
eq (consTailCP (tailCP (circPermNCP (S n) cp)) (headCP (circPermNCP (S n) cp))) (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp)))
+++++
apply eq_sym.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.
intro cp.
apply eq_sym.

*****
cp : cartesianPower T (S (S m))
IHn : forall cp : cartesianPower T (S (S m)),\neq (consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)))\n (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
m,n : nat
T : Type
*****
eq (circPermNCP (S n) (consTailCP (tailCP cp) (headCP cp))) (consTailCP (tailCP (circPermNCP (S n) cp)) (headCP (circPermNCP (S n) cp)))
+++++
rewrite circPermNCPOK.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.
intro cp.
apply eq_sym.
rewrite circPermNCPOK.

*****
cp : cartesianPower T (S (S m))
IHn : forall cp : cartesianPower T (S (S m)),\neq (consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)))\n (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
m,n : nat
T : Type
*****
eq (circPermNCP n (consTailCP (tailCP (consTailCP (tailCP cp) (headCP cp))) (headCP (consTailCP (tailCP cp) (headCP cp))))) (consTailCP (tailCP (circPermNCP (S n) cp)) (headCP (circPermNCP (S n) cp)))
+++++
rewrite <- IHn.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.
intro cp.
apply eq_sym.
rewrite circPermNCPOK.
rewrite <- IHn.

*****
cp : cartesianPower T (S (S m))
IHn : forall cp : cartesianPower T (S (S m)),\neq (consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)))\n (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
m,n : nat
T : Type
*****
eq (consTailCP (tailCP (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))) (headCP (circPermNCP n (consTailCP (tailCP cp) (headCP cp))))) (consTailCP (tailCP (circPermNCP (S n) cp)) (headCP (circPermNCP (S n) cp)))
+++++
rewrite <- circPermNCPOK.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.
intro cp.
apply eq_sym.
rewrite circPermNCPOK.
rewrite <- IHn.
rewrite <- circPermNCPOK.

*****
cp : cartesianPower T (S (S m))
IHn : forall cp : cartesianPower T (S (S m)),\neq (consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)))\n (circPermNCP n (consTailCP (tailCP cp) (headCP cp)))
m,n : nat
T : Type
*****
eq (consTailCP (tailCP (circPermNCP (S n) cp)) (headCP (circPermNCP (S n) cp))) (consTailCP (tailCP (circPermNCP (S n) cp)) (headCP (circPermNCP (S n) cp)))
+++++
reflexivity.
-----
Lemma circPermNConsTlOK {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), consTailCP (tailCP (circPermNCP n cp)) (headCP (circPermNCP n cp)) = circPermNCP n (consTailCP (tailCP cp) (headCP cp)).
Proof.
intros n.
induction n.

*****

*****

+++++
Qed.
-----
Lemma circPermPerm {T:Type} {m:nat} :\n  forall (n : nat) (cp : cartesianPower T (S (S m))),\n  circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).
-----
Lemma circPermPerm {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).

*****
m : nat
T : Type
*****
forall (n : nat) (cp : cartesianPower T (S (S m))), eq (circPermNCP (S (S (S n))) cp) (circPermNCP (S O) (circPermNCP (S (S n)) cp))
+++++
Proof.
-----
Lemma circPermPerm {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).
Proof.

*****
m : nat
T : Type
*****
forall (n : nat) (cp : cartesianPower T (S (S m))), eq (circPermNCP (S (S (S n))) cp) (circPermNCP (S O) (circPermNCP (S (S n)) cp))
+++++
intros n cp.
-----
Lemma circPermPerm {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).
Proof.
intros n cp.

*****
cp : cartesianPower T (S (S m))
m,n : nat
T : Type
*****
eq (circPermNCP (S (S (S n))) cp) (circPermNCP (S O) (circPermNCP (S (S n)) cp))
+++++
rewrite circPermNCPOK.
-----
Lemma circPermPerm {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).
Proof.
intros n cp.
rewrite circPermNCPOK.

*****
cp : cartesianPower T (S (S m))
m,n : nat
T : Type
*****
eq (circPermNCP (S (S n)) (consTailCP (tailCP cp) (headCP cp))) (circPermNCP (S O) (circPermNCP (S (S n)) cp))
+++++
apply eq_sym.
-----
Lemma circPermPerm {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).
Proof.
intros n cp.
rewrite circPermNCPOK.
apply eq_sym.

*****
cp : cartesianPower T (S (S m))
m,n : nat
T : Type
*****
eq (circPermNCP (S O) (circPermNCP (S (S n)) cp)) (circPermNCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)))
+++++
rewrite circPermNCPOK.
-----
Lemma circPermPerm {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).
Proof.
intros n cp.
rewrite circPermNCPOK.
apply eq_sym.
rewrite circPermNCPOK.

*****
cp : cartesianPower T (S (S m))
m,n : nat
T : Type
*****
eq (circPermNCP O (consTailCP (tailCP (circPermNCP (S (S n)) cp)) (headCP (circPermNCP (S (S n)) cp)))) (circPermNCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)))
+++++
rewrite <- circPermNCP0.
-----
Lemma circPermPerm {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).
Proof.
intros n cp.
rewrite circPermNCPOK.
apply eq_sym.
rewrite circPermNCPOK.
rewrite <- circPermNCP0.

*****
cp : cartesianPower T (S (S m))
m,n : nat
T : Type
*****
eq (consTailCP (tailCP (circPermNCP (S (S n)) cp)) (headCP (circPermNCP (S (S n)) cp))) (circPermNCP (S (S n)) (consTailCP (tailCP cp) (headCP cp)))
+++++
apply circPermNConsTlOK.
-----
Lemma circPermPerm {T:Type} {m:nat} : forall (n : nat) (cp : cartesianPower T (S (S m))), circPermNCP (S (S (S n))) cp = circPermNCP 1 (circPermNCP (S (S n)) cp).
Proof.
intros n cp.
rewrite circPermNCPOK.
apply eq_sym.
rewrite circPermNCPOK.
rewrite <- circPermNCP0.
apply circPermNConsTlOK.

*****

*****

+++++
Qed.
-----
Lemma nthCP01 {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S n)) Default,\n  nthCP 0 cp Default = nthCP 1 cp Default.
-----
Lemma nthCP01 {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) Default, nthCP 0 cp Default = nthCP 1 cp Default.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (Default : T), eq (nthCP O cp Default) (nthCP (S O) cp Default)
+++++
Proof.
-----
Lemma nthCP01 {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) Default, nthCP 0 cp Default = nthCP 1 cp Default.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (Default : T), eq (nthCP O cp Default) (nthCP (S O) cp Default)
+++++
unfold nthCP.
-----
Lemma nthCP01 {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) Default, nthCP 0 cp Default = nthCP 1 cp Default.
Proof.
unfold nthCP.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (Default : T), eq (nth (Init.Nat.sub O (S O)) (CPToList cp) Default) (nth (Init.Nat.sub (S O) (S O)) (CPToList cp) Default)
+++++
assert (H : 0 - 1 = 0) by (simpl; reflexivity); rewrite H; clear H.
-----
Lemma nthCP01 {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) Default, nthCP 0 cp Default = nthCP 1 cp Default.
Proof.
unfold nthCP.
assert (H : 0 - 1 = 0) by (simpl; reflexivity); rewrite H; clear H.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (Default : T), eq (nth O (CPToList cp) Default) (nth (Init.Nat.sub (S O) (S O)) (CPToList cp) Default)
+++++
assert (H : 1 - 1 = 0) by (simpl; reflexivity); rewrite H; clear H.
-----
Lemma nthCP01 {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) Default, nthCP 0 cp Default = nthCP 1 cp Default.
Proof.
unfold nthCP.
assert (H : 0 - 1 = 0) by (simpl; reflexivity); rewrite H; clear H.
assert (H : 1 - 1 = 0) by (simpl; reflexivity); rewrite H; clear H.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (Default : T), eq (nth O (CPToList cp) Default) (nth O (CPToList cp) Default)
+++++
reflexivity.
-----
Lemma nthCP01 {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) Default, nthCP 0 cp Default = nthCP 1 cp Default.
Proof.
unfold nthCP.
assert (H : 0 - 1 = 0) by (simpl; reflexivity); rewrite H; clear H.
assert (H : 1 - 1 = 0) by (simpl; reflexivity); rewrite H; clear H.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma circPermNIdAux {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))) (Default : T),\n  cp = circPermNCP (S (S n)) cp.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (_ : T), eq cp (circPermNCP (S (S n)) cp)
+++++
Proof.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S (S n))) (_ : T), eq cp (circPermNCP (S (S n)) cp)
+++++
intros cp Default.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.

*****
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq cp (circPermNCP (S (S n)) cp)
+++++
apply nthEqOK with Default.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.

*****
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
forall n0 : nat, eq (nthCP n0 cp Default) (nthCP n0 (circPermNCP (S (S n)) cp) Default)
+++++
intro m.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.

*****
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
+++++
assert (Hmn := le_lt_dec m (S (S n))).
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).

*****
Hmn : sumbool (le m (S (S n))) (lt (S (S n)) m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
+++++
elim Hmn.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.

*****
Hmn : sumbool (le m (S (S n))) (lt (S (S n)) m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
forall _ : le m (S (S n)), eq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
+++++
clear Hmn.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.

*****
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
forall _ : le m (S (S n)), eq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
+++++
intro Hmn.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.

*****
Hmn : le m (S (S n))
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
+++++
revert cp.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.

*****
Hmn : le m (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
+++++
induction m.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.

*****
Hmn : le O (S (S n))
Default : T
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (nthCP O cp Default) (nthCP O (circPermNCP (S (S n)) cp) Default)
+++++
intro cp.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.

*****
cp : cartesianPower T (S (S n))
Hmn : le O (S (S n))
Default : T
n : nat
T : Type
*****
eq (nthCP O cp Default) (nthCP O (circPermNCP (S (S n)) cp) Default)
+++++
do 2 (rewrite nthCP01).
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
do 2 (rewrite nthCP01).

*****
cp : cartesianPower T (S (S n))
Hmn : le O (S (S n))
Default : T
n : nat
T : Type
*****
eq (nthCP (S O) cp Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
apply circPermNIdFirst.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.

*****
IHm : forall (_ : le m (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
Hmn : le (S m) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (nthCP (S m) cp Default) (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
+++++
intro cp.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.

*****
cp : cartesianPower T (S (S n))
IHm : forall (_ : le m (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
Hmn : le (S m) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) cp Default) (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
+++++
clear IHm.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.

*****
cp : cartesianPower T (S (S n))
Hmn : le (S m) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) cp Default) (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
+++++
revert cp.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.

*****
Hmn : le (S m) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (nthCP (S m) cp Default) (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
+++++
induction m.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.

*****
Hmn : le (S O) (S (S n))
Default : T
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (nthCP (S O) cp Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
intro cp.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.

*****
cp : cartesianPower T (S (S n))
Hmn : le (S O) (S (S n))
Default : T
n : nat
T : Type
*****
eq (nthCP (S O) cp Default) (nthCP (S O) (circPermNCP (S (S n)) cp) Default)
+++++
apply circPermNIdFirst.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.

*****
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (nthCP (S (S m)) cp Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
intro cp.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.

*****
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S (S m)) cp Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
assert (H : m <= n).
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).

*****
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
le m n
+++++
do 2 (apply le_S_n).
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
do 2 (apply le_S_n).

*****
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
le (S (S m)) (S (S n))
+++++
assumption.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).

*****
H : le m n
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S (S m)) cp Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
idtac.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.

*****
H : le m n
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S (S m)) cp Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
rewrite nthCircPerm2Eq.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.

*****
H : le m n
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (consTailCP (tailCP cp) (headCP cp)) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
try assumption.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.

*****
H : le m n
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (consTailCP (tailCP cp) (headCP cp)) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
clear H.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.

*****
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (consTailCP (tailCP cp) (headCP cp)) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
assert (H : S m <= S (S n)).
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).

*****
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
le (S m) (S (S n))
+++++
intuition.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).

*****
H : le (S m) (S (S n))
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (consTailCP (tailCP cp) (headCP cp)) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
idtac.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.

*****
H : le (S m) (S (S n))
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (consTailCP (tailCP cp) (headCP cp)) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
rewrite IHm.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.

*****
H : le (S m) (S (S n))
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (circPermNCP (S (S n)) (consTailCP (tailCP cp) (headCP cp))) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
try assumption.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.

*****
H : le (S m) (S (S n))
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (circPermNCP (S (S n)) (consTailCP (tailCP cp) (headCP cp))) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
clear H.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.

*****
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (circPermNCP (S (S n)) (consTailCP (tailCP cp) (headCP cp))) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
clear IHm.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.

*****
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (circPermNCP (S (S n)) (consTailCP (tailCP cp) (headCP cp))) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
rewrite <- circPermNCPOK.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.

*****
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (circPermNCP (S (S (S n))) cp) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
rewrite circPermPerm.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.

*****
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (circPermNCP (S O) (circPermNCP (S (S n)) cp)) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
assert (H : m + 1 <= S n).
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.
assert (H : m + 1 <= S n).

*****
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
le (Init.Nat.add m (S O)) (S n)
+++++
rewrite plus_n_1.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.
assert (H : m + 1 <= S n).
rewrite plus_n_1.

*****
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
le (S m) (S n)
+++++
intuition.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.
assert (H : m + 1 <= S n).

*****
H : le (Init.Nat.add m (S O)) (S n)
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (circPermNCP (S O) (circPermNCP (S (S n)) cp)) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
idtac.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.
assert (H : m + 1 <= S n).
idtac.

*****
H : le (Init.Nat.add m (S O)) (S n)
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S m) (circPermNCP (S O) (circPermNCP (S (S n)) cp)) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
rewrite <- nthCircPermNAny.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.
assert (H : m + 1 <= S n).
idtac.
rewrite <- nthCircPermNAny.

*****
H : le (Init.Nat.add m (S O)) (S n)
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S m) (S O)) (circPermNCP (S (S n)) cp) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
try assumption.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.
assert (H : m + 1 <= S n).
idtac.
rewrite <- nthCircPermNAny.
try assumption.

*****
H : le (Init.Nat.add m (S O)) (S n)
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S m) (S O)) (circPermNCP (S (S n)) cp) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
clear H.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.
assert (H : m + 1 <= S n).
idtac.
rewrite <- nthCircPermNAny.
try assumption.
clear H.

*****
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (Init.Nat.add (S m) (S O)) (circPermNCP (S (S n)) cp) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
rewrite plus_n_1.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.
assert (H : m + 1 <= S n).
idtac.
rewrite <- nthCircPermNAny.
try assumption.
clear H.
rewrite plus_n_1.

*****
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
eq (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default) (nthCP (S (S m)) (circPermNCP (S (S n)) cp) Default)
+++++
reflexivity.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.
try assumption.
clear H.
clear IHm.
rewrite <- circPermNCPOK.
rewrite circPermPerm.
assert (H : m + 1 <= S n).
idtac.
rewrite <- nthCircPermNAny.

*****
H : le (Init.Nat.add m (S O)) (S n)
cp : cartesianPower T (S (S n))
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
le (Init.Nat.add m (S O)) (S n)
+++++
try assumption.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.
try assumption.
clear H.
assert (H : S m <= S (S n)).
idtac.
rewrite IHm.

*****
H : le (S m) (S (S n))
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
le (S m) (S (S n))
+++++
try assumption.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
revert cp.
induction m.
intro cp.
clear IHm.
revert cp.
induction m.
intro cp.
assert (H : m <= n).
idtac.
rewrite nthCircPerm2Eq.

*****
H : le m n
cp : cartesianPower T (S (S n))
IHm : forall (_ : le (S m) (S (S n))) (cp : cartesianPower T (S (S n))),\neq (nthCP (S m) cp Default)\n (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
Hmn : le (S (S m)) (S (S n))
m : nat
Default : T
n : nat
T : Type
*****
le m n
+++++
try assumption.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.

*****
Hmn : sumbool (le m (S (S n))) (lt (S (S n)) m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
forall _ : lt (S (S n)) m, eq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
+++++
clear Hmn.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.

*****
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
forall _ : lt (S (S n)) m, eq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
+++++
intro Hmn.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.

*****
Hmn : lt (S (S n)) m
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
+++++
induction m.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.

*****
Hmn : lt (S (S n)) O
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP O cp Default) (nthCP O (circPermNCP (S (S n)) cp) Default)
+++++
assert (H := lt_n_0 (S (S n))).
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
assert (H := lt_n_0 (S (S n))).

*****
H : not (lt (S (S n)) O)
Hmn : lt (S (S n)) O
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP O cp Default) (nthCP O (circPermNCP (S (S n)) cp) Default)
+++++
intuition.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.

*****
IHm : forall _ : lt (S (S n)) m,\neq (nthCP m cp Default) (nthCP m (circPermNCP (S (S n)) cp) Default)
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S m) cp Default) (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
+++++
clear IHm.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nthCP (S m) cp Default) (nthCP (S m) (circPermNCP (S (S n)) cp) Default)
+++++
unfold nthCP.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (nth (Init.Nat.sub (S m) (S O)) (CPToList cp) Default) (nth (Init.Nat.sub (S m) (S O)) (CPToList (circPermNCP (S (S n)) cp)) Default)
+++++
rewrite nth_overflow.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq Default (nth (Init.Nat.sub (S m) (S O)) (CPToList (circPermNCP (S (S n)) cp)) Default)
+++++
rewrite nth_overflow.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq Default Default
+++++
try reflexivity.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le (length (CPToList (circPermNCP (S (S n)) cp))) (Init.Nat.sub (S m) (S O))
+++++
try reflexivity.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow.
try reflexivity.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le (length (CPToList (circPermNCP (S (S n)) cp))) (Init.Nat.sub (S m) (S O))
+++++
rewrite <- lengthOfCPToList.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow.
try reflexivity.
rewrite <- lengthOfCPToList.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le (S (S n)) (Init.Nat.sub (S m) (S O))
+++++
simpl.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow.
try reflexivity.
rewrite <- lengthOfCPToList.
simpl.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le (S (S n)) (Init.Nat.sub m O)
+++++
rewrite minus_n_0.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow.
try reflexivity.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le (S (S n)) m
+++++
apply gt_S_le.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite nth_overflow.
try reflexivity.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.
apply gt_S_le.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
gt (S m) (S (S n))
+++++
assumption.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le (length (CPToList cp)) (Init.Nat.sub (S m) (S O))
+++++
rewrite <- lengthOfCPToList.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite <- lengthOfCPToList.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le (S (S n)) (Init.Nat.sub (S m) (S O))
+++++
simpl.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite <- lengthOfCPToList.
simpl.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le (S (S n)) (Init.Nat.sub m O)
+++++
rewrite minus_n_0.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
le (S (S n)) m
+++++
apply gt_S_le.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.
clear Hmn.
intro Hmn.
induction m.
clear IHm.
unfold nthCP.
rewrite nth_overflow.
rewrite <- lengthOfCPToList.
simpl.
rewrite minus_n_0.
apply gt_S_le.

*****
Hmn : lt (S (S n)) (S m)
m : nat
Default : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
gt (S m) (S (S n))
+++++
assumption.
-----
Lemma circPermNIdAux {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))) (Default : T), cp = circPermNCP (S (S n)) cp.
Proof.
intros cp Default.
apply nthEqOK with Default.
intro m.
assert (Hmn := le_lt_dec m (S (S n))).
elim Hmn.

*****

*****

+++++
Qed.
-----
Lemma circPermNId {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S (S n))),\n  cp = circPermNCP (S (S n)) cp.
-----
Lemma circPermNId {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = circPermNCP (S (S n)) cp.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq cp (circPermNCP (S (S n)) cp)
+++++
Proof.
-----
Lemma circPermNId {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = circPermNCP (S (S n)) cp.
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq cp (circPermNCP (S (S n)) cp)
+++++
intro cp.
-----
Lemma circPermNId {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = circPermNCP (S (S n)) cp.
Proof.
intro cp.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq cp (circPermNCP (S (S n)) cp)
+++++
apply circPermNIdAux.
-----
Lemma circPermNId {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = circPermNCP (S (S n)) cp.
Proof.
intro cp.
apply circPermNIdAux.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
T
+++++
exact (headCP cp).
-----
Lemma circPermNId {T:Type} {n:nat} : forall (cp : cartesianPower T (S (S n))), cp = circPermNCP (S (S n)) cp.
Proof.
intro cp.
apply circPermNIdAux.
exact (headCP cp).

*****

*****

+++++
Qed.
-----
Lemma circPermNConsOK {T:Type} {n:nat} :\n  forall (cp : cartesianPower T (S n)) (t1 t2 : T),\n  circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t1 t2 : T), eq (circPermNCP (S n) (consTailCP (consTailCP cp t1) t2)) (consHeadCP t1 (consHeadCP t2 cp))
+++++
Proof.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.

*****
n : nat
T : Type
*****
forall (cp : cartesianPower T (S n)) (t1 t2 : T), eq (circPermNCP (S n) (consTailCP (consTailCP cp t1) t2)) (consHeadCP t1 (consHeadCP t2 cp))
+++++
induction n; intros cp t1 t2.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.

*****
t1,t2 : T
cp : cartesianPower T (S O)
T : Type
*****
eq (circPermNCP (S O) (consTailCP (consTailCP cp t1) t2)) (consHeadCP t1 (consHeadCP t2 cp))
+++++
simpl; reflexivity.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
IHn : forall (cp : cartesianPower T (S n)) (t1 t2 : T),\neq (circPermNCP (S n) (consTailCP (consTailCP cp t1) t2))\n (consHeadCP t1 (consHeadCP t2 cp))
n : nat
T : Type
*****
eq (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2)) (consHeadCP t1 (consHeadCP t2 cp))
+++++
clear IHn.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2)) (consHeadCP t1 (consHeadCP t2 cp))
+++++
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2)) (circPermNCP (S (S (S (S n)))) (consHeadCP t1 (consHeadCP t2 cp)))
+++++
apply eq_sym.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.
apply eq_sym.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (circPermNCP (S (S (S (S n)))) (consHeadCP t1 (consHeadCP t2 cp))) (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2))
+++++
rewrite circPermNCPOK.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.
apply eq_sym.
rewrite circPermNCPOK.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (circPermNCP (S (S (S n))) (consTailCP (tailCP (consHeadCP t1 (consHeadCP t2 cp))) (headCP (consHeadCP t1 (consHeadCP t2 cp))))) (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2))
+++++
assert (H : headCP (consHeadCP t1 (consHeadCP t2 cp)) = t1) by (simpl; reflexivity); rewrite H; clear H.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.
apply eq_sym.
rewrite circPermNCPOK.
assert (H : headCP (consHeadCP t1 (consHeadCP t2 cp)) = t1) by (simpl; reflexivity); rewrite H; clear H.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (circPermNCP (S (S (S n))) (consTailCP (tailCP (consHeadCP t1 (consHeadCP t2 cp))) t1)) (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2))
+++++
assert (H : tailCP (consHeadCP t1 (consHeadCP t2 cp)) = consHeadCP t2 cp) by (simpl; reflexivity); rewrite H; clear H.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.
apply eq_sym.
rewrite circPermNCPOK.
assert (H : headCP (consHeadCP t1 (consHeadCP t2 cp)) = t1) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consHeadCP t1 (consHeadCP t2 cp)) = consHeadCP t2 cp) by (simpl; reflexivity); rewrite H; clear H.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (circPermNCP (S (S (S n))) (consTailCP (consHeadCP t2 cp) t1)) (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2))
+++++
rewrite circPermNCPOK.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.
apply eq_sym.
rewrite circPermNCPOK.
assert (H : headCP (consHeadCP t1 (consHeadCP t2 cp)) = t1) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consHeadCP t1 (consHeadCP t2 cp)) = consHeadCP t2 cp) by (simpl; reflexivity); rewrite H; clear H.
rewrite circPermNCPOK.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (circPermNCP (S (S n)) (consTailCP (tailCP (consTailCP (consHeadCP t2 cp) t1)) (headCP (consTailCP (consHeadCP t2 cp) t1)))) (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2))
+++++
assert (H : headCP (consTailCP (consHeadCP t2 cp) t1) = t2) by (simpl; reflexivity); rewrite H; clear H.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.
apply eq_sym.
rewrite circPermNCPOK.
assert (H : headCP (consHeadCP t1 (consHeadCP t2 cp)) = t1) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consHeadCP t1 (consHeadCP t2 cp)) = consHeadCP t2 cp) by (simpl; reflexivity); rewrite H; clear H.
rewrite circPermNCPOK.
assert (H : headCP (consTailCP (consHeadCP t2 cp) t1) = t2) by (simpl; reflexivity); rewrite H; clear H.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (circPermNCP (S (S n)) (consTailCP (tailCP (consTailCP (consHeadCP t2 cp) t1)) t2)) (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2))
+++++
assert (H : tailCP (consTailCP (consHeadCP t2 cp) t1) = consTailCP cp t1) by (simpl; reflexivity); rewrite H; clear H.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.
apply eq_sym.
rewrite circPermNCPOK.
assert (H : headCP (consHeadCP t1 (consHeadCP t2 cp)) = t1) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consHeadCP t1 (consHeadCP t2 cp)) = consHeadCP t2 cp) by (simpl; reflexivity); rewrite H; clear H.
rewrite circPermNCPOK.
assert (H : headCP (consTailCP (consHeadCP t2 cp) t1) = t2) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consTailCP (consHeadCP t2 cp) t1) = consTailCP cp t1) by (simpl; reflexivity); rewrite H; clear H.

*****
t1,t2 : T
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2)) (circPermNCP (S (S n)) (consTailCP (consTailCP cp t1) t2))
+++++
reflexivity.
-----
Lemma circPermNConsOK {T:Type} {n:nat} : forall (cp : cartesianPower T (S n)) (t1 t2 : T), circPermNCP (S n) (consTailCP (consTailCP cp t1) t2) = consHeadCP t1 (consHeadCP t2 cp).
Proof.
induction n; intros cp t1 t2.
simpl; reflexivity.
clear IHn.
assert (H := circPermNId (consHeadCP t1 (consHeadCP t2 cp))); rewrite H; clear H.
apply eq_sym.
rewrite circPermNCPOK.
assert (H : headCP (consHeadCP t1 (consHeadCP t2 cp)) = t1) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consHeadCP t1 (consHeadCP t2 cp)) = consHeadCP t2 cp) by (simpl; reflexivity); rewrite H; clear H.
rewrite circPermNCPOK.
assert (H : headCP (consTailCP (consHeadCP t2 cp) t1) = t2) by (simpl; reflexivity); rewrite H; clear H.
assert (H : tailCP (consTailCP (consHeadCP t2 cp) t1) = consTailCP cp t1) by (simpl; reflexivity); rewrite H; clear H.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default,\n  length l = (S n) ->\n  length l' = (S n) ->\n  hd Default l = hd Default l' ->\n  tl l = tl l' ->\n  l = l'.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.

*****
T : Type
*****
forall (n : nat) (l l' : list T) (Default : T) (_ : eq (length l) (S n)) (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l')) (_ : eq (tl l) (tl l')), eq l l'
+++++
Proof.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.

*****
T : Type
*****
forall (n : nat) (l l' : list T) (Default : T) (_ : eq (length l) (S n)) (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l')) (_ : eq (tl l) (tl l')), eq l l'
+++++
intros n l.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.

*****
l : list T
n : nat
T : Type
*****
forall (l' : list T) (Default : T) (_ : eq (length l) (S n)) (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l')) (_ : eq (tl l) (tl l')), eq l l'
+++++
induction l.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.

*****
n : nat
T : Type
*****
forall (l' : list T) (Default : T) (_ : eq (length nil) (S n)) (_ : eq (length l') (S n)) (_ : eq (hd Default nil) (hd Default l')) (_ : eq (tl nil) (tl l')), eq nil l'
+++++
intros l' Default Hl.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.
intros l' Default Hl.

*****
Hl : eq (length nil) (S n)
Default : T
l' : list T
n : nat
T : Type
*****
forall (_ : eq (length l') (S n)) (_ : eq (hd Default nil) (hd Default l')) (_ : eq (tl nil) (tl l')), eq nil l'
+++++
simpl in Hl.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.
intros l' Default Hl.
simpl in Hl.

*****
Hl : eq O (S n)
Default : T
l' : list T
n : nat
T : Type
*****
forall (_ : eq (length l') (S n)) (_ : eq (hd Default nil) (hd Default l')) (_ : eq (tl nil) (tl l')), eq nil l'
+++++
discriminate.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.

*****
IHl : forall (l' : list T) (Default : T) (_ : eq (length l) (S n))\n (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l'))\n (_ : eq (tl l) (tl l')), eq l l'
l : list T
a : T
n : nat
T : Type
*****
forall (l' : list T) (Default : T) (_ : eq (length (cons a l)) (S n)) (_ : eq (length l') (S n)) (_ : eq (hd Default (cons a l)) (hd Default l')) (_ : eq (tl (cons a l)) (tl l')), eq (cons a l) l'
+++++
intros l' Default Hl Hl' Hhd Htl.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.
intros l' Default Hl Hl' Hhd Htl.

*****
Htl : eq (tl (cons a l)) (tl l')
Hhd : eq (hd Default (cons a l)) (hd Default l')
Hl' : eq (length l') (S n)
Hl : eq (length (cons a l)) (S n)
Default : T
l' : list T
IHl : forall (l' : list T) (Default : T) (_ : eq (length l) (S n))\n (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l'))\n (_ : eq (tl l) (tl l')), eq l l'
l : list T
a : T
n : nat
T : Type
*****
eq (cons a l) l'
+++++
induction l'.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.
intros l' Default Hl Hl' Hhd Htl.
induction l'.

*****
Htl : eq (tl (cons a l)) (tl nil)
Hhd : eq (hd Default (cons a l)) (hd Default nil)
Hl' : eq (length nil) (S n)
Hl : eq (length (cons a l)) (S n)
Default : T
IHl : forall (l' : list T) (Default : T) (_ : eq (length l) (S n))\n (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l'))\n (_ : eq (tl l) (tl l')), eq l l'
l : list T
a : T
n : nat
T : Type
*****
eq (cons a l) nil
+++++
simpl in Hl'.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.
intros l' Default Hl Hl' Hhd Htl.
induction l'.
simpl in Hl'.

*****
Htl : eq (tl (cons a l)) (tl nil)
Hhd : eq (hd Default (cons a l)) (hd Default nil)
Hl' : eq O (S n)
Hl : eq (length (cons a l)) (S n)
Default : T
IHl : forall (l' : list T) (Default : T) (_ : eq (length l) (S n))\n (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l'))\n (_ : eq (tl l) (tl l')), eq l l'
l : list T
a : T
n : nat
T : Type
*****
eq (cons a l) nil
+++++
discriminate.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.
intros l' Default Hl Hl' Hhd Htl.
induction l'.

*****
IHl' : forall (_ : eq (length l') (S n))\n (_ : eq (hd Default (cons a l)) (hd Default l'))\n (_ : eq (tl (cons a l)) (tl l')), eq (cons a l) l'
Htl : eq (tl (cons a l)) (tl (cons a0 l'))
Hhd : eq (hd Default (cons a l)) (hd Default (cons a0 l'))
Hl' : eq (length (cons a0 l')) (S n)
Hl : eq (length (cons a l)) (S n)
Default : T
l' : list T
a0 : T
IHl : forall (l' : list T) (Default : T) (_ : eq (length l) (S n))\n (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l'))\n (_ : eq (tl l) (tl l')), eq l l'
l : list T
a : T
n : nat
T : Type
*****
eq (cons a l) (cons a0 l')
+++++
simpl in Hhd.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.
intros l' Default Hl Hl' Hhd Htl.
induction l'.
simpl in Hhd.

*****
IHl' : forall (_ : eq (length l') (S n))\n (_ : eq (hd Default (cons a l)) (hd Default l'))\n (_ : eq (tl (cons a l)) (tl l')), eq (cons a l) l'
Htl : eq (tl (cons a l)) (tl (cons a0 l'))
Hhd : eq a a0
Hl' : eq (length (cons a0 l')) (S n)
Hl : eq (length (cons a l)) (S n)
Default : T
l' : list T
a0 : T
IHl : forall (l' : list T) (Default : T) (_ : eq (length l) (S n))\n (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l'))\n (_ : eq (tl l) (tl l')), eq l l'
l : list T
a : T
n : nat
T : Type
*****
eq (cons a l) (cons a0 l')
+++++
simpl in Htl.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.
intros l' Default Hl Hl' Hhd Htl.
induction l'.
simpl in Hhd.
simpl in Htl.

*****
IHl' : forall (_ : eq (length l') (S n))\n (_ : eq (hd Default (cons a l)) (hd Default l'))\n (_ : eq (tl (cons a l)) (tl l')), eq (cons a l) l'
Htl : eq l l'
Hhd : eq a a0
Hl' : eq (length (cons a0 l')) (S n)
Hl : eq (length (cons a l)) (S n)
Default : T
l' : list T
a0 : T
IHl : forall (l' : list T) (Default : T) (_ : eq (length l) (S n))\n (_ : eq (length l') (S n)) (_ : eq (hd Default l) (hd Default l'))\n (_ : eq (tl l) (tl l')), eq l l'
l : list T
a : T
n : nat
T : Type
*****
eq (cons a l) (cons a0 l')
+++++
subst.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.
intros l' Default Hl Hl' Hhd Htl.
induction l'.
simpl in Hhd.
simpl in Htl.
subst.

*****
IHl' : forall (_ : eq (length l') (S n))\n (_ : eq (hd Default (cons a0 l')) (hd Default l'))\n (_ : eq (tl (cons a0 l')) (tl l')), eq (cons a0 l') l'
Hl,Hl' : eq (length (cons a0 l')) (S n)
a0,Default : T
IHl : forall (l'0 : list T) (Default : T) (_ : eq (length l') (S n))\n (_ : eq (length l'0) (S n)) (_ : eq (hd Default l') (hd Default l'0))\n (_ : eq (tl l') (tl l'0)), eq l' l'0
l' : list T
n : nat
T : Type
*****
eq (cons a0 l') (cons a0 l')
+++++
reflexivity.
-----
Lemma listInd {T : Type} : forall n (l l' : list T) Default, length l = (S n) -> length l' = (S n) -> hd Default l = hd Default l' -> tl l = tl l' -> l = l'.
Proof.
intros n l.
induction l.

*****

*****

+++++
Qed.
-----
Lemma CPLHd {T : Type} :\n  forall (a : T) l Default,\n  hd Default (CPToList (ListToCP (a :: l) Default)) = a.
-----
Lemma CPLHd {T : Type} : forall (a : T) l Default, hd Default (CPToList (ListToCP (a :: l) Default)) = a.

*****
T : Type
*****
forall (a : T) (l : list T) (Default : T), eq (hd Default (CPToList (ListToCP (cons a l) Default))) a
+++++
Proof.
-----
Lemma CPLHd {T : Type} : forall (a : T) l Default, hd Default (CPToList (ListToCP (a :: l) Default)) = a.
Proof.

*****
T : Type
*****
forall (a : T) (l : list T) (Default : T), eq (hd Default (CPToList (ListToCP (cons a l) Default))) a
+++++
intros a l Default.
-----
Lemma CPLHd {T : Type} : forall (a : T) l Default, hd Default (CPToList (ListToCP (a :: l) Default)) = a.
Proof.
intros a l Default.

*****
Default : T
l : list T
a : T
T : Type
*****
eq (hd Default (CPToList (ListToCP (cons a l) Default))) a
+++++
induction l.
-----
Lemma CPLHd {T : Type} : forall (a : T) l Default, hd Default (CPToList (ListToCP (a :: l) Default)) = a.
Proof.
intros a l Default.
induction l.

*****
a,Default : T
T : Type
*****
eq (hd Default (CPToList (ListToCP (cons a nil) Default))) a
+++++
simpl.
-----
Lemma CPLHd {T : Type} : forall (a : T) l Default, hd Default (CPToList (ListToCP (a :: l) Default)) = a.
Proof.
intros a l Default.
induction l.
simpl.

*****
a,Default : T
T : Type
*****
eq a a
+++++
reflexivity.
-----
Lemma CPLHd {T : Type} : forall (a : T) l Default, hd Default (CPToList (ListToCP (a :: l) Default)) = a.
Proof.
intros a l Default.
induction l.

*****
IHl : eq (hd Default (CPToList (ListToCP (cons a l) Default))) a
Default : T
l : list T
a,a0 : T
T : Type
*****
eq (hd Default (CPToList (ListToCP (cons a (cons a0 l)) Default))) a
+++++
simpl.
-----
Lemma CPLHd {T : Type} : forall (a : T) l Default, hd Default (CPToList (ListToCP (a :: l) Default)) = a.
Proof.
intros a l Default.
induction l.
simpl.

*****
IHl : eq (hd Default (CPToList (ListToCP (cons a l) Default))) a
Default : T
l : list T
a,a0 : T
T : Type
*****
eq a a
+++++
reflexivity.
-----
Lemma CPLHd {T : Type} : forall (a : T) l Default, hd Default (CPToList (ListToCP (a :: l) Default)) = a.
Proof.
intros a l Default.
induction l.

*****

*****

+++++
Qed.
-----
Lemma ListToCPTl {T : Type} :\n  forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0  :: l)) Haa0l Default,\n  tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l =\n  ListToCP (a0 :: l) Default.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.

*****
T : Type
*****
forall (a a0 : T) (l : list T) (Ha0l : eq (S (length l)) (length (cons a0 l))) (Haa0l : eq (S (S (length l))) (length (cons a (cons a0 l)))) (Default : T), eq (tailCPbis (length (cons a (cons a0 l))) (length (cons a l)) (ListToCP (cons a (cons a0 l)) Default) Haa0l Ha0l) (ListToCP (cons a0 l) Default)
+++++
Proof.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.

*****
T : Type
*****
forall (a a0 : T) (l : list T) (Ha0l : eq (S (length l)) (length (cons a0 l))) (Haa0l : eq (S (S (length l))) (length (cons a (cons a0 l)))) (Default : T), eq (tailCPbis (length (cons a (cons a0 l))) (length (cons a l)) (ListToCP (cons a (cons a0 l)) Default) Haa0l Ha0l) (ListToCP (cons a0 l) Default)
+++++
intros a a0 l Ha0l Haa0l Default.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.

*****
Default : T
Haa0l : eq (S (S (length l))) (length (cons a (cons a0 l)))
Ha0l : eq (S (length l)) (length (cons a0 l))
l : list T
a,a0 : T
T : Type
*****
eq (tailCPbis (length (cons a (cons a0 l))) (length (cons a l)) (ListToCP (cons a (cons a0 l)) Default) Haa0l Ha0l) (ListToCP (cons a0 l) Default)
+++++
simpl in *.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.
simpl in *.

*****
Default : T
Haa0l : eq (S (S (length l))) (S (S (length l)))
Ha0l : eq (S (length l)) (S (length l))
l : list T
a,a0 : T
T : Type
*****
eq (tailCPbis (S (S (length l))) (S (length l)) (pair a (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default)) (length l) (minus_n_0 (length l)))) Haa0l Ha0l) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default))
+++++
unfold tailCPbis.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.
simpl in *.
unfold tailCPbis.

*****
Default : T
Haa0l : eq (S (S (length l))) (S (S (length l)))
Ha0l : eq (S (length l)) (S (length l))
l : list T
a,a0 : T
T : Type
*****
eq (eq_rect (S (S (length l))) (fun m1 : nat => forall _ : cartesianPower T m1, cartesianPower T (S (length l))) (fun cp : cartesianPower T (S (S (length l))) => eq_rect (S (length l)) (fun m2 : nat => cartesianPower T m2) (tailCP cp) (S (length l)) Ha0l) (S (S (length l))) Haa0l (pair a (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default)) (length l) (minus_n_0 (length l))))) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default))
+++++
unfold tailCP.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.
simpl in *.
unfold tailCPbis.
unfold tailCP.

*****
Default : T
Haa0l : eq (S (S (length l))) (S (S (length l)))
Ha0l : eq (S (length l)) (S (length l))
l : list T
a,a0 : T
T : Type
*****
eq (eq_rect (S (S (length l))) (fun m1 : nat => forall _ : cartesianPower T m1, cartesianPower T (S (length l))) (fun cp : cartesianPower T (S (S (length l))) => eq_rect (S (length l)) (fun m2 : nat => cartesianPower T m2) (nat_rect (fun n : nat => forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)) (fun cp0 : cartesianPower T (S (S O)) => snd cp0) (fun (n : nat) (_ : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)) (cp0 : cartesianPower T (S (S (S n)))) => snd cp0) (length l) cp) (S (length l)) Ha0l) (S (S (length l))) Haa0l (pair a (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default)) (length l) (minus_n_0 (length l))))) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default))
+++++
repeat (elim_eq_rect; simpl).
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.
simpl in *.
unfold tailCPbis.
unfold tailCP.
repeat (elim_eq_rect; simpl).

*****
Default : T
Haa0l : eq (S (S (length l))) (S (S (length l)))
Ha0l : eq (S (length l)) (S (length l))
l : list T
a,a0 : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)) (fun cp : cartesianPower T (S (S O)) => snd cp) (fun (n : nat) (_ : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)) (cp : cartesianPower T (S (S (S n)))) => snd cp) (length l) (pair a (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default)) (length l) (minus_n_0 (length l))))) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default))
+++++
induction l.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.
simpl in *.
unfold tailCPbis.
unfold tailCP.
repeat (elim_eq_rect; simpl).
induction l.

*****
Default : T
Haa0l : eq (S (S (length nil))) (S (S (length nil)))
Ha0l : eq (S (length nil)) (S (length nil))
a,a0 : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)) (fun cp : cartesianPower T (S (S O)) => snd cp) (fun (n : nat) (_ : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)) (cp : cartesianPower T (S (S (S n)))) => snd cp) (length nil) (pair a (eq_rect (Init.Nat.sub (length nil) O) (fun n : nat => cartesianPowerAux T n) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) nil (ListToCP nil Default)) (length nil) (minus_n_0 (length nil))))) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) nil (ListToCP nil Default))
+++++
simpl.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.
simpl in *.
unfold tailCPbis.
unfold tailCP.
repeat (elim_eq_rect; simpl).
induction l.
simpl.

*****
Default : T
Haa0l : eq (S (S (length nil))) (S (S (length nil)))
Ha0l : eq (S (length nil)) (S (length nil))
a,a0 : T
T : Type
*****
eq a0 a0
+++++
reflexivity.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.
simpl in *.
unfold tailCPbis.
unfold tailCP.
repeat (elim_eq_rect; simpl).
induction l.

*****
IHl : forall (_ : eq (S (length l)) (S (length l)))\n (_ : eq (S (S (length l))) (S (S (length l)))),\neq\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower T (S (S n)), cartesianPower T (S n))\n (fun cp : cartesianPower T (S (S O)) => snd cp)\n (fun (n : nat)\n (_ : forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n))\n (cp : cartesianPower T (S (S (S n)))) => snd cp) \n (length l)\n (pair a\n (eq_rect (Init.Nat.sub (length l) O)\n (fun n : nat => cartesianPowerAux T n)\n (list_rect\n (fun l : list T =>\n forall _ : cartesianPower T (length l),\n cartesianPower T (S (length l)))\n (fun _ : cartesianPower T O => a0)\n (fun (_ : T) (l : list T)\n (_ : forall _ : cartesianPower T (length l),\n cartesianPower T (S (length l)))\n (IHl : cartesianPower T (S (length l))) =>\n pair a0\n (eq_rect (Init.Nat.sub (length l) O)\n (fun n : nat => cartesianPowerAux T n) IHl\n (length l) (minus_n_0 (length l)))) l\n (ListToCP l Default)) (length l) (minus_n_0 (length l)))))\n (list_rect\n (fun l : list T =>\n forall _ : cartesianPower T (length l),\n cartesianPower T (S (length l)))\n (fun _ : cartesianPower T O => a0)\n (fun (_ : T) (l : list T)\n (_ : forall _ : cartesianPower T (length l),\n cartesianPower T (S (length l)))\n (IHl : cartesianPower T (S (length l))) =>\n pair a0\n (eq_rect (Init.Nat.sub (length l) O)\n (fun n : nat => cartesianPowerAux T n) IHl \n (length l) (minus_n_0 (length l)))) l (ListToCP l Default))
Default : T
Haa0l : eq (S (S (length (cons a1 l)))) (S (S (length (cons a1 l))))
Ha0l : eq (S (length (cons a1 l))) (S (length (cons a1 l)))
l : list T
a,a0,a1 : T
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)) (fun cp : cartesianPower T (S (S O)) => snd cp) (fun (n : nat) (_ : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n)) (cp : cartesianPower T (S (S (S n)))) => snd cp) (length (cons a1 l)) (pair a (eq_rect (Init.Nat.sub (length (cons a1 l)) O) (fun n : nat => cartesianPowerAux T n) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) (cons a1 l) (ListToCP (cons a1 l) Default)) (length (cons a1 l)) (minus_n_0 (length (cons a1 l)))))) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a0) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) (cons a1 l) (ListToCP (cons a1 l) Default))
+++++
simpl.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.
simpl in *.
unfold tailCPbis.
unfold tailCP.
repeat (elim_eq_rect; simpl).
induction l.
simpl.

*****
IHl : forall (_ : eq (S (length l)) (S (length l)))\n (_ : eq (S (S (length l))) (S (S (length l)))),\neq\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower T (S (S n)), cartesianPower T (S n))\n (fun cp : cartesianPower T (S (S O)) => snd cp)\n (fun (n : nat)\n (_ : forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n))\n (cp : cartesianPower T (S (S (S n)))) => snd cp) \n (length l)\n (pair a\n (eq_rect (Init.Nat.sub (length l) O)\n (fun n : nat => cartesianPowerAux T n)\n (list_rect\n (fun l : list T =>\n forall _ : cartesianPower T (length l),\n cartesianPower T (S (length l)))\n (fun _ : cartesianPower T O => a0)\n (fun (_ : T) (l : list T)\n (_ : forall _ : cartesianPower T (length l),\n cartesianPower T (S (length l)))\n (IHl : cartesianPower T (S (length l))) =>\n pair a0\n (eq_rect (Init.Nat.sub (length l) O)\n (fun n : nat => cartesianPowerAux T n) IHl\n (length l) (minus_n_0 (length l)))) l\n (ListToCP l Default)) (length l) (minus_n_0 (length l)))))\n (list_rect\n (fun l : list T =>\n forall _ : cartesianPower T (length l),\n cartesianPower T (S (length l)))\n (fun _ : cartesianPower T O => a0)\n (fun (_ : T) (l : list T)\n (_ : forall _ : cartesianPower T (length l),\n cartesianPower T (S (length l)))\n (IHl : cartesianPower T (S (length l))) =>\n pair a0\n (eq_rect (Init.Nat.sub (length l) O)\n (fun n : nat => cartesianPowerAux T n) IHl \n (length l) (minus_n_0 (length l)))) l (ListToCP l Default))
Default : T
Haa0l : eq (S (S (length (cons a1 l)))) (S (S (length (cons a1 l))))
Ha0l : eq (S (length (cons a1 l))) (S (length (cons a1 l)))
l : list T
a,a0,a1 : T
T : Type
*****
eq (pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a1) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a1 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default)) (length l) (minus_n_0 (length l)))) (pair a0 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) (list_rect (fun l : list T => forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (fun _ : cartesianPower T O => a1) (fun (_ : T) (l : list T) (_ : forall _ : cartesianPower T (length l), cartesianPower T (S (length l))) (IHl : cartesianPower T (S (length l))) => pair a1 (eq_rect (Init.Nat.sub (length l) O) (fun n : nat => cartesianPowerAux T n) IHl (length l) (minus_n_0 (length l)))) l (ListToCP l Default)) (length l) (minus_n_0 (length l))))
+++++
reflexivity.
-----
Lemma ListToCPTl {T : Type} : forall (a a0 : T) l (Ha0l : (S (length l)) = length (a0 :: l)) Haa0l Default, tailCPbis (length (a :: a0 :: l)) (length (a :: l)) (ListToCP (a :: a0 :: l) Default) Haa0l Ha0l = ListToCP (a0 :: l) Default.
Proof.
intros a a0 l Ha0l Haa0l Default.
simpl in *.
unfold tailCPbis.
unfold tailCP.
repeat (elim_eq_rect; simpl).
induction l.

*****

*****

+++++
Qed.
-----
Lemma CPToListTl1 {T : Type} :\n  forall (a a0 : T) l (cp : cartesianPower T (length (a :: a0 :: l))), tl (CPToList cp) = CPToList (tailCP cp).
-----
Lemma CPToListTl1 {T : Type} : forall (a a0 : T) l (cp : cartesianPower T (length (a :: a0 :: l))), tl (CPToList cp) = CPToList (tailCP cp).

*****
T : Type
*****
forall (a a0 : T) (l : list T) (cp : cartesianPower T (length (cons a (cons a0 l)))), eq (tl (CPToList cp)) (CPToList (tailCP cp))
+++++
Proof.
-----
Lemma CPToListTl1 {T : Type} : forall (a a0 : T) l (cp : cartesianPower T (length (a :: a0 :: l))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.

*****
T : Type
*****
forall (a a0 : T) (l : list T) (cp : cartesianPower T (length (cons a (cons a0 l)))), eq (tl (CPToList cp)) (CPToList (tailCP cp))
+++++
simpl.
-----
Lemma CPToListTl1 {T : Type} : forall (a a0 : T) l (cp : cartesianPower T (length (a :: a0 :: l))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
simpl.

*****
T : Type
*****
forall (_ : T) (_ : T) (l : list T) (cp : cartesianPower T (S (S (length l)))), eq (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp0 : cartesianPower T (S O) => cons cp0 nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp0 : cartesianPower T (S (S n))) => cons (fst cp0) (IHn (tailCP cp0))) (length l) (tailCP cp)) (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp0 : cartesianPower T (S O) => cons cp0 nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp0 : cartesianPower T (S (S n))) => cons (fst cp0) (IHn (tailCP cp0))) ((fix length (l0 : list T) : nat := match l0 with | nil => O | cons _ l' => S (length l') end) l) (tailCP cp))
+++++
reflexivity.
-----
Lemma CPToListTl1 {T : Type} : forall (a a0 : T) l (cp : cartesianPower T (length (a :: a0 :: l))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
simpl.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma CPToListTl2 {T : Type} {n : nat} :\n  forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (tl (CPToList cp)) (CPToList (tailCP cp))
+++++
Proof.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.

*****
n : nat
T : Type
*****
forall cp : cartesianPower T (S (S n)), eq (tl (CPToList cp)) (CPToList (tailCP cp))
+++++
intro cp.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.

*****
cp : cartesianPower T (S (S n))
n : nat
T : Type
*****
eq (tl (CPToList cp)) (CPToList (tailCP cp))
+++++
induction n.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (tl (CPToList cp)) (CPToList (tailCP cp))
+++++
simpl.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
simpl.

*****
cp : cartesianPower T (S (S O))
T : Type
*****
eq (cons (snd cp) nil) (cons (snd cp) nil)
+++++
reflexivity.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (tl (CPToList cp)) (CPToList (tailCP cp))
+++++
apply listInd with (S n) (fst cp).
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (length (tl (CPToList cp))) (S (S n))
+++++
apply eq_add_S.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).
apply eq_add_S.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (S (length (tl (CPToList cp)))) (S (S (S n)))
+++++
assert (H := lengthOfCPToList cp).
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).
apply eq_add_S.
assert (H := lengthOfCPToList cp).

*****
H : eq (S (S (S n))) (length (CPToList cp))
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (S (length (tl (CPToList cp)))) (S (S (S n)))
+++++
rewrite H.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).
apply eq_add_S.
assert (H := lengthOfCPToList cp).
rewrite H.

*****
H : eq (S (S (S n))) (length (CPToList cp))
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (S (length (tl (CPToList cp)))) (length (CPToList cp))
+++++
simpl.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).
apply eq_add_S.
assert (H := lengthOfCPToList cp).
rewrite H.
simpl.

*****
H : eq (S (S (S n))) (length (CPToList cp))
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (S (S (length (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))))) (S (S (length (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))))))
+++++
reflexivity.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (length (CPToList (tailCP cp))) (S (S n))
+++++
assert (H := lengthOfCPToList (tailCP cp)).
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).
assert (H := lengthOfCPToList (tailCP cp)).

*****
H : eq (S (S n)) (length (CPToList (tailCP cp)))
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (length (CPToList (tailCP cp))) (S (S n))
+++++
rewrite H.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).
assert (H := lengthOfCPToList (tailCP cp)).
rewrite H.

*****
H : eq (S (S n)) (length (CPToList (tailCP cp)))
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (length (CPToList (tailCP cp))) (length (CPToList (tailCP cp)))
+++++
reflexivity.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (hd (fst cp) (tl (CPToList cp))) (hd (fst cp) (CPToList (tailCP cp)))
+++++
simpl.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).
simpl.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (fst (snd cp)) (fst (snd cp))
+++++
reflexivity.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (tl (tl (CPToList cp))) (tl (CPToList (tailCP cp)))
+++++
simpl.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.
apply listInd with (S n) (fst cp).
simpl.

*****
IHn : forall cp : cartesianPower T (S (S n)),\neq (tl (CPToList cp)) (CPToList (tailCP cp))
cp : cartesianPower T (S (S (S n)))
n : nat
T : Type
*****
eq (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp))) (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP (snd cp)))
+++++
reflexivity.
-----
Lemma CPToListTl2 {T : Type} {n : nat} : forall (cp : cartesianPower T (S (S n))), tl (CPToList cp) = CPToList (tailCP cp).
Proof.
intro cp.
induction n.

*****

*****

+++++
Qed.
-----
Lemma CPCPL {T : Type} :\n  forall (a : T) l (cp1 : cartesianPower T (length (a :: l)))\n  (cp2 : cartesianPower T (S(length l))),\n  cp1 = cp2 -> CPToList cp1 = CPToList cp2.
-----
Lemma CPCPL {T : Type} : forall (a : T) l (cp1 : cartesianPower T (length (a :: l))) (cp2 : cartesianPower T (S(length l))), cp1 = cp2 -> CPToList cp1 = CPToList cp2.

*****
T : Type
*****
forall (a : T) (l : list T) (cp1 : cartesianPower T (length (cons a l))) (cp2 : cartesianPower T (S (length l))) (_ : eq cp1 cp2), eq (CPToList cp1) (CPToList cp2)
+++++
Proof.
-----
Lemma CPCPL {T : Type} : forall (a : T) l (cp1 : cartesianPower T (length (a :: l))) (cp2 : cartesianPower T (S(length l))), cp1 = cp2 -> CPToList cp1 = CPToList cp2.
Proof.

*****
T : Type
*****
forall (a : T) (l : list T) (cp1 : cartesianPower T (length (cons a l))) (cp2 : cartesianPower T (S (length l))) (_ : eq cp1 cp2), eq (CPToList cp1) (CPToList cp2)
+++++
intros.
-----
Lemma CPCPL {T : Type} : forall (a : T) l (cp1 : cartesianPower T (length (a :: l))) (cp2 : cartesianPower T (S(length l))), cp1 = cp2 -> CPToList cp1 = CPToList cp2.
Proof.
intros.

*****
H : eq cp1 cp2
cp2 : cartesianPower T (S (length l))
cp1 : cartesianPower T (length (cons a l))
l : list T
a : T
T : Type
*****
eq (CPToList cp1) (CPToList cp2)
+++++
subst.
-----
Lemma CPCPL {T : Type} : forall (a : T) l (cp1 : cartesianPower T (length (a :: l))) (cp2 : cartesianPower T (S(length l))), cp1 = cp2 -> CPToList cp1 = CPToList cp2.
Proof.
intros.
subst.

*****
cp2 : cartesianPower T (S (length l))
l : list T
a : T
T : Type
*****
eq (CPToList cp2) (CPToList cp2)
+++++
reflexivity.
-----
Lemma CPCPL {T : Type} : forall (a : T) l (cp1 : cartesianPower T (length (a :: l))) (cp2 : cartesianPower T (S(length l))), cp1 = cp2 -> CPToList cp1 = CPToList cp2.
Proof.
intros.
subst.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma CPLCP {T : Type} {n : nat} :\n  forall (cp1 cp2 : cartesianPower T (S n)),\n  CPToList cp1 = CPToList cp2 -> cp1 = cp2.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.

*****
n : nat
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S n)) (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
+++++
Proof.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.

*****
n : nat
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S n)) (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
+++++
induction n.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.

*****
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S O)) (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
+++++
intros cp1 cp2 HCPL.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.

*****
HCPL : eq (CPToList cp1) (CPToList cp2)
cp1,cp2 : cartesianPower T (S O)
T : Type
*****
eq cp1 cp2
+++++
simpl in *.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.
simpl in *.

*****
HCPL : eq (cons cp1 nil) (cons cp2 nil)
cp1,cp2 : cartesianPower T (S O)
T : Type
*****
eq cp1 cp2
+++++
injection HCPL.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.
simpl in *.
injection HCPL.

*****
HCPL : eq (cons cp1 nil) (cons cp2 nil)
cp1,cp2 : cartesianPower T (S O)
T : Type
*****
forall _ : eq cp1 cp2, eq cp1 cp2
+++++
auto.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.

*****
IHn : forall (cp1 cp2 : cartesianPower T (S n))\n (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
n : nat
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S (S n))) (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
+++++
intros cp1 cp2 HCPL.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.

*****
HCPL : eq (CPToList cp1) (CPToList cp2)
cp1,cp2 : cartesianPower T (S (S n))
IHn : forall (cp1 cp2 : cartesianPower T (S n))\n (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
n : nat
T : Type
*****
eq cp1 cp2
+++++
do 2 (rewrite CPToListOK in HCPL).
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.
do 2 (rewrite CPToListOK in HCPL).

*****
HCPL : eq (cons (headCP cp1) (CPToList (tailCP cp1)))\n (cons (headCP cp2) (CPToList (tailCP cp2)))
cp1,cp2 : cartesianPower T (S (S n))
IHn : forall (cp1 cp2 : cartesianPower T (S n))\n (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
n : nat
T : Type
*****
eq cp1 cp2
+++++
apply CP_ind.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.
do 2 (rewrite CPToListOK in HCPL).
apply CP_ind.

*****
HCPL : eq (cons (headCP cp1) (CPToList (tailCP cp1)))\n (cons (headCP cp2) (CPToList (tailCP cp2)))
cp1,cp2 : cartesianPower T (S (S n))
IHn : forall (cp1 cp2 : cartesianPower T (S n))\n (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
n : nat
T : Type
*****
eq (headCP cp1) (headCP cp2)
+++++
injection HCPL.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.
do 2 (rewrite CPToListOK in HCPL).
apply CP_ind.
injection HCPL.

*****
HCPL : eq (cons (headCP cp1) (CPToList (tailCP cp1)))\n (cons (headCP cp2) (CPToList (tailCP cp2)))
cp1,cp2 : cartesianPower T (S (S n))
IHn : forall (cp1 cp2 : cartesianPower T (S n))\n (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
n : nat
T : Type
*****
forall (_ : eq (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp1)) (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp2))) (_ : eq (fst cp1) (fst cp2)), eq (headCP cp1) (headCP cp2)
+++++
auto.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.
do 2 (rewrite CPToListOK in HCPL).
apply CP_ind.

*****
HCPL : eq (cons (headCP cp1) (CPToList (tailCP cp1)))\n (cons (headCP cp2) (CPToList (tailCP cp2)))
cp1,cp2 : cartesianPower T (S (S n))
IHn : forall (cp1 cp2 : cartesianPower T (S n))\n (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
n : nat
T : Type
*****
eq (tailCP cp1) (tailCP cp2)
+++++
apply IHn.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.
do 2 (rewrite CPToListOK in HCPL).
apply CP_ind.
apply IHn.

*****
HCPL : eq (cons (headCP cp1) (CPToList (tailCP cp1)))\n (cons (headCP cp2) (CPToList (tailCP cp2)))
cp1,cp2 : cartesianPower T (S (S n))
IHn : forall (cp1 cp2 : cartesianPower T (S n))\n (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
n : nat
T : Type
*****
eq (CPToList (tailCP cp1)) (CPToList (tailCP cp2))
+++++
injection HCPL.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.
intros cp1 cp2 HCPL.
do 2 (rewrite CPToListOK in HCPL).
apply CP_ind.
apply IHn.
injection HCPL.

*****
HCPL : eq (cons (headCP cp1) (CPToList (tailCP cp1)))\n (cons (headCP cp2) (CPToList (tailCP cp2)))
cp1,cp2 : cartesianPower T (S (S n))
IHn : forall (cp1 cp2 : cartesianPower T (S n))\n (_ : eq (CPToList cp1) (CPToList cp2)), eq cp1 cp2
n : nat
T : Type
*****
forall (_ : eq (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp1)) (nat_rect (fun n : nat => forall _ : cartesianPower T (S n), list T) (fun cp : cartesianPower T (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower T (S n), list T) (cp : cartesianPower T (S (S n))) => cons (fst cp) (IHn (tailCP cp))) n (tailCP cp2))) (_ : eq (fst cp1) (fst cp2)), eq (CPToList (tailCP cp1)) (CPToList (tailCP cp2))
+++++
auto.
-----
Lemma CPLCP {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S n)), CPToList cp1 = CPToList cp2 -> cp1 = cp2.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma CPLRec {T : Type} :\n  forall (a : T) l Default,\n  (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).

*****
T : Type
*****
forall (a : T) (l : list T) (Default : T), eq (cons a (CPToList (ListToCP l Default))) (CPToList (ListToCP (cons a l) Default))
+++++
Proof.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.

*****
T : Type
*****
forall (a : T) (l : list T) (Default : T), eq (cons a (CPToList (ListToCP l Default))) (CPToList (ListToCP (cons a l) Default))
+++++
intros a l Default.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.

*****
Default : T
l : list T
a : T
T : Type
*****
eq (cons a (CPToList (ListToCP l Default))) (CPToList (ListToCP (cons a l) Default))
+++++
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).

*****
HlAux : eq (length l) (length (CPToList (ListToCP l Default)))
Default : T
l : list T
a : T
T : Type
*****
eq (cons a (CPToList (ListToCP l Default))) (CPToList (ListToCP (cons a l) Default))
+++++
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.

*****
Hl : eq (length (cons a (CPToList (ListToCP l Default)))) (S (length l))
Default : T
l : list T
a : T
T : Type
*****
eq (cons a (CPToList (ListToCP l Default))) (CPToList (ListToCP (cons a l) Default))
+++++
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.

*****
Hal : eq (length (CPToList (ListToCP (cons a l) Default)))\n (length (cons a l))
Hl : eq (length (cons a (CPToList (ListToCP l Default)))) (S (length l))
Default : T
l : list T
a : T
T : Type
*****
eq (cons a (CPToList (ListToCP l Default))) (CPToList (ListToCP (cons a l) Default))
+++++
apply listInd with (length l) Default; try assumption.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.

*****
Hal : eq (length (CPToList (ListToCP (cons a l) Default)))\n (length (cons a l))
Hl : eq (length (cons a (CPToList (ListToCP l Default)))) (S (length l))
Default : T
l : list T
a : T
T : Type
*****
eq (hd Default (cons a (CPToList (ListToCP l Default)))) (hd Default (CPToList (ListToCP (cons a l) Default)))
+++++
rewrite CPLHd; simpl; reflexivity.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.

*****
Hal : eq (length (CPToList (ListToCP (cons a l) Default)))\n (length (cons a l))
Hl : eq (length (cons a (CPToList (ListToCP l Default)))) (S (length l))
Default : T
l : list T
a : T
T : Type
*****
eq (tl (cons a (CPToList (ListToCP l Default)))) (tl (CPToList (ListToCP (cons a l) Default)))
+++++
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.

*****
Hal : eq (length (CPToList (ListToCP (cons a l) Default)))\n (length (cons a l))
Hl : eq (length (cons a (CPToList (ListToCP l Default)))) (S (length l))
Default : T
l : list T
a : T
T : Type
*****
eq (CPToList (ListToCP l Default)) (tl (CPToList (ListToCP (cons a l) Default)))
+++++
induction l.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.

*****
Hal : eq (length (CPToList (ListToCP (cons a nil) Default)))\n (length (cons a nil))
Hl : eq (length (cons a (CPToList (ListToCP nil Default)))) (S (length nil))
a,Default : T
T : Type
*****
eq (CPToList (ListToCP nil Default)) (tl (CPToList (ListToCP (cons a nil) Default)))
+++++
simpl; reflexivity.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.
simpl; reflexivity.

*****
IHl : forall\n (_ : eq (length (cons a (CPToList (ListToCP l Default))))\n (S (length l)))\n (_ : eq (length (CPToList (ListToCP (cons a l) Default)))\n (length (cons a l))),\neq (CPToList (ListToCP l Default))\n (tl (CPToList (ListToCP (cons a l) Default)))
Hal : eq (length (CPToList (ListToCP (cons a (cons a0 l)) Default)))\n (length (cons a (cons a0 l)))
Hl : eq (length (cons a (CPToList (ListToCP (cons a0 l) Default))))\n (S (length (cons a0 l)))
Default : T
l : list T
a,a0 : T
T : Type
*****
eq (CPToList (ListToCP (cons a0 l) Default)) (tl (CPToList (ListToCP (cons a (cons a0 l)) Default)))
+++++
clear IHl.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.
simpl; reflexivity.
clear IHl.

*****
Hal : eq (length (CPToList (ListToCP (cons a (cons a0 l)) Default)))\n (length (cons a (cons a0 l)))
Hl : eq (length (cons a (CPToList (ListToCP (cons a0 l) Default))))\n (S (length (cons a0 l)))
Default : T
l : list T
a,a0 : T
T : Type
*****
eq (CPToList (ListToCP (cons a0 l) Default)) (tl (CPToList (ListToCP (cons a (cons a0 l)) Default)))
+++++
assert (H := CPToListTl1 a a0 l (ListToCP (a :: a0 :: l) Default)); rewrite H; clear H.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.
simpl; reflexivity.
clear IHl.
assert (H := CPToListTl1 a a0 l (ListToCP (a :: a0 :: l) Default)); rewrite H; clear H.

*****
Hal : eq (length (CPToList (ListToCP (cons a (cons a0 l)) Default)))\n (length (cons a (cons a0 l)))
Hl : eq (length (cons a (CPToList (ListToCP (cons a0 l) Default))))\n (S (length (cons a0 l)))
Default : T
l : list T
a,a0 : T
T : Type
*****
eq (CPToList (ListToCP (cons a0 l) Default)) (CPToList (tailCP (ListToCP (cons a (cons a0 l)) Default)))
+++++
assert (H := CPCPL a0 l (ListToCP (a0 :: l) Default) (tailCP (ListToCP (a :: a0 :: l) Default))); apply H; clear H.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.
simpl; reflexivity.
clear IHl.
assert (H := CPToListTl1 a a0 l (ListToCP (a :: a0 :: l) Default)); rewrite H; clear H.
assert (H := CPCPL a0 l (ListToCP (a0 :: l) Default) (tailCP (ListToCP (a :: a0 :: l) Default))); apply H; clear H.

*****
Hal : eq (length (CPToList (ListToCP (cons a (cons a0 l)) Default)))\n (length (cons a (cons a0 l)))
Hl : eq (length (cons a (CPToList (ListToCP (cons a0 l) Default))))\n (S (length (cons a0 l)))
Default : T
l : list T
a,a0 : T
T : Type
*****
eq (ListToCP (cons a0 l) Default) (tailCP (ListToCP (cons a (cons a0 l)) Default))
+++++
assert (Ha0l : (S (length l)) = length (a0 :: l)) by (simpl; reflexivity).
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.
simpl; reflexivity.
clear IHl.
assert (H := CPToListTl1 a a0 l (ListToCP (a :: a0 :: l) Default)); rewrite H; clear H.
assert (H := CPCPL a0 l (ListToCP (a0 :: l) Default) (tailCP (ListToCP (a :: a0 :: l) Default))); apply H; clear H.
assert (Ha0l : (S (length l)) = length (a0 :: l)) by (simpl; reflexivity).

*****
Ha0l : eq (S (length l)) (length (cons a0 l))
Hal : eq (length (CPToList (ListToCP (cons a (cons a0 l)) Default)))\n (length (cons a (cons a0 l)))
Hl : eq (length (cons a (CPToList (ListToCP (cons a0 l) Default))))\n (S (length (cons a0 l)))
Default : T
l : list T
a,a0 : T
T : Type
*****
eq (ListToCP (cons a0 l) Default) (tailCP (ListToCP (cons a (cons a0 l)) Default))
+++++
assert (Haa0l : (S (S (length l))) = length (a :: a0 :: l)) by (simpl; reflexivity).
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.
simpl; reflexivity.
clear IHl.
assert (H := CPToListTl1 a a0 l (ListToCP (a :: a0 :: l) Default)); rewrite H; clear H.
assert (H := CPCPL a0 l (ListToCP (a0 :: l) Default) (tailCP (ListToCP (a :: a0 :: l) Default))); apply H; clear H.
assert (Ha0l : (S (length l)) = length (a0 :: l)) by (simpl; reflexivity).
assert (Haa0l : (S (S (length l))) = length (a :: a0 :: l)) by (simpl; reflexivity).

*****
Haa0l : eq (S (S (length l))) (length (cons a (cons a0 l)))
Ha0l : eq (S (length l)) (length (cons a0 l))
Hal : eq (length (CPToList (ListToCP (cons a (cons a0 l)) Default)))\n (length (cons a (cons a0 l)))
Hl : eq (length (cons a (CPToList (ListToCP (cons a0 l) Default))))\n (S (length (cons a0 l)))
Default : T
l : list T
a,a0 : T
T : Type
*****
eq (ListToCP (cons a0 l) Default) (tailCP (ListToCP (cons a (cons a0 l)) Default))
+++++
assert (H := ListToCPTl a a0 l Ha0l Haa0l Default); rewrite <- H; clear H.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.
simpl; reflexivity.
clear IHl.
assert (H := CPToListTl1 a a0 l (ListToCP (a :: a0 :: l) Default)); rewrite H; clear H.
assert (H := CPCPL a0 l (ListToCP (a0 :: l) Default) (tailCP (ListToCP (a :: a0 :: l) Default))); apply H; clear H.
assert (Ha0l : (S (length l)) = length (a0 :: l)) by (simpl; reflexivity).
assert (Haa0l : (S (S (length l))) = length (a :: a0 :: l)) by (simpl; reflexivity).
assert (H := ListToCPTl a a0 l Ha0l Haa0l Default); rewrite <- H; clear H.

*****
Haa0l : eq (S (S (length l))) (length (cons a (cons a0 l)))
Ha0l : eq (S (length l)) (length (cons a0 l))
Hal : eq (length (CPToList (ListToCP (cons a (cons a0 l)) Default)))\n (length (cons a (cons a0 l)))
Hl : eq (length (cons a (CPToList (ListToCP (cons a0 l) Default))))\n (S (length (cons a0 l)))
Default : T
l : list T
a,a0 : T
T : Type
*****
eq (tailCPbis (length (cons a (cons a0 l))) (length (cons a l)) (ListToCP (cons a (cons a0 l)) Default) Haa0l Ha0l) (tailCP (ListToCP (cons a (cons a0 l)) Default))
+++++
unfold tailCPbis.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.
simpl; reflexivity.
clear IHl.
assert (H := CPToListTl1 a a0 l (ListToCP (a :: a0 :: l) Default)); rewrite H; clear H.
assert (H := CPCPL a0 l (ListToCP (a0 :: l) Default) (tailCP (ListToCP (a :: a0 :: l) Default))); apply H; clear H.
assert (Ha0l : (S (length l)) = length (a0 :: l)) by (simpl; reflexivity).
assert (Haa0l : (S (S (length l))) = length (a :: a0 :: l)) by (simpl; reflexivity).
assert (H := ListToCPTl a a0 l Ha0l Haa0l Default); rewrite <- H; clear H.
unfold tailCPbis.

*****
Haa0l : eq (S (S (length l))) (length (cons a (cons a0 l)))
Ha0l : eq (S (length l)) (length (cons a0 l))
Hal : eq (length (CPToList (ListToCP (cons a (cons a0 l)) Default)))\n (length (cons a (cons a0 l)))
Hl : eq (length (cons a (CPToList (ListToCP (cons a0 l) Default))))\n (S (length (cons a0 l)))
Default : T
l : list T
a,a0 : T
T : Type
*****
eq (eq_rect (S (S (length l))) (fun m1 : nat => forall _ : cartesianPower T m1, cartesianPower T (length (cons a l))) (fun cp : cartesianPower T (S (S (length l))) => eq_rect (S (length l)) (fun m2 : nat => cartesianPower T m2) (tailCP cp) (length (cons a l)) Ha0l) (length (cons a (cons a0 l))) Haa0l (ListToCP (cons a (cons a0 l)) Default)) (tailCP (ListToCP (cons a (cons a0 l)) Default))
+++++
repeat (elim_eq_rect; simpl); reflexivity.
-----
Lemma CPLRec {T : Type} : forall (a : T) l Default, (a :: (CPToList (ListToCP l Default))) = CPToList (ListToCP (a :: l) Default).
Proof.
intros a l Default.
assert (HlAux := lengthOfCPToList (ListToCP l Default)).
assert (Hl : S (length l) = length (a :: CPToList (ListToCP l Default))) by (simpl; apply eq_S; assumption); clear HlAux; apply eq_sym in Hl.
assert (Hal := lengthOfCPToList (ListToCP (a :: l) Default)); apply eq_sym in Hal.
apply listInd with (length l) Default; try assumption.
rewrite CPLHd; simpl; reflexivity.
assert (H : tl (a :: CPToList (ListToCP l Default)) = CPToList (ListToCP l Default)) by (simpl; reflexivity); rewrite H; clear H.
induction l.
simpl; reflexivity.
clear IHl.
assert (H := CPToListTl1 a a0 l (ListToCP (a :: a0 :: l) Default)); rewrite H; clear H.
assert (H := CPCPL a0 l (ListToCP (a0 :: l) Default) (tailCP (ListToCP (a :: a0 :: l) Default))); apply H; clear H.
assert (Ha0l : (S (length l)) = length (a0 :: l)) by (simpl; reflexivity).
assert (Haa0l : (S (S (length l))) = length (a :: a0 :: l)) by (simpl; reflexivity).
assert (H := ListToCPTl a a0 l Ha0l Haa0l Default); rewrite <- H; clear H.
unfold tailCPbis.
repeat (elim_eq_rect; simpl); reflexivity.

*****

*****

+++++
Qed.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default,\n  CPToList (ListToCP l Default) = l.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default, CPToList (ListToCP l Default) = l.

*****
T : Type
*****
forall (l : list T) (Default : T), eq (CPToList (ListToCP l Default)) l
+++++
Proof.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default, CPToList (ListToCP l Default) = l.
Proof.

*****
T : Type
*****
forall (l : list T) (Default : T), eq (CPToList (ListToCP l Default)) l
+++++
intros l Default.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default, CPToList (ListToCP l Default) = l.
Proof.
intros l Default.

*****
Default : T
l : list T
T : Type
*****
eq (CPToList (ListToCP l Default)) l
+++++
induction l.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default, CPToList (ListToCP l Default) = l.
Proof.
intros l Default.
induction l.

*****
Default : T
T : Type
*****
eq (CPToList (ListToCP nil Default)) nil
+++++
simpl.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default, CPToList (ListToCP l Default) = l.
Proof.
intros l Default.
induction l.
simpl.

*****
Default : T
T : Type
*****
eq nil nil
+++++
reflexivity.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default, CPToList (ListToCP l Default) = l.
Proof.
intros l Default.
induction l.

*****
IHl : eq (CPToList (ListToCP l Default)) l
Default : T
l : list T
a : T
T : Type
*****
eq (CPToList (ListToCP (cons a l) Default)) (cons a l)
+++++
rewrite <- CPLRec.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default, CPToList (ListToCP l Default) = l.
Proof.
intros l Default.
induction l.
rewrite <- CPLRec.

*****
IHl : eq (CPToList (ListToCP l Default)) l
Default : T
l : list T
a : T
T : Type
*****
eq (cons a (CPToList (ListToCP l Default))) (cons a l)
+++++
rewrite IHl.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default, CPToList (ListToCP l Default) = l.
Proof.
intros l Default.
induction l.
rewrite <- CPLRec.
rewrite IHl.

*****
IHl : eq (CPToList (ListToCP l Default)) l
Default : T
l : list T
a : T
T : Type
*****
eq (cons a l) (cons a l)
+++++
reflexivity.
-----
Lemma CPLOK {T : Type} : forall (l : list T) Default, CPToList (ListToCP l Default) = l.
Proof.
intros l Default.
induction l.

*****

*****

+++++
Qed.
-----
Definition fixLastCP {T:Type} {n:nat} (appPred : cartesianPower T (S (S n)) -> Prop) (t : T) : cartesianPower T (S n) -> Prop.
-----
Definition fixLastCP {T:Type} {n:nat} (appPred : cartesianPower T (S (S n)) -> Prop) (t : T) : cartesianPower T (S n) -> Prop.

*****
t : T
appPred : forall _ : cartesianPower T (S (S n)), Prop
n : nat
T : Type
*****
forall _ : cartesianPower T (S n), Prop
+++++
Proof.
-----
Definition fixLastCP {T:Type} {n:nat} (appPred : cartesianPower T (S (S n)) -> Prop) (t : T) : cartesianPower T (S n) -> Prop.
Proof.

*****
t : T
appPred : forall _ : cartesianPower T (S (S n)), Prop
n : nat
T : Type
*****
forall _ : cartesianPower T (S n), Prop
+++++
intro cp.
-----
Definition fixLastCP {T:Type} {n:nat} (appPred : cartesianPower T (S (S n)) -> Prop) (t : T) : cartesianPower T (S n) -> Prop.
Proof.
intro cp.

*****
cp : cartesianPower T (S n)
t : T
appPred : forall _ : cartesianPower T (S (S n)), Prop
n : nat
T : Type
*****
Prop
+++++
apply appPred.
-----
Definition fixLastCP {T:Type} {n:nat} (appPred : cartesianPower T (S (S n)) -> Prop) (t : T) : cartesianPower T (S n) -> Prop.
Proof.
intro cp.
apply appPred.

*****
cp : cartesianPower T (S n)
t : T
appPred : forall _ : cartesianPower T (S (S n)), Prop
n : nat
T : Type
*****
cartesianPower T (S (S n))
+++++
exact (consTailCP cp t).
-----
Definition fixLastCP {T:Type} {n:nat} (appPred : cartesianPower T (S (S n)) -> Prop) (t : T) : cartesianPower T (S n) -> Prop.
Proof.
intro cp.
apply appPred.
exact (consTailCP cp t).

*****

*****

+++++
Defined.
-----
Lemma fixLastCPOK {T:Type} {n:nat} :\n  forall (appPred : cartesianPower T (S (S n)) -> Prop) (cp : cartesianPower T (S n)) (t : T),\n  appPred (consTailCP  cp t) = (fixLastCP appPred t) cp.
-----
Lemma fixLastCPOK {T:Type} {n:nat} : forall (appPred : cartesianPower T (S (S n)) -> Prop) (cp : cartesianPower T (S n)) (t : T), appPred (consTailCP cp t) = (fixLastCP appPred t) cp.

*****
n : nat
T : Type
*****
forall (appPred : forall _ : cartesianPower T (S (S n)), Prop) (cp : cartesianPower T (S n)) (t : T), eq (appPred (consTailCP cp t)) (fixLastCP appPred t cp)
+++++
Proof.
-----
Lemma fixLastCPOK {T:Type} {n:nat} : forall (appPred : cartesianPower T (S (S n)) -> Prop) (cp : cartesianPower T (S n)) (t : T), appPred (consTailCP cp t) = (fixLastCP appPred t) cp.
Proof.

*****
n : nat
T : Type
*****
forall (appPred : forall _ : cartesianPower T (S (S n)), Prop) (cp : cartesianPower T (S n)) (t : T), eq (appPred (consTailCP cp t)) (fixLastCP appPred t cp)
+++++
intros appPred cp.
-----
Lemma fixLastCPOK {T:Type} {n:nat} : forall (appPred : cartesianPower T (S (S n)) -> Prop) (cp : cartesianPower T (S n)) (t : T), appPred (consTailCP cp t) = (fixLastCP appPred t) cp.
Proof.
intros appPred cp.

*****
cp : cartesianPower T (S n)
appPred : forall _ : cartesianPower T (S (S n)), Prop
n : nat
T : Type
*****
forall t : T, eq (appPred (consTailCP cp t)) (fixLastCP appPred t cp)
+++++
unfold fixLastCP.
-----
Lemma fixLastCPOK {T:Type} {n:nat} : forall (appPred : cartesianPower T (S (S n)) -> Prop) (cp : cartesianPower T (S n)) (t : T), appPred (consTailCP cp t) = (fixLastCP appPred t) cp.
Proof.
intros appPred cp.
unfold fixLastCP.

*****
cp : cartesianPower T (S n)
appPred : forall _ : cartesianPower T (S (S n)), Prop
n : nat
T : Type
*****
forall t : T, eq (appPred (consTailCP cp t)) (appPred (consTailCP cp t))
+++++
reflexivity.
-----
Lemma fixLastCPOK {T:Type} {n:nat} : forall (appPred : cartesianPower T (S (S n)) -> Prop) (cp : cartesianPower T (S n)) (t : T), appPred (consTailCP cp t) = (fixLastCP appPred t) cp.
Proof.
intros appPred cp.
unfold fixLastCP.
reflexivity.

*****

*****

+++++
Qed.
-----
Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.
-----
Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.

*****
cp : cartesianPower T n
pred : arity T n
n : nat
T : Type
*****
Prop
+++++
Proof.
-----
Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.
Proof.

*****
cp : cartesianPower T n
pred : arity T n
n : nat
T : Type
*****
Prop
+++++
induction n.
-----
Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.
Proof.
induction n.

*****
cp : cartesianPower T O
pred : arity T O
T : Type
*****
Prop
+++++
apply pred.
-----
Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.
Proof.
induction n.

*****
IHn : forall (_ : arity T n) (_ : cartesianPower T n), Prop
cp : cartesianPower T (S n)
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
clear IHn.
-----
Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.

*****
cp : cartesianPower T (S n)
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
induction n.
-----
Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.
induction n.

*****
cp : cartesianPower T (S O)
pred : arity T (S O)
T : Type
*****
Prop
+++++
exact (pred cp).
-----
Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.
induction n.

*****
IHn : forall (_ : arity T (S n)) (_ : cartesianPower T (S n)), Prop
cp : cartesianPower T (S (S n))
pred : arity T (S (S n))
n : nat
T : Type
*****
Prop
+++++
exact (IHn (pred (headCP cp)) (tailCP cp)).
-----
Definition app {T:Type} {n:nat} (pred : arity T n) (cp : cartesianPower T n) : Prop.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.
-----
Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.

*****
x : T
cp : cartesianPower T n
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
Proof.
-----
Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.
Proof.

*****
x : T
cp : cartesianPower T n
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
induction n.
-----
Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.
Proof.
induction n.

*****
x : T
cp : cartesianPower T O
pred : arity T (S O)
T : Type
*****
Prop
+++++
exact (pred x).
-----
Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.
Proof.
induction n.

*****
IHn : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop
x : T
cp : cartesianPower T (S n)
pred : arity T (S (S n))
n : nat
T : Type
*****
Prop
+++++
clear IHn.
-----
Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.
Proof.
induction n.
clear IHn.

*****
x : T
cp : cartesianPower T (S n)
pred : arity T (S (S n))
n : nat
T : Type
*****
Prop
+++++
induction n.
-----
Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.
Proof.
induction n.
clear IHn.
induction n.

*****
x : T
cp : cartesianPower T (S O)
pred : arity T (S (S O))
T : Type
*****
Prop
+++++
exact (pred cp x).
-----
Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.
Proof.
induction n.
clear IHn.
induction n.

*****
IHn : forall (_ : arity T (S (S n))) (_ : cartesianPower T (S n)), Prop
x : T
cp : cartesianPower T (S (S n))
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
Prop
+++++
exact (IHn (pred (headCP cp)) (tailCP cp)).
-----
Definition app_n_1 {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T n) (x : T) : Prop.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma app_n_1_app {T:Type} {n:nat} :\n  forall (pred : arity T (S (S n))) (x : T)\n         (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),\n    app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x ->\n    app pred cpt.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : app_n_1 pred cpp x) (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), app pred cpt
+++++
Proof.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : app_n_1 pred cpp x) (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), app pred cpt
+++++
intros.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app pred cpt
+++++
induction n.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : arity T (S (S O))
T : Type
*****
app pred cpt
+++++
simpl in *.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.

*****
H1 : eq (snd cpt) x
H0 : eq (fst cpt) cpp
H : pred cpp x
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred (fst cpt) (snd cpt)
+++++
rewrite H0.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.

*****
H1 : eq (snd cpt) x
H0 : eq (fst cpt) cpp
H : pred cpp x
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred cpp (snd cpt)
+++++
rewrite H1.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.
rewrite H1.

*****
H1 : eq (snd cpt) x
H0 : eq (fst cpt) cpp
H : pred cpp x
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred cpp x
+++++
apply H.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), \napp pred cpt
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app pred cpt
+++++
apply IHn with (tailCP cpp).
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), \napp pred cpt
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app_n_1 (pred (headCP cpt)) (tailCP cpp) x
+++++
clear IHn.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app_n_1 (pred (headCP cpt)) (tailCP cpp) x
+++++
unfold app_n_1 in *.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
unfold app_n_1 in *.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T (S O)) (_ : cartesianPower T O) => pred x)\n (fun (n : nat)\n (_ : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (pred : arity T (S (S n))) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)),\n Prop)\n (fun (pred0 : arity T (S (S O))) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0 x)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S (S n0)))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S (S n0))))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S n)) pred cpp
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop) (fun (pred : arity T (S O)) (_ : cartesianPower T O) => pred x) (fun (n : nat) (_ : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop) (pred : arity T (S (S n))) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)), Prop) (fun (pred0 : arity T (S (S O))) (cp0 : cartesianPower T (S O)) => pred0 cp0 x) (fun (n0 : nat) (IHn0 : forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)), Prop) (pred0 : arity T (S (S (S n0)))) (cp0 : cartesianPower T (S (S n0))) => IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) (S n) (pred (headCP cpt)) (tailCP cpp)
+++++
assert (H3 : (fst cpt) = fst (cpp)).
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
unfold app_n_1 in *.
assert (H3 : (fst cpt) = fst (cpp)).

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T (S O)) (_ : cartesianPower T O) => pred x)\n (fun (n : nat)\n (_ : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (pred : arity T (S (S n))) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)),\n Prop)\n (fun (pred0 : arity T (S (S O))) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0 x)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S (S n0)))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S (S n0))))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S n)) pred cpp
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cpt) (fst cpp)
+++++
rewrite <- H0.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
unfold app_n_1 in *.
assert (H3 : (fst cpt) = fst (cpp)).
rewrite <- H0.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T (S O)) (_ : cartesianPower T O) => pred x)\n (fun (n : nat)\n (_ : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (pred : arity T (S (S n))) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)),\n Prop)\n (fun (pred0 : arity T (S (S O))) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0 x)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S (S n0)))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S (S n0))))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S n)) pred cpp
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cpt) (fst (allButLastCP cpt))
+++++
simpl.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
unfold app_n_1 in *.
assert (H3 : (fst cpt) = fst (cpp)).
rewrite <- H0.
simpl.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T (S O)) (_ : cartesianPower T O) => pred x)\n (fun (n : nat)\n (_ : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (pred : arity T (S (S n))) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)),\n Prop)\n (fun (pred0 : arity T (S (S O))) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0 x)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S (S n0)))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S (S n0))))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S n)) pred cpp
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cpt) (fst cpt)
+++++
reflexivity.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
unfold app_n_1 in *.
assert (H3 : (fst cpt) = fst (cpp)).

*****
H3 : eq (fst cpt) (fst cpp)
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T (S O)) (_ : cartesianPower T O) => pred x)\n (fun (n : nat)\n (_ : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (pred : arity T (S (S n))) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)),\n Prop)\n (fun (pred0 : arity T (S (S O))) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0 x)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S (S n0)))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S (S n0))))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S n)) pred cpp
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop) (fun (pred : arity T (S O)) (_ : cartesianPower T O) => pred x) (fun (n : nat) (_ : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop) (pred : arity T (S (S n))) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)), Prop) (fun (pred0 : arity T (S (S O))) (cp0 : cartesianPower T (S O)) => pred0 cp0 x) (fun (n0 : nat) (IHn0 : forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)), Prop) (pred0 : arity T (S (S (S n0)))) (cp0 : cartesianPower T (S (S n0))) => IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) (S n) (pred (headCP cpt)) (tailCP cpp)
+++++
idtac.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
unfold app_n_1 in *.
assert (H3 : (fst cpt) = fst (cpp)).
idtac.

*****
H3 : eq (fst cpt) (fst cpp)
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T (S O)) (_ : cartesianPower T O) => pred x)\n (fun (n : nat)\n (_ : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop)\n (pred : arity T (S (S n))) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)),\n Prop)\n (fun (pred0 : arity T (S (S O))) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0 x)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S (S n0)))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S (S n0))))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S n)) pred cpp
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop) (fun (pred : arity T (S O)) (_ : cartesianPower T O) => pred x) (fun (n : nat) (_ : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop) (pred : arity T (S (S n))) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)), Prop) (fun (pred0 : arity T (S (S O))) (cp0 : cartesianPower T (S O)) => pred0 cp0 x) (fun (n0 : nat) (IHn0 : forall (_ : arity T (S (S n0))) (_ : cartesianPower T (S n0)), Prop) (pred0 : arity T (S (S (S n0)))) (cp0 : cartesianPower T (S (S n0))) => IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) (S n) (pred (headCP cpt)) (tailCP cpp)
+++++
simpl in *.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
unfold app_n_1 in *.
assert (H3 : (fst cpt) = fst (cpp)).
idtac.
simpl in *.

*****
H3 : eq (fst cpt) (fst cpp)
H1 : eq (lastCP (tailCP (snd cpt))) x
H0 : eq\n (pair (fst cpt)\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) (F n0) n0 \n (minus_n_0 n0) (snd cp))\n end) n) n (minus_n_0 n) (snd cpt))) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : forall (_ : T) (_ : T), arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (fun (pred : forall (_ : T) (_ : T), Prop)\n (cp : cartesianPower T (S O)) => pred cp x)\n (fun (n : nat)\n (IHn : forall (_ : forall (_ : T) (_ : T), arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpp)) \n (tailCP cpp)
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall (_ : T) (_ : T), arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall (_ : T) (_ : T), Prop) (cp : cartesianPower T (S O)) => pred cp x) (fun (n : nat) (IHn : forall (_ : forall (_ : T) (_ : T), arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt)) (tailCP cpp)
+++++
rewrite H3.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
unfold app_n_1 in *.
assert (H3 : (fst cpt) = fst (cpp)).
idtac.
simpl in *.
rewrite H3.

*****
H3 : eq (fst cpt) (fst cpp)
H1 : eq (lastCP (tailCP (snd cpt))) x
H0 : eq\n (pair (fst cpt)\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) (F n0) n0 \n (minus_n_0 n0) (snd cp))\n end) n) n (minus_n_0 n) (snd cpt))) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : forall (_ : T) (_ : T), arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (fun (pred : forall (_ : T) (_ : T), Prop)\n (cp : cartesianPower T (S O)) => pred cp x)\n (fun (n : nat)\n (IHn : forall (_ : forall (_ : T) (_ : T), arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpp)) \n (tailCP cpp)
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall (_ : T) (_ : T), arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall (_ : T) (_ : T), Prop) (cp : cartesianPower T (S O)) => pred cp x) (fun (n : nat) (IHn : forall (_ : forall (_ : T) (_ : T), arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpp)) (tailCP cpp)
+++++
apply H.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), \napp pred cpt
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP cpp)
+++++
clear IHn.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP cpp)
+++++
rewrite <- H0.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H0.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
+++++
induction n.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H0.
induction n.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S (S O))
x : T
pred : arity T (S (S (S O)))
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
+++++
simpl.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H0.
induction n.
simpl.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S (S O))
x : T
pred : arity T (S (S (S O)))
T : Type
*****
eq (fst (snd cpt)) (fst (snd cpt))
+++++
reflexivity.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H0.
induction n.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
+++++
apply CP_ind.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H0.
induction n.
apply CP_ind.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (headCP (allButLastCP (tailCP cpt))) (headCP (tailCP (allButLastCP cpt)))
+++++
simpl.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H0.
induction n.
apply CP_ind.
simpl.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (fst (snd cpt)) (fst (snd cpt))
+++++
reflexivity.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H0.
induction n.
apply CP_ind.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (tailCP (allButLastCP (tailCP cpt))) (tailCP (tailCP (allButLastCP cpt)))
+++++
simpl in *.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H0.
induction n.
apply CP_ind.
simpl in *.

*****
IHn : forall (pred : forall (_ : T) (_ : T) (_ : T), arity T n)\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n))))\n (_ : nat_rect\n (fun n : nat =>\n forall (_ : forall (_ : T) (_ : T), arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (fun (pred0 : forall (_ : T) (_ : T), Prop)\n (cp : cartesianPower T (S O)) => pred0 cp x)\n (fun (n : nat)\n (IHn : forall (_ : forall (_ : T) (_ : T), arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred0 : forall (_ : T) (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred0 (fst cp)) (tailCP cp)) n (pred (fst cpp))\n (tailCP cpp))\n (_ : eq\n (pair (fst cpt)\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) \n (F n0) n0 (minus_n_0 n0) \n (snd cp))\n end) n) n (minus_n_0 n) (snd cpt))) cpp)\n (_ : eq (lastCP (tailCP (snd cpt))) x),\neq (allButLastCP (snd cpt))\n (tailCP\n (pair (fst cpt)\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) (F n0) n0\n (minus_n_0 n0) (snd cp))\n end) n) n (minus_n_0 n) (snd cpt))))
H1 : eq (lastCP (tailCP (snd (snd cpt)))) x
H0 : eq\n (pair (fst cpt)\n (pair (fst (snd cpt))\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) (F n0) n0\n (minus_n_0 n0) (snd cp))\n end) n) n (minus_n_0 n) (snd (snd cpt))))) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : forall (_ : T) (_ : T), arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (fun (pred : forall (_ : T) (_ : T), Prop)\n (cp : cartesianPower T (S O)) => pred cp x)\n (fun (n : nat)\n (IHn : forall (_ : forall (_ : T) (_ : T), arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpp) (fst (snd cpp)))\n (tailCP (snd cpp))
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
eq (tailCP (pair (fst (snd cpt)) (eq_rect (Init.Nat.sub n O) (fun n0 : nat => forall _ : prod T (cartesianPowerAux T n), cartesianPowerAux T n0) ((fix F (n : nat) : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T (S (S n0)), cartesianPower T (S n0)) with | O => fun cp : cartesianPower T (S (S O)) => fst cp | S n0 => fun cp : cartesianPower T (S (S (S n0))) => pair (fst cp) (eq_rect (Init.Nat.sub n0 O) (fun n1 : nat => forall _ : prod T (cartesianPowerAux T n0), cartesianPowerAux T n1) (F n0) n0 (minus_n_0 n0) (snd cp)) end) n) n (minus_n_0 n) (snd (snd cpt))))) (tailCP (pair (fst (snd cpt)) (eq_rect (Init.Nat.sub n O) (fun n0 : nat => forall _ : prod T (cartesianPowerAux T n), cartesianPowerAux T n0) ((fix F (n : nat) : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T (S (S n0)), cartesianPower T (S n0)) with | O => fun cp : cartesianPower T (S (S O)) => fst cp | S n0 => fun cp : cartesianPower T (S (S (S n0))) => pair (fst cp) (eq_rect (Init.Nat.sub n0 O) (fun n1 : nat => forall _ : prod T (cartesianPowerAux T n0), cartesianPowerAux T n1) (F n0) n0 (minus_n_0 n0) (snd cp)) end) n) n (minus_n_0 n) (snd (snd cpt)))))
+++++
reflexivity.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), \napp pred cpt
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (lastCP (tailCP cpt)) x
+++++
clear IHn.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (lastCP (tailCP cpt)) x
+++++
rewrite <- H1.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H1.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (lastCP (tailCP cpt)) (lastCP cpt)
+++++
induction n.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H1.
induction n.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S (S O))
x : T
pred : arity T (S (S (S O)))
T : Type
*****
eq (lastCP (tailCP cpt)) (lastCP cpt)
+++++
simpl.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H1.
induction n.
simpl.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S (S O))
x : T
pred : arity T (S (S (S O)))
T : Type
*****
eq (snd (snd cpt)) (snd (snd cpt))
+++++
reflexivity.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H1.
induction n.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (lastCP (tailCP cpt)) (lastCP cpt)
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (lastCP (tailCP cpt)) (lastCP cpt)
+++++
simpl.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.
apply IHn with (tailCP cpp).
clear IHn.
rewrite <- H1.
induction n.
simpl.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app_n_1 pred cpp x)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (lastCP (tailCP cpt)) (lastCP cpt)
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app_n_1 pred cpp x
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (lastCP (tailCP (snd (snd cpt)))) (lastCP (tailCP (snd (snd cpt))))
+++++
reflexivity.
-----
Lemma app_n_1_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_n_1 pred cpp x -> allButLastCP cpt = cpp -> lastCP cpt = x -> app pred cpt.
Proof.
intros.
induction n.

*****

*****

+++++
Qed.
-----
Lemma app_app_n_1 {T:Type} {n:nat} :\n  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),\n  app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x ->\n  app_n_1 pred cpp x.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : app pred cpt) (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), app_n_1 pred cpp x
+++++
Proof.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : app pred cpt) (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), app_n_1 pred cpp x
+++++
intros.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app_n_1 pred cpp x
+++++
induction n.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : arity T (S (S O))
T : Type
*****
app_n_1 pred cpp x
+++++
simpl in *.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
simpl in *.

*****
H1 : eq (snd cpt) x
H0 : eq (fst cpt) cpp
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred cpp x
+++++
rewrite <- H0.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.

*****
H1 : eq (snd cpt) x
H0 : eq (fst cpt) cpp
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred (fst cpt) x
+++++
rewrite <- H1.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.
rewrite <- H1.

*****
H1 : eq (snd cpt) x
H0 : eq (fst cpt) cpp
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred (fst cpt) (snd cpt)
+++++
apply H.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\napp_n_1 pred cpp x
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app_n_1 pred cpp x
+++++
apply IHn with (tailCP cpt).
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\napp_n_1 pred cpp x
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app (pred (headCP cpp)) (tailCP cpt)
+++++
clear IHn.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app (pred (headCP cpp)) (tailCP cpt)
+++++
unfold app in *.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
unfold app in *.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat => forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T O) (_ : cartesianPower T O) => pred)\n (fun (n : nat)\n (_ : forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (pred : arity T (S n)) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop)\n (fun (pred0 : arity T (S O)) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S n0))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S n0)))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S (S n))) pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : arity T n) (_ : cartesianPower T n), Prop) (fun (pred : arity T O) (_ : cartesianPower T O) => pred) (fun (n : nat) (_ : forall (_ : arity T n) (_ : cartesianPower T n), Prop) (pred : arity T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop) (fun (pred0 : arity T (S O)) (cp0 : cartesianPower T (S O)) => pred0 cp0) (fun (n0 : nat) (IHn0 : forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop) (pred0 : arity T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) => IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) (S (S n)) (pred (headCP cpp)) (tailCP cpt)
+++++
assert (H3 : (fst cpt) = fst (cpp)).
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
unfold app in *.
assert (H3 : (fst cpt) = fst (cpp)).

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat => forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T O) (_ : cartesianPower T O) => pred)\n (fun (n : nat)\n (_ : forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (pred : arity T (S n)) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop)\n (fun (pred0 : arity T (S O)) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S n0))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S n0)))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S (S n))) pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cpt) (fst cpp)
+++++
rewrite <- H0.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
unfold app in *.
assert (H3 : (fst cpt) = fst (cpp)).
rewrite <- H0.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat => forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T O) (_ : cartesianPower T O) => pred)\n (fun (n : nat)\n (_ : forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (pred : arity T (S n)) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop)\n (fun (pred0 : arity T (S O)) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S n0))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S n0)))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S (S n))) pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cpt) (fst (allButLastCP cpt))
+++++
simpl.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
unfold app in *.
assert (H3 : (fst cpt) = fst (cpp)).
rewrite <- H0.
simpl.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat => forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T O) (_ : cartesianPower T O) => pred)\n (fun (n : nat)\n (_ : forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (pred : arity T (S n)) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop)\n (fun (pred0 : arity T (S O)) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S n0))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S n0)))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S (S n))) pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (fst cpt) (fst cpt)
+++++
reflexivity.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
unfold app in *.
assert (H3 : (fst cpt) = fst (cpp)).

*****
H3 : eq (fst cpt) (fst cpp)
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat => forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T O) (_ : cartesianPower T O) => pred)\n (fun (n : nat)\n (_ : forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (pred : arity T (S n)) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop)\n (fun (pred0 : arity T (S O)) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S n0))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S n0)))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S (S n))) pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : arity T n) (_ : cartesianPower T n), Prop) (fun (pred : arity T O) (_ : cartesianPower T O) => pred) (fun (n : nat) (_ : forall (_ : arity T n) (_ : cartesianPower T n), Prop) (pred : arity T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop) (fun (pred0 : arity T (S O)) (cp0 : cartesianPower T (S O)) => pred0 cp0) (fun (n0 : nat) (IHn0 : forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop) (pred0 : arity T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) => IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) (S (S n)) (pred (headCP cpp)) (tailCP cpt)
+++++
idtac.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
unfold app in *.
assert (H3 : (fst cpt) = fst (cpp)).
idtac.

*****
H3 : eq (fst cpt) (fst cpp)
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : nat_rect\n (fun n : nat => forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (fun (pred : arity T O) (_ : cartesianPower T O) => pred)\n (fun (n : nat)\n (_ : forall (_ : arity T n) (_ : cartesianPower T n), Prop)\n (pred : arity T (S n)) (cp : cartesianPower T (S n)) =>\n nat_rect\n (fun n0 : nat =>\n forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop)\n (fun (pred0 : arity T (S O)) (cp0 : cartesianPower T (S O)) =>\n pred0 cp0)\n (fun (n0 : nat)\n (IHn0 : forall (_ : arity T (S n0))\n (_ : cartesianPower T (S n0)), Prop)\n (pred0 : arity T (S (S n0)))\n (cp0 : cartesianPower T (S (S n0))) =>\n IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) \n (S (S (S n))) pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : arity T n) (_ : cartesianPower T n), Prop) (fun (pred : arity T O) (_ : cartesianPower T O) => pred) (fun (n : nat) (_ : forall (_ : arity T n) (_ : cartesianPower T n), Prop) (pred : arity T (S n)) (cp : cartesianPower T (S n)) => nat_rect (fun n0 : nat => forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop) (fun (pred0 : arity T (S O)) (cp0 : cartesianPower T (S O)) => pred0 cp0) (fun (n0 : nat) (IHn0 : forall (_ : arity T (S n0)) (_ : cartesianPower T (S n0)), Prop) (pred0 : arity T (S (S n0))) (cp0 : cartesianPower T (S (S n0))) => IHn0 (pred0 (headCP cp0)) (tailCP cp0)) n pred cp) (S (S n)) (pred (headCP cpp)) (tailCP cpt)
+++++
simpl in *.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
unfold app in *.
assert (H3 : (fst cpt) = fst (cpp)).
idtac.
simpl in *.

*****
H3 : eq (fst cpt) (fst cpp)
H1 : eq (lastCP (tailCP (snd cpt))) x
H0 : eq\n (pair (fst cpt)\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) (F n0) n0 \n (minus_n_0 n0) (snd cp))\n end) n) n (minus_n_0 n) (snd cpt))) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)))\n (tailCP (snd cpt))
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpp) (fst (snd cpt))) (tailCP (snd cpt))
+++++
rewrite <- H3.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
unfold app in *.
assert (H3 : (fst cpt) = fst (cpp)).
idtac.
simpl in *.
rewrite <- H3.

*****
H3 : eq (fst cpt) (fst cpp)
H1 : eq (lastCP (tailCP (snd cpt))) x
H0 : eq\n (pair (fst cpt)\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) (F n0) n0 \n (minus_n_0 n0) (snd cp))\n end) n) n (minus_n_0 n) (snd cpt))) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)))\n (tailCP (snd cpt))
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt))) (tailCP (snd cpt))
+++++
apply H.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\napp_n_1 pred cpp x
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP cpp)
+++++
clear IHn.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP cpp)
+++++
rewrite <- H0.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H0.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
+++++
induction n.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H0.
induction n.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S (S O))
x : T
pred : arity T (S (S (S O)))
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
+++++
simpl.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H0.
induction n.
simpl.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S (S O))
x : T
pred : arity T (S (S (S O)))
T : Type
*****
eq (fst (snd cpt)) (fst (snd cpt))
+++++
reflexivity.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H0.
induction n.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
+++++
apply CP_ind.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H0.
induction n.
apply CP_ind.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (headCP (allButLastCP (tailCP cpt))) (headCP (tailCP (allButLastCP cpt)))
+++++
simpl.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H0.
induction n.
apply CP_ind.
simpl.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (fst (snd cpt)) (fst (snd cpt))
+++++
reflexivity.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H0.
induction n.
apply CP_ind.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (allButLastCP (tailCP cpt)) (tailCP (allButLastCP cpt))
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (tailCP (allButLastCP (tailCP cpt))) (tailCP (tailCP (allButLastCP cpt)))
+++++
simpl in *.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H0.
induction n.
apply CP_ind.
simpl in *.

*****
IHn : forall (pred : forall (_ : T) (_ : T) (_ : T), arity T n)\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n))))\n (_ : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (fun (pred0 : forall _ : T, Prop)\n (cp : cartesianPower T (S O)) => pred0 cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred0 : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred0 (fst cp)) (tailCP cp)) n\n (pred (fst cpt) (fst (snd cpt))) (tailCP (snd cpt)))\n (_ : eq\n (pair (fst cpt)\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) \n (F n0) n0 (minus_n_0 n0) \n (snd cp))\n end) n) n (minus_n_0 n) (snd cpt))) cpp)\n (_ : eq (lastCP (tailCP (snd cpt))) x),\neq (allButLastCP (snd cpt))\n (tailCP\n (pair (fst cpt)\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) (F n0) n0\n (minus_n_0 n0) (snd cp))\n end) n) n (minus_n_0 n) (snd cpt))))
H1 : eq (lastCP (tailCP (snd (snd cpt)))) x
H0 : eq\n (pair (fst cpt)\n (pair (fst (snd cpt))\n (eq_rect (Init.Nat.sub n O)\n (fun n0 : nat =>\n forall _ : prod T (cartesianPowerAux T n),\n cartesianPowerAux T n0)\n ((fix F (n : nat) :\n forall _ : cartesianPower T (S (S n)),\n cartesianPower T (S n) :=\n match\n n as n0\n return\n (forall _ : cartesianPower T (S (S n0)),\n cartesianPower T (S n0))\n with\n | O => fun cp : cartesianPower T (S (S O)) => fst cp\n | S n0 =>\n fun cp : cartesianPower T (S (S (S n0))) =>\n pair (fst cp)\n (eq_rect (Init.Nat.sub n0 O)\n (fun n1 : nat =>\n forall _ : prod T (cartesianPowerAux T n0),\n cartesianPowerAux T n1) (F n0) n0\n (minus_n_0 n0) (snd cp))\n end) n) n (minus_n_0 n) (snd (snd cpt))))) cpp
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n\n (pred (fst cpt) (fst (snd cpt)) (fst (snd (snd cpt))))\n (tailCP (snd (snd cpt)))
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
eq (tailCP (pair (fst (snd cpt)) (eq_rect (Init.Nat.sub n O) (fun n0 : nat => forall _ : prod T (cartesianPowerAux T n), cartesianPowerAux T n0) ((fix F (n : nat) : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T (S (S n0)), cartesianPower T (S n0)) with | O => fun cp : cartesianPower T (S (S O)) => fst cp | S n0 => fun cp : cartesianPower T (S (S (S n0))) => pair (fst cp) (eq_rect (Init.Nat.sub n0 O) (fun n1 : nat => forall _ : prod T (cartesianPowerAux T n0), cartesianPowerAux T n1) (F n0) n0 (minus_n_0 n0) (snd cp)) end) n) n (minus_n_0 n) (snd (snd cpt))))) (tailCP (pair (fst (snd cpt)) (eq_rect (Init.Nat.sub n O) (fun n0 : nat => forall _ : prod T (cartesianPowerAux T n), cartesianPowerAux T n0) ((fix F (n : nat) : forall _ : cartesianPower T (S (S n)), cartesianPower T (S n) := match n as n0 return (forall _ : cartesianPower T (S (S n0)), cartesianPower T (S n0)) with | O => fun cp : cartesianPower T (S (S O)) => fst cp | S n0 => fun cp : cartesianPower T (S (S (S n0))) => pair (fst cp) (eq_rect (Init.Nat.sub n0 O) (fun n1 : nat => forall _ : prod T (cartesianPowerAux T n0), cartesianPowerAux T n1) (F n0) n0 (minus_n_0 n0) (snd cp)) end) n) n (minus_n_0 n) (snd (snd cpt)))))
+++++
reflexivity.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\napp_n_1 pred cpp x
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (lastCP (tailCP cpt)) x
+++++
clear IHn.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (lastCP (tailCP cpt)) x
+++++
rewrite <- H1.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H1.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
eq (lastCP (tailCP cpt)) (lastCP cpt)
+++++
induction n.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H1.
induction n.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S (S O))
x : T
pred : arity T (S (S (S O)))
T : Type
*****
eq (lastCP (tailCP cpt)) (lastCP cpt)
+++++
simpl.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H1.
induction n.
simpl.

*****
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S (S O))
x : T
pred : arity T (S (S (S O)))
T : Type
*****
eq (snd (snd cpt)) (snd (snd cpt))
+++++
reflexivity.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H1.
induction n.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (lastCP (tailCP cpt)) (lastCP cpt)
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (lastCP (tailCP cpt)) (lastCP cpt)
+++++
simpl.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.
apply IHn with (tailCP cpt).
clear IHn.
rewrite <- H1.
induction n.
simpl.

*****
IHn : forall (pred : arity T (S (S (S n))))\n (cpp : cartesianPower T (S (S n)))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app pred cpt)\n (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x),\neq (lastCP (tailCP cpt)) (lastCP cpt)
H1 : eq (lastCP cpt) x
H0 : eq (allButLastCP cpt) cpp
H : app pred cpt
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S (S n)))
x : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
eq (lastCP (tailCP (snd (snd cpt)))) (lastCP (tailCP (snd (snd cpt))))
+++++
reflexivity.
-----
Lemma app_app_n_1 {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> allButLastCP cpt = cpp -> lastCP cpt = x -> app_n_1 pred cpp x.
Proof.
intros.
induction n.

*****

*****

+++++
Qed.
-----
Lemma app_n_1_app_eq {T:Type} {n:nat} :\n  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),\n  allButLastCP cpt = cpp -> lastCP cpt = x ->\n  (app pred cpt <-> app_n_1 pred cpp x).
-----
Lemma app_n_1_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), allButLastCP cpt = cpp -> lastCP cpt = x -> (app pred cpt <-> app_n_1 pred cpp x).

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), iff (app pred cpt) (app_n_1 pred cpp x)
+++++
Proof.
-----
Lemma app_n_1_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), allButLastCP cpt = cpp -> lastCP cpt = x -> (app pred cpt <-> app_n_1 pred cpp x).
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : eq (allButLastCP cpt) cpp) (_ : eq (lastCP cpt) x), iff (app pred cpt) (app_n_1 pred cpp x)
+++++
intros.
-----
Lemma app_n_1_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), allButLastCP cpt = cpp -> lastCP cpt = x -> (app pred cpt <-> app_n_1 pred cpp x).
Proof.
intros.

*****
H0 : eq (lastCP cpt) x
H : eq (allButLastCP cpt) cpp
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
iff (app pred cpt) (app_n_1 pred cpp x)
+++++
split.
-----
Lemma app_n_1_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), allButLastCP cpt = cpp -> lastCP cpt = x -> (app pred cpt <-> app_n_1 pred cpp x).
Proof.
intros.
split.

*****
H0 : eq (lastCP cpt) x
H : eq (allButLastCP cpt) cpp
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
forall _ : app pred cpt, app_n_1 pred cpp x
+++++
intro H1.
-----
Lemma app_n_1_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), allButLastCP cpt = cpp -> lastCP cpt = x -> (app pred cpt <-> app_n_1 pred cpp x).
Proof.
intros.
split.
intro H1.

*****
H1 : app pred cpt
H0 : eq (lastCP cpt) x
H : eq (allButLastCP cpt) cpp
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app_n_1 pred cpp x
+++++
apply (app_app_n_1 pred x cpp cpt H1 H H0).
-----
Lemma app_n_1_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), allButLastCP cpt = cpp -> lastCP cpt = x -> (app pred cpt <-> app_n_1 pred cpp x).
Proof.
intros.
split.

*****
H0 : eq (lastCP cpt) x
H : eq (allButLastCP cpt) cpp
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
forall _ : app_n_1 pred cpp x, app pred cpt
+++++
intro H1.
-----
Lemma app_n_1_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), allButLastCP cpt = cpp -> lastCP cpt = x -> (app pred cpt <-> app_n_1 pred cpp x).
Proof.
intros.
split.
intro H1.

*****
H1 : app_n_1 pred cpp x
H0 : eq (lastCP cpt) x
H : eq (allButLastCP cpt) cpp
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app pred cpt
+++++
apply (app_n_1_app pred x cpp cpt H1 H H0).
-----
Lemma app_n_1_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), allButLastCP cpt = cpp -> lastCP cpt = x -> (app pred cpt <-> app_n_1 pred cpp x).
Proof.
intros.
split.

*****

*****

+++++
Qed.
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.

*****
cp : cartesianPower T n
x : T
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
Proof.
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.

*****
cp : cartesianPower T n
x : T
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
induction n.
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.

*****
cp : cartesianPower T O
x : T
pred : arity T (S O)
T : Type
*****
Prop
+++++
exact (pred x).
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.

*****
IHn : forall (_ : arity T (S n)) (_ : cartesianPower T n), Prop
cp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
Prop
+++++
clear IHn.
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.

*****
cp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
Prop
+++++
induction n.
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.
induction n.

*****
cp : cartesianPower T (S O)
x : T
pred : arity T (S (S O))
T : Type
*****
Prop
+++++
exact (pred x cp).
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.
induction n.

*****
IHn : forall (_ : arity T (S (S n))) (_ : cartesianPower T (S n)), Prop
cp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
Prop
+++++
clear IHn.
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.
induction n.
clear IHn.

*****
cp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
Prop
+++++
assert (newPred : arity T (S n)).
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.
induction n.
clear IHn.
assert (newPred : arity T (S n)).

*****
cp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
arity T (S n)
+++++
exact (pred x (headCP cp)).
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.
induction n.
clear IHn.
assert (newPred : arity T (S n)).

*****
newPred : arity T (S n)
cp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
Prop
+++++
idtac.
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.
clear IHn.
induction n.
clear IHn.
assert (newPred : arity T (S n)).
idtac.

*****
newPred : arity T (S n)
cp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
Prop
+++++
exact (app newPred (tailCP cp)).
-----
Definition app_1_n {T:Type} {n:nat} (pred : arity T (S n)) (x : T) (cp : cartesianPower T n) : Prop.
Proof.
induction n.

*****

*****

+++++
Defined.
-----
Lemma app_1_n_app {T:Type} {n:nat} :\n  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),\n  app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp ->\n  app pred cpt.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : app_1_n pred x cpp) (_ : eq (headCP cpt) x) (_ : eq (tailCP cpt) cpp), app pred cpt
+++++
Proof.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : app_1_n pred x cpp) (_ : eq (headCP cpt) x) (_ : eq (tailCP cpt) cpp), app pred cpt
+++++
intros.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.

*****
H1 : eq (tailCP cpt) cpp
H0 : eq (headCP cpt) x
H : app_1_n pred x cpp
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app pred cpt
+++++
induction n.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.

*****
H1 : eq (tailCP cpt) cpp
H0 : eq (headCP cpt) x
H : app_1_n pred x cpp
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : arity T (S (S O))
T : Type
*****
app pred cpt
+++++
simpl in *.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : pred x cpp
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred (fst cpt) (snd cpt)
+++++
rewrite H0.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : pred x cpp
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred x (snd cpt)
+++++
rewrite H1.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.
rewrite H1.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : pred x cpp
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred x cpp
+++++
apply H.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app_1_n pred x cpp)\n (_ : eq (headCP cpt) x) (_ : eq (tailCP cpt) cpp), \napp pred cpt
H1 : eq (tailCP cpt) cpp
H0 : eq (headCP cpt) x
H : app_1_n pred x cpp
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app pred cpt
+++++
clear IHn.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.
clear IHn.

*****
H1 : eq (tailCP cpt) cpp
H0 : eq (headCP cpt) x
H : app_1_n pred x cpp
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app pred cpt
+++++
simpl in *.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.
clear IHn.
simpl in *.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred x (fst cpp)) \n (tailCP cpp)
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt))) (tailCP (snd cpt))
+++++
rewrite H0.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite H0.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred x (fst cpp)) \n (tailCP cpp)
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred x (fst (snd cpt))) (tailCP (snd cpt))
+++++
rewrite H1.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite H0.
rewrite H1.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred x (fst cpp)) \n (tailCP cpp)
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred x (fst cpp)) (tailCP cpp)
+++++
apply H.
-----
Lemma app_1_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app_1_n pred x cpp -> headCP cpt = x -> tailCP cpt = cpp -> app pred cpt.
Proof.
intros.
induction n.

*****

*****

+++++
Qed.
-----
Lemma app_app_1_n {T:Type} {n:nat} :\n  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),\n  app pred cpt -> headCP cpt = x -> tailCP cpt = cpp ->\n  app_1_n pred x cpp.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : app pred cpt) (_ : eq (headCP cpt) x) (_ : eq (tailCP cpt) cpp), app_1_n pred x cpp
+++++
Proof.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : app pred cpt) (_ : eq (headCP cpt) x) (_ : eq (tailCP cpt) cpp), app_1_n pred x cpp
+++++
intros.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.

*****
H1 : eq (tailCP cpt) cpp
H0 : eq (headCP cpt) x
H : app pred cpt
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app_1_n pred x cpp
+++++
induction n.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.

*****
H1 : eq (tailCP cpt) cpp
H0 : eq (headCP cpt) x
H : app pred cpt
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : arity T (S (S O))
T : Type
*****
app_1_n pred x cpp
+++++
simpl in *.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.
simpl in *.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred x cpp
+++++
rewrite <- H0.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred (fst cpt) cpp
+++++
rewrite <- H1.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.
rewrite <- H1.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp : cartesianPower T (S O)
x : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred (fst cpt) (snd cpt)
+++++
apply H.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.

*****
IHn : forall (pred : arity T (S (S n))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S n))) (_ : app pred cpt)\n (_ : eq (headCP cpt) x) (_ : eq (tailCP cpt) cpp), \napp_1_n pred x cpp
H1 : eq (tailCP cpt) cpp
H0 : eq (headCP cpt) x
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app_1_n pred x cpp
+++++
clear IHn.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.
clear IHn.

*****
H1 : eq (tailCP cpt) cpp
H0 : eq (headCP cpt) x
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app_1_n pred x cpp
+++++
simpl in *.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)))\n (tailCP (snd cpt))
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred x (fst cpp)) (tailCP cpp)
+++++
rewrite <- H0.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite <- H0.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)))\n (tailCP (snd cpt))
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst cpp)) (tailCP cpp)
+++++
rewrite <- H1.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite <- H0.
rewrite <- H1.

*****
H1 : eq (snd cpt) cpp
H0 : eq (fst cpt) x
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)))\n (tailCP (snd cpt))
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S (S n))
x : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt))) (tailCP (snd cpt))
+++++
apply H.
-----
Lemma app_app_1_n {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x -> tailCP cpt = cpp -> app_1_n pred x cpp.
Proof.
intros.
induction n.

*****

*****

+++++
Qed.
-----
Lemma app_1_n_app_eq {T:Type} {n:nat} :\n  forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))),\n  headCP cpt = x -> tailCP cpt = cpp ->\n  (app pred cpt <-> app_1_n pred x cpp).
-----
Lemma app_1_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), headCP cpt = x -> tailCP cpt = cpp -> (app pred cpt <-> app_1_n pred x cpp).

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : eq (headCP cpt) x) (_ : eq (tailCP cpt) cpp), iff (app pred cpt) (app_1_n pred x cpp)
+++++
Proof.
-----
Lemma app_1_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), headCP cpt = x -> tailCP cpt = cpp -> (app pred cpt <-> app_1_n pred x cpp).
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))) (_ : eq (headCP cpt) x) (_ : eq (tailCP cpt) cpp), iff (app pred cpt) (app_1_n pred x cpp)
+++++
intros.
-----
Lemma app_1_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), headCP cpt = x -> tailCP cpt = cpp -> (app pred cpt <-> app_1_n pred x cpp).
Proof.
intros.

*****
H0 : eq (tailCP cpt) cpp
H : eq (headCP cpt) x
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
iff (app pred cpt) (app_1_n pred x cpp)
+++++
split.
-----
Lemma app_1_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), headCP cpt = x -> tailCP cpt = cpp -> (app pred cpt <-> app_1_n pred x cpp).
Proof.
intros.
split.

*****
H0 : eq (tailCP cpt) cpp
H : eq (headCP cpt) x
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
forall _ : app pred cpt, app_1_n pred x cpp
+++++
intro H1.
-----
Lemma app_1_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), headCP cpt = x -> tailCP cpt = cpp -> (app pred cpt <-> app_1_n pred x cpp).
Proof.
intros.
split.
intro H1.

*****
H1 : app pred cpt
H0 : eq (tailCP cpt) cpp
H : eq (headCP cpt) x
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app_1_n pred x cpp
+++++
apply (app_app_1_n pred x cpp cpt H1 H H0).
-----
Lemma app_1_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), headCP cpt = x -> tailCP cpt = cpp -> (app pred cpt <-> app_1_n pred x cpp).
Proof.
intros.
split.

*****
H0 : eq (tailCP cpt) cpp
H : eq (headCP cpt) x
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
forall _ : app_1_n pred x cpp, app pred cpt
+++++
intro H1.
-----
Lemma app_1_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), headCP cpt = x -> tailCP cpt = cpp -> (app pred cpt <-> app_1_n pred x cpp).
Proof.
intros.
split.
intro H1.

*****
H1 : app_1_n pred x cpp
H0 : eq (tailCP cpt) cpp
H : eq (headCP cpt) x
cpt : cartesianPower T (S (S n))
cpp : cartesianPower T (S n)
x : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app pred cpt
+++++
apply (app_1_n_app pred x cpp cpt H1 H H0).
-----
Lemma app_1_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S n))), headCP cpt = x -> tailCP cpt = cpp -> (app pred cpt <-> app_1_n pred x cpp).
Proof.
intros.
split.

*****

*****

+++++
Qed.
-----
Definition app_2_n {T:Type} {n:nat} (pred : arity T (S (S n))) (x1 x2 : T) (cp : cartesianPower T n) : Prop.
-----
Definition app_2_n {T:Type} {n:nat} (pred : arity T (S (S n))) (x1 x2 : T) (cp : cartesianPower T n) : Prop.

*****
cp : cartesianPower T n
x1,x2 : T
pred : arity T (S (S n))
n : nat
T : Type
*****
Prop
+++++
Proof.
-----
Definition app_2_n {T:Type} {n:nat} (pred : arity T (S (S n))) (x1 x2 : T) (cp : cartesianPower T n) : Prop.
Proof.

*****
cp : cartesianPower T n
x1,x2 : T
pred : arity T (S (S n))
n : nat
T : Type
*****
Prop
+++++
exact (app (pred x1 x2) cp).
-----
Definition app_2_n {T:Type} {n:nat} (pred : arity T (S (S n))) (x1 x2 : T) (cp : cartesianPower T n) : Prop.
Proof.
exact (app (pred x1 x2) cp).

*****

*****

+++++
Defined.
-----
Lemma app_2_n_app {T:Type} {n:nat} :\n  forall (pred : arity T (S (S (S n)))) (x1 x2 : T)\n  (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))),\n  app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp ->\n  app pred cpt.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))) (_ : app_2_n pred x1 x2 cpp) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailCP (tailCP cpt)) cpp), app pred cpt
+++++
Proof.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))) (_ : app_2_n pred x1 x2 cpp) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailCP (tailCP cpt)) cpp), app pred cpt
+++++
intros.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.

*****
H2 : eq (tailCP (tailCP cpt)) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app pred cpt
+++++
induction n.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.

*****
H2 : eq (tailCP (tailCP cpt)) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : arity T (S (S (S O)))
T : Type
*****
app pred cpt
+++++
simpl in *.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), Prop
T : Type
*****
pred (fst cpt) (fst (snd cpt)) (snd (snd cpt))
+++++
rewrite H0.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), Prop
T : Type
*****
pred x1 (fst (snd cpt)) (snd (snd cpt))
+++++
rewrite H1.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.
rewrite H1.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), Prop
T : Type
*****
pred x1 x2 (snd (snd cpt))
+++++
rewrite H2.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.
rewrite H1.
rewrite H2.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), Prop
T : Type
*****
pred x1 x2 cpp
+++++
apply H.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.

*****
IHn : forall (pred : arity T (S (S (S n)))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app_2_n pred x1 x2 cpp)\n (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2)\n (_ : eq (tailCP (tailCP cpt)) cpp), app pred cpt
H2 : eq (tailCP (tailCP cpt)) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
app pred cpt
+++++
clear IHn.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.
clear IHn.

*****
H2 : eq (tailCP (tailCP cpt)) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
app pred cpt
+++++
simpl in *.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.
clear IHn.
simpl in *.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)) (fst (snd (snd cpt)))) (tailCP (snd (snd cpt)))
+++++
rewrite H0.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite H0.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred x1 (fst (snd cpt)) (fst (snd (snd cpt)))) (tailCP (snd (snd cpt)))
+++++
rewrite H1.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite H0.
rewrite H1.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred x1 x2 (fst (snd (snd cpt)))) (tailCP (snd (snd cpt)))
+++++
rewrite H2.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite H0.
rewrite H1.
rewrite H2.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred x1 x2 (fst cpp)) (tailCP cpp)
+++++
apply H.
-----
Lemma app_2_n_app {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app pred cpt.
Proof.
intros.
induction n.

*****

*****

+++++
Qed.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} :\n  forall (pred : arity T (S (S n))) (x1 x2 : T)\n  (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))),\n  app_2_n pred x1 x2 cpp -> headCP cpt = x1 ->\n  headCP (tailCP cpt) = x2 ->\n  tailDefaultCP (tailCP cpt) Default = cpp ->\n  app pred cpt.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))) (_ : app_2_n pred x1 x2 cpp) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp), app pred cpt
+++++
Proof.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))) (_ : app_2_n pred x1 x2 cpp) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp), app pred cpt
+++++
intros.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.

*****
H2 : eq (tailDefaultCP (tailCP cpt) Default) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S n))
cpp,Default : cartesianPower T n
x1,x2 : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app pred cpt
+++++
induction n.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.

*****
H2 : eq (tailDefaultCP (tailCP cpt) Default) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S O))
cpp,Default : cartesianPower T O
x1,x2 : T
pred : arity T (S (S O))
T : Type
*****
app pred cpt
+++++
simpl in *.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.

*****
H2 : eq Default cpp
H1 : eq (snd cpt) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S O))
cpp,Default : cartesianPower T O
x1,x2 : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred (fst cpt) (snd cpt)
+++++
rewrite H0.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.

*****
H2 : eq Default cpp
H1 : eq (snd cpt) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S O))
cpp,Default : cartesianPower T O
x1,x2 : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred x1 (snd cpt)
+++++
rewrite H1.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.
rewrite H1.

*****
H2 : eq Default cpp
H1 : eq (snd cpt) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S O))
cpp,Default : cartesianPower T O
x1,x2 : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
pred x1 x2
+++++
apply H.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.

*****
IHn : forall (pred : arity T (S (S n))) (cpp Default : cartesianPower T n)\n (cpt : cartesianPower T (S (S n))) (_ : app_2_n pred x1 x2 cpp)\n (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2)\n (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp), \napp pred cpt
H2 : eq (tailDefaultCP (tailCP cpt) Default) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app pred cpt
+++++
simpl in *.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.

*****
IHn : forall (pred : forall (_ : T) (_ : T), arity T n)\n (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n)))\n (_ : app_2_n pred x1 x2 cpp) (_ : eq (fst cpt) x1)\n (_ : eq (headCP (tailCP cpt)) x2)\n (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp),\nnat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred0 : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred0 cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred0 : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred0 (fst cp)) (tailCP cp)) n (pred (fst cpt)) \n (tailCP cpt)
H2 : eq (tailCP (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt))) (tailCP (snd cpt))
+++++
rewrite H0.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.

*****
IHn : forall (pred : forall (_ : T) (_ : T), arity T n)\n (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n)))\n (_ : app_2_n pred x1 x2 cpp) (_ : eq (fst cpt) x1)\n (_ : eq (headCP (tailCP cpt)) x2)\n (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp),\nnat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred0 : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred0 cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred0 : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred0 (fst cp)) (tailCP cp)) n (pred (fst cpt)) \n (tailCP cpt)
H2 : eq (tailCP (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred x1 (fst (snd cpt))) (tailCP (snd cpt))
+++++
rewrite H1.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.
rewrite H1.

*****
IHn : forall (pred : forall (_ : T) (_ : T), arity T n)\n (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n)))\n (_ : app_2_n pred x1 x2 cpp) (_ : eq (fst cpt) x1)\n (_ : eq (headCP (tailCP cpt)) x2)\n (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp),\nnat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred0 : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred0 cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred0 : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred0 (fst cp)) (tailCP cp)) n (pred (fst cpt)) \n (tailCP cpt)
H2 : eq (tailCP (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred x1 x2) (tailCP (snd cpt))
+++++
rewrite H2.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.
simpl in *.
rewrite H0.
rewrite H1.
rewrite H2.

*****
IHn : forall (pred : forall (_ : T) (_ : T), arity T n)\n (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n)))\n (_ : app_2_n pred x1 x2 cpp) (_ : eq (fst cpt) x1)\n (_ : eq (headCP (tailCP cpt)) x2)\n (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp),\nnat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred0 : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred0 cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred0 : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred0 (fst cp)) (tailCP cp)) n (pred (fst cpt)) \n (tailCP cpt)
H2 : eq (tailCP (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : app_2_n pred x1 x2 cpp
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
nat_rect (fun n : nat => forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) => pred cp) (fun (n : nat) (IHn : forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)), Prop) (pred : forall (_ : T) (_ : T), arity T n) (cp : cartesianPower T (S (S n))) => IHn (pred (fst cp)) (tailCP cp)) n (pred x1 x2) cpp
+++++
apply H.
-----
Lemma app_2_n_app_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app_2_n pred x1 x2 cpp -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app pred cpt.
Proof.
intros.
induction n.

*****

*****

+++++
Qed.
-----
Lemma app_app_2_n {T:Type} {n:nat} :\n  forall (pred : arity T (S (S (S n)))) (x1 x2 : T)\n  (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))),\n  app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp ->\n  app_2_n pred x1 x2 cpp.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))) (_ : app pred cpt) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailCP (tailCP cpt)) cpp), app_2_n pred x1 x2 cpp
+++++
Proof.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))) (_ : app pred cpt) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailCP (tailCP cpt)) cpp), app_2_n pred x1 x2 cpp
+++++
intros.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.

*****
H2 : eq (tailCP (tailCP cpt)) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
induction n.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.

*****
H2 : eq (tailCP (tailCP cpt)) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app pred cpt
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : arity T (S (S (S O)))
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
simpl in *.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
simpl in *.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : pred (fst cpt) (fst (snd cpt)) (snd (snd cpt))
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), Prop
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
rewrite <- H0.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : pred (fst cpt) (fst (snd cpt)) (snd (snd cpt))
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), Prop
T : Type
*****
app_2_n pred (fst cpt) x2 cpp
+++++
rewrite <- H1.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.
rewrite <- H1.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : pred (fst cpt) (fst (snd cpt)) (snd (snd cpt))
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), Prop
T : Type
*****
app_2_n pred (fst cpt) (fst (snd cpt)) cpp
+++++
rewrite <- H2.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.
rewrite <- H1.
rewrite <- H2.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : pred (fst cpt) (fst (snd cpt)) (snd (snd cpt))
cpt : cartesianPower T (S (S (S O)))
cpp : cartesianPower T (S O)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), Prop
T : Type
*****
app_2_n pred (fst cpt) (fst (snd cpt)) (snd (snd cpt))
+++++
apply H.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.

*****
IHn : forall (pred : arity T (S (S (S n)))) (cpp : cartesianPower T (S n))\n (cpt : cartesianPower T (S (S (S n)))) (_ : app pred cpt)\n (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2)\n (_ : eq (tailCP (tailCP cpt)) cpp), app_2_n pred x1 x2 cpp
H2 : eq (tailCP (tailCP cpt)) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app pred cpt
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
clear IHn.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.

*****
H2 : eq (tailCP (tailCP cpt)) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app pred cpt
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : arity T (S (S (S (S n))))
n : nat
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
simpl in *.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n\n (pred (fst cpt) (fst (snd cpt)) (fst (snd (snd cpt))))\n (tailCP (snd (snd cpt)))
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
rewrite <- H0.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite <- H0.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n\n (pred (fst cpt) (fst (snd cpt)) (fst (snd (snd cpt))))\n (tailCP (snd (snd cpt)))
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
app_2_n pred (fst cpt) x2 cpp
+++++
rewrite <- H1.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite <- H0.
rewrite <- H1.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n\n (pred (fst cpt) (fst (snd cpt)) (fst (snd (snd cpt))))\n (tailCP (snd (snd cpt)))
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
app_2_n pred (fst cpt) (fst (snd cpt)) cpp
+++++
rewrite <- H2.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite <- H0.
rewrite <- H1.
rewrite <- H2.

*****
H2 : eq (snd (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n\n (pred (fst cpt) (fst (snd cpt)) (fst (snd (snd cpt))))\n (tailCP (snd (snd cpt)))
cpt : cartesianPower T (S (S (S (S n))))
cpp : cartesianPower T (S (S n))
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
app_2_n pred (fst cpt) (fst (snd cpt)) (snd (snd cpt))
+++++
apply H.
-----
Lemma app_app_2_n {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.

*****

*****

+++++
Qed.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} :\n  forall (pred : arity T (S (S n))) (x1 x2 : T)\n  (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))),\n  app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp ->\n  app_2_n pred x1 x2 cpp.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))) (_ : app pred cpt) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp), app_2_n pred x1 x2 cpp
+++++
Proof.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))) (_ : app pred cpt) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp), app_2_n pred x1 x2 cpp
+++++
intros.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.

*****
H2 : eq (tailDefaultCP (tailCP cpt) Default) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app pred cpt
cpt : cartesianPower T (S (S n))
cpp,Default : cartesianPower T n
x1,x2 : T
pred : arity T (S (S n))
n : nat
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
induction n.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.

*****
H2 : eq (tailDefaultCP (tailCP cpt) Default) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app pred cpt
cpt : cartesianPower T (S (S O))
cpp,Default : cartesianPower T O
x1,x2 : T
pred : arity T (S (S O))
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
simpl in *.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
simpl in *.

*****
H2 : eq Default cpp
H1 : eq (snd cpt) x2
H0 : eq (fst cpt) x1
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp,Default : cartesianPower T O
x1,x2 : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
rewrite <- H0.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.

*****
H2 : eq Default cpp
H1 : eq (snd cpt) x2
H0 : eq (fst cpt) x1
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp,Default : cartesianPower T O
x1,x2 : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
app_2_n pred (fst cpt) x2 cpp
+++++
rewrite <- H1.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.
rewrite <- H1.

*****
H2 : eq Default cpp
H1 : eq (snd cpt) x2
H0 : eq (fst cpt) x1
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp,Default : cartesianPower T O
x1,x2 : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
app_2_n pred (fst cpt) (snd cpt) cpp
+++++
rewrite <- H2.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
simpl in *.
rewrite <- H0.
rewrite <- H1.
rewrite <- H2.

*****
H2 : eq Default cpp
H1 : eq (snd cpt) x2
H0 : eq (fst cpt) x1
H : pred (fst cpt) (snd cpt)
cpt : cartesianPower T (S (S O))
cpp,Default : cartesianPower T O
x1,x2 : T
pred : forall (_ : T) (_ : T), Prop
T : Type
*****
app_2_n pred (fst cpt) (snd cpt) Default
+++++
apply H.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.

*****
IHn : forall (pred : arity T (S (S n))) (cpp Default : cartesianPower T n)\n (cpt : cartesianPower T (S (S n))) (_ : app pred cpt)\n (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2)\n (_ : eq (tailDefaultCP (tailCP cpt) Default) cpp),\napp_2_n pred x1 x2 cpp
H2 : eq (tailDefaultCP (tailCP cpt) Default) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
clear IHn.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.

*****
H2 : eq (tailDefaultCP (tailCP cpt) Default) cpp
H1 : eq (headCP (tailCP cpt)) x2
H0 : eq (headCP cpt) x1
H : app pred cpt
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
simpl in *.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.

*****
H2 : eq (tailCP (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)))\n (tailCP (snd cpt))
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
rewrite <- H0.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite <- H0.

*****
H2 : eq (tailCP (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)))\n (tailCP (snd cpt))
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
app_2_n pred (fst cpt) x2 cpp
+++++
rewrite <- H1.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite <- H0.
rewrite <- H1.

*****
H2 : eq (tailCP (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)))\n (tailCP (snd cpt))
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
app_2_n pred (fst cpt) (fst (snd cpt)) cpp
+++++
rewrite <- H2.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.
clear IHn.
simpl in *.
rewrite <- H0.
rewrite <- H1.
rewrite <- H2.

*****
H2 : eq (tailCP (snd cpt)) cpp
H1 : eq (fst (snd cpt)) x2
H0 : eq (fst cpt) x1
H : nat_rect\n (fun n : nat =>\n forall (_ : forall _ : T, arity T n) (_ : cartesianPower T (S n)),\n Prop)\n (fun (pred : forall _ : T, Prop) (cp : cartesianPower T (S O)) =>\n pred cp)\n (fun (n : nat)\n (IHn : forall (_ : forall _ : T, arity T n)\n (_ : cartesianPower T (S n)), Prop)\n (pred : forall (_ : T) (_ : T), arity T n)\n (cp : cartesianPower T (S (S n))) =>\n IHn (pred (fst cp)) (tailCP cp)) n (pred (fst cpt) (fst (snd cpt)))\n (tailCP (snd cpt))
cpt : cartesianPower T (S (S (S n)))
cpp,Default : cartesianPower T (S n)
x1,x2 : T
pred : forall (_ : T) (_ : T) (_ : T), arity T n
n : nat
T : Type
*****
app_2_n pred (fst cpt) (fst (snd cpt)) (tailCP (snd cpt))
+++++
apply H.
-----
Lemma app_app_2_n_default {T:Type} {n:nat} : forall (pred : arity T (S (S n))) (x1 x2 : T) (cpp Default : cartesianPower T n) (cpt : cartesianPower T (S (S n))), app pred cpt -> headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailDefaultCP (tailCP cpt) Default = cpp -> app_2_n pred x1 x2 cpp.
Proof.
intros.
induction n.

*****

*****

+++++
Qed.
-----
Lemma app_2_n_app_eq {T:Type} {n:nat} :\n  forall (pred : arity T (S (S (S n)))) (x1 x2 : T)\n  (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))),\n  headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp ->\n  (app pred cpt <-> app_2_n pred x1 x2 cpp).
-----
Lemma app_2_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> (app pred cpt <-> app_2_n pred x1 x2 cpp).

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailCP (tailCP cpt)) cpp), iff (app pred cpt) (app_2_n pred x1 x2 cpp)
+++++
Proof.
-----
Lemma app_2_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> (app pred cpt <-> app_2_n pred x1 x2 cpp).
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))) (_ : eq (headCP cpt) x1) (_ : eq (headCP (tailCP cpt)) x2) (_ : eq (tailCP (tailCP cpt)) cpp), iff (app pred cpt) (app_2_n pred x1 x2 cpp)
+++++
intros.
-----
Lemma app_2_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> (app pred cpt <-> app_2_n pred x1 x2 cpp).
Proof.
intros.

*****
H1 : eq (tailCP (tailCP cpt)) cpp
H0 : eq (headCP (tailCP cpt)) x2
H : eq (headCP cpt) x1
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
iff (app pred cpt) (app_2_n pred x1 x2 cpp)
+++++
split.
-----
Lemma app_2_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> (app pred cpt <-> app_2_n pred x1 x2 cpp).
Proof.
intros.
split.

*****
H1 : eq (tailCP (tailCP cpt)) cpp
H0 : eq (headCP (tailCP cpt)) x2
H : eq (headCP cpt) x1
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
forall _ : app pred cpt, app_2_n pred x1 x2 cpp
+++++
intro H2.
-----
Lemma app_2_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> (app pred cpt <-> app_2_n pred x1 x2 cpp).
Proof.
intros.
split.
intro H2.

*****
H2 : app pred cpt
H1 : eq (tailCP (tailCP cpt)) cpp
H0 : eq (headCP (tailCP cpt)) x2
H : eq (headCP cpt) x1
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app_2_n pred x1 x2 cpp
+++++
apply (app_app_2_n pred x1 x2 cpp cpt H2 H H0 H1).
-----
Lemma app_2_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> (app pred cpt <-> app_2_n pred x1 x2 cpp).
Proof.
intros.
split.

*****
H1 : eq (tailCP (tailCP cpt)) cpp
H0 : eq (headCP (tailCP cpt)) x2
H : eq (headCP cpt) x1
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
forall _ : app_2_n pred x1 x2 cpp, app pred cpt
+++++
intro H2.
-----
Lemma app_2_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> (app pred cpt <-> app_2_n pred x1 x2 cpp).
Proof.
intros.
split.
intro H2.

*****
H2 : app_2_n pred x1 x2 cpp
H1 : eq (tailCP (tailCP cpt)) cpp
H0 : eq (headCP (tailCP cpt)) x2
H : eq (headCP cpt) x1
cpt : cartesianPower T (S (S (S n)))
cpp : cartesianPower T (S n)
x1,x2 : T
pred : arity T (S (S (S n)))
n : nat
T : Type
*****
app pred cpt
+++++
apply (app_2_n_app pred x1 x2 cpp cpt H2 H H0 H1).
-----
Lemma app_2_n_app_eq {T:Type} {n:nat} : forall (pred : arity T (S (S (S n)))) (x1 x2 : T) (cpp : cartesianPower T (S n)) (cpt : cartesianPower T (S (S (S n)))), headCP cpt = x1 -> headCP (tailCP cpt) = x2 -> tailCP (tailCP cpt) = cpp -> (app pred cpt <-> app_2_n pred x1 x2 cpp).
Proof.
intros.
split.

*****

*****

+++++
Qed.
-----
Lemma PermOKAux {T : Type} {m : nat} :\n  forall (appPred : (cartesianPower T (S (S m))) -> Prop) n,\n  (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) ->\n  (forall (X : cartesianPower T (S (S m))),\n          appPred X -> appPred (circPermNCP n X)).
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).

*****
m : nat
T : Type
*****
forall (appPred : forall _ : cartesianPower T (S (S m)), Prop) (n : nat) (_ : forall (A : T) (X : cartesianPower T (S m)) (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)) (X : cartesianPower T (S (S m))) (_ : appPred X), appPred (circPermNCP n X)
+++++
Proof.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.

*****
m : nat
T : Type
*****
forall (appPred : forall _ : cartesianPower T (S (S m)), Prop) (n : nat) (_ : forall (A : T) (X : cartesianPower T (S m)) (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)) (X : cartesianPower T (S (S m))) (_ : appPred X), appPred (circPermNCP n X)
+++++
intros appPred n HPerm.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.

*****
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
forall (X : cartesianPower T (S (S m))) (_ : appPred X), appPred (circPermNCP n X)
+++++
induction n.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.

*****
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
forall (X : cartesianPower T (S (S m))) (_ : appPred X), appPred (circPermNCP O X)
+++++
simpl.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
simpl.

*****
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
forall (X : cartesianPower T (S (S m))) (_ : appPred X), appPred X
+++++
auto.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.

*****
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
forall (X : cartesianPower T (S (S m))) (_ : appPred X), appPred (circPermNCP (S n) X)
+++++
intros X HappPred.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
intros X HappPred.

*****
HappPred : appPred X
X : cartesianPower T (S (S m))
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
appPred (circPermNCP (S n) X)
+++++
assert (H : appPred (circPermNCP n X)).
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
intros X HappPred.
assert (H : appPred (circPermNCP n X)).

*****
HappPred : appPred X
X : cartesianPower T (S (S m))
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
appPred (circPermNCP n X)
+++++
apply IHn.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
intros X HappPred.
assert (H : appPred (circPermNCP n X)).
apply IHn.

*****
HappPred : appPred X
X : cartesianPower T (S (S m))
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
appPred X
+++++
assumption.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
intros X HappPred.
assert (H : appPred (circPermNCP n X)).

*****
H : appPred (circPermNCP n X)
HappPred : appPred X
X : cartesianPower T (S (S m))
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
appPred (circPermNCP (S n) X)
+++++
idtac.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
intros X HappPred.
assert (H : appPred (circPermNCP n X)).
idtac.

*****
H : appPred (circPermNCP n X)
HappPred : appPred X
X : cartesianPower T (S (S m))
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
appPred (circPermNCP (S n) X)
+++++
rewrite consHeadCPOK in H.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
intros X HappPred.
assert (H : appPred (circPermNCP n X)).
idtac.
rewrite consHeadCPOK in H.

*****
H : appPred\n (consHeadCP (headCP (circPermNCP n X)) (tailCP (circPermNCP n X)))
HappPred : appPred X
X : cartesianPower T (S (S m))
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
appPred (circPermNCP (S n) X)
+++++
apply HPerm in H.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
intros X HappPred.
assert (H : appPred (circPermNCP n X)).
idtac.
rewrite consHeadCPOK in H.
apply HPerm in H.

*****
H : appPred\n (consTailCP (tailCP (circPermNCP n X)) (headCP (circPermNCP n X)))
HappPred : appPred X
X : cartesianPower T (S (S m))
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
appPred (circPermNCP (S n) X)
+++++
rewrite circPermNCPOK.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
intros X HappPred.
assert (H : appPred (circPermNCP n X)).
idtac.
rewrite consHeadCPOK in H.
apply HPerm in H.
rewrite circPermNCPOK.

*****
H : appPred\n (consTailCP (tailCP (circPermNCP n X)) (headCP (circPermNCP n X)))
HappPred : appPred X
X : cartesianPower T (S (S m))
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
appPred (circPermNCP n (consTailCP (tailCP X) (headCP X)))
+++++
rewrite <- circPermNConsTlOK.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.
intros X HappPred.
assert (H : appPred (circPermNCP n X)).
idtac.
rewrite consHeadCPOK in H.
apply HPerm in H.
rewrite circPermNCPOK.
rewrite <- circPermNConsTlOK.

*****
H : appPred\n (consTailCP (tailCP (circPermNCP n X)) (headCP (circPermNCP n X)))
HappPred : appPred X
X : cartesianPower T (S (S m))
IHn : forall (X : cartesianPower T (S (S m))) (_ : appPred X),\nappPred (circPermNCP n X)
HPerm : forall (A : T) (X : cartesianPower T (S m))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
n : nat
appPred : forall _ : cartesianPower T (S (S m)), Prop
m : nat
T : Type
*****
appPred (consTailCP (tailCP (circPermNCP n X)) (headCP (circPermNCP n X)))
+++++
assumption.
-----
Lemma PermOKAux {T : Type} {m : nat} : forall (appPred : (cartesianPower T (S (S m))) -> Prop) n, (forall (A : T) (X : cartesianPower T (S m)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (X : cartesianPower T (S (S m))), appPred X -> appPred (circPermNCP n X)).
Proof.
intros appPred n HPerm.
induction n.

*****

*****

+++++
Qed.
-----
Lemma PermOK {T : Type} {n : nat} :\n  forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop),\n  (forall (A : T) (X : cartesianPower T (S n)),\n    appPred (consHeadCP A X) -> appPred (consTailCP X A)) ->\n  (forall (A B : T) (X : cartesianPower T n),\n    appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) ->\n  appPred cp1 ->\n  Permutation.Permutation (CPToList cp1) (CPToList cp2) ->\n  appPred cp2.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.

*****
n : nat
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : forall _ : cartesianPower T (S (S n)), Prop) (_ : forall (A : T) (X : cartesianPower T (S n)) (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)) (_ : forall (A B : T) (X : cartesianPower T n) (_ : appPred (consHeadCP A (consHeadCP B X))), appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1) (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)), appPred cp2
+++++
Proof.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.

*****
n : nat
T : Type
*****
forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : forall _ : cartesianPower T (S (S n)), Prop) (_ : forall (A : T) (X : cartesianPower T (S n)) (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)) (_ : forall (A B : T) (X : cartesianPower T n) (_ : appPred (consHeadCP A (consHeadCP B X))), appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1) (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)), appPred cp2
+++++
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.

*****
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T O)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S O)), Prop
cp1,cp2 : cartesianPower T (S (S O))
T : Type
*****
appPred cp2
+++++
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.

*****
HPerm : Permutation.Permutation (CPToList (pair (fst cp1) (snd cp1)))\n (CPToList cp2)
Hpred : appPred (pair (fst cp1) (snd cp1))
pred_perm_2 : forall (A B : T) (X : cartesianPower T O)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S O)), Prop
cp1,cp2 : cartesianPower T (S (S O))
T : Type
*****
appPred cp2
+++++
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.

*****
HPerm : Permutation.Permutation (CPToList (pair (fst cp1) (snd cp1)))\n (CPToList (pair (fst cp2) (snd cp2)))
Hpred : appPred (pair (fst cp1) (snd cp1))
pred_perm_2 : forall (A B : T) (X : cartesianPower T O)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S O)), Prop
cp1,cp2 : cartesianPower T (S (S O))
T : Type
*****
appPred (pair (fst cp2) (snd cp2))
+++++
simpl in *.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.

*****
HPerm : Permutation.Permutation (cons (fst cp1) (cons (snd cp1) nil))\n (cons (fst cp2) (cons (snd cp2) nil))
Hpred : appPred (pair (fst cp1) (snd cp1))
pred_perm_2 : forall (A B : T) (_ : cartesianPower T O) (_ : appPred (pair A B)),\nappPred (pair B A)
pred_perm_1 : forall (A : T) (X : cartesianPower T (S O)) (_ : appPred (pair A X)),\nappPred (pair X A)
appPred : forall _ : cartesianPower T (S (S O)), Prop
cp1,cp2 : cartesianPower T (S (S O))
T : Type
*****
appPred (pair (fst cp2) (snd cp2))
+++++
apply Permutation.Permutation_length_2 in HPerm.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.

*****
HPerm : or (and (eq (fst cp1) (fst cp2)) (eq (snd cp1) (snd cp2)))\n (and (eq (fst cp1) (snd cp2)) (eq (snd cp1) (fst cp2)))
Hpred : appPred (pair (fst cp1) (snd cp1))
pred_perm_2 : forall (A B : T) (_ : cartesianPower T O) (_ : appPred (pair A B)),\nappPred (pair B A)
pred_perm_1 : forall (A : T) (X : cartesianPower T (S O)) (_ : appPred (pair A X)),\nappPred (pair X A)
appPred : forall _ : cartesianPower T (S (S O)), Prop
cp1,cp2 : cartesianPower T (S (S O))
T : Type
*****
appPred (pair (fst cp2) (snd cp2))
+++++
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.

*****
HEq2 : eq (snd cp1) (snd cp2)
HEq1 : eq (fst cp1) (fst cp2)
Hpred : appPred (pair (fst cp1) (snd cp1))
pred_perm_2 : forall (A B : T) (_ : cartesianPower T O) (_ : appPred (pair A B)),\nappPred (pair B A)
pred_perm_1 : forall (A : T) (X : cartesianPower T (S O)) (_ : appPred (pair A X)),\nappPred (pair X A)
appPred : forall _ : cartesianPower T (S (S O)), Prop
cp1,cp2 : cartesianPower T (S (S O))
T : Type
*****
appPred (pair (fst cp1) (snd cp1))
+++++
assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.

*****
HEq2 : eq (snd cp1) (fst cp2)
HEq1 : eq (fst cp1) (snd cp2)
Hpred : appPred (pair (fst cp1) (snd cp1))
pred_perm_2 : forall (A B : T) (_ : cartesianPower T O) (_ : appPred (pair A B)),\nappPred (pair B A)
pred_perm_1 : forall (A : T) (X : cartesianPower T (S O)) (_ : appPred (pair A X)),\nappPred (pair X A)
appPred : forall _ : cartesianPower T (S (S O)), Prop
cp1,cp2 : cartesianPower T (S (S O))
T : Type
*****
appPred (pair (snd cp1) (fst cp1))
+++++
apply pred_perm_1; assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.

*****
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp1,cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred cp2
+++++
rewrite consTailCPOK.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.

*****
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp1,cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp2))
+++++
assert (H' := lastCPIn cp2).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).

*****
H' : InCP (lastCP cp2) cp2
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp1,cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp2))
+++++
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.

*****
H : InCP (lastCP cp2) cp1
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp1,cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp2))
+++++
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.

*****
H' : ex\n (fun id : nat =>\n and (ge id (S O))\n (and (le id (S (S (S n))))\n (eq (lastCP cp2) (nthCP id cp1 (headCP cp2)))))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp1,cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp2))
+++++
destruct H' as [id [Hge [Hle Hnth]]].
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].

*****
Hnth : eq (lastCP cp2) (nthCP id cp1 (headCP cp2))
Hle : le id (S (S (S n)))
Hge : ge id (S O)
id : nat
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp1,cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp2))
+++++
assert (H : exists cp, appPred cp /\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\ lastCP cp = lastCP cp2).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).

*****
Hnth : eq (lastCP cp2) (nthCP id cp1 (headCP cp2))
Hle : le id (S (S (S n)))
Hge : ge id (S O)
id : nat
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp1,cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.

*****
Hnth : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))
Hle : le (S id) (S (S (S n)))
Hge : ge (S id) (S O)
id : nat
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp1,cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.

*****
Hnth : eq (lastCP cp2) (nthCP (S O) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
exists (consTailCP (tailCP cp1) (headCP cp1)).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).

*****
Hnth : eq (lastCP cp2) (nthCP (S O) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
and (appPred (consTailCP (tailCP cp1) (headCP cp1))) (and (Permutation.Permutation (CPToList cp2) (CPToList (consTailCP (tailCP cp1) (headCP cp1)))) (eq (lastCP (consTailCP (tailCP cp1) (headCP cp1))) (lastCP cp2)))
+++++
split.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.

*****
Hnth : eq (lastCP cp2) (nthCP (S O) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (tailCP cp1) (headCP cp1))
+++++
apply pred_perm_1.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.

*****
Hnth : eq (lastCP cp2) (nthCP (S O) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consHeadCP (headCP cp1) (tailCP cp1))
+++++
rewrite <- consHeadCPOK.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.

*****
Hnth : eq (lastCP cp2) (nthCP (S O) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred cp1
+++++
assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.

*****
Hnth : eq (lastCP cp2) (nthCP (S O) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
and (Permutation.Permutation (CPToList cp2) (CPToList (consTailCP (tailCP cp1) (headCP cp1)))) (eq (lastCP (consTailCP (tailCP cp1) (headCP cp1))) (lastCP cp2))
+++++
split.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.

*****
Hnth : eq (lastCP cp2) (nthCP (S O) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
Permutation.Permutation (CPToList cp2) (CPToList (consTailCP (tailCP cp1) (headCP cp1)))
+++++
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).

*****
Hnth : eq (lastCP cp2) (nthCP (S O) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
Permutation.Permutation (CPToList cp2) (CPToList cp1)
+++++
apply Permutation.Permutation_sym; assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.

*****
Hnth : eq (lastCP cp2) (nthCP (S O) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
eq (lastCP (consTailCP (tailCP cp1) (headCP cp1))) (lastCP cp2)
+++++
apply nthCircPerm1 in Hnth.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.

*****
Hnth : eq (lastCP cp2)\n (nthCP (S (S (S n))) (consTailCP (tailCP cp1) (headCP cp1))\n (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
eq (lastCP (consTailCP (tailCP cp1) (headCP cp1))) (lastCP cp2)
+++++
rewrite Hnth.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.

*****
Hnth : eq (lastCP cp2)\n (nthCP (S (S (S n))) (consTailCP (tailCP cp1) (headCP cp1))\n (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
Hle : le (S O) (S (S (S n)))
Hge : ge (S O) (S O)
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
eq (lastCP (consTailCP (tailCP cp1) (headCP cp1))) (nthCP (S (S (S n))) (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2))
+++++
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.

*****
Hnth : eq (lastCP cp2) (nthCP (S (S id)) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S (S id)) (S (S (S n)))
Hge : ge (S (S id)) (S O)
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
assert (H := Hle).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).

*****
H : le (S (S id)) (S (S (S n)))
Hnth : eq (lastCP cp2) (nthCP (S (S id)) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S (S id)) (S (S (S n)))
Hge : ge (S (S id)) (S O)
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
do 2 (apply Le.le_S_n in H).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).

*****
H : le id (S n)
Hnth : eq (lastCP cp2) (nthCP (S (S id)) cp1 (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S (S id)) (S (S (S n)))
Hge : ge (S (S id)) (S O)
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
apply nthCircPerm2 in Hnth; try assumption; clear H.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.

*****
Hnth : eq (lastCP cp2)\n (nthCP (S id) (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S (S id)) (S (S (S n)))
Hge : ge (S (S id)) (S O)
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
apply Le.le_Sn_le in Hle.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.

*****
Hnth : eq (lastCP cp2)\n (nthCP (S id) (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S id) (S (S (S n)))
Hge : ge (S (S id)) (S O)
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.

*****
Hge : ge (S id) (S O)
Hnth : eq (lastCP cp2)\n (nthCP (S id) (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S id) (S (S (S n)))
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.

*****
Hpred : appPred (consTailCP (tailCP cp1) (headCP cp1))
Hge : ge (S id) (S O)
Hnth : eq (lastCP cp2)\n (nthCP (S id) (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S id) (S (S (S n)))
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.

*****
H : Permutation.Permutation\n (CPToList (consTailCP (tailCP cp1) (headCP cp1))) \n (CPToList cp1)
Hpred : appPred (consTailCP (tailCP cp1) (headCP cp1))
Hge : ge (S id) (S O)
Hnth : eq (lastCP cp2)\n (nthCP (S id) (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2))
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S id) (S (S (S n)))
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.

*****
HPerm : Permutation.Permutation\n (CPToList (consTailCP (tailCP cp1) (headCP cp1))) \n (CPToList cp2)
H : Permutation.Permutation\n (CPToList (consTailCP (tailCP cp1) (headCP cp1))) \n (CPToList cp1)
Hpred : appPred (consTailCP (tailCP cp1) (headCP cp1))
Hge : ge (S id) (S O)
Hnth : eq (lastCP cp2)\n (nthCP (S id) (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2))
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S id) (S (S (S n)))
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).

*****
H' : ex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
HPerm : Permutation.Permutation\n (CPToList (consTailCP (tailCP cp1) (headCP cp1))) \n (CPToList cp2)
H : Permutation.Permutation\n (CPToList (consTailCP (tailCP cp1) (headCP cp1))) \n (CPToList cp1)
Hpred : appPred (consTailCP (tailCP cp1) (headCP cp1))
Hge : ge (S id) (S O)
Hnth : eq (lastCP cp2)\n (nthCP (S id) (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2))
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S id) (S (S (S n)))
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
ex (fun cp : cartesianPower T (S (S (S n))) => and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2))))
+++++
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.

*****
Hlastcp : eq (lastCP cp) (lastCP cp2)
HPermcp : Permutation.Permutation (CPToList cp2) (CPToList cp)
Hpredcp : appPred cp
cp : cartesianPower T (S (S (S n)))
HPerm : Permutation.Permutation\n (CPToList (consTailCP (tailCP cp1) (headCP cp1))) \n (CPToList cp2)
H : Permutation.Permutation\n (CPToList (consTailCP (tailCP cp1) (headCP cp1))) \n (CPToList cp1)
Hpred : appPred (consTailCP (tailCP cp1) (headCP cp1))
Hge : ge (S id) (S O)
Hnth : eq (lastCP cp2)\n (nthCP (S id) (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2))
cp1 : cartesianPower T (S (S (S n)))
IHid : forall (_ : ge (S id) (S O)) (_ : le (S id) (S (S (S n))))\n (cp1 : cartesianPower T (S (S (S n)))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2))\n (_ : eq (lastCP cp2) (nthCP (S id) cp1 (headCP cp2))),\nex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hle : le (S id) (S (S (S n)))
id : nat
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
and (appPred cp) (and (Permutation.Permutation (CPToList cp2) (CPToList cp)) (eq (lastCP cp) (lastCP cp2)))
+++++
do 2 (split; try assumption).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).

*****
H : ex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
Hnth : eq (lastCP cp2) (nthCP id cp1 (headCP cp2))
Hle : le id (S (S (S n)))
Hge : ge id (S O)
id : nat
HPerm : Permutation.Permutation (CPToList cp1) (CPToList cp2)
Hpred : appPred cp1
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp1,cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp2))
+++++
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.

*****
H : ex\n (fun cp : cartesianPower T (S (S (S n))) =>\n and (appPred cp)\n (and (Permutation.Permutation (CPToList cp2) (CPToList cp))\n (eq (lastCP cp) (lastCP cp2))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp2))
+++++
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.

*****
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList cp2) (CPToList cp)
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.

*****
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList cp2)\n (CPToList (consTailCP (allButLastCP cp) (lastCP cp)))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.

*****
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation\n (CPToList (consTailCP (allButLastCP cp2) (lastCP cp2)))\n (CPToList (consTailCP (allButLastCP cp) (lastCP cp)))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
do 2 (rewrite consTailOK in HPerm).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).

*****
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation\n (Datatypes.app (CPToList (allButLastCP cp2)) (cons (lastCP cp2) nil))\n (Datatypes.app (CPToList (allButLastCP cp)) (cons (lastCP cp) nil))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
rewrite Hlast in HPerm.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.

*****
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation\n (Datatypes.app (CPToList (allButLastCP cp2)) (cons (lastCP cp2) nil))\n (Datatypes.app (CPToList (allButLastCP cp)) (cons (lastCP cp2) nil))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
apply Permutation.Permutation_app_inv_r in HPerm.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.

*****
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
assert (ablcp := allButLastCP cp).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).

*****
ablcp : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
assert (ablcp2 := allButLastCP cp2).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).

*****
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).

*****
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).

*****
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
forall (A : T) (X : cartesianPower T (S n)) (_ : fixLastCP appPred (lastCP cp) (consHeadCP A X)), fixLastCP appPred (lastCP cp) (consTailCP X A)
+++++
unfold fixLastCP; intros A X HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.

*****
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S n)
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
induction n.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.

*****
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S O)
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S O)))) (_ : appPred X),\nappPred (circPermNCP (S O) X)
ablcp,ablcp2 : cartesianPower T (S (S O))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S O)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S O))), Prop
cp2 : cartesianPower T (S (S (S O)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S O)))\n (appPred : forall _ : cartesianPower T (S (S O)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T O)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.

*****
HappPred : appPred (pair A (pair X (snd (snd cp))))
X : cartesianPower T (S O)
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S O)))) (_ : appPred X),\nappPred (circPermNCP (S O) X)
ablcp,ablcp2 : cartesianPower T (S (S O))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S O)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S O))), Prop
cp2 : cartesianPower T (S (S (S O)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S O)))\n (appPred : forall _ : cartesianPower T (S (S O)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T O)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
apply pred_perm_2.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.

*****
HappPred : appPred (pair A (pair X (snd (snd cp))))
X : cartesianPower T (S O)
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S O)))) (_ : appPred X),\nappPred (circPermNCP (S O) X)
ablcp,ablcp2 : cartesianPower T (S (S O))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S O)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S O))), Prop
cp2 : cartesianPower T (S (S (S O)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S O)))\n (appPred : forall _ : cartesianPower T (S (S O)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T O)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (consHeadCP (tailCP (consTailCP X A)) (consHeadCP (headCP (consTailCP X A)) (let (_, y) := tailCP cp in y)))
+++++
simpl.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.

*****
HappPred : appPred (pair A (pair X (snd (snd cp))))
X : cartesianPower T (S O)
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S O)))) (_ : appPred X),\nappPred (circPermNCP (S O) X)
ablcp,ablcp2 : cartesianPower T (S (S O))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S O)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S O))), Prop
cp2 : cartesianPower T (S (S (S O)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S O)))\n (appPred : forall _ : cartesianPower T (S (S O)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T O)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair A (pair X (let (_, y) := snd cp in y)))
+++++
assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.

*****
IHn0 : forall\n (_ : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)),\n appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X)))\n (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\n appPred cp2) (cp2 : cartesianPower T (S (S (S n))))\n (appPred : forall _ : cartesianPower T (S (S (S n))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X)))\n (cp : cartesianPower T (S (S (S n)))) (_ : appPred cp)\n (_ : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp)))\n (_ : eq (lastCP cp) (lastCP cp2)) (_ : cartesianPower T (S (S n)))\n (_ : cartesianPower T (S (S n)))\n (_ : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\n appPred (circPermNCP (S n) X)) (X : cartesianPower T (S n))\n (_ : appPred (consTailCP (consHeadCP A X) (lastCP cp))),\nappPred (consTailCP (consTailCP X A) (lastCP cp))
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S n))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S n))))) (_ : appPred X),\nappPred (circPermNCP (S (S n)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S n)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S n))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S n)))), Prop
cp2 : cartesianPower T (S (S (S (S n))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S n))))\n (appPred : forall _ : cartesianPower T (S (S (S n))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
clear IHn0.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.

*****
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S n))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S n))))) (_ : appPred X),\nappPred (circPermNCP (S (S n)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S n)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S n))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S n)))), Prop
cp2 : cartesianPower T (S (S (S (S n))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S n))))\n (appPred : forall _ : cartesianPower T (S (S (S n))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
induction n.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.

*****
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
simpl.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.

*****
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
+++++
simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.

*****
HappPred : appPred (pair A (pair (fst X) (pair (snd X) (snd (snd (snd cp))))))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
+++++
simpl in pred_perm_1.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.

*****
HappPred : appPred (pair A (pair (fst X) (pair (snd X) (snd (snd (snd cp))))))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A X)),\nappPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) A)))
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
+++++
simpl in pred_perm_2.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.

*****
HappPred : appPred (pair A (pair (fst X) (pair (snd X) (snd (snd (snd cp))))))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A X)),\nappPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) A)))
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
+++++
apply pred_perm_2 in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.

*****
HappPred : appPred (pair (fst X) (pair A (pair (snd X) (snd (snd (snd cp))))))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A X)),\nappPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) A)))
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
+++++
apply pred_perm_1 in HappPred; simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.

*****
HappPred : appPred (pair A (pair (snd X) (pair (snd (snd (snd cp))) (fst X))))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A X)),\nappPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) A)))
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
+++++
apply pred_perm_2 in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.

*****
HappPred : appPred (pair (snd X) (pair A (pair (snd (snd (snd cp))) (fst X))))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A X)),\nappPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) A)))
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
+++++
apply pred_perm_1 in HappPred; simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.

*****
HappPred : appPred (pair A (pair (snd (snd (snd cp))) (pair (fst X) (snd X))))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A X)),\nappPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) A)))
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
+++++
apply pred_perm_3 in HappPred; simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.

*****
HappPred : appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
X : cartesianPower T (S (S O))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S O))))) (_ : appPred X),\nappPred (circPermNCP (S (S O)) X)
ablcp,ablcp2 : cartesianPower T (S (S (S O)))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S O))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A X)),\nappPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) A)))
appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop
cp2 : cartesianPower T (S (S (S (S O))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S O))))\n (appPred : forall _ : cartesianPower T (S (S (S O))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S O))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (snd X) (pair A (snd (snd (snd cp))))))
+++++
assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.

*****
IHn0 : forall\n (_ : forall (cp1 cp2 : cartesianPower T (S (S (S n))))\n (appPred : forall _ : cartesianPower T (S (S (S n))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)),\n appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X)))\n (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\n appPred cp2) (cp2 : cartesianPower T (S (S (S (S n)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S n)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X)))\n (cp : cartesianPower T (S (S (S (S n))))) (_ : appPred cp)\n (_ : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp)))\n (_ : eq (lastCP cp) (lastCP cp2))\n (_ : cartesianPower T (S (S (S n))))\n (_ : cartesianPower T (S (S (S n))))\n (_ : forall (X : cartesianPower T (S (S (S (S n))))) (_ : appPred X),\n appPred (circPermNCP (S (S n)) X))\n (X : cartesianPower T (S (S n)))\n (_ : appPred (consTailCP (consHeadCP A X) (lastCP cp))),\nappPred (consTailCP (consTailCP X A) (lastCP cp))
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S (S n)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S n)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S n))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S n))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S n)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop
cp2 : cartesianPower T (S (S (S (S (S n)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S n)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S n)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
clear IHn0.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.

*****
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S (S n)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S n)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S n))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S n))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S n)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop
cp2 : cartesianPower T (S (S (S (S (S n)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S n)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S n)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
induction n.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.

*****
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
simpl.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.

*****
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.

*****
HappPred : appPred\n (pair A\n (pair (fst X)\n (pair (fst (snd X))\n (pair (snd (snd X)) (snd (snd (snd (snd cp))))))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
simpl in pred_perm_1.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.

*****
HappPred : appPred\n (pair A\n (pair (fst X)\n (pair (fst (snd X))\n (pair (snd (snd X)) (snd (snd (snd (snd cp))))))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
simpl in pred_perm_2.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.

*****
HappPred : appPred\n (pair A\n (pair (fst X)\n (pair (fst (snd X))\n (pair (snd (snd X)) (snd (snd (snd (snd cp))))))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
apply pred_perm_2 in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.

*****
HappPred : appPred\n (pair (fst X)\n (pair A\n (pair (fst (snd X))\n (pair (snd (snd X)) (snd (snd (snd (snd cp))))))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
apply pred_perm_1 in HappPred; simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.

*****
HappPred : appPred\n (pair A\n (pair (fst (snd X))\n (pair (snd (snd X)) (pair (snd (snd (snd (snd cp)))) (fst X)))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
apply pred_perm_2 in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.

*****
HappPred : appPred\n (pair (fst (snd X))\n (pair A\n (pair (snd (snd X)) (pair (snd (snd (snd (snd cp)))) (fst X)))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
apply pred_perm_1 in HappPred; simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.

*****
HappPred : appPred\n (pair A\n (pair (snd (snd X))\n (pair (snd (snd (snd (snd cp)))) (pair (fst X) (fst (snd X))))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
apply pred_perm_2 in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.

*****
HappPred : appPred\n (pair (snd (snd X))\n (pair A\n (pair (snd (snd (snd (snd cp)))) (pair (fst X) (fst (snd X))))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
apply pred_perm_1 in HappPred; simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.

*****
HappPred : appPred\n (pair A\n (pair (snd (snd (snd (snd cp))))\n (pair (fst X) (pair (fst (snd X)) (snd (snd X))))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
apply pred_perm_1 in HappPred; simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.

*****
HappPred : appPred\n (pair (snd (snd (snd (snd cp))))\n (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) A))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
apply pred_perm_1 in HappPred; simpl in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.

*****
HappPred : appPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
X : cartesianPower T (S (S (S O)))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S O)))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S O))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S O))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S O)))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (pair A (pair B X))), appPred (pair B (pair A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S O)))))\n (_ : appPred (pair A X)),\nappPred\n (pair (fst X)\n (pair (fst (snd X))\n (pair (fst (snd (snd X))) (pair (snd (snd (snd X))) A))))
appPred : forall _ : cartesianPower T (S (S (S (S (S O))))), Prop
cp2 : cartesianPower T (S (S (S (S (S O)))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S O)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S O)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S O))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S O)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
T : Type
*****
appPred (pair (fst X) (pair (fst (snd X)) (pair (snd (snd X)) (pair A (snd (snd (snd (snd cp))))))))
+++++
assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.

*****
IHn0 : forall\n (_ : forall (cp1 cp2 : cartesianPower T (S (S (S (S n)))))\n (appPred : forall _ : cartesianPower T (S (S (S (S n)))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A X)),\n appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X)))\n (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\n appPred cp2) (cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X)))\n (cp : cartesianPower T (S (S (S (S (S n)))))) (_ : appPred cp)\n (_ : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp)))\n (_ : eq (lastCP cp) (lastCP cp2))\n (_ : cartesianPower T (S (S (S (S n)))))\n (_ : cartesianPower T (S (S (S (S n)))))\n (_ : forall (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred X), appPred (circPermNCP (S (S (S n))) X))\n (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consTailCP (consHeadCP A X) (lastCP cp))),\nappPred (consTailCP (consTailCP X A) (lastCP cp))
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
clear IHn0.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.

*****
HappPred : appPred (consTailCP (consHeadCP A X) (lastCP cp))
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP X A) (lastCP cp))
+++++
assert (H := consHeadCPOK X); rewrite H in *; clear H.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.

*****
HappPred : appPred\n (consTailCP (consHeadCP A (consHeadCP (headCP X) (tailCP X)))\n (lastCP cp))
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP (headCP X) (tailCP X)) A) (lastCP cp))
+++++
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.

*****
HappPred : appPred\n (consTailCP\n (consHeadCP A\n (consHeadCP (headCP X)\n (consTailCP (allButLastCP (tailCP X)) (lastCP (tailCP X)))))\n (lastCP cp))
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP (headCP X) (consTailCP (allButLastCP (tailCP X)) (lastCP (tailCP X)))) A) (lastCP cp))
+++++
set (B := headCP X) in *.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.

*****
HappPred : appPred\n (consTailCP\n (consHeadCP A\n (consHeadCP B\n (consTailCP (allButLastCP (tailCP X)) (lastCP (tailCP X)))))\n (lastCP cp))
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP B (consTailCP (allButLastCP (tailCP X)) (lastCP (tailCP X)))) A) (lastCP cp))
+++++
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.

*****
CP : cartesianPower T (S n)
HappPred : appPred\n (consTailCP\n (consHeadCP A\n (consHeadCP B\n (consTailCP (allButLastCP (tailCP X)) (lastCP (tailCP X)))))\n (lastCP cp))
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP B (consTailCP (allButLastCP (tailCP X)) (lastCP (tailCP X)))) A) (lastCP cp))
+++++
set (C := tailCP (allButLastCP (tailCP X))) in *.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consTailCP\n (consHeadCP A\n (consHeadCP B\n (consTailCP (allButLastCP (tailCP X)) (lastCP (tailCP X)))))\n (lastCP cp))
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP B (consTailCP (allButLastCP (tailCP X)) (lastCP (tailCP X)))) A) (lastCP cp))
+++++
set (D := lastCP (tailCP X)) in *.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consTailCP\n (consHeadCP A\n (consHeadCP B (consTailCP (allButLastCP (tailCP X)) D)))\n (lastCP cp))
D : T
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP B (consTailCP (allButLastCP (tailCP X)) D)) A) (lastCP cp))
+++++
set (E := lastCP cp) in *.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consTailCP\n (consHeadCP A\n (consHeadCP B (consTailCP (allButLastCP (tailCP X)) D))) E)
D : T
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq E (lastCP cp2)
E : T
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP B (consTailCP (allButLastCP (tailCP X)) D)) A) E)
+++++
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consHeadCP D\n (consHeadCP E\n (consHeadCP A (consHeadCP B (allButLastCP (tailCP X))))))
D : T
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq E (lastCP cp2)
E : T
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP B (consTailCP (allButLastCP (tailCP X)) D)) A) E)
+++++
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consHeadCP E\n (consHeadCP A\n (consTailCP (consHeadCP B (allButLastCP (tailCP X))) D)))
D : T
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq E (lastCP cp2)
E : T
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP B (consTailCP (allButLastCP (tailCP X)) D)) A) E)
+++++
apply pred_perm_2 in HappPred.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consHeadCP A\n (consHeadCP E\n (consTailCP (consHeadCP B (allButLastCP (tailCP X))) D)))
D : T
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq E (lastCP cp2)
E : T
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consHeadCP B (consTailCP (allButLastCP (tailCP X)) D)) A) E)
+++++
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consHeadCP A\n (consHeadCP E\n (consTailCP (consHeadCP B (allButLastCP (tailCP X))) D)))
D : T
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq E (lastCP cp2)
E : T
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (circPermNCP (S (S (S (S n)))) (consTailCP (consTailCP (consTailCP (consTailCP (allButLastCP (tailCP X)) D) A) E) B))
+++++
apply pred_perm_3.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consHeadCP A\n (consHeadCP E\n (consTailCP (consHeadCP B (allButLastCP (tailCP X))) D)))
D : T
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq E (lastCP cp2)
E : T
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consTailCP (consTailCP (consTailCP (allButLastCP (tailCP X)) D) A) E) B)
+++++
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consHeadCP A\n (consHeadCP E\n (consTailCP (consHeadCP B (allButLastCP (tailCP X))) D)))
D : T
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq E (lastCP cp2)
E : T
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (consHeadCP E (consHeadCP B (consTailCP (allButLastCP (tailCP X)) D))) A)
+++++
apply pred_perm_1.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
apply pred_perm_1.

*****
C : cartesianPower T (S n)
CP : cartesianPower T (S n)
HappPred : appPred\n (consHeadCP A\n (consHeadCP E\n (consTailCP (consHeadCP B (allButLastCP (tailCP X))) D)))
D : T
B : T
X : cartesianPower T (S (S (S (S n))))
A : T
pred_perm_3 : forall (X : cartesianPower T (S (S (S (S (S (S n))))))) (_ : appPred X),\nappPred (circPermNCP (S (S (S (S n)))) X)
ablcp,ablcp2 : cartesianPower T (S (S (S (S (S n)))))
Hlast : eq E (lastCP cp2)
E : T
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S (S (S (S n))))))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S (S (S (S n))))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S (S (S (S n)))))), Prop
cp2 : cartesianPower T (S (S (S (S (S (S n))))))
IHn : forall (cp1 cp2 : cartesianPower T (S (S (S (S (S n))))))\n (appPred : forall _ : cartesianPower T (S (S (S (S (S n))))), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S (S (S (S n)))))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T (S (S (S n))))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consHeadCP A (consHeadCP E (consHeadCP B (consTailCP (allButLastCP (tailCP X)) D))))
+++++
assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
apply pred_perm_1.
assumption.

*****
HPerm1 : forall (A : T) (X : cartesianPower T (S n))\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A X)),\nfixLastCP appPred (lastCP cp) (consTailCP X A)
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
assert (HPerm2 : (forall (A B : T) (X : cartesianPower T n), (fixLastCP appPred (lastCP cp)) (consHeadCP A (consHeadCP B X)) -> (fixLastCP appPred (lastCP cp)) (consHeadCP B (consHeadCP A X)))) by (unfold fixLastCP; intros A B X HappPred; rewrite <- consTlHdHdTl; apply pred_perm_2; rewrite consTlHdHdTl; assumption).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
apply pred_perm_1.
assumption.
assert (HPerm2 : (forall (A B : T) (X : cartesianPower T n), (fixLastCP appPred (lastCP cp)) (consHeadCP A (consHeadCP B X)) -> (fixLastCP appPred (lastCP cp)) (consHeadCP B (consHeadCP A X)))) by (unfold fixLastCP; intros A B X HappPred; rewrite <- consTlHdHdTl; apply pred_perm_2; rewrite consTlHdHdTl; assumption).

*****
HPerm2 : forall (A B : T) (X : cartesianPower T n)\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A (consHeadCP B X))),\nfixLastCP appPred (lastCP cp) (consHeadCP B (consHeadCP A X))
HPerm1 : forall (A : T) (X : cartesianPower T (S n))\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A X)),\nfixLastCP appPred (lastCP cp) (consTailCP X A)
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp2))\n (CPToList (allButLastCP cp))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
apply Permutation.Permutation_sym in HPerm.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
apply pred_perm_1.
assumption.
assert (HPerm2 : (forall (A B : T) (X : cartesianPower T n), (fixLastCP appPred (lastCP cp)) (consHeadCP A (consHeadCP B X)) -> (fixLastCP appPred (lastCP cp)) (consHeadCP B (consHeadCP A X)))) by (unfold fixLastCP; intros A B X HappPred; rewrite <- consTlHdHdTl; apply pred_perm_2; rewrite consTlHdHdTl; assumption).
apply Permutation.Permutation_sym in HPerm.

*****
HPerm2 : forall (A B : T) (X : cartesianPower T n)\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A (consHeadCP B X))),\nfixLastCP appPred (lastCP cp) (consHeadCP B (consHeadCP A X))
HPerm1 : forall (A : T) (X : cartesianPower T (S n))\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A X)),\nfixLastCP appPred (lastCP cp) (consTailCP X A)
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp))\n (CPToList (allButLastCP cp2))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
assert (H := IHn (allButLastCP cp) (allButLastCP cp2) (fixLastCP appPred (lastCP cp)) HPerm1 HPerm2).
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
apply pred_perm_1.
assumption.
assert (HPerm2 : (forall (A B : T) (X : cartesianPower T n), (fixLastCP appPred (lastCP cp)) (consHeadCP A (consHeadCP B X)) -> (fixLastCP appPred (lastCP cp)) (consHeadCP B (consHeadCP A X)))) by (unfold fixLastCP; intros A B X HappPred; rewrite <- consTlHdHdTl; apply pred_perm_2; rewrite consTlHdHdTl; assumption).
apply Permutation.Permutation_sym in HPerm.
assert (H := IHn (allButLastCP cp) (allButLastCP cp2) (fixLastCP appPred (lastCP cp)) HPerm1 HPerm2).

*****
H : forall (_ : fixLastCP appPred (lastCP cp) (allButLastCP cp))\n (_ : Permutation.Permutation (CPToList (allButLastCP cp))\n (CPToList (allButLastCP cp2))),\nfixLastCP appPred (lastCP cp) (allButLastCP cp2)
HPerm2 : forall (A B : T) (X : cartesianPower T n)\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A (consHeadCP B X))),\nfixLastCP appPred (lastCP cp) (consHeadCP B (consHeadCP A X))
HPerm1 : forall (A : T) (X : cartesianPower T (S n))\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A X)),\nfixLastCP appPred (lastCP cp) (consTailCP X A)
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp))\n (CPToList (allButLastCP cp2))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp2) (lastCP cp))
+++++
apply H; try assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
apply pred_perm_1.
assumption.
assert (HPerm2 : (forall (A B : T) (X : cartesianPower T n), (fixLastCP appPred (lastCP cp)) (consHeadCP A (consHeadCP B X)) -> (fixLastCP appPred (lastCP cp)) (consHeadCP B (consHeadCP A X)))) by (unfold fixLastCP; intros A B X HappPred; rewrite <- consTlHdHdTl; apply pred_perm_2; rewrite consTlHdHdTl; assumption).
apply Permutation.Permutation_sym in HPerm.
assert (H := IHn (allButLastCP cp) (allButLastCP cp2) (fixLastCP appPred (lastCP cp)) HPerm1 HPerm2).
apply H; try assumption.

*****
H : forall (_ : fixLastCP appPred (lastCP cp) (allButLastCP cp))\n (_ : Permutation.Permutation (CPToList (allButLastCP cp))\n (CPToList (allButLastCP cp2))),\nfixLastCP appPred (lastCP cp) (allButLastCP cp2)
HPerm2 : forall (A B : T) (X : cartesianPower T n)\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A (consHeadCP B X))),\nfixLastCP appPred (lastCP cp) (consHeadCP B (consHeadCP A X))
HPerm1 : forall (A : T) (X : cartesianPower T (S n))\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A X)),\nfixLastCP appPred (lastCP cp) (consTailCP X A)
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp))\n (CPToList (allButLastCP cp2))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
fixLastCP appPred (lastCP cp) (allButLastCP cp)
+++++
rewrite <- fixLastCPOK.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
apply pred_perm_1.
assumption.
assert (HPerm2 : (forall (A B : T) (X : cartesianPower T n), (fixLastCP appPred (lastCP cp)) (consHeadCP A (consHeadCP B X)) -> (fixLastCP appPred (lastCP cp)) (consHeadCP B (consHeadCP A X)))) by (unfold fixLastCP; intros A B X HappPred; rewrite <- consTlHdHdTl; apply pred_perm_2; rewrite consTlHdHdTl; assumption).
apply Permutation.Permutation_sym in HPerm.
assert (H := IHn (allButLastCP cp) (allButLastCP cp2) (fixLastCP appPred (lastCP cp)) HPerm1 HPerm2).
apply H; try assumption.
rewrite <- fixLastCPOK.

*****
H : forall (_ : fixLastCP appPred (lastCP cp) (allButLastCP cp))\n (_ : Permutation.Permutation (CPToList (allButLastCP cp))\n (CPToList (allButLastCP cp2))),\nfixLastCP appPred (lastCP cp) (allButLastCP cp2)
HPerm2 : forall (A B : T) (X : cartesianPower T n)\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A (consHeadCP B X))),\nfixLastCP appPred (lastCP cp) (consHeadCP B (consHeadCP A X))
HPerm1 : forall (A : T) (X : cartesianPower T (S n))\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A X)),\nfixLastCP appPred (lastCP cp) (consTailCP X A)
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp))\n (CPToList (allButLastCP cp2))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred (consTailCP (allButLastCP cp) (lastCP cp))
+++++
rewrite <- consTailCPOK.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
apply pred_perm_1.
assumption.
assert (HPerm2 : (forall (A B : T) (X : cartesianPower T n), (fixLastCP appPred (lastCP cp)) (consHeadCP A (consHeadCP B X)) -> (fixLastCP appPred (lastCP cp)) (consHeadCP B (consHeadCP A X)))) by (unfold fixLastCP; intros A B X HappPred; rewrite <- consTlHdHdTl; apply pred_perm_2; rewrite consTlHdHdTl; assumption).
apply Permutation.Permutation_sym in HPerm.
assert (H := IHn (allButLastCP cp) (allButLastCP cp2) (fixLastCP appPred (lastCP cp)) HPerm1 HPerm2).
apply H; try assumption.
rewrite <- fixLastCPOK.
rewrite <- consTailCPOK.

*****
H : forall (_ : fixLastCP appPred (lastCP cp) (allButLastCP cp))\n (_ : Permutation.Permutation (CPToList (allButLastCP cp))\n (CPToList (allButLastCP cp2))),\nfixLastCP appPred (lastCP cp) (allButLastCP cp2)
HPerm2 : forall (A B : T) (X : cartesianPower T n)\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A (consHeadCP B X))),\nfixLastCP appPred (lastCP cp) (consHeadCP B (consHeadCP A X))
HPerm1 : forall (A : T) (X : cartesianPower T (S n))\n (_ : fixLastCP appPred (lastCP cp) (consHeadCP A X)),\nfixLastCP appPred (lastCP cp) (consTailCP X A)
pred_perm_3 : forall (X : cartesianPower T (S (S (S n)))) (_ : appPred X),\nappPred (circPermNCP (S n) X)
ablcp,ablcp2 : cartesianPower T (S (S n))
Hlast : eq (lastCP cp) (lastCP cp2)
HPerm : Permutation.Permutation (CPToList (allButLastCP cp))\n (CPToList (allButLastCP cp2))
Hpred : appPred cp
cp : cartesianPower T (S (S (S n)))
pred_perm_2 : forall (A B : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A (consHeadCP B X))),\nappPred (consHeadCP B (consHeadCP A X))
pred_perm_1 : forall (A : T) (X : cartesianPower T (S (S n)))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A)
appPred : forall _ : cartesianPower T (S (S (S n))), Prop
cp2 : cartesianPower T (S (S (S n)))
IHn : forall (cp1 cp2 : cartesianPower T (S (S n)))\n (appPred : forall _ : cartesianPower T (S (S n)), Prop)\n (_ : forall (A : T) (X : cartesianPower T (S n))\n (_ : appPred (consHeadCP A X)), appPred (consTailCP X A))\n (_ : forall (A B : T) (X : cartesianPower T n)\n (_ : appPred (consHeadCP A (consHeadCP B X))),\n appPred (consHeadCP B (consHeadCP A X))) (_ : appPred cp1)\n (_ : Permutation.Permutation (CPToList cp1) (CPToList cp2)),\nappPred cp2
n : nat
T : Type
*****
appPred cp
+++++
assumption.
-----
Lemma PermOK {T : Type} {n : nat} : forall (cp1 cp2 : cartesianPower T (S (S n))) (appPred : (cartesianPower T (S (S n))) -> Prop), (forall (A : T) (X : cartesianPower T (S n)), appPred (consHeadCP A X) -> appPred (consTailCP X A)) -> (forall (A B : T) (X : cartesianPower T n), appPred (consHeadCP A (consHeadCP B X)) -> appPred (consHeadCP B (consHeadCP A X))) -> appPred cp1 -> Permutation.Permutation (CPToList cp1) (CPToList cp2) -> appPred cp2.
Proof.
induction n; intros cp1 cp2 appPred pred_perm_1 pred_perm_2 Hpred HPerm.
assert (Hcp1 := CPPair cp1); rewrite Hcp1 in *; clear Hcp1.
assert (Hcp2 := CPPair cp2); rewrite Hcp2 in *; clear Hcp2.
simpl in *.
apply Permutation.Permutation_length_2 in HPerm.
elim HPerm; clear HPerm; intro HPerm; destruct HPerm as [HEq1 HEq2]; rewrite <- HEq1; rewrite <- HEq2.
assumption.
apply pred_perm_1; assumption.
rewrite consTailCPOK.
assert (H' := lastCPIn cp2).
assert (H : InCP (lastCP cp2) cp1) by (unfold InCP;apply Permutation.Permutation_in with (CPToList cp2); try apply Permutation.Permutation_sym; assumption); clear H'.
assert (H' := InNth cp1 (lastCP cp2) (headCP cp2) H); clear H.
destruct H' as [id [Hge [Hle Hnth]]].
assert (H : exists cp, appPred cp /\\ Permutation.Permutation (CPToList cp2) (CPToList cp) /\\ lastCP cp = lastCP cp2).
induction id; try (unfold ge in Hge; assert (H := Le.le_Sn_0 0); contradiction); clear IHid.
revert Hnth; revert HPerm; revert Hpred; revert cp1; induction id; intros.
exists (consTailCP (tailCP cp1) (headCP cp1)).
split.
apply pred_perm_1.
rewrite <- consHeadCPOK.
assumption.
split.
apply Permutation.perm_trans with (CPToList cp1); try (apply consTailPerm).
apply Permutation.Permutation_sym; assumption.
apply nthCircPerm1 in Hnth.
rewrite Hnth.
assert (H := nthLast (consTailCP (tailCP cp1) (headCP cp1)) (headCP cp2)); rewrite H; reflexivity.
assert (H := Hle).
do 2 (apply Le.le_S_n in H).
apply nthCircPerm2 in Hnth; try assumption; clear H.
apply Le.le_Sn_le in Hle.
assert (H : S id >= 1) by intuition; clear Hge; rename H into Hge.
assert (H : appPred (consTailCP (tailCP cp1) (headCP cp1))) by (apply pred_perm_1; rewrite <- consHeadCPOK; assumption) ; clear Hpred; rename H into Hpred.
assert (H := consTailPerm cp1); apply Permutation.Permutation_sym in H.
assert (H' : Permutation.Permutation (CPToList (consTailCP (tailCP cp1) (headCP cp1))) (CPToList cp2)) by (apply Permutation.perm_trans with (CPToList cp1); assumption); clear HPerm; rename H' into HPerm.
assert (H' := IHid Hge Hle (consTailCP (tailCP cp1) (headCP cp1)) Hpred HPerm Hnth).
destruct H' as [cp [Hpredcp [HPermcp Hlastcp]]]; exists cp.
do 2 (split; try assumption).
clear Hnth; clear Hle; clear Hge; clear id; clear HPerm; clear Hpred; clear cp1.
destruct H as [cp [Hpred [HPerm Hlast]]]; rewrite <- Hlast.
assert (H := consTailCPOK cp); rewrite H in HPerm; clear H.
assert (H := consTailCPOK cp2); rewrite H in HPerm; clear H.
do 2 (rewrite consTailOK in HPerm).
rewrite Hlast in HPerm.
apply Permutation.Permutation_app_inv_r in HPerm.
assert (ablcp := allButLastCP cp).
assert (ablcp2 := allButLastCP cp2).
assert (pred_perm_3 := PermOKAux appPred (S n) pred_perm_1).
assert (HPerm1 : (forall (A : T) (X : cartesianPower T (S n)), (fixLastCP appPred (lastCP cp)) (consHeadCP A X) -> (fixLastCP appPred (lastCP cp)) (consTailCP X A))).
unfold fixLastCP; intros A X HappPred.
induction n.
simpl in HappPred.
apply pred_perm_2.
simpl.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_3 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
induction n.
simpl.
simpl in HappPred.
simpl in pred_perm_1.
simpl in pred_perm_2.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_2 in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
apply pred_perm_1 in HappPred; simpl in HappPred.
assumption.
clear IHn0.
assert (H := consHeadCPOK X); rewrite H in *; clear H.
assert (H := consTailCPOK (tailCP X)); rewrite H in *; clear H.
set (B := headCP X) in *.
set (CP := allButLastCP (allButLastCP (tailCP X))) in *.
set (C := tailCP (allButLastCP (tailCP X))) in *.
set (D := lastCP (tailCP X)) in *.
set (E := lastCP cp) in *.
apply pred_perm_3 in HappPred; rewrite consTlHdHdTl in HappPred; rewrite circPermNConsOK in HappPred.
apply pred_perm_1 in HappPred; do 2 (rewrite <- consHdTlTlHd in HappPred).
apply pred_perm_2 in HappPred.
apply pred_perm_1; rewrite <- consHdTlTlHd; rewrite <- circPermNConsOK.
apply pred_perm_3.
do 2 (apply pred_perm_1; rewrite consHdTlTlHd); rewrite consHdTlTlHd.
apply pred_perm_1.
assumption.
assert (HPerm2 : (forall (A B : T) (X : cartesianPower T n), (fixLastCP appPred (lastCP cp)) (consHeadCP A (consHeadCP B X)) -> (fixLastCP appPred (lastCP cp)) (consHeadCP B (consHeadCP A X)))) by (unfold fixLastCP; intros A B X HappPred; rewrite <- consTlHdHdTl; apply pred_perm_2; rewrite consTlHdHdTl; assumption).
apply Permutation.Permutation_sym in HPerm.
assert (H := IHn (allButLastCP cp) (allButLastCP cp2) (fixLastCP appPred (lastCP cp)) HPerm1 HPerm2).
apply H; try assumption.
rewrite <- fixLastCPOK.
rewrite <- consTailCPOK.
assumption.

*****

*****

+++++
Qed.
-----
Lemma lengthNilOK {A : Type} : forall (l : list A),\n  length l = 0 -> l = nil.
-----
Lemma lengthNilOK {A : Type} : forall (l : list A), length l = 0 -> l = nil.

*****
A : Type
*****
forall (l : list A) (_ : eq (length l) O), eq l nil
+++++
Proof.
-----
Lemma lengthNilOK {A : Type} : forall (l : list A), length l = 0 -> l = nil.
Proof.

*****
A : Type
*****
forall (l : list A) (_ : eq (length l) O), eq l nil
+++++
intros l Hlength.
-----
Lemma lengthNilOK {A : Type} : forall (l : list A), length l = 0 -> l = nil.
Proof.
intros l Hlength.

*****
Hlength : eq (length l) O
l : list A
A : Type
*****
eq l nil
+++++
induction l.
-----
Lemma lengthNilOK {A : Type} : forall (l : list A), length l = 0 -> l = nil.
Proof.
intros l Hlength.
induction l.

*****
Hlength : eq (length nil) O
A : Type
*****
eq nil nil
+++++
reflexivity.
-----
Lemma lengthNilOK {A : Type} : forall (l : list A), length l = 0 -> l = nil.
Proof.
intros l Hlength.
induction l.

*****
IHl : forall _ : eq (length l) O, eq l nil
Hlength : eq (length (cons a l)) O
l : list A
a : A
A : Type
*****
eq (cons a l) nil
+++++
simpl in Hlength.
-----
Lemma lengthNilOK {A : Type} : forall (l : list A), length l = 0 -> l = nil.
Proof.
intros l Hlength.
induction l.
simpl in Hlength.

*****
IHl : forall _ : eq (length l) O, eq l nil
Hlength : eq (S (length l)) O
l : list A
a : A
A : Type
*****
eq (cons a l) nil
+++++
discriminate.
-----
Lemma lengthNilOK {A : Type} : forall (l : list A), length l = 0 -> l = nil.
Proof.
intros l Hlength.
induction l.

*****

*****

+++++
Qed.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A),\n  incl l l' ->\n  length l = length l' ->\n  NoDup l ->\n  Permutation.Permutation l l'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.

*****
A : Type
*****
forall (l l' : list A) (_ : incl l l') (_ : eq (length l) (length l')) (_ : NoDup l), Permutation.Permutation l l'
+++++
Proof.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.

*****
A : Type
*****
forall (l l' : list A) (_ : incl l l') (_ : eq (length l) (length l')) (_ : NoDup l), Permutation.Permutation l l'
+++++
intro l.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.

*****
l : list A
A : Type
*****
forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l')) (_ : NoDup l), Permutation.Permutation l l'
+++++
induction l.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.

*****
A : Type
*****
forall (l' : list A) (_ : incl nil l') (_ : eq (length nil) (length l')) (_ : NoDup nil), Permutation.Permutation nil l'
+++++
intros l' Hincl Hlength HNoDup.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.

*****
HNoDup : NoDup nil
Hlength : eq (length nil) (length l')
Hincl : incl nil l'
l' : list A
A : Type
*****
Permutation.Permutation nil l'
+++++
simpl in Hlength.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
simpl in Hlength.

*****
HNoDup : NoDup nil
Hlength : eq O (length l')
Hincl : incl nil l'
l' : list A
A : Type
*****
Permutation.Permutation nil l'
+++++
apply eq_sym in Hlength.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
simpl in Hlength.
apply eq_sym in Hlength.

*****
HNoDup : NoDup nil
Hlength : eq (length l') O
Hincl : incl nil l'
l' : list A
A : Type
*****
Permutation.Permutation nil l'
+++++
apply lengthNilOK in Hlength.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
simpl in Hlength.
apply eq_sym in Hlength.
apply lengthNilOK in Hlength.

*****
HNoDup : NoDup nil
Hlength : eq l' nil
Hincl : incl nil l'
l' : list A
A : Type
*****
Permutation.Permutation nil l'
+++++
subst.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
simpl in Hlength.
apply eq_sym in Hlength.
apply lengthNilOK in Hlength.
subst.

*****
HNoDup : NoDup nil
Hincl : incl nil nil
A : Type
*****
Permutation.Permutation nil nil
+++++
apply Permutation.perm_nil.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.

*****
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall (l' : list A) (_ : incl (cons a l) l') (_ : eq (length (cons a l)) (length l')) (_ : NoDup (cons a l)), Permutation.Permutation (cons a l) l'
+++++
intros l' Hincl Hlength HNoDup.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.

*****
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length l')
Hincl : incl (cons a l) l'
l' : list A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) l'
+++++
induction l'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.

*****
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length nil)
Hincl : incl (cons a l) nil
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) nil
+++++
simpl in Hlength.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
simpl in Hlength.

*****
HNoDup : NoDup (cons a l)
Hlength : eq (S (length l)) O
Hincl : incl (cons a l) nil
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) nil
+++++
discriminate.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.

*****
IHl' : forall (_ : incl (cons a l) l')\n (_ : eq (length (cons a l)) (length l')),\nPermutation.Permutation (cons a l) l'
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a0 l'))
Hincl : incl (cons a l) (cons a0 l')
l' : list A
a0 : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a0 l')
+++++
clear IHl'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.

*****
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a0 l'))
Hincl : incl (cons a l) (cons a0 l')
l' : list A
a0 : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a0 l')
+++++
rename a0 into a'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.

*****
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a' l'))
Hincl : incl (cons a l) (cons a' l')
l' : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a' l')
+++++
assert (HIn := in_eq a l).
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).

*****
HIn : In a (cons a l)
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a' l'))
Hincl : incl (cons a l) (cons a' l')
l' : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a' l')
+++++
assert (H := Hincl).
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).

*****
H : incl (cons a l) (cons a' l')
HIn : In a (cons a l)
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a' l'))
Hincl : incl (cons a l) (cons a' l')
l' : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a' l')
+++++
unfold incl in H.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.

*****
H : forall (a0 : A) (_ : In a0 (cons a l)), In a0 (cons a' l')
HIn : In a (cons a l)
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a' l'))
Hincl : incl (cons a l) (cons a' l')
l' : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a' l')
+++++
apply H in HIn.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.

*****
H : forall (a0 : A) (_ : In a0 (cons a l)), In a0 (cons a' l')
HIn : In a (cons a' l')
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a' l'))
Hincl : incl (cons a l) (cons a' l')
l' : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a' l')
+++++
clear H.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.

*****
HIn : In a (cons a' l')
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a' l'))
Hincl : incl (cons a l) (cons a' l')
l' : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a' l')
+++++
apply in_split in HIn.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.

*****
HIn : ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A => eq (cons a' l') (Datatypes.app l1 (cons a l2))))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a' l'))
Hincl : incl (cons a l) (cons a' l')
l' : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a' l')
+++++
destruct HIn as [l1 [l2 Hl']].
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
l1,l2 : list A
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (cons a' l'))
Hincl : incl (cons a l) (cons a' l')
l' : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (cons a' l')
+++++
rewrite Hl' in *.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation (cons a l) (Datatypes.app l1 (cons a l2))
+++++
apply Permutation.Permutation_cons_app.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
Permutation.Permutation l (Datatypes.app l1 l2)
+++++
apply IHl.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
incl l (Datatypes.app l1 l2)
+++++
unfold incl.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall (a : A) (_ : In a l), In a (Datatypes.app l1 l2)
+++++
intros e HIn.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.

*****
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
unfold incl in Hincl.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.

*****
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : forall (a0 : A) (_ : In a0 (cons a l)),\nIn a0 (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
assert (H := Hincl e).
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).

*****
H : forall _ : In e (cons a l), In e (Datatypes.app l1 (cons a l2))
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : forall (a0 : A) (_ : In a0 (cons a l)),\nIn a0 (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
clear Hincl.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.

*****
H : forall _ : In e (cons a l), In e (Datatypes.app l1 (cons a l2))
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
assert (HIn' := in_cons a e l HIn).
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).

*****
HIn' : In e (cons a l)
H : forall _ : In e (cons a l), In e (Datatypes.app l1 (cons a l2))
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
apply H in HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.

*****
HIn' : In e (Datatypes.app l1 (cons a l2))
H : forall _ : In e (cons a l), In e (Datatypes.app l1 (cons a l2))
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
clear H.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.

*****
HIn' : In e (Datatypes.app l1 (cons a l2))
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
apply in_app_or in HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.

*****
HIn' : or (In e l1) (In e (cons a l2))
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
elim HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.

*****
HIn' : or (In e l1) (In e (cons a l2))
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall _ : In e l1, In e (Datatypes.app l1 l2)
+++++
clear HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.

*****
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall _ : In e l1, In e (Datatypes.app l1 l2)
+++++
intro HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.

*****
HIn' : In e l1
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
apply in_or_app.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_or_app.

*****
HIn' : In e l1
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
or (In e l1) (In e l2)
+++++
auto.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.

*****
HIn' : or (In e l1) (In e (cons a l2))
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall _ : In e (cons a l2), In e (Datatypes.app l1 l2)
+++++
clear HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.

*****
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall _ : In e (cons a l2), In e (Datatypes.app l1 l2)
+++++
intro HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.

*****
HIn' : In e (cons a l2)
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
apply in_inv in HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.

*****
HIn' : or (eq a e) (In e l2)
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
elim HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.

*****
HIn' : or (eq a e) (In e l2)
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall _ : eq a e, In e (Datatypes.app l1 l2)
+++++
clear HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.
clear HIn'.

*****
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall _ : eq a e, In e (Datatypes.app l1 l2)
+++++
intro HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.

*****
HIn' : eq a e
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
subst.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
subst.

*****
HIn : In e l
Hlength : eq (length (cons e l)) (length (Datatypes.app l1 (cons e l2)))
HNoDup : NoDup (cons e l)
Hl' : eq (cons a' l') (Datatypes.app l1 (cons e l2))
e : A
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
assert (H := NoDup_remove_2 nil l e).
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
subst.
assert (H := NoDup_remove_2 nil l e).

*****
H : forall _ : NoDup (Datatypes.app nil (cons e l)),\nnot (In e (Datatypes.app nil l))
HIn : In e l
Hlength : eq (length (cons e l)) (length (Datatypes.app l1 (cons e l2)))
HNoDup : NoDup (cons e l)
Hl' : eq (cons a' l') (Datatypes.app l1 (cons e l2))
e : A
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
simpl in H.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
subst.
assert (H := NoDup_remove_2 nil l e).
simpl in H.

*****
H : forall _ : NoDup (cons e l), not (In e l)
HIn : In e l
Hlength : eq (length (cons e l)) (length (Datatypes.app l1 (cons e l2)))
HNoDup : NoDup (cons e l)
Hl' : eq (cons a' l') (Datatypes.app l1 (cons e l2))
e : A
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
apply H in HNoDup.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
subst.
assert (H := NoDup_remove_2 nil l e).
simpl in H.
apply H in HNoDup.

*****
H : forall _ : NoDup (cons e l), not (In e l)
HIn : In e l
Hlength : eq (length (cons e l)) (length (Datatypes.app l1 (cons e l2)))
HNoDup : not (In e l)
Hl' : eq (cons a' l') (Datatypes.app l1 (cons e l2))
e : A
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
contradiction.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.

*****
HIn' : or (eq a e) (In e l2)
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall _ : In e l2, In e (Datatypes.app l1 l2)
+++++
clear HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.
clear HIn'.

*****
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
forall _ : In e l2, In e (Datatypes.app l1 l2)
+++++
intro HIn'.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.

*****
HIn' : In e l2
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
apply in_or_app.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
unfold incl.
intros e HIn.
unfold incl in Hincl.
assert (H := Hincl e).
clear Hincl.
assert (HIn' := in_cons a e l HIn).
apply H in HIn'.
clear H.
apply in_app_or in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_inv in HIn'.
elim HIn'.
clear HIn'.
intro HIn'.
apply in_or_app.

*****
HIn' : In e l2
HIn : In e l
e : A
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
or (In e l1) (In e l2)
+++++
auto.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
eq (length l) (length (Datatypes.app l1 l2))
+++++
rewrite app_length.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
rewrite app_length.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
eq (length l) (Init.Nat.add (length l1) (length l2))
+++++
rewrite app_length in Hlength.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
rewrite app_length.
rewrite app_length in Hlength.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (Init.Nat.add (length l1) (length (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
eq (length l) (Init.Nat.add (length l1) (length l2))
+++++
simpl in Hlength.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
rewrite app_length.
rewrite app_length in Hlength.
simpl in Hlength.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (S (length l)) (Init.Nat.add (length l1) (S (length l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
eq (length l) (Init.Nat.add (length l1) (length l2))
+++++
rewrite <- plus_n_Sm in Hlength.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
rewrite app_length.
rewrite app_length in Hlength.
simpl in Hlength.
rewrite <- plus_n_Sm in Hlength.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (S (length l)) (S (Init.Nat.add (length l1) (length l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
eq (length l) (Init.Nat.add (length l1) (length l2))
+++++
apply eq_add_S in Hlength.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
rewrite app_length.
rewrite app_length in Hlength.
simpl in Hlength.
rewrite <- plus_n_Sm in Hlength.
apply eq_add_S in Hlength.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length l) (Init.Nat.add (length l1) (length l2))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
eq (length l) (Init.Nat.add (length l1) (length l2))
+++++
assumption.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.

*****
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
NoDup l
+++++
assert (H := NoDup_remove_1 nil l a).
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
assert (H := NoDup_remove_1 nil l a).

*****
H : forall _ : NoDup (Datatypes.app nil (cons a l)),\nNoDup (Datatypes.app nil l)
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
NoDup l
+++++
simpl in H.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
assert (H := NoDup_remove_1 nil l a).
simpl in H.

*****
H : forall _ : NoDup (cons a l), NoDup l
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
NoDup l
+++++
apply H.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.
intros l' Hincl Hlength HNoDup.
induction l'.
clear IHl'.
rename a0 into a'.
assert (HIn := in_eq a l).
assert (H := Hincl).
unfold incl in H.
apply H in HIn.
clear H.
apply in_split in HIn.
destruct HIn as [l1 [l2 Hl']].
rewrite Hl' in *.
apply Permutation.Permutation_cons_app.
apply IHl.
assert (H := NoDup_remove_1 nil l a).
simpl in H.
apply H.

*****
H : forall _ : NoDup (cons a l), NoDup l
Hl' : eq (cons a' l') (Datatypes.app l1 (cons a l2))
HNoDup : NoDup (cons a l)
Hlength : eq (length (cons a l)) (length (Datatypes.app l1 (cons a l2)))
Hincl : incl (cons a l) (Datatypes.app l1 (cons a l2))
l',l1,l2 : list A
a' : A
IHl : forall (l' : list A) (_ : incl l l') (_ : eq (length l) (length l'))\n (_ : NoDup l), Permutation.Permutation l l'
l : list A
a : A
A : Type
*****
NoDup (cons a l)
+++++
assumption.
-----
Lemma NoDupOK {A : Type} : forall (l l' : list A), incl l l' -> length l = length l' -> NoDup l -> Permutation.Permutation l l'.
Proof.
intro l.
induction l.

*****

*****

+++++
Qed.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A),\n  (forall x y : A, {x = y} + {x <> y}) ->\n  NoDup l \/ ~ NoDup l.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.

*****
A : Type
*****
forall (l : list A) (_ : forall x y : A, sumbool (eq x y) (not (eq x y))), or (NoDup l) (not (NoDup l))
+++++
Proof.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.

*****
A : Type
*****
forall (l : list A) (_ : forall x y : A, sumbool (eq x y) (not (eq x y))), or (NoDup l) (not (NoDup l))
+++++
intros l HDec.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.

*****
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
A : Type
*****
or (NoDup l) (not (NoDup l))
+++++
induction l.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.

*****
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
A : Type
*****
or (NoDup nil) (not (NoDup nil))
+++++
left.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
left.

*****
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
A : Type
*****
NoDup nil
+++++
apply NoDup_nil.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.

*****
IHl : or (NoDup l) (not (NoDup l))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
elim IHl.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.

*****
IHl : or (NoDup l) (not (NoDup l))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : NoDup l, or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
clear IHl.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.

*****
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : NoDup l, or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
intro H.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.

*****
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
assert (HIn := in_dec HDec a l).
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).

*****
HIn : sumbool (In a l) (not (In a l))
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
elim HIn.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.

*****
HIn : sumbool (In a l) (not (In a l))
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : In a l, or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
clear HIn.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.

*****
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : In a l, or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
intro HIn.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.

*****
HIn : In a l
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
right.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
right.

*****
HIn : In a l
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
not (NoDup (cons a l))
+++++
clear H.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
right.
clear H.

*****
HIn : In a l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
not (NoDup (cons a l))
+++++
intro H.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
right.
clear H.
intro H.

*****
H : NoDup (cons a l)
HIn : In a l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
False
+++++
assert (H' := NoDup_remove_2 nil l a).
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
right.
clear H.
intro H.
assert (H' := NoDup_remove_2 nil l a).

*****
H' : forall _ : NoDup (Datatypes.app nil (cons a l)),\nnot (In a (Datatypes.app nil l))
H : NoDup (cons a l)
HIn : In a l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
False
+++++
simpl in H'.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
right.
clear H.
intro H.
assert (H' := NoDup_remove_2 nil l a).
simpl in H'.

*****
H' : forall _ : NoDup (cons a l), not (In a l)
H : NoDup (cons a l)
HIn : In a l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
False
+++++
apply H' in H.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
right.
clear H.
intro H.
assert (H' := NoDup_remove_2 nil l a).
simpl in H'.
apply H' in H.

*****
H' : forall _ : NoDup (cons a l), not (In a l)
H : not (In a l)
HIn : In a l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
False
+++++
contradiction.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.

*****
HIn : sumbool (In a l) (not (In a l))
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : not (In a l), or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
clear HIn.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.

*****
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : not (In a l), or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
intro HIn.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.

*****
HIn : not (In a l)
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
left.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
left.

*****
HIn : not (In a l)
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
NoDup (cons a l)
+++++
apply NoDup_cons.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
left.
apply NoDup_cons.

*****
HIn : not (In a l)
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
not (In a l)
+++++
assumption.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
left.
apply NoDup_cons.

*****
HIn : not (In a l)
H : NoDup l
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
NoDup l
+++++
assumption.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.

*****
IHl : or (NoDup l) (not (NoDup l))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : not (NoDup l), or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
clear IHl.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.

*****
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : not (NoDup l), or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
intro H.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.

*****
H : not (NoDup l)
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
or (NoDup (cons a l)) (not (NoDup (cons a l)))
+++++
right.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
right.

*****
H : not (NoDup l)
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
not (NoDup (cons a l))
+++++
intro H'.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
right.
intro H'.

*****
H' : NoDup (cons a l)
H : not (NoDup l)
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
False
+++++
apply H.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
right.
intro H'.
apply H.

*****
H' : NoDup (cons a l)
H : not (NoDup l)
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
NoDup l
+++++
clear H.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
right.
intro H'.
apply H.
clear H.

*****
H' : NoDup (cons a l)
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
NoDup l
+++++
assert (H := NoDup_remove_1 nil l a).
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
right.
intro H'.
apply H.
clear H.
assert (H := NoDup_remove_1 nil l a).

*****
H : forall _ : NoDup (Datatypes.app nil (cons a l)),\nNoDup (Datatypes.app nil l)
H' : NoDup (cons a l)
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
NoDup l
+++++
simpl in H.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.
elim IHl.
clear IHl.
intro H.
right.
intro H'.
apply H.
clear H.
assert (H := NoDup_remove_1 nil l a).
simpl in H.

*****
H : forall _ : NoDup (cons a l), NoDup l
H' : NoDup (cons a l)
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
NoDup l
+++++
auto.
-----
Lemma NoDup_dec {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> NoDup l \\/ ~ NoDup l.
Proof.
intros l HDec.
induction l.

*****

*****

+++++
Qed.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A),\n  (forall x y : A, {x = y} + {x <> y}) ->\n  ~ NoDup l->\n  exists e l1 l2, l = l1 ++ e :: l2 /\ In e (l1 ++ l2).
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).

*****
A : Type
*****
forall (l : list A) (_ : forall x y : A, sumbool (eq x y) (not (eq x y))) (_ : not (NoDup l)), ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq l (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
Proof.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.

*****
A : Type
*****
forall (l : list A) (_ : forall x y : A, sumbool (eq x y) (not (eq x y))) (_ : not (NoDup l)), ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq l (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
intros l HDec.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.

*****
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
A : Type
*****
forall _ : not (NoDup l), ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq l (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
induction l.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.

*****
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
A : Type
*****
forall _ : not (NoDup nil), ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq nil (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
intro HDup.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.

*****
HDup : not (NoDup nil)
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq nil (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
assert (H := NoDup_nil A).
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (H := NoDup_nil A).

*****
H : NoDup nil
HDup : not (NoDup nil)
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq nil (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
contradiction.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.

*****
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : not (NoDup (cons a l)), ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
intro HDup.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.

*****
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
assert (HIn := in_dec HDec a l).
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).

*****
HIn : sumbool (In a l) (not (In a l))
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
elim HIn.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.

*****
HIn : sumbool (In a l) (not (In a l))
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : In a l, ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
clear HIn.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.

*****
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : In a l, ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
intro HIn.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.

*****
HIn : In a l
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
exists a.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
exists a.

*****
HIn : In a l
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons a l2))) (In a (Datatypes.app l1 l2))))
+++++
exists nil.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
exists a.
exists nil.

*****
HIn : In a l
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app nil (cons a l2))) (In a (Datatypes.app nil l2)))
+++++
exists l.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
exists a.
exists nil.
exists l.

*****
HIn : In a l
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
and (eq (cons a l) (Datatypes.app nil (cons a l))) (In a (Datatypes.app nil l))
+++++
simpl.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
exists a.
exists nil.
exists l.
simpl.

*****
HIn : In a l
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
and (eq (cons a l) (cons a l)) (In a l)
+++++
auto.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.

*****
HIn : sumbool (In a l) (not (In a l))
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : not (In a l), ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
clear HIn.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.

*****
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : not (In a l), ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
intro HIn.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.

*****
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
assert (HDup' := NoDup_dec l HDec).
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).

*****
HDup' : or (NoDup l) (not (NoDup l))
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
elim HDup'.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.

*****
HDup' : or (NoDup l) (not (NoDup l))
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : NoDup l, ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
clear HDup'.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.

*****
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : NoDup l, ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
intro HDup'.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.

*****
HDup' : NoDup l
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
exfalso.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
exfalso.

*****
HDup' : NoDup l
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
False
+++++
apply HDup.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
exfalso.
apply HDup.

*****
HDup' : NoDup l
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
NoDup (cons a l)
+++++
apply NoDup_cons.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
exfalso.
apply HDup.
apply NoDup_cons.

*****
HDup' : NoDup l
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
not (In a l)
+++++
assumption.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
exfalso.
apply HDup.
apply NoDup_cons.

*****
HDup' : NoDup l
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
NoDup l
+++++
assumption.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.

*****
HDup' : or (NoDup l) (not (NoDup l))
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : not (NoDup l), ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
clear HDup'.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.

*****
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
forall _ : not (NoDup l), ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
intro HDup'.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.

*****
HDup' : not (NoDup l)
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
apply IHl in HDup'.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.

*****
HDup' : ex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HDec : forall x y : A, sumbool (eq x y) (not (eq x y))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
clear HDec.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.

*****
HDup' : ex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HIn : not (In a l)
HDup : not (NoDup (cons a l))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
clear HDup.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.

*****
HDup' : ex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
HIn : not (In a l)
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
clear HIn.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.

*****
HDup' : ex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
IHl : forall _ : not (NoDup l),\nex\n (fun e : A =>\n ex\n (fun l1 : list A =>\n ex\n (fun l2 : list A =>\n and (eq l (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
clear IHl.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
clear IHl.

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
l : list A
a : A
A : Type
*****
ex (fun e : A => ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2)))))
+++++
exists e.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
clear IHl.
exists e.

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
l : list A
a : A
A : Type
*****
ex (fun l1 : list A => ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app l1 (cons e l2))) (In e (Datatypes.app l1 l2))))
+++++
exists (a :: l1).
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
clear IHl.
exists e.
exists (a :: l1).

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
l : list A
a : A
A : Type
*****
ex (fun l2 : list A => and (eq (cons a l) (Datatypes.app (cons a l1) (cons e l2))) (In e (Datatypes.app (cons a l1) l2)))
+++++
exists l2.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
clear IHl.
exists e.
exists (a :: l1).
exists l2.

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
l : list A
a : A
A : Type
*****
and (eq (cons a l) (Datatypes.app (cons a l1) (cons e l2))) (In e (Datatypes.app (cons a l1) l2))
+++++
simpl.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
clear IHl.
exists e.
exists (a :: l1).
exists l2.
simpl.

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
l : list A
a : A
A : Type
*****
and (eq (cons a l) (cons a (Datatypes.app l1 (cons e l2)))) (or (eq a e) (In e (Datatypes.app l1 l2)))
+++++
split.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
clear IHl.
exists e.
exists (a :: l1).
exists l2.
simpl.
split.

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
l : list A
a : A
A : Type
*****
eq (cons a l) (cons a (Datatypes.app l1 (cons e l2)))
+++++
rewrite HEq.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
clear IHl.
exists e.
exists (a :: l1).
exists l2.
simpl.
split.
rewrite HEq.

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
l : list A
a : A
A : Type
*****
eq (cons a (Datatypes.app l1 (cons e l2))) (cons a (Datatypes.app l1 (cons e l2)))
+++++
reflexivity.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
clear IHl.
exists e.
exists (a :: l1).
exists l2.
simpl.
split.

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
l : list A
a : A
A : Type
*****
or (eq a e) (In e (Datatypes.app l1 l2))
+++++
right.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.
intro HDup.
assert (HIn := in_dec HDec a l).
elim HIn.
clear HIn.
intro HIn.
assert (HDup' := NoDup_dec l HDec).
elim HDup'.
clear HDup'.
intro HDup'.
apply IHl in HDup'.
clear HDec.
clear HDup.
clear HIn.
destruct HDup' as [e [l1 [l2 [HEq HIn]]]].
clear IHl.
exists e.
exists (a :: l1).
exists l2.
simpl.
split.
right.

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq l (Datatypes.app l1 (cons e l2))
l1,l2 : list A
e : A
l : list A
a : A
A : Type
*****
In e (Datatypes.app l1 l2)
+++++
assumption.
-----
Lemma NotNoDupDup {A : Type} : forall (l : list A), (forall x y : A, {x = y} + {x <> y}) -> ~ NoDup l-> exists e l1 l2, l = l1 ++ e :: l2 /\\ In e (l1 ++ l2).
Proof.
intros l HDec.
induction l.

*****

*****

+++++
Qed.
-----
Definition pred_conj_aux {T:Type} {n:nat} (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S m)) (cpwd : cartesianPower T n) : Prop.
-----
Definition pred_conj_aux {T:Type} {n:nat} (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S m)) (cpwd : cartesianPower T n) : Prop.

*****
cpwd : cartesianPower T n
cp : cartesianPower T (S m)
m : nat
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
Proof.
-----
Definition pred_conj_aux {T:Type} {n:nat} (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S m)) (cpwd : cartesianPower T n) : Prop.
Proof.

*****
cpwd : cartesianPower T n
cp : cartesianPower T (S m)
m : nat
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
induction m.
-----
Definition pred_conj_aux {T:Type} {n:nat} (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S m)) (cpwd : cartesianPower T n) : Prop.
Proof.
induction m.

*****
cpwd : cartesianPower T n
cp : cartesianPower T (S O)
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
exact (app_1_n pred cp cpwd).
-----
Definition pred_conj_aux {T:Type} {n:nat} (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S m)) (cpwd : cartesianPower T n) : Prop.
Proof.
induction m.

*****
IHm : forall _ : cartesianPower T (S m), Prop
cpwd : cartesianPower T n
cp : cartesianPower T (S (S m))
m : nat
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
exact ((app_1_n pred (headCP cp) cpwd) /\ IHm (tailCP cp)).
-----
Definition pred_conj_aux {T:Type} {n:nat} (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S m)) (cpwd : cartesianPower T n) : Prop.
Proof.
induction m.

*****

*****

+++++
Defined.
-----
Lemma pcaHdTl {T:Type} {n:nat} : forall (pred : arity T (S n)) m cp cpwd,\n  pred_conj_aux pred (S m) cp cpwd = (app_1_n pred (headCP cp) cpwd /\ pred_conj_aux pred m (tailCP cp) cpwd).
-----
Lemma pcaHdTl {T:Type} {n:nat} : forall (pred : arity T (S n)) m cp cpwd, pred_conj_aux pred (S m) cp cpwd = (app_1_n pred (headCP cp) cpwd /\\ pred_conj_aux pred m (tailCP cp) cpwd).

*****
n : nat
T : Type
*****
forall (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S (S m))) (cpwd : cartesianPower T n), eq (pred_conj_aux pred (S m) cp cpwd) (and (app_1_n pred (headCP cp) cpwd) (pred_conj_aux pred m (tailCP cp) cpwd))
+++++
Proof.
-----
Lemma pcaHdTl {T:Type} {n:nat} : forall (pred : arity T (S n)) m cp cpwd, pred_conj_aux pred (S m) cp cpwd = (app_1_n pred (headCP cp) cpwd /\\ pred_conj_aux pred m (tailCP cp) cpwd).
Proof.

*****
n : nat
T : Type
*****
forall (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S (S m))) (cpwd : cartesianPower T n), eq (pred_conj_aux pred (S m) cp cpwd) (and (app_1_n pred (headCP cp) cpwd) (pred_conj_aux pred m (tailCP cp) cpwd))
+++++
unfold pred_conj_aux.
-----
Lemma pcaHdTl {T:Type} {n:nat} : forall (pred : arity T (S n)) m cp cpwd, pred_conj_aux pred (S m) cp cpwd = (app_1_n pred (headCP cp) cpwd /\\ pred_conj_aux pred m (tailCP cp) cpwd).
Proof.
unfold pred_conj_aux.

*****
n : nat
T : Type
*****
forall (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S (S m))) (cpwd : cartesianPower T n), eq (nat_rect (fun m0 : nat => forall _ : cartesianPower T (S m0), Prop) (fun cp0 : cartesianPower T (S O) => app_1_n pred cp0 cpwd) (fun (m0 : nat) (IHm : forall _ : cartesianPower T (S m0), Prop) (cp0 : cartesianPower T (S (S m0))) => and (app_1_n pred (headCP cp0) cpwd) (IHm (tailCP cp0))) (S m) cp) (and (app_1_n pred (headCP cp) cpwd) (nat_rect (fun m0 : nat => forall _ : cartesianPower T (S m0), Prop) (fun cp0 : cartesianPower T (S O) => app_1_n pred cp0 cpwd) (fun (m0 : nat) (IHm : forall _ : cartesianPower T (S m0), Prop) (cp0 : cartesianPower T (S (S m0))) => and (app_1_n pred (headCP cp0) cpwd) (IHm (tailCP cp0))) m (tailCP cp)))
+++++
unfold nat_rect.
-----
Lemma pcaHdTl {T:Type} {n:nat} : forall (pred : arity T (S n)) m cp cpwd, pred_conj_aux pred (S m) cp cpwd = (app_1_n pred (headCP cp) cpwd /\\ pred_conj_aux pred m (tailCP cp) cpwd).
Proof.
unfold pred_conj_aux.
unfold nat_rect.

*****
n : nat
T : Type
*****
forall (pred : arity T (S n)) (m : nat) (cp : cartesianPower T (S (S m))) (cpwd : cartesianPower T n), eq (and (app_1_n pred (headCP cp) cpwd) ((fix F (n : nat) : forall _ : cartesianPower T (S n), Prop := match n as n0 return (forall _ : cartesianPower T (S n0), Prop) with | O => fun cp0 : cartesianPower T (S O) => app_1_n pred cp0 cpwd | S n0 => fun cp0 : cartesianPower T (S (S n0)) => and (app_1_n pred (headCP cp0) cpwd) (F n0 (tailCP cp0)) end) m (tailCP cp))) (and (app_1_n pred (headCP cp) cpwd) ((fix F (n : nat) : forall _ : cartesianPower T (S n), Prop := match n as n0 return (forall _ : cartesianPower T (S n0), Prop) with | O => fun cp0 : cartesianPower T (S O) => app_1_n pred cp0 cpwd | S n0 => fun cp0 : cartesianPower T (S (S n0)) => and (app_1_n pred (headCP cp0) cpwd) (F n0 (tailCP cp0)) end) m (tailCP cp)))
+++++
reflexivity.
-----
Lemma pcaHdTl {T:Type} {n:nat} : forall (pred : arity T (S n)) m cp cpwd, pred_conj_aux pred (S m) cp cpwd = (app_1_n pred (headCP cp) cpwd /\\ pred_conj_aux pred m (tailCP cp) cpwd).
Proof.
unfold pred_conj_aux.
unfold nat_rect.
reflexivity.

*****

*****

+++++
Qed.
-----
Definition pred_conj {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T (S n)) (cpwd : cartesianPower T n) : Prop.
-----
Definition pred_conj {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T (S n)) (cpwd : cartesianPower T n) : Prop.

*****
cpwd : cartesianPower T n
cp : cartesianPower T (S n)
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
Proof.
-----
Definition pred_conj {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T (S n)) (cpwd : cartesianPower T n) : Prop.
Proof.

*****
cpwd : cartesianPower T n
cp : cartesianPower T (S n)
pred : arity T (S n)
n : nat
T : Type
*****
Prop
+++++
exact (pred_conj_aux pred n cp cpwd).
-----
Definition pred_conj {T:Type} {n:nat} (pred : arity T (S n)) (cp : cartesianPower T (S n)) (cpwd : cartesianPower T n) : Prop.
Proof.
exact (pred_conj_aux pred n cp cpwd).

*****

*****

+++++
Defined.
-----
