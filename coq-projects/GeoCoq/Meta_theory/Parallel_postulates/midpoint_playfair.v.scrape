Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Tarski_dev.Ch12_parallel.
-----
Section midpoint_playfair.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma midpoint_converse_postulate_implies_playfair :\n  midpoint_converse_postulate ->\n  playfair_s_postulate.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : midpoint_converse_postulate, playfair_s_postulate
+++++
Proof.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : midpoint_converse_postulate, playfair_s_postulate
+++++
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.

*****
HCol2 : Col P C1 C2
HPar2 : Par A1 A2 C1 C2
HCol1 : Col P B1 B2
HPar1 : Par A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.

*****
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).

*****
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].

*****
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HB3 : exists B3, Col B1 B2 B3 /\ BetS A2 B3 X).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).

*****
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B3 : Tpoint => and (Col B1 B2 B3) (BetS A2 B3 X))
+++++
assert (H : P <> B1 \/ P <> B2).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).

*****
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (not (eq P B1)) (not (eq P B2))
+++++
elim (par_strict_distinct A1 A2 B1 B2 HPar1); intros.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim (par_strict_distinct A1 A2 B1 B2 HPar1); intros.

*****
H0 : and (not (eq A1 B1))\n (and (not (eq A1 B2))\n (and (not (eq A2 B1)) (and (not (eq A2 B2)) (not (eq B1 B2)))))
H : not (eq A1 A2)
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (not (eq P B1)) (not (eq P B2))
+++++
elim (eq_dec_points P B1); intro; elim (eq_dec_points P B2); intro; treat_equalities; intuition.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).

*****
H : or (not (eq P B1)) (not (eq P B2))
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B3 : Tpoint => and (Col B1 B2 B3) (BetS A2 B3 X))
+++++
elim H; clear H; intro H.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.

*****
H : not (eq P B1)
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B3 : Tpoint => and (Col B1 B2 B3) (BetS A2 B3 X))
+++++
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar X A1 A2 B1
+++++
apply coplanar_perm_22, col_cop__cop with P; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
apply coplanar_perm_22, col_cop__cop with P; Col.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A2 B1 A1 P
+++++
apply coplanar_perm_2, col_cop__cop with B2; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
apply coplanar_perm_22, col_cop__cop with P; Col.
apply coplanar_perm_2, col_cop__cop with B2; Col.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A2 A1 B1 B2
+++++
apply par__coplanar; Par.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A2 P B1)
+++++
intro; apply HPar1; exists A2; split; Col; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col X A1 B1)
+++++
intro; apply H; apply l6_21 with A1 P B1 P; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
intro; apply H; apply l6_21 with A1 P B1 P; Col.

*****
H7 : Col X A1 B1
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A1 P B1)
+++++
intro; apply par_strict_not_col_3 in HPar1; apply HPar1; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
intro; apply H; apply l6_21 with A1 P B1 P; Col.

*****
H7 : Col X A1 B1
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A1 P B1
+++++
assert_diffs; assert_cols; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
HBet : or (and (Bet X B3 A2) (and (not (eq X B3)) (not (eq B3 A2))))\n (and (Bet A1 B3 A2) (and (not (eq A1 B3)) (not (eq B3 A2))))
HCol : Col B1 P B3
B3 : Tpoint
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
+++++
induction HBet; spliter; Between.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
induction HBet; spliter; Between.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H9 : not (eq B3 A2)
H8 : not (eq A1 B3)
H7 : Bet A1 B3 A2
HCol : Col B1 P B3
B3 : Tpoint
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
+++++
assert (Hc : ~ Bet A2 B3 A1) by (intro; apply HPar1; exists B3; assert_cols; split; ColR).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B1 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
induction HBet; spliter; Between.
assert (Hc : ~ Bet A2 B3 A1) by (intro; apply HPar1; exists B3; assert_cols; split; ColR).

*****
Hc : not (Bet A2 B3 A1)
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H9 : not (eq B3 A2)
H8 : not (eq A1 B3)
H7 : Bet A1 B3 A2
HCol : Col B1 P B3
B3 : Tpoint
H : not (eq P B1)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
+++++
exfalso; apply Hc; Between.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.

*****
H : not (eq P B2)
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B3 : Tpoint => and (Col B1 B2 B3) (BetS A2 B3 X))
+++++
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar X A1 A2 B2
+++++
apply coplanar_perm_22, col_cop__cop with P; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
apply coplanar_perm_22, col_cop__cop with P; Col.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A2 B2 A1 P
+++++
apply coplanar_perm_2, col_cop__cop with B1; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
apply coplanar_perm_22, col_cop__cop with P; Col.
apply coplanar_perm_2, col_cop__cop with B1; Col.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A2 A1 B2 B1
+++++
apply par__coplanar; Par.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A2 P B2)
+++++
intro; apply HPar1; exists A2; split; Col; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col X A1 B2)
+++++
intro; apply H; apply l6_21 with A1 P B2 P; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
intro; apply H; apply l6_21 with A1 P B2 P; Col.

*****
H7 : Col X A1 B2
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A1 P B2)
+++++
intro; apply par_strict_not_col_3 in HPar1; apply HPar1; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
intro; apply H; apply l6_21 with A1 P B2 P; Col.

*****
H7 : Col X A1 B2
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A1 P B2
+++++
assert_diffs; assert_cols; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
HBet : or (and (Bet X B3 A2) (and (not (eq X B3)) (not (eq B3 A2))))\n (and (Bet A1 B3 A2) (and (not (eq A1 B3)) (not (eq B3 A2))))
HCol : Col B2 P B3
B3 : Tpoint
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
+++++
induction HBet; spliter; Between.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
induction HBet; spliter; Between.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H9 : not (eq B3 A2)
H8 : not (eq A1 B3)
H7 : Bet A1 B3 A2
HCol : Col B2 P B3
B3 : Tpoint
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
+++++
assert (Hc : ~ Bet A2 B3 A1) by (intro; apply HPar1; exists B3; assert_cols; split; ColR).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
assert (H : P <> B1 \\/ P <> B2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 B2 P) as [B3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists B3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
induction HBet; spliter; Between.
assert (Hc : ~ Bet A2 B3 A1) by (intro; apply HPar1; exists B3; assert_cols; split; ColR).

*****
Hc : not (Bet A2 B3 A1)
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H9 : not (eq B3 A2)
H8 : not (eq A1 B3)
H7 : Bet A1 B3 A2
HCol : Col B2 P B3
B3 : Tpoint
H : not (eq P B2)
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
+++++
exfalso; apply Hc; Between.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).

*****
HB3 : ex (fun B3 : Tpoint => and (Col B1 B2 B3) (BetS A2 B3 X))
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
destruct HB3 as [B3 [HCol3 HBet1]].
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].

*****
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HPB3 : P <> B3).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).

*****
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P B3)
+++++
intro; treat_equalities; apply HPar1.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
intro; treat_equalities; apply HPar1.

*****
HBet1 : BetS A2 P X
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X A1 A2) (Col X B1 B2))
+++++
exists P; unfold BetS in *; spliter; assert_diffs; assert_cols; split; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).

*****
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).

*****
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HC3 : exists C3, Col C1 C2 C3 /\ BetS A2 C3 X).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).

*****
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C3 : Tpoint => and (Col C1 C2 C3) (BetS A2 C3 X))
+++++
assert (H : P <> C1 \/ P <> C2).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).

*****
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (not (eq P C1)) (not (eq P C2))
+++++
elim (par_strict_distinct A1 A2 C1 C2 HPar2); intros.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim (par_strict_distinct A1 A2 C1 C2 HPar2); intros.

*****
H0 : and (not (eq A1 C1))\n (and (not (eq A1 C2))\n (and (not (eq A2 C1)) (and (not (eq A2 C2)) (not (eq C1 C2)))))
H : not (eq A1 A2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (not (eq P C1)) (not (eq P C2))
+++++
elim (eq_dec_points P C1); intro; elim (eq_dec_points P C2); intro; treat_equalities; intuition.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).

*****
H : or (not (eq P C1)) (not (eq P C2))
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C3 : Tpoint => and (Col C1 C2 C3) (BetS A2 C3 X))
+++++
elim H; clear H; intro H.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.

*****
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C3 : Tpoint => and (Col C1 C2 C3) (BetS A2 C3 X))
+++++
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar X A1 A2 C1
+++++
apply coplanar_perm_22, col_cop__cop with P; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
apply coplanar_perm_22, col_cop__cop with P; Col.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A2 C1 A1 P
+++++
apply coplanar_perm_2, col_cop__cop with C2; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
apply coplanar_perm_22, col_cop__cop with P; Col.
apply coplanar_perm_2, col_cop__cop with C2; Col.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A2 A1 C1 C2
+++++
apply par__coplanar; Par.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A2 P C1)
+++++
intro; apply HPar2; exists A2; split; Col; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col X A1 C1)
+++++
intro; apply H; apply l6_21 with A1 P C1 P; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
intro; apply H; apply l6_21 with A1 P C1 P; Col.

*****
H7 : Col X A1 C1
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A1 P C1)
+++++
intro; apply par_strict_not_col_3 in HPar2; apply HPar2; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
intro; apply H; apply l6_21 with A1 P C1 P; Col.

*****
H7 : Col X A1 C1
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A1 P C1
+++++
assert_diffs; assert_cols; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
HBet : or (and (Bet X C3 A2) (and (not (eq X C3)) (not (eq C3 A2))))\n (and (Bet A1 C3 A2) (and (not (eq A1 C3)) (not (eq C3 A2))))
HCol : Col C1 P C3
C3 : Tpoint
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 C3 X) (and (not (eq A2 C3)) (not (eq C3 X)))
+++++
induction HBet; spliter; Between.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
induction HBet; spliter; Between.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H9 : not (eq C3 A2)
H8 : not (eq A1 C3)
H7 : Bet A1 C3 A2
HCol : Col C1 P C3
C3 : Tpoint
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
H12 : not (eq B3 X)
H11 : not (eq A2 B3)
H10 : Bet A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 C3 X) (and (not (eq A2 C3)) (not (eq C3 X)))
+++++
assert (Hc : ~ Bet A2 C3 A1) by (intro; apply HPar2; exists C3; assert_cols; split; ColR).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C1 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
induction HBet; spliter; Between.
assert (Hc : ~ Bet A2 C3 A1) by (intro; apply HPar2; exists C3; assert_cols; split; ColR).

*****
Hc : not (Bet A2 C3 A1)
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H9 : not (eq C3 A2)
H8 : not (eq A1 C3)
H7 : Bet A1 C3 A2
HCol : Col C1 P C3
C3 : Tpoint
H : not (eq P C1)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
H12 : not (eq B3 X)
H11 : not (eq A2 B3)
H10 : Bet A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 C3 X) (and (not (eq A2 C3)) (not (eq C3 X)))
+++++
exfalso; apply Hc; Between.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.

*****
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C3 : Tpoint => and (Col C1 C2 C3) (BetS A2 C3 X))
+++++
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar X A1 A2 C2
+++++
apply coplanar_perm_22, col_cop__cop with P; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
apply coplanar_perm_22, col_cop__cop with P; Col.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A2 C2 A1 P
+++++
apply coplanar_perm_2, col_cop__cop with C1; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
apply coplanar_perm_22, col_cop__cop with P; Col.
apply coplanar_perm_2, col_cop__cop with C1; Col.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A2 A1 C2 C1
+++++
apply par__coplanar; Par.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A2 P C2)
+++++
intro; apply HPar2; exists A2; split; Col; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col X A1 C2)
+++++
intro; apply H; apply l6_21 with A1 P C2 P; Col.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
intro; apply H; apply l6_21 with A1 P C2 P; Col.

*****
H7 : Col X A1 C2
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A1 P C2)
+++++
intro; apply par_strict_not_col_3 in HPar2; apply HPar2; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
intro; apply H; apply l6_21 with A1 P C2 P; Col.

*****
H7 : Col X A1 C2
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A1 P C2
+++++
assert_diffs; assert_cols; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
HBet : or (and (Bet X C3 A2) (and (not (eq X C3)) (not (eq C3 A2))))\n (and (Bet A1 C3 A2) (and (not (eq A1 C3)) (not (eq C3 A2))))
HCol : Col C2 P C3
C3 : Tpoint
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : and (Bet A2 B3 X) (and (not (eq A2 B3)) (not (eq B3 X)))
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 C3 X) (and (not (eq A2 C3)) (not (eq C3 X)))
+++++
induction HBet; spliter; Between.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
induction HBet; spliter; Between.

*****
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H9 : not (eq C3 A2)
H8 : not (eq A1 C3)
H7 : Bet A1 C3 A2
HCol : Col C2 P C3
C3 : Tpoint
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
H12 : not (eq B3 X)
H11 : not (eq A2 B3)
H10 : Bet A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 C3 X) (and (not (eq A2 C3)) (not (eq C3 X)))
+++++
assert (Hc : ~ Bet A2 C3 A1) by (intro; apply HPar2; exists C3; assert_cols; split; ColR).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
assert (H : P <> C1 \\/ P <> C2).
elim H; clear H; intro H.
destruct (hilbert_s_version_of_pasch X A1 A2 C2 P) as [C3 [HCol HBet]]; assert_diffs; unfold Midpoint in *; spliter; try (exists C3; split); Col; unfold BetS in *; try ColR; [..|repeat split; Between|].
induction HBet; spliter; Between.
assert (Hc : ~ Bet A2 C3 A1) by (intro; apply HPar2; exists C3; assert_cols; split; ColR).

*****
Hc : not (Bet A2 C3 A1)
H4 : not (eq B1 B2)
H3 : not (eq C1 C2)
H0 : not (eq A1 A2)
H2 : not (eq P X)
H1 : not (eq A1 X)
H9 : not (eq C3 A2)
H8 : not (eq A1 C3)
H7 : Bet A1 C3 A2
HCol : Col C2 P C3
C3 : Tpoint
H : not (eq P C2)
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
H12 : not (eq B3 X)
H11 : not (eq A2 B3)
H10 : Bet A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
H6 : Cong A1 P P X
H5 : Bet A1 P X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A2 C3 X) (and (not (eq A2 C3)) (not (eq C3 X)))
+++++
exfalso; apply Hc; Between.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).

*****
HC3 : ex (fun C3 : Tpoint => and (Col C1 C2 C3) (BetS A2 C3 X))
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
destruct HC3 as [C3 [HCol4 HBet2]].
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].

*****
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HPC3 : P <> C3).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).

*****
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P C3)
+++++
intro; treat_equalities; apply HPar1.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).
intro; treat_equalities; apply HPar1.

*****
HBet2 : BetS A2 P X
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X A1 A2) (Col X B1 B2))
+++++
exists P; unfold BetS in *; spliter; assert_diffs; assert_cols; split; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).

*****
HPC3 : not (eq P C3)
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HPar4 : Par A1 A2 P C3) by (apply par_col2_par with C1 C2; try ColR; try left; Par).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).
assert (HPar4 : Par A1 A2 P C3) by (apply par_col2_par with C1 C2; try ColR; try left; Par).

*****
HPar4 : Par A1 A2 P C3
HPC3 : not (eq P C3)
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HCol5 : Col A2 X B3) by (unfold BetS in *; spliter; assert_cols; Col).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).
assert (HPar4 : Par A1 A2 P C3) by (apply par_col2_par with C1 C2; try ColR; try left; Par).
assert (HCol5 : Col A2 X B3) by (unfold BetS in *; spliter; assert_cols; Col).

*****
HCol5 : Col A2 X B3
HPar4 : Par A1 A2 P C3
HPC3 : not (eq P C3)
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HCol6 : Col A2 X C3) by (unfold BetS in *; spliter; assert_cols; Col).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).
assert (HPar4 : Par A1 A2 P C3) by (apply par_col2_par with C1 C2; try ColR; try left; Par).
assert (HCol5 : Col A2 X B3) by (unfold BetS in *; spliter; assert_cols; Col).
assert (HCol6 : Col A2 X C3) by (unfold BetS in *; spliter; assert_cols; Col).

*****
HCol6 : Col A2 X C3
HCol5 : Col A2 X B3
HPar4 : Par A1 A2 P C3
HPC3 : not (eq P C3)
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (HNC' : ~ Col A1 A2 X) by (intro; apply HPar1; exists P; assert_diffs; assert_cols; split; ColR).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).
assert (HPar4 : Par A1 A2 P C3) by (apply par_col2_par with C1 C2; try ColR; try left; Par).
assert (HCol5 : Col A2 X B3) by (unfold BetS in *; spliter; assert_cols; Col).
assert (HCol6 : Col A2 X C3) by (unfold BetS in *; spliter; assert_cols; Col).
assert (HNC' : ~ Col A1 A2 X) by (intro; apply HPar1; exists P; assert_diffs; assert_cols; split; ColR).

*****
HNC' : not (Col A1 A2 X)
HCol6 : Col A2 X C3
HCol5 : Col A2 X B3
HPar4 : Par A1 A2 P C3
HPC3 : not (eq P C3)
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
assert (B3 = C3) by (apply l7_17 with A2 X; apply HT with A1 P; Col; Par).
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).
assert (HPar4 : Par A1 A2 P C3) by (apply par_col2_par with C1 C2; try ColR; try left; Par).
assert (HCol5 : Col A2 X B3) by (unfold BetS in *; spliter; assert_cols; Col).
assert (HCol6 : Col A2 X C3) by (unfold BetS in *; spliter; assert_cols; Col).
assert (HNC' : ~ Col A1 A2 X) by (intro; apply HPar1; exists P; assert_diffs; assert_cols; split; ColR).
assert (B3 = C3) by (apply l7_17 with A2 X; apply HT with A1 P; Col; Par).

*****
H : eq B3 C3
HNC' : not (Col A1 A2 X)
HCol6 : Col A2 X C3
HCol5 : Col A2 X B3
HPar4 : Par A1 A2 P C3
HPC3 : not (eq P C3)
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
elim (par_strict_distinct A1 A2 B1 B2 HPar1); intros.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).
assert (HPar4 : Par A1 A2 P C3) by (apply par_col2_par with C1 C2; try ColR; try left; Par).
assert (HCol5 : Col A2 X B3) by (unfold BetS in *; spliter; assert_cols; Col).
assert (HCol6 : Col A2 X C3) by (unfold BetS in *; spliter; assert_cols; Col).
assert (HNC' : ~ Col A1 A2 X) by (intro; apply HPar1; exists P; assert_diffs; assert_cols; split; ColR).
assert (B3 = C3) by (apply l7_17 with A2 X; apply HT with A1 P; Col; Par).
elim (par_strict_distinct A1 A2 B1 B2 HPar1); intros.

*****
H1 : and (not (eq A1 B1))\n (and (not (eq A1 B2))\n (and (not (eq A2 B1)) (and (not (eq A2 B2)) (not (eq B1 B2)))))
H0 : not (eq A1 A2)
H : eq B3 C3
HNC' : not (Col A1 A2 X)
HCol6 : Col A2 X C3
HCol5 : Col A2 X B3
HPar4 : Par A1 A2 P C3
HPC3 : not (eq P C3)
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
elim (par_strict_distinct A1 A2 C1 C2 HPar2); intros.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
assert (HDiff : P <> A1) by (intro; treat_equalities; apply HPar1; exists P; Col).
assert (HX := symmetric_point_construction A1 P); destruct HX as [X HMid1].
assert (HB3 : exists B3, Col B1 B2 B3 /\\ BetS A2 B3 X).
destruct HB3 as [B3 [HCol3 HBet1]].
assert (HPB3 : P <> B3).
assert (HPar3 : Par A1 A2 P B3) by (apply par_col2_par with B1 B2; try ColR; try left; Par).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ BetS A2 C3 X).
destruct HC3 as [C3 [HCol4 HBet2]].
assert (HPC3 : P <> C3).
assert (HPar4 : Par A1 A2 P C3) by (apply par_col2_par with C1 C2; try ColR; try left; Par).
assert (HCol5 : Col A2 X B3) by (unfold BetS in *; spliter; assert_cols; Col).
assert (HCol6 : Col A2 X C3) by (unfold BetS in *; spliter; assert_cols; Col).
assert (HNC' : ~ Col A1 A2 X) by (intro; apply HPar1; exists P; assert_diffs; assert_cols; split; ColR).
assert (B3 = C3) by (apply l7_17 with A2 X; apply HT with A1 P; Col; Par).
elim (par_strict_distinct A1 A2 B1 B2 HPar1); intros.
elim (par_strict_distinct A1 A2 C1 C2 HPar2); intros.

*****
H3 : and (not (eq A1 C1))\n (and (not (eq A1 C2))\n (and (not (eq A2 C1)) (and (not (eq A2 C2)) (not (eq C1 C2)))))
H2 : not (eq A1 A2)
H1 : and (not (eq A1 B1))\n (and (not (eq A1 B2))\n (and (not (eq A2 B1)) (and (not (eq A2 B2)) (not (eq B1 B2)))))
H0 : not (eq A1 A2)
H : eq B3 C3
HNC' : not (Col A1 A2 X)
HCol6 : Col A2 X C3
HCol5 : Col A2 X B3
HPar4 : Par A1 A2 P C3
HPC3 : not (eq P C3)
HBet2 : BetS A2 C3 X
HCol4 : Col C1 C2 C3
C3 : Tpoint
HPar3 : Par A1 A2 P B3
HPB3 : not (eq P B3)
HBet1 : BetS A2 B3 X
HCol3 : Col B1 B2 B3
B3 : Tpoint
HMid1 : Midpoint P A1 X
X : Tpoint
HDiff : not (eq P A1)
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
spliter; treat_equalities; split; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.

*****
HPar2 : and (not (eq A1 A2))\n (and (not (eq C1 C2)) (and (Col A1 C1 C2) (Col A2 C1 C2)))
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
elim (par_strict_distinct A1 A2 B1 B2 HPar1); intros; spliter; exfalso; apply HPar1.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
elim (par_strict_distinct A1 A2 B1 B2 HPar1); intros; spliter; exfalso; apply HPar1.

*****
H4 : not (eq B1 B2)
H3 : not (eq A2 B2)
H2 : not (eq A2 B1)
H1 : not (eq A1 B2)
H0 : not (eq A1 B1)
H : not (eq A1 A2)
H8 : Col A2 C1 C2
H7 : Col A1 C1 C2
H6 : not (eq C1 C2)
H5 : not (eq A1 A2)
HPar1 : Par_strict A1 A2 B1 B2
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X A1 A2) (Col X B1 B2))
+++++
exists P; split; Col; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.

*****
HPar2 : Par_strict A1 A2 C1 C2
HPar1 : and (not (eq A1 A2))\n (and (not (eq B1 B2)) (and (Col A1 B1 B2) (Col A2 B1 B2)))
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
elim (par_strict_distinct A1 A2 C1 C2 HPar2); intros; spliter; exfalso; apply HPar2.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.
elim (par_strict_distinct A1 A2 C1 C2 HPar2); intros; spliter; exfalso; apply HPar2.

*****
H4 : not (eq C1 C2)
H3 : not (eq A2 C2)
H2 : not (eq A2 C1)
H1 : not (eq A1 C2)
H0 : not (eq A1 C1)
H : not (eq A1 A2)
HPar2 : Par_strict A1 A2 C1 C2
H8 : Col A2 B1 B2
H7 : Col A1 B1 B2
H6 : not (eq B1 B2)
H5 : not (eq A1 A2)
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X A1 A2) (Col X C1 C2))
+++++
exists P; split; Col; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.

*****
HPar2 : and (not (eq A1 A2))\n (and (not (eq C1 C2)) (and (Col A1 C1 C2) (Col A2 C1 C2)))
HPar1 : and (not (eq A1 A2))\n (and (not (eq B1 B2)) (and (Col A1 B1 B2) (Col A2 B1 B2)))
HCol2 : Col P C1 C2
HCol1 : Col P B1 B2
A1,A2,B1,B2,C1,C2,P : Tpoint
HT : midpoint_converse_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col C1 B1 B2) (Col C2 B1 B2)
+++++
spliter; spliter; split; Col; ColR.
-----
Lemma midpoint_converse_postulate_implies_playfair : midpoint_converse_postulate -> playfair_s_postulate.
Proof.
intros HT A1 A2 B1 B2 C1 C2 P HPar1 HCol1 HPar2 HCol2.
elim HPar1; clear HPar1; intro HPar1; elim HPar2; clear HPar2; intro HPar2.

*****

*****

+++++
Qed.
-----
End midpoint_playfair.
-----
