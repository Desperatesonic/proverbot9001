Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Meta_theory.Parallel_postulates.tarski_s_euclid_remove_degenerated_cases.
-----
Require Import GeoCoq.Tarski_dev.Ch12_parallel.
-----
Section SPP_tarski.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma impossible_case_5 : forall P Q R S T U I,\n  BetS P T Q ->\n  BetS R T S ->\n  BetS Q U R ->\n  ~ Col P Q S ->\n  ~ Col P R U ->\n  Par P R Q S ->\n  Par P S Q R ->\n  Bet S Q I ->\n  Bet U I P ->\n  False.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q R S T U I : Tpoint) (_ : BetS P T Q) (_ : BetS R T S) (_ : BetS Q U R) (_ : not (Col P Q S)) (_ : not (Col P R U)) (_ : Par P R Q S) (_ : Par P S Q R) (_ : Bet S Q I) (_ : Bet U I P), False
+++++
Proof.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q R S T U I : Tpoint) (_ : BetS P T Q) (_ : BetS R T S) (_ : BetS Q U R) (_ : not (Col P Q S)) (_ : not (Col P R U)) (_ : Par P R Q S) (_ : Par P S Q R) (_ : Bet S Q I) (_ : Bet U I P), False
+++++
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.

*****
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : BetS R T S
HPTQ : BetS P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HPTQ.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.

*****
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : BetS R T S
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HRTS.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.

*****
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HQUR.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.

*****
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTS : TS Q S P U).
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).

*****
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS Q S P U
+++++
assert_diffs.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.

*****
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS Q S P U
+++++
spliter.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.

*****
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS Q S P U
+++++
assert_cols.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.
assert_cols.

*****
H23 : Col P T Q
H22 : Col R T S
H21 : Col Q U R
H20 : Col S Q I
H19 : Col U I P
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS Q S P U
+++++
repeat split.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.
assert_cols.
repeat split.

*****
H23 : Col P T Q
H22 : Col R T S
H21 : Col Q U R
H20 : Col S Q I
H19 : Col U I P
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col P Q S)
+++++
Col.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.
assert_cols.
repeat split.

*****
H23 : Col P T Q
H22 : Col R T S
H21 : Col Q U R
H20 : Col S Q I
H19 : Col U I P
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col U Q S)
+++++
Col.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.

*****
H23 : Col P T Q
H22 : Col R T S
H21 : Col Q U R
H20 : Col S Q I
H19 : Col U I P
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col U Q S)
+++++
try (exists I; Col; Between).
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.
try (exists I; Col; Between).

*****
H23 : Col P T Q
H22 : Col R T S
H21 : Col Q U R
H20 : Col S Q I
H19 : Col U I P
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col U Q S)
+++++
intro.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.
try (exists I; Col; Between).
intro.

*****
H24 : Col U Q S
H23 : Col P T Q
H22 : Col R T S
H21 : Col Q U R
H20 : Col S Q I
H19 : Col U I P
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNC'.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.
try (exists I; Col; Between).
intro.
apply HNC'.

*****
H24 : Col U Q S
H23 : Col P T Q
H22 : Col R T S
H21 : Col Q U R
H20 : Col S Q I
H19 : Col U I P
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P R U
+++++
ColR...
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.
assert_cols.
repeat split.

*****
H23 : Col P T Q
H22 : Col R T S
H21 : Col Q U R
H20 : Col S Q I
H19 : Col U I P
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T Q S) (Bet P T U))
+++++
Col.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.

*****
H23 : Col P T Q
H22 : Col R T S
H21 : Col Q U R
H20 : Col S Q I
H19 : Col U I P
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H10 : not (eq U R)
H9 : not (eq Q R)
H8 : not (eq Q U)
H6 : Bet Q U R
H14 : not (eq T S)
H13 : not (eq R S)
H12 : not (eq R T)
H11 : Bet R T S
H18 : not (eq T Q)
H17 : not (eq P Q)
H16 : not (eq P T)
H15 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T Q S) (Bet P T U))
+++++
try (exists I; Col; Between).
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).

*****
HTS : TS Q S P U
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.

*****
HTS : TS Q S P U
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply l9_9 in HTS.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HTS.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Q S P U
+++++
apply one_side_transitivity with R.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Q S P R
+++++
apply l12_6.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
apply l12_6.

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict Q S P R
+++++
apply par_not_col_strict with P.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
apply l12_6.
apply par_not_col_strict with P.

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par Q S P R
+++++
Col.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
apply l12_6.
apply par_not_col_strict with P.
Col.

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par Q S P R
+++++
Par.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
apply l12_6.
apply par_not_col_strict with P.

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P R P
+++++
Col.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
apply l12_6.
apply par_not_col_strict with P.

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q S P)
+++++
Col.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Q S R U
+++++
assert (HQS : Q <> S).
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).

*****
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q S)
+++++
assert_diffs.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
assert_diffs.

*****
H0 : not (eq Q R)
H : not (eq S I)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q S)
+++++
assumption.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).

*****
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Q S R U
+++++
idtac.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.

*****
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Q S R U
+++++
assert (HQSQ : Col Q S Q).
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).

*****
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Q S Q
+++++
Col.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).

*****
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Q S R U
+++++
idtac.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.

*****
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Q S R U
+++++
assert (HRUQ : Col R U Q).
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).

*****
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col R U Q
+++++
spliter.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
spliter.

*****
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col R U Q
+++++
assert_cols.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
spliter.
assert_cols.

*****
H15 : Col P T Q
H14 : Col R T S
H13 : Col Q U R
H12 : Col S Q I
H11 : Col U I P
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col R U Q
+++++
Col.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Q S R U
+++++
idtac.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Q S R U
+++++
rewrite (l9_19 Q S R U Q HQSQ HRUQ).
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.
rewrite (l9_19 Q S R U Q HQSQ HRUQ).

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out Q R U) (not (Col Q S R))
+++++
split.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.
rewrite (l9_19 Q S R U Q HQSQ HRUQ).
split.

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Q R U
+++++
spliter.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.
rewrite (l9_19 Q S R U Q HQSQ HRUQ).
split.
spliter.

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Q R U
+++++
try (intro; apply HNC; assert_cols; ColR).
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.
rewrite (l9_19 Q S R U Q HQSQ HRUQ).
split.
spliter.
try (intro; apply HNC; assert_cols; ColR).

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Q R U
+++++
repeat split.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.
rewrite (l9_19 Q S R U Q HQSQ HRUQ).
split.
spliter.
try (intro; apply HNC; assert_cols; ColR).
repeat split.

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq R Q)
+++++
Between.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.
rewrite (l9_19 Q S R U Q HQSQ HRUQ).
split.
spliter.
try (intro; apply HNC; assert_cols; ColR).
repeat split.

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq U Q)
+++++
Between.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.
rewrite (l9_19 Q S R U Q HQSQ HRUQ).
split.
spliter.
try (intro; apply HNC; assert_cols; ColR).
repeat split.

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet Q R U) (Bet Q U R)
+++++
Between.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.
rewrite (l9_19 Q S R U Q HQSQ HRUQ).
split.

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q S R)
+++++
spliter.
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).
idtac.
apply l9_9 in HTS.
apply HTS.
apply one_side_transitivity with R.
assert (HQS : Q <> S).
idtac.
assert (HQSQ : Col Q S Q).
idtac.
assert (HRUQ : Col R U Q).
idtac.
rewrite (l9_19 Q S R U Q HQSQ HRUQ).
split.
spliter.

*****
HRUQ : Col R U Q
HQSQ : Col Q S Q
HQS : not (eq Q S)
HTS : not (OS Q S P U)
HPUI : Bet U I P
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q S R)
+++++
try (intro; apply HNC; assert_cols; ColR).
-----
Lemma impossible_case_5 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet U I P -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
assert (HTS : TS Q S P U).

*****

*****

+++++
Qed.
-----
Lemma impossible_case_6 : forall P Q R S T U I,\n  BetS P T Q ->\n  BetS R T S ->\n  BetS Q U R ->\n  ~ Col P Q S ->\n  ~ Col P R U ->\n  Par P R Q S ->\n  Par P S Q R ->\n  Bet S Q I ->\n  Bet I P U ->\n  False.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q R S T U I : Tpoint) (_ : BetS P T Q) (_ : BetS R T S) (_ : BetS Q U R) (_ : not (Col P Q S)) (_ : not (Col P R U)) (_ : Par P R Q S) (_ : Par P S Q R) (_ : Bet S Q I) (_ : Bet I P U), False
+++++
Proof.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q R S T U I : Tpoint) (_ : BetS P T Q) (_ : BetS R T S) (_ : BetS Q U R) (_ : not (Col P Q S)) (_ : not (Col P R U)) (_ : Par P R Q S) (_ : Par P S Q R) (_ : Bet S Q I) (_ : Bet I P U), False
+++++
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.

*****
HPUI : Bet I P U
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : BetS R T S
HPTQ : BetS P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HPTQ.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.

*****
HPUI : Bet I P U
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : BetS R T S
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HRTS.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.

*****
HPUI : Bet I P U
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HQUR.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.

*****
HPUI : Bet I P U
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply between_symmetry in HPUI.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.

*****
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].

*****
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HParS : Par_strict P S Q U).
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).

*****
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict P S Q U
+++++
apply par_not_col_strict with R.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.

*****
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par P S Q U
+++++
spliter.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
spliter.

*****
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par P S Q U
+++++
assert_cols.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
spliter.
assert_cols.

*****
H17 : Col P T Q
H16 : Col R T S
H15 : Col Q U R
H14 : Col S Q I
H13 : Col U P I
H12 : Col Q J U
H11 : Col P J S
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par P S Q U
+++++
apply par_col_par with R.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
spliter.
assert_cols.
apply par_col_par with R.

*****
H17 : Col P T Q
H16 : Col R T S
H15 : Col Q U R
H14 : Col S Q I
H13 : Col U P I
H12 : Col Q J U
H11 : Col P J S
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q U)
+++++
Par.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
spliter.
assert_cols.
apply par_col_par with R.

*****
H17 : Col P T Q
H16 : Col R T S
H15 : Col Q U R
H14 : Col S Q I
H13 : Col U P I
H12 : Col Q J U
H11 : Col P J S
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par P S Q R
+++++
Par.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
spliter.
assert_cols.
apply par_col_par with R.

*****
H17 : Col P T Q
H16 : Col R T S
H15 : Col Q U R
H14 : Col S Q I
H13 : Col U P I
H12 : Col Q J U
H11 : Col P J S
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Q R U
+++++
Par.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
spliter.
assert_cols.
apply par_col_par with R.
Par.

*****
H17 : Col P T Q
H16 : Col R T S
H15 : Col Q U R
H14 : Col S Q I
H13 : Col U P I
H12 : Col Q J U
H11 : Col P J S
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Q R U
+++++
ColR.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.

*****
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Q U R
+++++
spliter.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
spliter.

*****
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Q U R
+++++
assert_cols.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
spliter.
assert_cols.

*****
H17 : Col P T Q
H16 : Col R T S
H15 : Col Q U R
H14 : Col S Q I
H13 : Col U P I
H12 : Col Q J U
H11 : Col P J S
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Q U R
+++++
ColR.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.

*****
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col P S R)
+++++
intro.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
intro.

*****
H : Col P S R
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNC.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
intro.
apply HNC.

*****
H : Col P S R
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q S
+++++
spliter.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
intro.
apply HNC.
spliter.

*****
H : Col P S R
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H3 : not (eq U R)
H2 : not (eq Q R)
H1 : not (eq Q U)
H0 : Bet Q U R
H7 : not (eq T S)
H6 : not (eq R S)
H5 : not (eq R T)
H4 : Bet R T S
H11 : not (eq T Q)
H10 : not (eq P Q)
H9 : not (eq P T)
H8 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q S
+++++
assert_cols.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply par_not_col_strict with R.
intro.
apply HNC.
spliter.
assert_cols.

*****
H18 : Col P T Q
H17 : Col R T S
H16 : Col Q U R
H15 : Col S Q I
H14 : Col U P I
H13 : Col Q J U
H12 : Col P J S
H : Col P S R
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H3 : not (eq U R)
H2 : not (eq Q R)
H1 : not (eq Q U)
H0 : Bet Q U R
H7 : not (eq T S)
H6 : not (eq R S)
H5 : not (eq R T)
H4 : Bet R T S
H11 : not (eq T Q)
H10 : not (eq P Q)
H9 : not (eq P T)
H8 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q S
+++++
ColR.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).

*****
HParS : Par_strict P S Q U
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HParS.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply HParS.

*****
HParS : Par_strict P S Q U
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X P S) (Col X Q U))
+++++
exists J.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply HParS.
exists J.

*****
HParS : Par_strict P S Q U
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col J P S) (Col J Q U)
+++++
assert_cols.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).
apply HParS.
exists J.
assert_cols.

*****
H2 : Col S Q I
H1 : Col U P I
H0 : Col Q J U
H : Col P J S
HParS : Par_strict P S Q U
HBet2 : Bet P J S
HBet1 : Bet Q J U
J : Tpoint
HPUI : Bet U P I
HSQI : Bet S Q I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col J P S) (Col J Q U)
+++++
Col.
-----
Lemma impossible_case_6 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Bet S Q I -> Bet I P U -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HSQI HPUI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
apply between_symmetry in HPUI.
destruct (inner_pasch S U I Q P HSQI HPUI) as [J [HBet1 HBet2]].
assert (HParS : Par_strict P S Q U).

*****

*****

+++++
Qed.
-----
Lemma impossible_case_7 : forall P Q R S T U I,\n  BetS P T Q ->\n  BetS R T S ->\n  BetS Q U R ->\n  ~ Col P Q S ->\n  ~ Col P R U ->\n  Par P R Q S ->\n  Par P S Q R ->\n  Col P U I ->\n  Bet Q I S ->\n  False.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q R S T U I : Tpoint) (_ : BetS P T Q) (_ : BetS R T S) (_ : BetS Q U R) (_ : not (Col P Q S)) (_ : not (Col P R U)) (_ : Par P R Q S) (_ : Par P S Q R) (_ : Col P U I) (_ : Bet Q I S), False
+++++
Proof.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q R S T U I : Tpoint) (_ : BetS P T Q) (_ : BetS R T S) (_ : BetS Q U R) (_ : not (Col P Q S)) (_ : not (Col P R U)) (_ : Par P R Q S) (_ : Par P S Q R) (_ : Col P U I) (_ : Bet Q I S), False
+++++
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.

*****
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : BetS R T S
HPTQ : BetS P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HPTQ.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.

*****
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : BetS R T S
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HRTS.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.

*****
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HQUR.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.

*****
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
elim (eq_dec_points I S).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).

*****
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq I S, False
+++++
intro HIS.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.

*****
HIS : eq I S
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HParS : Par_strict Q R P I).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict Q R P I
+++++
apply par_not_col_strict with P.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par Q R P I
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.
Col.

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par Q R P I
+++++
Par.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P I P
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q R P)
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.
Col.

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q R P)
+++++
Par.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.
Col.
Par.

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q R P)
+++++
unfold BetS in *.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.
Col.
Par.
unfold BetS in *.

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q R P)
+++++
spliter.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.
Col.
Par.
unfold BetS in *.
spliter.

*****
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T I)
H5 : not (eq R I)
H4 : not (eq R T)
H3 : Bet R T I
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q R P)
+++++
assert_cols.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.
Col.
Par.
unfold BetS in *.
spliter.
assert_cols.

*****
H13 : Col P T Q
H12 : Col R T I
H11 : Col Q U R
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T I)
H5 : not (eq R I)
H4 : not (eq R T)
H3 : Bet R T I
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q R P)
+++++
intro.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.
Col.
Par.
unfold BetS in *.
spliter.
assert_cols.
intro.

*****
H14 : Col Q R P
H13 : Col P T Q
H12 : Col R T I
H11 : Col Q U R
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T I)
H5 : not (eq R I)
H4 : not (eq R T)
H3 : Bet R T I
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNC'.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
apply par_not_col_strict with P.
Col.
Par.
unfold BetS in *.
spliter.
assert_cols.
intro.
apply HNC'.

*****
H14 : Col Q R P
H13 : Col P T Q
H12 : Col R T I
H11 : Col Q U R
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T I)
H5 : not (eq R I)
H4 : not (eq R T)
H3 : Bet R T I
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P R U
+++++
ColR...
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).

*****
HParS : Par_strict Q R P I
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
idtac.

*****
HParS : Par_strict Q R P I
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HParS.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
idtac.
apply HParS.

*****
HParS : Par_strict Q R P I
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X Q R) (Col X P I))
+++++
exists U.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
idtac.
apply HParS.
exists U.

*****
HParS : Par_strict Q R P I
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T I)\n (and (not (eq R T)) (and (not (eq R I)) (not (eq T I))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U Q R) (Col U P I)
+++++
spliter.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
idtac.
apply HParS.
exists U.
spliter.

*****
HParS : Par_strict Q R P I
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T I)
H5 : not (eq R I)
H4 : not (eq R T)
H3 : Bet R T I
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U Q R) (Col U P I)
+++++
assert_cols.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HParS : Par_strict Q R P I).
idtac.
apply HParS.
exists U.
spliter.
assert_cols.

*****
H13 : Col P T Q
H12 : Col R T I
H11 : Col Q U R
HParS : Par_strict Q R P I
HPUI : Col P U I
HPar1 : Par P R Q I
HPar2 : Par P I Q R
HNC' : not (Col P R U)
HNC : not (Col P Q I)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T I)
H5 : not (eq R I)
H4 : not (eq R T)
H3 : Bet R T I
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U Q R) (Col U P I)
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).

*****
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq I S), False
+++++
intro HIS.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.

*****
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.

*****
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HTS : TS P U Q S).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).

*****
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U Q S
+++++
assert_diffs.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.

*****
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U Q S
+++++
spliter.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.

*****
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U Q S
+++++
assert_cols.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.

*****
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U Q S
+++++
repeat split.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.

*****
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q P U)
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.

*****
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q P U)
+++++
try (exists I; Col; Between).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.
try (exists I; Col; Between).

*****
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q P U)
+++++
intro.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.
try (exists I; Col; Between).
intro.

*****
H22 : Col Q P U
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNC.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.
try (exists I; Col; Between).
intro.
apply HNC.

*****
H22 : Col Q P U
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q S
+++++
ColR...
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.

*****
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col S P U)
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.

*****
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col S P U)
+++++
try (exists I; Col; Between).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.
try (exists I; Col; Between).

*****
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col S P U)
+++++
intro.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.
try (exists I; Col; Between).
intro.

*****
H22 : Col S P U
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNC.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.
try (exists I; Col; Between).
intro.
apply HNC.

*****
H22 : Col S P U
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q S
+++++
ColR...
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.

*****
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T P U) (Bet Q T S))
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
assert_diffs.
spliter.
assert_cols.
repeat split.
Col.

*****
H21 : Col P T Q
H20 : Col R T S
H19 : Col Q U R
H18 : Col Q I S
H : not (eq Q R)
H7 : not (eq P S)
H3 : not (eq Q S)
H5 : not (eq P Q)
H4 : not (eq P U)
H1 : not (eq R U)
H2 : not (eq P R)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H9 : not (eq U R)
H8 : not (eq Q R)
H6 : not (eq Q U)
H0 : Bet Q U R
H13 : not (eq T S)
H12 : not (eq R S)
H11 : not (eq R T)
H10 : Bet R T S
H17 : not (eq T Q)
H16 : not (eq P Q)
H15 : not (eq P T)
H14 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T P U) (Bet Q T S))
+++++
try (exists I; Col; Between).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).

*****
HTS : TS P U Q S
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.

*****
HTS : TS P U Q S
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply l9_9 in HTS.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.

*****
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HTS.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.

*****
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS P U Q S
+++++
exists R.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.

*****
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (TS P U Q R) (TS P U S R)
+++++
split.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.

*****
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U Q R
+++++
spliter.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.

*****
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U Q R
+++++
assert_diffs.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.
assert_diffs.

*****
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U Q R
+++++
assert_cols.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.
assert_diffs.
assert_cols.

*****
H17 : Col P T Q
H15 : Col R T S
H12 : Col Q U R
H11 : Col Q I S
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U Q R
+++++
split.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.
assert_diffs.
assert_cols.
split.

*****
H17 : Col P T Q
H15 : Col R T S
H12 : Col Q U R
H11 : Col Q I S
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col Q P U)
+++++
try (intro; apply HNC; ColR).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.
assert_diffs.
assert_cols.
split.

*****
H17 : Col P T Q
H15 : Col R T S
H12 : Col Q U R
H11 : Col Q I S
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col R P U)) (ex (fun T : Tpoint => and (Col T P U) (Bet Q T R)))
+++++
try (intro; apply HNC; ColR).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).

*****
H17 : Col P T Q
H15 : Col R T S
H12 : Col Q U R
H11 : Col Q I S
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col R P U)) (ex (fun T : Tpoint => and (Col T P U) (Bet Q T R)))
+++++
split.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.

*****
H17 : Col P T Q
H15 : Col R T S
H12 : Col Q U R
H11 : Col Q I S
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col R P U)
+++++
try (intro; apply HNC; ColR).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.

*****
H17 : Col P T Q
H15 : Col R T S
H12 : Col Q U R
H11 : Col Q I S
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T P U) (Bet Q T R))
+++++
try (intro; apply HNC; ColR).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.
try (intro; apply HNC; ColR).

*****
H17 : Col P T Q
H15 : Col R T S
H12 : Col Q U R
H11 : Col Q I S
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T P U) (Bet Q T R))
+++++
exists U.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.
try (intro; apply HNC; ColR).
exists U.

*****
H17 : Col P T Q
H15 : Col R T S
H12 : Col Q U R
H11 : Col Q I S
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
H : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U P U) (Bet Q U R)
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.

*****
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
destruct HPTQ as [HPTQ HDiff1].
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].

*****
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HDiff1 : and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q)))
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
destruct HQUR as [HQUR HDiff2].
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].

*****
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HDiff2 : and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R)))
HQUR : Bet Q U R
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HDiff1 : and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q)))
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
apply between_symmetry in HQUR.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.

*****
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HDiff2 : and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R)))
HQUR : Bet R U Q
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HDiff1 : and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q)))
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].

*****
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HDiff2 : and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R)))
HQUR : Bet R U Q
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HDiff1 : and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q)))
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
assert (HRJS : Bet R J S).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).

*****
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HDiff2 : and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R)))
HQUR : Bet R U Q
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HDiff1 : and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q)))
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet R J S
+++++
spliter.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
spliter.

*****
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet R J S
+++++
eBetween.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).

*****
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HDiff2 : and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R)))
HQUR : Bet R U Q
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HDiff1 : and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q)))
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
idtac.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.

*****
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HDiff2 : and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R)))
HQUR : Bet R U Q
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HDiff1 : and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q)))
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
spliter.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.

*****
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
assert_diffs.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.

*****
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
assert_cols.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS P U S R
+++++
split.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col S P U)
+++++
try (intro; apply HNC; ColR).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col R P U)) (ex (fun T : Tpoint => and (Col T P U) (Bet S T R)))
+++++
try (intro; apply HNC; ColR).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col R P U)) (ex (fun T : Tpoint => and (Col T P U) (Bet S T R)))
+++++
split.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col R P U)
+++++
try (intro; apply HNC; ColR).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T P U) (Bet S T R))
+++++
try (intro; apply HNC; ColR).
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.
try (intro; apply HNC; ColR).

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T P U) (Bet S T R))
+++++
exists J.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.
try (intro; apply HNC; ColR).
exists J.

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col J P U) (Bet S J R)
+++++
split.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.
try (intro; apply HNC; ColR).
exists J.
split.

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col J P U
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.
try (intro; apply HNC; ColR).
exists J.
split.

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet S J R
+++++
Col.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).
intro HIS.
treat_equalities.
assert (HTS : TS P U Q S).
idtac.
apply l9_9 in HTS.
apply HTS.
exists R.
split.
destruct HPTQ as [HPTQ HDiff1].
destruct HQUR as [HQUR HDiff2].
apply between_symmetry in HQUR.
destruct (inner_pasch R P Q U T HQUR HPTQ) as [J [HPJU HRJT]].
assert (HRJS : Bet R J S).
idtac.
spliter.
assert_diffs.
assert_cols.
split.
try (intro; apply HNC; ColR).
split.
try (intro; apply HNC; ColR).
exists J.
split.
Col.

*****
H19 : Col P T Q
H18 : Col R T S
H17 : Col R U Q
H15 : Col Q I S
H13 : Col U J P
H10 : Col T J R
H9 : Col R J S
H16 : not (eq P S)
H11 : not (eq Q S)
H14 : not (eq P U)
H12 : not (eq P R)
HRJS : Bet R J S
HRJT : Bet T J R
HPJU : Bet U J P
J : Tpoint
HTS : not (OS P U Q S)
HIS : not (eq I S)
HSQI : Bet Q I S
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H1 : not (eq U R)
H0 : not (eq Q R)
H : not (eq Q U)
HQUR : Bet R U Q
H5 : not (eq T S)
H4 : not (eq R S)
H3 : not (eq R T)
H2 : Bet R T S
H8 : not (eq T Q)
H7 : not (eq P Q)
H6 : not (eq P T)
HPTQ : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet S J R
+++++
Between.
-----
Lemma impossible_case_7 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet Q I S -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ.
apply BetSEq in HRTS.
apply BetSEq in HQUR.
elim (eq_dec_points I S).

*****

*****

+++++
Qed.
-----
Lemma impossible_case_8 : forall P Q R S T U I,\n  BetS P T Q ->\n  BetS R T S ->\n  BetS Q U R ->\n  ~ Col P Q S ->\n  ~ Col P R U ->\n  Par P R Q S ->\n  Par P S Q R ->\n  Col P U I ->\n  Bet I S Q ->\n  False.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q R S T U I : Tpoint) (_ : BetS P T Q) (_ : BetS R T S) (_ : BetS Q U R) (_ : not (Col P Q S)) (_ : not (Col P R U)) (_ : Par P R Q S) (_ : Par P S Q R) (_ : Col P U I) (_ : Bet I S Q), False
+++++
Proof.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (P Q R S T U I : Tpoint) (_ : BetS P T Q) (_ : BetS R T S) (_ : BetS Q U R) (_ : not (Col P Q S)) (_ : not (Col P R U)) (_ : Par P R Q S) (_ : Par P S Q R) (_ : Col P U I) (_ : Bet I S Q), False
+++++
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.

*****
HSQI : Bet I S Q
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : BetS Q U R
HRTS : BetS R T S
HPTQ : BetS P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.

*****
HSQI : Bet I S Q
HPUI : Col P U I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
elim HPUI; clear HPUI; intro HPUI.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.

*****
HPUI : Bet P U I
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (H : Par_strict P S Q R) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P S Q R) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.

*****
H : Par_strict P S Q R
HPUI : Bet P U I
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X P S) (Col X Q R))
+++++
apply between_symmetry in HSQI.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P S Q R) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
apply between_symmetry in HSQI.

*****
H : Par_strict P S Q R
HPUI : Bet P U I
HSQI : Bet Q S I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X P S) (Col X Q R))
+++++
destruct (inner_pasch P Q I U S HPUI HSQI) as [J [HQJU HPJS]]; exists J.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P S Q R) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
apply between_symmetry in HSQI.
destruct (inner_pasch P Q I U S HPUI HSQI) as [J [HQJU HPJS]]; exists J.

*****
HPJS : Bet S J P
HQJU : Bet U J Q
J : Tpoint
H : Par_strict P S Q R
HPUI : Bet P U I
HSQI : Bet Q S I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col J P S) (Col J Q R)
+++++
spliter; assert_diffs; assert_cols; split; Col; ColR.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.

*****
HPUI : or (Bet U I P) (Bet I P U)
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
elim HPUI; clear HPUI; intro HPUI.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
elim HPUI; clear HPUI; intro HPUI.

*****
HPUI : Bet U I P
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (H : Par_strict P S Q R) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P S Q R) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.

*****
H : Par_strict P S Q R
HPUI : Bet U I P
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X P S) (Col X Q R))
+++++
apply between_symmetry in HSQI.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P S Q R) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
apply between_symmetry in HSQI.

*****
H : Par_strict P S Q R
HPUI : Bet U I P
HSQI : Bet Q S I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X P S) (Col X Q R))
+++++
destruct (outer_pasch U Q I P S HPUI HSQI) as [J [HQJU HPSJ]]; exists J.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P S Q R) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
apply between_symmetry in HSQI.
destruct (outer_pasch U Q I P S HPUI HSQI) as [J [HQJU HPSJ]]; exists J.

*****
HPSJ : Bet P S J
HQJU : Bet U J Q
J : Tpoint
H : Par_strict P S Q R
HPUI : Bet U I P
HSQI : Bet Q S I
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col J P S) (Col J Q R)
+++++
spliter; assert_diffs; assert_cols; split; Col; ColR.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
elim HPUI; clear HPUI; intro HPUI.

*****
HPUI : Bet I P U
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (H : Par_strict P R Q S) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P R Q S) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.

*****
H : Par_strict P R Q S
HPUI : Bet I P U
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HQUR : and (Bet Q U R)\n (and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R))))
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X P R) (Col X Q S))
+++++
destruct HQUR as [HQUR HDiff].
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P R Q S) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
destruct HQUR as [HQUR HDiff].

*****
H : Par_strict P R Q S
HPUI : Bet I P U
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HDiff : and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R)))
HQUR : Bet Q U R
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Col X P R) (Col X Q S))
+++++
destruct (outer_pasch Q I U R P HQUR HPUI) as [J [HQJI HRPJ]]; exists J.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P R Q S) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
destruct HQUR as [HQUR HDiff].
destruct (outer_pasch Q I U R P HQUR HPUI) as [J [HQJI HRPJ]]; exists J.

*****
HRPJ : Bet R P J
HQJI : Bet Q J I
J : Tpoint
H : Par_strict P R Q S
HPUI : Bet I P U
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
HDiff : and (not (eq Q U)) (and (not (eq Q R)) (not (eq U R)))
HQUR : Bet Q U R
HRTS : and (Bet R T S)\n (and (not (eq R T)) (and (not (eq R S)) (not (eq T S))))
HPTQ : and (Bet P T Q)\n (and (not (eq P T)) (and (not (eq P Q)) (not (eq T Q))))
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col J P R) (Col J Q S)
+++++
spliter; assert_diffs; assert_cols; split; Col.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.
elim HPUI; clear HPUI; intro HPUI.
assert (H : Par_strict P R Q S) by (apply par_not_col_strict with Q; Col; Par; unfold BetS in *; spliter; assert_cols; intro; apply HNC'; ColR); apply H.
destruct HQUR as [HQUR HDiff].
destruct (outer_pasch Q I U R P HQUR HPUI) as [J [HQJI HRPJ]]; exists J.
spliter; assert_diffs; assert_cols; split; Col.

*****
H24 : Col P T Q
H23 : Col R T S
H22 : Col Q U R
H21 : Col I S Q
H20 : Col I P U
H19 : Col Q J I
H17 : Col R P J
H15 : not (eq I Q)
H12 : not (eq I U)
H11 : not (eq R J)
H18 : not (eq P S)
H13 : not (eq Q S)
H16 : not (eq P U)
H14 : not (eq P R)
HRPJ : Bet R P J
HQJI : Bet Q J I
J : Tpoint
H : Par_strict P R Q S
HPUI : Bet I P U
HSQI : Bet I S Q
HPar2 : Par P S Q R
HPar1 : Par P R Q S
HNC' : not (Col P R U)
HNC : not (Col P Q S)
H2 : not (eq U R)
H1 : not (eq Q R)
H0 : not (eq Q U)
HQUR : Bet Q U R
H6 : not (eq T S)
H5 : not (eq R S)
H4 : not (eq R T)
H3 : Bet R T S
H10 : not (eq T Q)
H9 : not (eq P Q)
H8 : not (eq P T)
H7 : Bet P T Q
P,Q,R,S,T,U,I : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col J Q S
+++++
elim (eq_dec_points Q I); intro HQI; treat_equalities; Col; ColR.
-----
Lemma impossible_case_8 : forall P Q R S T U I, BetS P T Q -> BetS R T S -> BetS Q U R -> ~ Col P Q S -> ~ Col P R U -> Par P R Q S -> Par P S Q R -> Col P U I -> Bet I S Q -> False.
Proof.
intros P Q R S T U I HPTQ HRTS HQUR HNC HNC' HPar1 HPar2 HPUI HSQI.
apply BetSEq in HPTQ; apply BetSEq in HRTS; apply BetSEq in HQUR.
elim HPUI; clear HPUI; intro HPUI.

*****

*****

+++++
Qed.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux :\n  strong_parallel_postulate ->\n  (forall A B C D T,\n   A <> B ->\n   A <> C ->\n   A <> D ->\n   A <> T ->\n   B <> C ->\n   B <> D ->\n   B <> T ->\n   C <> D ->\n   C <> T ->\n   D <> T ->\n   ~ Col A B C ->\n   Bet A D T ->\n   Bet B D C ->\n   exists B', exists B'', exists MB, exists X, Bet A B X /\ Par_strict B C T X /\\n   BetS B MB T /\ BetS B' MB B'' /\\n   Cong B MB T MB /\ Cong B' MB B'' MB /\\n   Col B B' D /\ Bet B'' T X /\\n   B <> B' /\ B'' <> T).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : strong_parallel_postulate) (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : Bet B D C), ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
Proof.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : strong_parallel_postulate) (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : Bet B D C), ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.

*****
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct (symmetric_point_construction D B) as [B' HB'].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].

*****
HB' : Midpoint B D B'
B' : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].

*****
HBB' : not (eq B B')
HB'D : not (eq D B')
HB' : Midpoint B D B'
B' : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct HB' as [HBDB' HCong1].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].

*****
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet D B B'
B' : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
apply between_symmetry in HADT.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.

*****
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet D B B'
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
apply between_symmetry in HBDB'.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.

*****
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].

*****
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct (midpoint_existence B T) as [MB HMB].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].

*****
HMB : Midpoint MB B T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].

*****
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HMB : Midpoint MB B T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct HMB as [HBMBT HCong2].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].

*****
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct (symmetric_point_construction B' MB) as [B'' HB''].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].

*****
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (HB'MB : MB <> B').
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').

*****
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq MB B')
+++++
assert (H : ~ Col B' D MB).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
assert (H : ~ Col B' D MB).

*****
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B' D MB)
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
assert (H : ~ Col B' D MB).
intro.

*****
H : Col B' D MB
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HABC.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
assert (H : ~ Col B' D MB).
intro.
apply HABC.

*****
H : Col B' D MB
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
assert (H : ~ Col B' D MB).
intro.
apply HABC.
assert_cols.

*****
H6 : Col MB B' B''
H5 : Col T D A
H4 : Col B D C
H3 : Col B' B D
H2 : Col T B''' B'
H1 : Col A B B'''
H0 : Col B MB T
H : Col B' D MB
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
assert (H : ~ Col B' D MB).

*****
H : not (Col B' D MB)
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq MB B')
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
assert (H : ~ Col B' D MB).
idtac.

*****
H : not (Col B' D MB)
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq MB B')
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
assert (H : ~ Col B' D MB).
idtac.
intro.

*****
H0 : eq MB B'
H : not (Col B' D MB)
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
assert (H : ~ Col B' D MB).
idtac.
intro.
treat_equalities.

*****
HBMBT : Bet B B'' T
HCong2 : Cong B B'' B'' T
HMBT : not (eq B'' T)
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B''
B''' : Tpoint
HBB' : not (eq B B'')
HB'D : not (eq D B'')
HCong1 : Cong D B B B''
HBDB' : Bet B'' B D
H : not (Col B'' D B'')
HB'' : Midpoint B'' B'' B''
B'' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
assert (H : ~ Col B' D MB).
idtac.
intro.
treat_equalities.
apply H.

*****
HBMBT : Bet B B'' T
HCong2 : Cong B B'' B'' T
HMBT : not (eq B'' T)
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B''
B''' : Tpoint
HBB' : not (eq B B'')
HB'D : not (eq D B'')
HCong1 : Cong D B B B''
HBDB' : Bet B'' B D
H : not (Col B'' D B'')
HB'' : Midpoint B'' B'' B''
B'' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B'' D B''
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').

*****
HB'MB : not (eq MB B')
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].

*****
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HB'' : Midpoint MB B' B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct HB'' as [HB'MBB'' HCong3].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].

*****
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (H1 : BetS B MB T).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).

*****
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
repeat split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
repeat split.

*****
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B MB T
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
repeat split.

*****
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B MB)
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
repeat split.

*****
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq MB T)
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).

*****
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.

*****
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (H2 : BetS B' MB B'').
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').

*****
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
repeat split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
repeat split.

*****
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B' MB B''
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
repeat split.

*****
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' MB)
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
repeat split.

*****
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq MB B'')
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').

*****
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.

*****
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (HB'T : B' <> T).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).

*****
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' T)
+++++
assert (H : ~ Col B B' T).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (H : ~ Col B B' T).

*****
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' T)
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (H : ~ Col B B' T).
intro.

*****
H : Col B B' T
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HABC.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (H : ~ Col B B' T).
intro.
apply HABC.

*****
H : Col B B' T
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (H : ~ Col B B' T).
intro.
apply HABC.
assert_cols.

*****
H8 : Col T D A
H7 : Col B D C
H6 : Col B' B D
H5 : Col T B''' B'
H4 : Col A B B'''
H3 : Col B MB T
H0 : Col B' MB B''
H : Col B B' T
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (H : ~ Col B B' T).

*****
H : not (Col B B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' T)
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (H : ~ Col B B' T).
idtac.

*****
H : not (Col B B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' T)
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (H : ~ Col B B' T).
idtac.
intro.

*****
H0 : eq B' T
H : not (Col B B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (H : ~ Col B B' T).
idtac.
intro.
treat_equalities.

*****
H : not (Col B B' B')
H2 : BetS B' MB B''
H1 : BetS B MB B'
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB B')
HBMB : not (eq MB B)
HBMBT : Bet B MB B'
HCong2 : Cong B MB MB B'
MB : Tpoint
HABB''' : Bet A B B'
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
HBDC : Bet B D C
HADT : Bet B' D A
HABC : not (Col A B C)
HCT : not (eq C B')
HDT : not (eq D B')
HCD : not (eq C D)
HBT : not (eq B B')
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A B')
B' : Tpoint
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (H : ~ Col B B' T).
idtac.
intro.
treat_equalities.
apply H.

*****
H : not (Col B B' B')
H2 : BetS B' MB B''
H1 : BetS B MB B'
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB B')
HBMB : not (eq MB B)
HBMBT : Bet B MB B'
HCong2 : Cong B MB MB B'
MB : Tpoint
HABB''' : Bet A B B'
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
HBDC : Bet B D C
HADT : Bet B' D A
HABC : not (Col A B C)
HCT : not (eq C B')
HDT : not (eq D B')
HCD : not (eq C D)
HBT : not (eq B B')
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A B')
B' : Tpoint
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B' B'
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).

*****
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (HB'B''' : B' <> B''').
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').

*****
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' B''')
+++++
assert (H : ~ Col A B B').
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (H : ~ Col A B B').

*****
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B B')
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (H : ~ Col A B B').
intro.

*****
H : Col A B B'
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HABC.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (H : ~ Col A B B').
intro.
apply HABC.

*****
H : Col A B B'
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (H : ~ Col A B B').
intro.
apply HABC.
assert_cols.

*****
H8 : Col T D A
H7 : Col B D C
H6 : Col B' B D
H5 : Col T B''' B'
H4 : Col A B B'''
H3 : Col B MB T
H0 : Col B' MB B''
H : Col A B B'
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (H : ~ Col A B B').

*****
H : not (Col A B B')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' B''')
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (H : ~ Col A B B').
idtac.

*****
H : not (Col A B B')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' B''')
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (H : ~ Col A B B').
idtac.
intro.

*****
H0 : eq B' B'''
H : not (Col A B B')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (H : ~ Col A B B').
idtac.
intro.
treat_equalities.

*****
H : not (Col A B B')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (H : ~ Col A B B').
idtac.
intro.
treat_equalities.
apply H.

*****
H : not (Col A B B')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B B'
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').

*****
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (HB'''T : B''' <> T).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).

*****
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B''' T)
+++++
assert (H : ~ Col A B T).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H : ~ Col A B T).

*****
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B T)
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H : ~ Col A B T).
intro.

*****
H : Col A B T
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HABC.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H : ~ Col A B T).
intro.
apply HABC.

*****
H : Col A B T
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H : ~ Col A B T).
intro.
apply HABC.
assert_cols.

*****
H8 : Col T D A
H7 : Col B D C
H6 : Col B' B D
H5 : Col T B''' B'
H4 : Col A B B'''
H3 : Col B MB T
H0 : Col B' MB B''
H : Col A B T
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H : ~ Col A B T).

*****
H : not (Col A B T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B''' T)
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H : ~ Col A B T).
idtac.

*****
H : not (Col A B T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B''' T)
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H : ~ Col A B T).
idtac.
intro.

*****
H0 : eq B''' T
H : not (Col A B T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H : ~ Col A B T).
idtac.
intro.
treat_equalities.

*****
H : not (Col A B B''')
HB'T : not (eq B' B''')
H2 : BetS B' MB B''
H1 : BetS B MB B'''
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB B''')
HBMB : not (eq MB B)
HBMBT : Bet B MB B'''
HCong2 : Cong B MB MB B'''
MB : Tpoint
HABB''' : Bet A B B'''
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
HBDC : Bet B D C
HADT : Bet B''' D A
HABC : not (Col A B C)
HCT : not (eq C B''')
HDT : not (eq D B''')
HCD : not (eq C D)
HBT : not (eq B B''')
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A B''')
B''',B' : Tpoint
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H : ~ Col A B T).
idtac.
intro.
treat_equalities.
apply H.

*****
H : not (Col A B B''')
HB'T : not (eq B' B''')
H2 : BetS B' MB B''
H1 : BetS B MB B'''
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB B''')
HBMB : not (eq MB B)
HBMBT : Bet B MB B'''
HCong2 : Cong B MB MB B'''
MB : Tpoint
HABB''' : Bet A B B'''
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
HBDC : Bet B D C
HADT : Bet B''' D A
HABC : not (Col A B C)
HCT : not (eq C B''')
HDT : not (eq D B''')
HCD : not (eq C D)
HBT : not (eq B B''')
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A B''')
B''',B' : Tpoint
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B B'''
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).

*****
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (H3 : BetS T B''' B').
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').

*****
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS T B''' B'
+++++
repeat split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
repeat split.

*****
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet T B''' B'
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
repeat split.

*****
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T B''')
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
repeat split.

*****
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B''' B')
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').

*****
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.

*****
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (H4 : ~ Col B T B'').
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').

*****
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B T B'')
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
intro.

*****
H : Col B T B''
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HABC.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
intro.
apply HABC.

*****
H : Col B T B''
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
intro.
apply HABC.
assert_cols.

*****
H9 : Col T D A
H8 : Col B D C
H7 : Col B' B D
H6 : Col T B''' B'
H5 : Col A B B'''
H4 : Col B MB T
H0 : Col B' MB B''
H : Col B T B''
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').

*****
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.

*****
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (H5 : Cong B MB T MB).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).

*****
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B MB T MB
+++++
Cong.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).

*****
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.

*****
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (H6 : Cong B' MB B'' MB).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).

*****
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B' MB B'' MB
+++++
Cong.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
Cop.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
try (intro; apply H4; assert_diffs; assert_cols; ColR).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B T B' B'''
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar B T B' B'''
+++++
Cop.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B MB T MB
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].

*****
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B' MB B'' MB
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].

*****
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.

*****
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
Cop.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.

*****
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
try (intro; apply H4; assert_diffs; assert_cols; ColR).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).

*****
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (HNC : ~ Col B B' B''').
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').

*****
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
intro.

*****
H : Col B B' B'''
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
intro.
assert_diffs.

*****
H0 : not (eq A B''')
H11 : not (eq B B'')
H8 : not (eq T B'')
H : Col B B' B'''
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
intro.
assert_diffs.
assert_cols.

*****
H13 : Col T D A
H12 : Col B D C
H10 : Col B' B D
H9 : Col T B''' B'
H7 : Col A B B'''
H6 : Col B MB T
H5 : Col B' MB B''
H0 : not (eq A B''')
H11 : not (eq B B'')
H8 : not (eq T B'')
H : Col B B' B'''
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H4.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
intro.
assert_diffs.
assert_cols.
apply H4.

*****
H13 : Col T D A
H12 : Col B D C
H10 : Col B' B D
H9 : Col T B''' B'
H7 : Col A B B'''
H6 : Col B MB T
H5 : Col B' MB B''
H0 : not (eq A B''')
H11 : not (eq B B'')
H8 : not (eq T B'')
H : Col B B' B'''
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B T B''
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (HPar1 : Par B B' T B'').
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
unfold BetS in *.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : and (Bet T B''' B') (and (not (eq T B''')) (not (eq B''' B')))
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : and (Bet B' MB B'') (and (not (eq B' MB)) (not (eq MB B'')))
H1 : and (Bet B MB T) (and (not (eq B MB)) (not (eq MB T)))
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.
spliter.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
apply l12_17 with MB.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.
spliter.
apply l12_17 with MB.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B B')
+++++
try split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.
spliter.
apply l12_17 with MB.
try split.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B B')
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.
spliter.
apply l12_17 with MB.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint MB B T
+++++
try split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.
spliter.
apply l12_17 with MB.
try split.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B MB T
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.
spliter.
apply l12_17 with MB.
try split.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B MB MB T
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.
spliter.
apply l12_17 with MB.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint MB B' B''
+++++
try split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.
spliter.
apply l12_17 with MB.
try split.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B' MB B''
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
unfold BetS in *.
spliter.
apply l12_17 with MB.
try split.

*****
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B' MB MB B''
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').

*****
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.

*****
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (HPar2 : Par B B'' T B').
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').

*****
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
unfold BetS in *.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.

*****
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : and (Bet T B''' B') (and (not (eq T B''')) (not (eq B''' B')))
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : and (Bet B' MB B'') (and (not (eq B' MB)) (not (eq MB B'')))
H1 : and (Bet B MB T) (and (not (eq B MB)) (not (eq MB T)))
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.

*****
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : not (eq B''' B')
H0 : not (eq T B''')
H : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H8 : not (eq MB B'')
H7 : not (eq B' MB)
H2 : Bet B' MB B''
H10 : not (eq MB T)
H9 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
assert_diffs.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
apply l12_17 with MB.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.
apply l12_17 with MB.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B B'')
+++++
try split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.
apply l12_17 with MB.
try split.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B B'')
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.
apply l12_17 with MB.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint MB B T
+++++
try split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.
apply l12_17 with MB.
try split.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B MB T
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.
apply l12_17 with MB.
try split.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B MB MB T
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.
apply l12_17 with MB.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint MB B'' B'
+++++
try split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.
apply l12_17 with MB.
try split.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B'' MB B'
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.
apply l12_17 with MB.
try split.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B'' MB MB B'
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
unfold BetS in *.
spliter.
assert_diffs.
apply l12_17 with MB.
try split.
Between.

*****
H : not (eq A B''')
H5 : not (eq B B'')
H1 : not (eq T B'')
H16 : not (eq B B''')
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B'' MB MB B'
+++++
Cong.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').

*****
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.

*****
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
elim HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.

*****
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B'' T X, ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.

*****
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B'' T X, ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
intro HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.

*****
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
elim HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.

*****
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B B''' X, ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.

*****
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B B''' X, ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
intro HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.

*****
HX : Bet B B''' X
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (H : BetS B'' T X).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).

*****
HX : Bet B B''' X
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B'' T X
+++++
repeat split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.

*****
HX : Bet B B''' X
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B'' T X
+++++
try (intro; treat_equalities).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.
try (intro; treat_equalities).

*****
HX : Bet B B''' X
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B'' T X
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.

*****
HX : Bet B B''' X
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B'' T)
+++++
try (intro; treat_equalities).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.
try (intro; treat_equalities).

*****
HX : Bet B B''' X
HPar1 : Par B B' B'' B''
HPar2 : Par B B'' B'' B'
HNC : not (Col B B' B''')
X : Tpoint
HB'''T : not (eq B''' B'')
H3 : BetS B'' B''' B'
H4 : not (Col B B'' B'')
HB'B''' : not (eq B' B''')
H2 : BetS B' MB B''
H1 : BetS B MB B''
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
HMBT : not (eq MB B'')
HBMB : not (eq MB B)
HBMBT : Bet B MB B''
HCong2 : Cong B MB MB B''
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet B'' B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet B'' D A
HABC : not (Col A B C)
HCT : not (eq C B'')
HDT : not (eq D B'')
HCD : not (eq C D)
HBT : not (eq B B'')
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A B'')
B'' : Tpoint
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.

*****
HX : Bet B B''' X
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T X)
+++++
try (intro; treat_equalities).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.
try (intro; treat_equalities).

*****
HX : Bet B B''' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.
try (intro; treat_equalities).
Col.

*****
HX : Bet B B''' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H4.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.
try (intro; treat_equalities).
Col.
apply H4.

*****
HX : Bet B B''' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B T B''
+++++
assert_diffs.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.
try (intro; treat_equalities).
Col.
apply H4.
assert_diffs.

*****
H : not (eq A B''')
H9 : not (eq B B'')
H5 : not (eq T B'')
H8 : not (eq B B''')
HX : Bet B B''' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B T B''
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
repeat split.
try (intro; treat_equalities).
Col.
apply H4.
assert_diffs.
assert_cols.

*****
H14 : Col T D A
H13 : Col B D C
H12 : Col B' B D
H11 : Col T B''' B'
H10 : Col A B B'''
H7 : Col B MB T
H6 : Col B' MB B''
H0 : Col B B''' T
H : not (eq A B''')
H9 : not (eq B B'')
H5 : not (eq T B'')
H8 : not (eq B B''')
HX : Bet B B''' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B T B''
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).

*****
H : BetS B'' T X
HX : Bet B B''' X
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.

*****
H : BetS B'' T X
HX : Bet B B''' X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
rename H into HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.

*****
HBetS : BetS B'' T X
HX : Bet B B''' X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
assert (H : BetS B B''' X).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).

*****
HBetS : BetS B'' T X
HX : Bet B B''' X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B B''' X
+++++
repeat split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.

*****
HBetS : BetS B'' T X
HX : Bet B B''' X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B B''' X
+++++
try (intro; treat_equalities).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.
try (intro; treat_equalities).

*****
HBetS : BetS B'' T X
HX : Bet B B''' X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B B''' X
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.

*****
HBetS : BetS B'' T X
HX : Bet B B''' X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B B''')
+++++
try (intro; treat_equalities).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.
try (intro; treat_equalities).

*****
HBetS : BetS B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B)
X : Tpoint
H4 : not (Col B T B'')
H3 : BetS T B B'
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HTB'''B' : Bet T B B'
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.

*****
HBetS : BetS B'' T X
HX : Bet B B''' X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B''' X)
+++++
try (intro; treat_equalities).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.
try (intro; treat_equalities).

*****
HBetS : BetS B'' T B'''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.
try (intro; treat_equalities).
Col.

*****
HBetS : BetS B'' T B'''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
unfold BetS in *.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.
try (intro; treat_equalities).
Col.
unfold BetS in *.

*****
HBetS : and (Bet B'' T B''') (and (not (eq B'' T)) (not (eq T B''')))
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H3 : and (Bet T B''' B') (and (not (eq T B''')) (not (eq B''' B')))
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : and (Bet B' MB B'') (and (not (eq B' MB)) (not (eq MB B'')))
H1 : and (Bet B MB T) (and (not (eq B MB)) (not (eq MB T)))
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.
try (intro; treat_equalities).
Col.
unfold BetS in *.
spliter.

*****
H5 : not (eq T B''')
H0 : not (eq B'' T)
H : Bet B'' T B'''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H7 : not (eq B''' B')
H6 : not (eq T B''')
H3 : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H9 : not (eq MB B'')
H8 : not (eq B' MB)
H2 : Bet B' MB B''
H11 : not (eq MB T)
H10 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply H4.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.
try (intro; treat_equalities).
Col.
unfold BetS in *.
spliter.
apply H4.

*****
H5 : not (eq T B''')
H0 : not (eq B'' T)
H : Bet B'' T B'''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
H7 : not (eq B''' B')
H6 : not (eq T B''')
H3 : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H9 : not (eq MB B'')
H8 : not (eq B' MB)
H2 : Bet B' MB B''
H11 : not (eq MB T)
H10 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B T B''
+++++
assert_diffs.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.
try (intro; treat_equalities).
Col.
unfold BetS in *.
spliter.
apply H4.
assert_diffs.

*****
H2 : not (eq A B''')
H1 : not (eq B'' B''')
H7 : not (eq B B'')
H17 : not (eq B B''')
H0 : not (eq B'' T)
H : Bet B'' T B'''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B T B''
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
repeat split.
try (intro; treat_equalities).
Col.
unfold BetS in *.
spliter.
apply H4.
assert_diffs.
assert_cols.

*****
H12 : Col T D A
H11 : Col B D C
H10 : Col B' B D
H9 : Col T B''' B'
H8 : Col A B B'''
H6 : Col B MB T
H5 : Col B' MB B''
H3 : Col B'' T B'''
H2 : not (eq A B''')
H1 : not (eq B'' B''')
H7 : not (eq B B'')
H17 : not (eq B B''')
H0 : not (eq B'' T)
H : Bet B'' T B'''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
H4 : not (Col B T B'')
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B T B''
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).

*****
H : BetS B B''' X
HBetS : BetS B'' T X
HX : Bet B B''' X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.

*****
H : BetS B B''' X
HBetS : BetS B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
rename H into HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.

*****
HX : BetS B B''' X
HBetS : BetS B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
apply BetSEq in HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.

*****
HX : BetS B B''' X
HBetS : and (Bet B'' T X)\n (and (not (eq B'' T)) (and (not (eq B'' X)) (not (eq T X))))
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].

*****
HX : BetS B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
exists B'.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.

*****
HX : BetS B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))))))
+++++
exists B''.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.

*****
HX : BetS B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))
+++++
exists MB.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.

*****
HX : BetS B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))))
+++++
exists X.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.

*****
HX : BetS B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))
+++++
split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.

*****
HX : BetS B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B X
+++++
unfold BetS in HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.

*****
HX : and (Bet B B''' X) (and (not (eq B B''')) (not (eq B''' X)))
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B X
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B X
+++++
eBetween.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.

*****
HX : BetS B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))
+++++
unfold BetS in HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.

*****
HX : and (Bet B B''' X) (and (not (eq B B''')) (not (eq B''' X)))
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))
+++++
eBetween.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))
+++++
assert (HPar : Par B' B B'' T).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B' B B'' T
+++++
apply l12_17 with MB.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
apply l12_17 with MB.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' B)
+++++
try split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
apply l12_17 with MB.
try split.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' B)
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
apply l12_17 with MB.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint MB B' B''
+++++
try split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
apply l12_17 with MB.
try split.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B' MB B''
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
apply l12_17 with MB.
try split.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B' MB MB B''
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
apply l12_17 with MB.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Midpoint MB B T
+++++
try split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
apply l12_17 with MB.
try split.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B MB T
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
apply l12_17 with MB.
try split.

*****
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B MB MB T
+++++
Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).

*****
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.

*****
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))
+++++
assert (HPar' : Par B C B'' T).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).

*****
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B C B'' T
+++++
apply par_symmetry.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
apply par_symmetry.

*****
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B'' T B C
+++++
apply par_col_par with B'.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
apply par_symmetry.
apply par_col_par with B'.

*****
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C)
+++++
Par.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
apply par_symmetry.
apply par_col_par with B'.

*****
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B'' T B B'
+++++
Par.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
apply par_symmetry.
apply par_col_par with B'.

*****
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B' C
+++++
Par.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
apply par_symmetry.
apply par_col_par with B'.
Par.

*****
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B' C
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
apply par_symmetry.
apply par_col_par with B'.
Par.
assert_cols.

*****
H16 : Col T D A
H15 : Col B D C
H14 : Col B' B D
H13 : Col T B''' B'
H12 : Col A B B'''
H11 : Col B MB T
H10 : Col B' MB B''
H9 : Col B'' T X
H8 : Col B B''' X
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B' C
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))
+++++
idtac.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T)))))))))
+++++
split.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B C T X
+++++
apply par_not_col_strict with T.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B C T X
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B C T X
+++++
apply par_col_par with B''.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.
apply par_col_par with B''.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T X)
+++++
Par.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.
apply par_col_par with B''.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B C T B''
+++++
Par.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.
apply par_col_par with B''.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col T B'' X
+++++
Par.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.
apply par_col_par with B''.
Par.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col T B'' X
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.
apply par_col_par with B''.
Par.
assert_cols.

*****
H16 : Col T D A
H15 : Col B D C
H14 : Col B' B D
H13 : Col T B''' B'
H12 : Col A B B'''
H11 : Col B MB T
H10 : Col B' MB B''
H9 : Col B'' T X
H8 : Col B B''' X
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col T B'' X
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col T X T
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B C T)
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B C T)
+++++
intro.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.
intro.

*****
H8 : Col B C T
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HABC.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.
intro.
apply HABC.

*****
H8 : Col B C T
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
apply par_not_col_strict with T.
Col.
intro.
apply HABC.
assert_cols.

*****
H17 : Col T D A
H16 : Col B D C
H15 : Col B' B D
H14 : Col T B''' B'
H13 : Col A B B'''
H12 : Col B MB T
H11 : Col B' MB B''
H10 : Col B'' T X
H9 : Col B B''' X
H8 : Col B C T
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))
+++++
repeat (split; try assumption).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
repeat (split; try assumption).

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B' D
+++++
unfold BetS in *.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
repeat (split; try assumption).
unfold BetS in *.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : and (Bet T B''' B') (and (not (eq T B''')) (not (eq B''' B')))
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : and (Bet B' MB B'') (and (not (eq B' MB)) (not (eq MB B'')))
H1 : and (Bet B MB T) (and (not (eq B MB)) (not (eq MB T)))
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B' D
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
repeat (split; try assumption).
unfold BetS in *.
spliter.

*****
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H9 : not (eq B''' B')
H8 : not (eq T B''')
H3 : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H11 : not (eq MB B'')
H10 : not (eq B' MB)
H2 : Bet B' MB B''
H13 : not (eq MB T)
H12 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B' D
+++++
assert_cols.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
assert (H : BetS B'' T X).
clear HBetS.
rename H into HBetS.
assert (H : BetS B B''' X).
clear HX.
rename H into HX.
apply BetSEq in HBetS.
destruct HBetS as [HB''TX [HB''T [HB''X HBTX]]].
exists B'.
exists B''.
exists MB.
exists X.
split.
unfold BetS in HX.
spliter.
eBetween.
assert (HPar : Par B' B B'' T).
idtac.
assert (HPar' : Par B C B'' T).
idtac.
split.
repeat (split; try assumption).
unfold BetS in *.
spliter.
assert_cols.

*****
H22 : Col T D A
H21 : Col B D C
H20 : Col B' B D
H19 : Col A B B'''
H18 : Col B MB T
H17 : Col B' MB B''
H16 : Col T B''' B'
H15 : Col B'' T X
H14 : Col B B''' X
HPar' : Par B C B'' T
HPar : Par B' B B'' T
H7 : not (eq B''' X)
H0 : not (eq B B''')
H : Bet B B''' X
HBTX : not (eq T X)
HB''X : not (eq B'' X)
HB''T : not (eq B'' T)
HB''TX : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H9 : not (eq B''' B')
H8 : not (eq T B''')
H3 : Bet T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H11 : not (eq MB B'')
H10 : not (eq B' MB)
H2 : Bet B' MB B''
H13 : not (eq MB T)
H12 : not (eq B MB)
H1 : Bet B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B' D
+++++
Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.

*****
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Bet B''' X B) (Bet X B B'''), ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.

*****
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Bet B''' X B) (Bet X B B'''), ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
intro HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.

*****
HX : or (Bet B''' X B) (Bet X B B''')
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
elim HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.

*****
HX : or (Bet B''' X B) (Bet X B B''')
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B''' X B, ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.

*****
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet B''' X B, ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
intro HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
exfalso.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply impossible_case_5 with B T B' B'' MB B''' X.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS T B''' B'
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS T B''' B'
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B T B'')
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B T B'')
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B'' T X
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B'' T X
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B''' X B
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_5 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet B''' X B
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B''' X B
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.

*****
HX : or (Bet B''' X B) (Bet X B B''')
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet X B B''', ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.

*****
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet X B B''', ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
intro HX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
exfalso.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply impossible_case_6 with B T B' B'' MB B''' X.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS T B''' B'
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS T B''' B'
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B T B'')
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B T B'')
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B'' T X
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B'' T X
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X B B'''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HX.
clear HX.
intro HX.
elim HX.
clear HX.
intro HX.
exfalso.
apply impossible_case_6 with B T B' B'' MB B''' X.
spliter.

*****
HX : Bet X B B'''
HBetS : Bet B'' T X
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X B B'''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.

*****
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
HBetS : Col B'' T X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Bet T X B'') (Bet X B'' T), ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.

*****
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : or (Bet T X B'') (Bet X B'' T), ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
intro HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.

*****
HBetS : or (Bet T X B'') (Bet X B'' T)
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
elim HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.

*****
HBetS : or (Bet T X B'') (Bet X B'' T)
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet T X B'', ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.

*****
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet T X B'', ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
intro HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
exfalso.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply impossible_case_7 with B T B' B'' MB B''' X.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS T B''' B'
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS T B''' B'
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B T B'')
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B T B'')
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B''' X
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B''' X
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet T X B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_7 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet T X B''
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet T X B''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.

*****
HBetS : or (Bet T X B'') (Bet X B'' T)
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet X B'' T, ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
clear HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.

*****
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Bet X B'' T, ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
intro HBetS.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun B'' : Tpoint => ex (fun MB : Tpoint => ex (fun X : Tpoint => and (Bet A B X) (and (Par_strict B C T X) (and (BetS B MB T) (and (BetS B' MB B'') (and (Cong B MB T MB) (and (Cong B' MB B'' MB) (and (Col B B' D) (and (Bet B'' T X) (and (not (eq B B')) (not (eq B'' T))))))))))))))
+++++
exfalso.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply impossible_case_8 with B T B' B'' MB B''' X.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B MB T
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS B' MB B''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS T B''' B'
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
BetS T B''' B'
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B T B'')
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B T B'')
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B B' B''')
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B' T B''
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B B'' T B'
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B''' X
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B B''' X
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X B'' T
+++++
spliter.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').
destruct (midpoint_distinct_2 MB B' B'' HB'MB HB'') as [HB'B'' HB''MB].
destruct HB'' as [HB'MBB'' HCong3].
assert (H1 : BetS B MB T).
idtac.
assert (H2 : BetS B' MB B'').
idtac.
assert (HB'T : B' <> T).
assert (HB'B''' : B' <> B''').
assert (HB'''T : B''' <> T).
assert (H3 : BetS T B''' B').
idtac.
assert (H4 : ~ Col B T B'').
idtac.
assert (H5 : Cong B MB T MB).
idtac.
assert (H6 : Cong B' MB B'' MB).
idtac.
destruct (HSPP B T B' B'' MB B''') as [X [HBetS HX]].
Col.
Cop.
try (intro; apply H4; assert_diffs; assert_cols; ColR).
assert (HNC : ~ Col B B' B''').
idtac.
assert (HPar1 : Par B B' T B'').
idtac.
assert (HPar2 : Par B B'' T B').
idtac.
elim HBetS.
clear HBetS.
intro HBetS.
elim HBetS.
clear HBetS.
intro HBetS.
exfalso.
apply impossible_case_8 with B T B' B'' MB B''' X.
spliter.

*****
HBetS : Bet X B'' T
HPar2 : Par B B'' T B'
HPar1 : Par B B' T B''
HNC : not (Col B B' B''')
HX : Col B B''' X
X : Tpoint
H6 : Cong B' MB B'' MB
H5 : Cong B MB T MB
H4 : not (Col B T B'')
H3 : BetS T B''' B'
HB'''T : not (eq B''' T)
HB'B''' : not (eq B' B''')
HB'T : not (eq B' T)
H2 : BetS B' MB B''
H1 : BetS B MB T
HB''MB : not (eq MB B'')
HB'B'' : not (eq B' B'')
HB'MB : not (eq MB B')
HCong3 : Cong B' MB MB B''
HB'MBB'' : Bet B' MB B''
B'' : Tpoint
HMBT : not (eq MB T)
HBMB : not (eq MB B)
HCong2 : Cong B MB MB T
HBMBT : Bet B MB T
MB : Tpoint
HABB''' : Bet A B B'''
HTB'''B' : Bet T B''' B'
B''' : Tpoint
HBB' : not (eq B B')
HB'D : not (eq D B')
HCong1 : Cong D B B B'
HBDB' : Bet B' B D
B' : Tpoint
HBDC : Bet B D C
HADT : Bet T D A
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X B'' T
+++++
assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid_aux : strong_parallel_postulate -> (forall A B C D T, A <> B -> A <> C -> A <> D -> A <> T -> B <> C -> B <> D -> B <> T -> C <> D -> C <> T -> D <> T -> ~ Col A B C -> Bet A D T -> Bet B D C -> exists B', exists B'', exists MB, exists X, Bet A B X /\\ Par_strict B C T X /\\ BetS B MB T /\\ BetS B' MB B'' /\\ Cong B MB T MB /\\ Cong B' MB B'' MB /\\ Col B B' D /\\ Bet B'' T X /\\ B <> B' /\\ B'' <> T).
Proof.
intros HSPP A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (symmetric_point_construction D B) as [B' HB'].
destruct (midpoint_distinct_2 B D B' HBD HB') as [HB'D HBB'].
destruct HB' as [HBDB' HCong1].
apply between_symmetry in HADT.
apply between_symmetry in HBDB'.
destruct (outer_pasch T B' D A B HADT HBDB') as [B''' [HTB'''B' HABB''']].
destruct (midpoint_existence B T) as [MB HMB].
destruct (midpoint_distinct_1 MB B T HBT HMB) as [HBMB HMBT].
destruct HMB as [HBMBT HCong2].
destruct (symmetric_point_construction B' MB) as [B'' HB''].
assert (HB'MB : MB <> B').

*****

*****

+++++
Qed.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid :\n  strong_parallel_postulate ->\n  tarski_s_parallel_postulate.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : strong_parallel_postulate, tarski_s_parallel_postulate
+++++
Proof.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : strong_parallel_postulate, tarski_s_parallel_postulate
+++++
unfold tarski_s_parallel_postulate.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : strong_parallel_postulate) (A B C D T : Tpoint) (_ : Bet A D T) (_ : Bet B D C) (_ : not (eq A D)), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Bet A B X) (and (Bet A C Y) (Bet X T Y))))
+++++
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.

*****
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D T : Tpoint) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq A D)) (_ : not (eq A T)) (_ : not (eq B C)) (_ : not (eq B D)) (_ : not (eq B T)) (_ : not (eq C D)) (_ : not (eq C T)) (_ : not (eq D T)) (_ : not (Col A B C)) (_ : Bet A D T) (_ : Bet B D C), ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.

*****
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.

*****
HC''T : not (eq C'' T)
HCC' : not (eq C C')
HC''TY : Bet C'' T Y
HCC'D : Col C C' D
HCong4 : Cong C' MC C'' MC
HCong3 : Cong C MC T MC
HBet4 : BetS C' MC C''
HBet3 : BetS C MC T
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',MC,Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HPar' : Par_strict B C T X
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.

*****
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun x : Tpoint => ex (fun y : Tpoint => and (Bet A B x) (and (Bet A C y) (Bet x T y))))
+++++
exists X; exists Y; repeat split; try assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.

*****
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
elim (col_dec X T Y); intro HXTY.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.

*****
HXTY : Col X T Y
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
apply between_symmetry in HACY.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
apply between_symmetry in HACY.

*****
HXTY : Col X T Y
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet Y C A
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HU := outer_pasch Y B C A D HACY HBDC); destruct HU as [U [HYUB HADU]].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
apply between_symmetry in HACY.
assert (HU := outer_pasch Y B C A D HACY HBDC); destruct HU as [U [HYUB HADU]].

*****
HADU : Bet A D U
HYUB : Bet Y U B
U : Tpoint
HXTY : Col X T Y
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet Y C A
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
apply between_symmetry in HABX.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
apply between_symmetry in HACY.
assert (HU := outer_pasch Y B C A D HACY HBDC); destruct HU as [U [HYUB HADU]].
apply between_symmetry in HABX.

*****
HADU : Bet A D U
HYUB : Bet Y U B
U : Tpoint
HXTY : Col X T Y
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet Y C A
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet X B A
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HV := outer_pasch X Y B A U HABX HYUB); destruct HV as [V [HXVY HAUV]].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
apply between_symmetry in HACY.
assert (HU := outer_pasch Y B C A D HACY HBDC); destruct HU as [U [HYUB HADU]].
apply between_symmetry in HABX.
assert (HV := outer_pasch X Y B A U HABX HYUB); destruct HV as [V [HXVY HAUV]].

*****
HAUV : Bet A U V
HXVY : Bet X V Y
V : Tpoint
HADU : Bet A D U
HYUB : Bet Y U B
U : Tpoint
HXTY : Col X T Y
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet Y C A
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet X B A
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HAX : A <> X) by (intro; treat_equalities; Col).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
apply between_symmetry in HACY.
assert (HU := outer_pasch Y B C A D HACY HBDC); destruct HU as [U [HYUB HADU]].
apply between_symmetry in HABX.
assert (HV := outer_pasch X Y B A U HABX HYUB); destruct HV as [V [HXVY HAUV]].
assert (HAX : A <> X) by (intro; treat_equalities; Col).

*****
HAX : not (eq A X)
HAUV : Bet A U V
HXVY : Bet X V Y
V : Tpoint
HADU : Bet A D U
HYUB : Bet Y U B
U : Tpoint
HXTY : Col X T Y
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet Y C A
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet X B A
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HAY : A <> Y) by (intro; treat_equalities; Col).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
apply between_symmetry in HACY.
assert (HU := outer_pasch Y B C A D HACY HBDC); destruct HU as [U [HYUB HADU]].
apply between_symmetry in HABX.
assert (HV := outer_pasch X Y B A U HABX HYUB); destruct HV as [V [HXVY HAUV]].
assert (HAX : A <> X) by (intro; treat_equalities; Col).
assert (HAY : A <> Y) by (intro; treat_equalities; Col).

*****
HAY : not (eq A Y)
HAX : not (eq A X)
HAUV : Bet A U V
HXVY : Bet X V Y
V : Tpoint
HADU : Bet A D U
HYUB : Bet Y U B
U : Tpoint
HXTY : Col X T Y
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet Y C A
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet X B A
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HAXY : ~ Col A X Y) by (intro; assert_cols; apply HABC; ColR).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
apply between_symmetry in HACY.
assert (HU := outer_pasch Y B C A D HACY HBDC); destruct HU as [U [HYUB HADU]].
apply between_symmetry in HABX.
assert (HV := outer_pasch X Y B A U HABX HYUB); destruct HV as [V [HXVY HAUV]].
assert (HAX : A <> X) by (intro; treat_equalities; Col).
assert (HAY : A <> Y) by (intro; treat_equalities; Col).
assert (HAXY : ~ Col A X Y) by (intro; assert_cols; apply HABC; ColR).

*****
HAXY : not (Col A X Y)
HAY : not (eq A Y)
HAX : not (eq A X)
HAUV : Bet A U V
HXVY : Bet X V Y
V : Tpoint
HADU : Bet A D U
HYUB : Bet Y U B
U : Tpoint
HXTY : Col X T Y
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet Y C A
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet X B A
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HAU : A <> U) by (intro; treat_equalities; Col).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
apply between_symmetry in HACY.
assert (HU := outer_pasch Y B C A D HACY HBDC); destruct HU as [U [HYUB HADU]].
apply between_symmetry in HABX.
assert (HV := outer_pasch X Y B A U HABX HYUB); destruct HV as [V [HXVY HAUV]].
assert (HAX : A <> X) by (intro; treat_equalities; Col).
assert (HAY : A <> Y) by (intro; treat_equalities; Col).
assert (HAXY : ~ Col A X Y) by (intro; assert_cols; apply HABC; ColR).
assert (HAU : A <> U) by (intro; treat_equalities; Col).

*****
HAU : not (eq A U)
HAXY : not (Col A X Y)
HAY : not (eq A Y)
HAX : not (eq A X)
HAUV : Bet A U V
HXVY : Bet X V Y
V : Tpoint
HADU : Bet A D U
HYUB : Bet Y U B
U : Tpoint
HXTY : Col X T Y
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet Y C A
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet X B A
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HEq : T = V) by (assert_cols; apply l6_21 with X Y A D; Col; ColR); subst; assumption.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.

*****
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).

*****
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
assert (HCop : Coplanar T B B'' Y).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).

*****
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar T B B'' Y
+++++
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.

*****
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C T
+++++
exists D; assert_cols; Col5.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.

*****
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C B''
+++++
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).

*****
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C B''
+++++
apply coplanar_trans_1 with D; [Cop..|].
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].

*****
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar D A B B''
+++++
apply ts__coplanar.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.

*****
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS D A B B''
+++++
apply l9_8_2 with X.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.

*****
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS D A X B''
+++++
assert (HAX : A <> X) by (intro; treat_equalities; apply HABC; Col).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.
assert (HAX : A <> X) by (intro; treat_equalities; apply HABC; Col).

*****
HAX : not (eq A X)
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS D A X B''
+++++
split; try (intro; assert_cols; apply HABC; ColR).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.
assert (HAX : A <> X) by (intro; treat_equalities; apply HABC; Col).
split; try (intro; assert_cols; apply HABC; ColR).

*****
HAX : not (eq A X)
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col B'' D A)) (ex (fun T : Tpoint => and (Col T D A) (Bet X T B'')))
+++++
split; try (intro; assert_cols; apply HABC; ColR).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.
assert (HAX : A <> X) by (intro; treat_equalities; apply HABC; Col).
split; try (intro; assert_cols; apply HABC; ColR).
split; try (intro; assert_cols; apply HABC; ColR).

*****
HAX : not (eq A X)
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T D A) (Bet X T B''))
+++++
exists T; split; Col; Between.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.

*****
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS D A X B
+++++
apply invert_one_side.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.
apply invert_one_side.

*****
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A D X B
+++++
assert (HADA : Col A D A) by Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.
apply invert_one_side.
assert (HADA : Col A D A) by Col.

*****
HADA : Col A D A
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A D X B
+++++
assert (HXBA : Col X B A) by (assert_cols; Col).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.
apply invert_one_side.
assert (HADA : Col A D A) by Col.
assert (HXBA : Col X B A) by (assert_cols; Col).

*****
HXBA : Col X B A
HADA : Col A D A
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A D X B
+++++
rewrite (l9_19 A D X B A HADA HXBA).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.
apply invert_one_side.
assert (HADA : Col A D A) by Col.
assert (HXBA : Col X B A) by (assert_cols; Col).
rewrite (l9_19 A D X B A HADA HXBA).

*****
HXBA : Col X B A
HADA : Col A D A
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A X B) (not (Col A D X))
+++++
assert (HAX : A <> X) by (intro; treat_equalities; apply HABC; Col).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
apply coplanar_pseudo_trans with A B C; assert_cols; Cop.
assert (HABD : ~ Col D A B) by (intro; assert_cols; apply HABC; ColR).
apply coplanar_trans_1 with D; [Cop..|].
apply ts__coplanar.
apply l9_8_2 with X.
apply invert_one_side.
assert (HADA : Col A D A) by Col.
assert (HXBA : Col X B A) by (assert_cols; Col).
rewrite (l9_19 A D X B A HADA HXBA).
assert (HAX : A <> X) by (intro; treat_equalities; apply HABC; Col).

*****
HAX : not (eq A X)
HXBA : Col X B A
HADA : Col A D A
HABD : not (Col D A B)
H3 : Col A D T
H2 : Col B D C
H1 : Col A B X
H0 : Col B'' T X
H : Col A C Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A X B) (not (Col A D X))
+++++
split; try (intro; assert_cols; apply HABC; ColR); split; auto.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).

*****
HCop : Coplanar T B B'' Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
HBet2 : BetS B' MB B''
HBet1 : BetS B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
destruct (HSPP T B B'' B' MB Y) as [I [HCol1 HCol2]]; Cong; try (unfold BetS in *; spliter; repeat (split; try Between)).
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
destruct (HSPP T B B'' B' MB Y) as [I [HCol1 HCol2]]; Cong; try (unfold BetS in *; spliter; repeat (split; try Between)).

*****
HCol2 : Col T Y I
HCol1 : Col B' B I
I : Tpoint
HCop : Coplanar T B B'' Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
H1 : not (eq MB B'')
H0 : not (eq B' MB)
H : Bet B' MB B''
H4 : not (eq MB T)
H3 : not (eq B MB)
H2 : Bet B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X T Y
+++++
exfalso; apply HPar; exists I; split; Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
destruct (HSPP T B B'' B' MB Y) as [I [HCol1 HCol2]]; Cong; try (unfold BetS in *; spliter; repeat (split; try Between)).
exfalso; apply HPar; exists I; split; Col.

*****
HCol2 : Col T Y I
HCol1 : Col B' B I
I : Tpoint
HCop : Coplanar T B B'' Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
H1 : not (eq MB B'')
H0 : not (eq B' MB)
H : Bet B' MB B''
H4 : not (eq MB T)
H3 : not (eq B MB)
H2 : Bet B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col I C B
+++++
elim (eq_dec_points I B); intro HBI; subst; Col.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.
assert (HNC : ~ Col T B'' Y) by (intro; apply HXTY; unfold BetS in *; spliter; assert_cols; ColR).
assert (HCop : Coplanar T B B'' Y).
destruct (HSPP T B B'' B' MB Y) as [I [HCol1 HCol2]]; Cong; try (unfold BetS in *; spliter; repeat (split; try Between)).
exfalso; apply HPar; exists I; split; Col.
elim (eq_dec_points I B); intro HBI; subst; Col.

*****
HBI : not (eq I B)
HCol2 : Col T Y I
HCol1 : Col B' B I
I : Tpoint
HCop : Coplanar T B B'' Y
HNC : not (Col T B'' Y)
HXTY : not (Col X T Y)
HCC' : not (eq C C')
HCC'D : Col C C' D
HPar : Par_strict C B T Y
HACY : Bet A C Y
C',C'',Y : Tpoint
HB''T : not (eq B'' T)
HBB' : not (eq B B')
HB''TX : Bet B'' T X
HBB'D : Col B B' D
HCong2 : Cong B' MB B'' MB
HCong1 : Cong B MB T MB
H1 : not (eq MB B'')
H0 : not (eq B' MB)
H : Bet B' MB B''
H4 : not (eq MB T)
H3 : not (eq B MB)
H2 : Bet B MB T
HABX : Bet A B X
B',B'',MB,X : Tpoint
HBDC : Bet B D C
HADT : Bet A D T
HABC : not (Col A B C)
HDT : not (eq D T)
HCT : not (eq C T)
HCD : not (eq C D)
HBT : not (eq B T)
HBD : not (eq B D)
HBC : not (eq B C)
HAT : not (eq A T)
HAD : not (eq A D)
HAC : not (eq A C)
HAB : not (eq A B)
A,B,C,D,T : Tpoint
HSPP : strong_parallel_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col I C B
+++++
unfold BetS in *; spliter; assert_cols; ColR.
-----
Lemma strong_parallel_postulate_implies_tarski_s_euclid : strong_parallel_postulate -> tarski_s_parallel_postulate.
Proof.
unfold tarski_s_parallel_postulate.
intro HSPP; apply tarski_s_euclid_remove_degenerated_cases.
intros A B C D T HAB HAC HAD HAT HBC HBD HBT HCD HCT HDT HABC HADT HBDC.
destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A B C D T) as [B' [B'' [MB [X [HABX [HPar' [HBet1 [HBet2 [HCong1 [HCong2 [HBB'D [HB''TX [HBB' HB''T]]]]]]]]]]]]]; destruct (strong_parallel_postulate_implies_tarski_s_euclid_aux HSPP A C B D T) as [C' [C'' [MC [Y [HACY [HPar [HBet3 [HBet4 [HCong3 [HCong4 [HCC'D [HC''TY [HCC' HC''T]]]]]]]]]]]]]; Between; Col.
clear HBet3; clear HBet4; clear HCong3; clear HCong4; clear MC; clear HC''TY; clear HC''T; clear HPar'.
exists X; exists Y; repeat split; try assumption.
elim (col_dec X T Y); intro HXTY.

*****

*****

+++++
Qed.
-----
End SPP_tarski.
-----
