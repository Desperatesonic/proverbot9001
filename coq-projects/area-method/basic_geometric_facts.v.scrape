Require Export geometry_tools.
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.

*****

*****
forall (a : F) (_ : eq (Fopp a) F0), eq a F0
+++++
Proof.
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.

*****

*****
forall (a : F) (_ : eq (Fopp a) F0), eq a F0
+++++
intros.
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.

*****
H : eq (Fopp a) F0
a : F
*****
eq a F0
+++++
assert (- -a=-0).
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.
assert (- -a=-0).

*****
H : eq (Fopp a) F0
a : F
*****
eq (Fopp (Fopp a)) (Fopp F0)
+++++
rewrite H.
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.
assert (- -a=-0).
rewrite H.

*****
H : eq (Fopp a) F0
a : F
*****
eq (Fopp F0) (Fopp F0)
+++++
try solve [ ring | congruence ].
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.
assert (- -a=-0).

*****
H0 : eq (Fopp (Fopp a)) (Fopp F0)
H : eq (Fopp a) F0
a : F
*****
eq a F0
+++++
assert (- -a=a).
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.
assert (- -a=-0).
assert (- -a=a).

*****
H0 : eq (Fopp (Fopp a)) (Fopp F0)
H : eq (Fopp a) F0
a : F
*****
eq (Fopp (Fopp a)) a
+++++
try solve [ ring | congruence ].
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.
assert (- -a=-0).
assert (- -a=a).

*****
H1 : eq (Fopp (Fopp a)) a
H0 : eq (Fopp (Fopp a)) (Fopp F0)
H : eq (Fopp a) F0
a : F
*****
eq a F0
+++++
try solve [ ring | congruence ].
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.
assert (- -a=-0).
assert (- -a=a).
try solve [ ring | congruence ].

*****
H1 : eq (Fopp (Fopp a)) a
H0 : eq (Fopp (Fopp a)) (Fopp F0)
H : eq (Fopp a) F0
a : F
*****
eq a F0
+++++
assert (-0=0).
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.
assert (- -a=-0).
assert (- -a=a).
try solve [ ring | congruence ].
assert (-0=0).

*****
H1 : eq (Fopp (Fopp a)) a
H0 : eq (Fopp (Fopp a)) (Fopp F0)
H : eq (Fopp a) F0
a : F
*****
eq (Fopp F0) F0
+++++
try solve [ ring | congruence ].
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.
assert (- -a=-0).
assert (- -a=a).
try solve [ ring | congruence ].
assert (-0=0).

*****
H2 : eq (Fopp F0) F0
H1 : eq (Fopp (Fopp a)) a
H0 : eq (Fopp (Fopp a)) (Fopp F0)
H : eq (Fopp a) F0
a : F
*****
eq a F0
+++++
try solve [ ring | congruence ].
-----
Theorem field_prop1 : forall a : F, -a=0 -> a=0.
Proof.
intros.
assert (- -a=-0).

*****

*****

+++++
Qed.
-----
Hint Resolve field_prop1 : Geom.
-----
Theorem col_1 : forall A B C : Point, Col A B C -> Col B A C.
-----
Theorem col_1 : forall A B C : Point, Col A B C -> Col B A C.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col B A C
+++++
Proof.
-----
Theorem col_1 : forall A B C : Point, Col A B C -> Col B A C.
Proof.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col B A C
+++++
unfold Col in |- *.
-----
Theorem col_1 : forall A B C : Point, Col A B C -> Col B A C.
Proof.
unfold Col in |- *.

*****

*****
forall (A B C : Point) (_ : eq (S A B C) F0), eq (S B A C) F0
+++++
intros.
-----
Theorem col_1 : forall A B C : Point, Col A B C -> Col B A C.
Proof.
unfold Col in |- *.
intros.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (S B A C) F0
+++++
uniformize_signed_areas.
-----
Theorem col_1 : forall A B C : Point, Col A B C -> Col B A C.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (Fopp (S A B C)) F0
+++++
Geometry.
-----
Theorem col_1 : forall A B C : Point, Col A B C -> Col B A C.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.
Geometry.

*****

*****

+++++
Qed.
-----
Theorem col_2 : forall A B C : Point, Col A B C -> Col A C B.
-----
Theorem col_2 : forall A B C : Point, Col A B C -> Col A C B.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col A C B
+++++
Proof.
-----
Theorem col_2 : forall A B C : Point, Col A B C -> Col A C B.
Proof.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col A C B
+++++
unfold Col in |- *.
-----
Theorem col_2 : forall A B C : Point, Col A B C -> Col A C B.
Proof.
unfold Col in |- *.

*****

*****
forall (A B C : Point) (_ : eq (S A B C) F0), eq (S A C B) F0
+++++
intros.
-----
Theorem col_2 : forall A B C : Point, Col A B C -> Col A C B.
Proof.
unfold Col in |- *.
intros.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (S A C B) F0
+++++
uniformize_signed_areas.
-----
Theorem col_2 : forall A B C : Point, Col A B C -> Col A C B.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (Fopp (S A B C)) F0
+++++
Geometry.
-----
Theorem col_2 : forall A B C : Point, Col A B C -> Col A C B.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.
Geometry.

*****

*****

+++++
Qed.
-----
Theorem col_3 : forall A B C : Point, Col A B C -> Col B C A.
-----
Theorem col_3 : forall A B C : Point, Col A B C -> Col B C A.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col B C A
+++++
Proof.
-----
Theorem col_3 : forall A B C : Point, Col A B C -> Col B C A.
Proof.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col B C A
+++++
unfold Col in |- *.
-----
Theorem col_3 : forall A B C : Point, Col A B C -> Col B C A.
Proof.
unfold Col in |- *.

*****

*****
forall (A B C : Point) (_ : eq (S A B C) F0), eq (S B C A) F0
+++++
intros.
-----
Theorem col_3 : forall A B C : Point, Col A B C -> Col B C A.
Proof.
unfold Col in |- *.
intros.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (S B C A) F0
+++++
uniformize_signed_areas.
-----
Theorem col_3 : forall A B C : Point, Col A B C -> Col B C A.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (S A B C) F0
+++++
Geometry.
-----
Theorem col_3 : forall A B C : Point, Col A B C -> Col B C A.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.
Geometry.

*****

*****

+++++
Qed.
-----
Theorem col_4 : forall A B C : Point, Col A B C -> Col C B A.
-----
Theorem col_4 : forall A B C : Point, Col A B C -> Col C B A.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col C B A
+++++
Proof.
-----
Theorem col_4 : forall A B C : Point, Col A B C -> Col C B A.
Proof.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col C B A
+++++
unfold Col in |- *.
-----
Theorem col_4 : forall A B C : Point, Col A B C -> Col C B A.
Proof.
unfold Col in |- *.

*****

*****
forall (A B C : Point) (_ : eq (S A B C) F0), eq (S C B A) F0
+++++
intros.
-----
Theorem col_4 : forall A B C : Point, Col A B C -> Col C B A.
Proof.
unfold Col in |- *.
intros.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (S C B A) F0
+++++
uniformize_signed_areas.
-----
Theorem col_4 : forall A B C : Point, Col A B C -> Col C B A.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (Fopp (S A B C)) F0
+++++
Geometry.
-----
Theorem col_4 : forall A B C : Point, Col A B C -> Col C B A.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.
Geometry.

*****

*****

+++++
Qed.
-----
Theorem col_5 : forall A B C : Point, Col A B C -> Col C A B.
-----
Theorem col_5 : forall A B C : Point, Col A B C -> Col C A B.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col C A B
+++++
Proof.
-----
Theorem col_5 : forall A B C : Point, Col A B C -> Col C A B.
Proof.

*****

*****
forall (A B C : Point) (_ : Col A B C), Col C A B
+++++
unfold Col in |- *.
-----
Theorem col_5 : forall A B C : Point, Col A B C -> Col C A B.
Proof.
unfold Col in |- *.

*****

*****
forall (A B C : Point) (_ : eq (S A B C) F0), eq (S C A B) F0
+++++
intros.
-----
Theorem col_5 : forall A B C : Point, Col A B C -> Col C A B.
Proof.
unfold Col in |- *.
intros.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (S C A B) F0
+++++
uniformize_signed_areas.
-----
Theorem col_5 : forall A B C : Point, Col A B C -> Col C A B.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.

*****
H : eq (S A B C) F0
A,B,C : Point
*****
eq (S A B C) F0
+++++
Geometry.
-----
Theorem col_5 : forall A B C : Point, Col A B C -> Col C A B.
Proof.
unfold Col in |- *.
intros.
uniformize_signed_areas.
Geometry.

*****

*****

+++++
Qed.
-----
Hint Resolve col_1 col_2 col_3 col_4 col_5: Geom.
-----
Theorem noteqnotzero : forall A B : Point, A <> B -> A ** B <> 0.
-----
Theorem noteqnotzero : forall A B : Point, A <> B -> A ** B <> 0.

*****

*****
forall (A B : Point) (_ : not (eq A B)), not (eq (DSeg A B) F0)
+++++
intros.
-----
Theorem noteqnotzero : forall A B : Point, A <> B -> A ** B <> 0.
intros.

*****
H : not (eq A B)
A,B : Point
*****
not (eq (DSeg A B) F0)
+++++
assert (A ** B = 0 <-> A = B).
-----
Theorem noteqnotzero : forall A B : Point, A <> B -> A ** B <> 0.
intros.
assert (A ** B = 0 <-> A = B).

*****
H : not (eq A B)
A,B : Point
*****
iff (eq (DSeg A B) F0) (eq A B)
+++++
apply A1b.
-----
Theorem noteqnotzero : forall A B : Point, A <> B -> A ** B <> 0.
intros.
assert (A ** B = 0 <-> A = B).

*****
H0 : iff (eq (DSeg A B) F0) (eq A B)
H : not (eq A B)
A,B : Point
*****
not (eq (DSeg A B) F0)
+++++
intuition.
-----
Theorem noteqnotzero : forall A B : Point, A <> B -> A ** B <> 0.
intros.
assert (A ** B = 0 <-> A = B).

*****

*****

+++++
Qed.
-----
Hint Resolve noteqnotzero: Geom.
-----
Theorem egalcol : forall A B C : Point, A = B -> Col A B C.
-----
Theorem egalcol : forall A B C : Point, A = B -> Col A B C.

*****

*****
forall (A B C : Point) (_ : eq A B), Col A B C
+++++
Proof.
-----
Theorem egalcol : forall A B C : Point, A = B -> Col A B C.
Proof.

*****

*****
forall (A B C : Point) (_ : eq A B), Col A B C
+++++
intros.
-----
Theorem egalcol : forall A B C : Point, A = B -> Col A B C.
Proof.
intros.

*****
H : eq A B
A,B,C : Point
*****
Col A B C
+++++
unfold Col.
-----
Theorem egalcol : forall A B C : Point, A = B -> Col A B C.
Proof.
intros.
unfold Col.

*****
H : eq A B
A,B,C : Point
*****
eq (S A B C) F0
+++++
rewrite H.
-----
Theorem egalcol : forall A B C : Point, A = B -> Col A B C.
Proof.
intros.
unfold Col.
rewrite H.

*****
H : eq A B
A,B,C : Point
*****
eq (S B B C) F0
+++++
try solve [ Geometry | congruence ].
-----
Theorem egalcol : forall A B C : Point, A = B -> Col A B C.
Proof.
intros.
unfold Col.
rewrite H.
try solve [ Geometry | congruence ].

*****

*****

+++++
Qed.
-----
Theorem notcolnotegal_1 : forall A B C : Point, ~ Col A B C -> A <> B.
-----
Theorem notcolnotegal_1 : forall A B C : Point, ~ Col A B C -> A <> B.

*****

*****
forall (A B C : Point) (_ : not (Col A B C)), not (eq A B)
+++++
unfold Col in |- *.
-----
Theorem notcolnotegal_1 : forall A B C : Point, ~ Col A B C -> A <> B.
unfold Col in |- *.

*****

*****
forall (A B C : Point) (_ : not (eq (S A B C) F0)), not (eq A B)
+++++
intros.
-----
Theorem notcolnotegal_1 : forall A B C : Point, ~ Col A B C -> A <> B.
unfold Col in |- *.
intros.

*****
H : not (eq (S A B C) F0)
A,B,C : Point
*****
not (eq A B)
+++++
intuition.
-----
Theorem notcolnotegal_1 : forall A B C : Point, ~ Col A B C -> A <> B.
unfold Col in |- *.
intros.
intuition.

*****
H0 : eq A B
H : forall _ : eq (S A B C) F0, False
A,B,C : Point
*****
False
+++++
assert (T := egalcol A B C H0).
-----
Theorem notcolnotegal_1 : forall A B C : Point, ~ Col A B C -> A <> B.
unfold Col in |- *.
intros.
intuition.
assert (T := egalcol A B C H0).

*****
T : Col A B C
H0 : eq A B
H : forall _ : eq (S A B C) F0, False
A,B,C : Point
*****
False
+++++
auto.
-----
Theorem notcolnotegal_1 : forall A B C : Point, ~ Col A B C -> A <> B.
unfold Col in |- *.
intros.
intuition.
assert (T := egalcol A B C H0).
auto.

*****

*****

+++++
Qed.
-----
Theorem notcolnotegal_2 : forall A B C : Point, ~ Col A B C -> B <> C.
-----
Theorem notcolnotegal_2 : forall A B C : Point, ~ Col A B C -> B <> C.

*****

*****
forall (A B C : Point) (_ : not (Col A B C)), not (eq B C)
+++++
intros.
-----
Theorem notcolnotegal_2 : forall A B C : Point, ~ Col A B C -> B <> C.
intros.

*****
H : not (Col A B C)
A,B,C : Point
*****
not (eq B C)
+++++
assert (~ Col A B C -> ~ Col B C A).
-----
Theorem notcolnotegal_2 : forall A B C : Point, ~ Col A B C -> B <> C.
intros.
assert (~ Col A B C -> ~ Col B C A).

*****
H : not (Col A B C)
A,B,C : Point
*****
forall _ : not (Col A B C), not (Col B C A)
+++++
intuition.
-----
Theorem notcolnotegal_2 : forall A B C : Point, ~ Col A B C -> B <> C.
intros.
assert (~ Col A B C -> ~ Col B C A).

*****
H0 : forall _ : not (Col A B C), not (Col B C A)
H : not (Col A B C)
A,B,C : Point
*****
not (eq B C)
+++++
assert (~ Col B C A).
-----
Theorem notcolnotegal_2 : forall A B C : Point, ~ Col A B C -> B <> C.
intros.
assert (~ Col A B C -> ~ Col B C A).
assert (~ Col B C A).

*****
H0 : forall _ : not (Col A B C), not (Col B C A)
H : not (Col A B C)
A,B,C : Point
*****
not (Col B C A)
+++++
auto.
-----
Theorem notcolnotegal_2 : forall A B C : Point, ~ Col A B C -> B <> C.
intros.
assert (~ Col A B C -> ~ Col B C A).
assert (~ Col B C A).

*****
H1 : not (Col B C A)
H0 : forall _ : not (Col A B C), not (Col B C A)
H : not (Col A B C)
A,B,C : Point
*****
not (eq B C)
+++++
eapply notcolnotegal_1.
-----
Theorem notcolnotegal_2 : forall A B C : Point, ~ Col A B C -> B <> C.
intros.
assert (~ Col A B C -> ~ Col B C A).
assert (~ Col B C A).
eapply notcolnotegal_1.

*****
H1 : not (Col B C A)
H0 : forall _ : not (Col A B C), not (Col B C A)
H : not (Col A B C)
A,B,C : Point
*****
not (Col B C ?C)
+++++
apply H1.
-----
Theorem notcolnotegal_2 : forall A B C : Point, ~ Col A B C -> B <> C.
intros.
assert (~ Col A B C -> ~ Col B C A).

*****

*****

+++++
Qed.
-----
Theorem notcolnotegal_3 : forall A B C : Point, ~ Col A B C -> A <> C.
-----
Theorem notcolnotegal_3 : forall A B C : Point, ~ Col A B C -> A <> C.

*****

*****
forall (A B C : Point) (_ : not (Col A B C)), not (eq A C)
+++++
intros.
-----
Theorem notcolnotegal_3 : forall A B C : Point, ~ Col A B C -> A <> C.
intros.

*****
H : not (Col A B C)
A,B,C : Point
*****
not (eq A C)
+++++
assert (~ Col A B C -> ~ Col A C B).
-----
Theorem notcolnotegal_3 : forall A B C : Point, ~ Col A B C -> A <> C.
intros.
assert (~ Col A B C -> ~ Col A C B).

*****
H : not (Col A B C)
A,B,C : Point
*****
forall _ : not (Col A B C), not (Col A C B)
+++++
intuition.
-----
Theorem notcolnotegal_3 : forall A B C : Point, ~ Col A B C -> A <> C.
intros.
assert (~ Col A B C -> ~ Col A C B).

*****
H0 : forall _ : not (Col A B C), not (Col A C B)
H : not (Col A B C)
A,B,C : Point
*****
not (eq A C)
+++++
assert (~ Col A C B).
-----
Theorem notcolnotegal_3 : forall A B C : Point, ~ Col A B C -> A <> C.
intros.
assert (~ Col A B C -> ~ Col A C B).
assert (~ Col A C B).

*****
H0 : forall _ : not (Col A B C), not (Col A C B)
H : not (Col A B C)
A,B,C : Point
*****
not (Col A C B)
+++++
auto.
-----
Theorem notcolnotegal_3 : forall A B C : Point, ~ Col A B C -> A <> C.
intros.
assert (~ Col A B C -> ~ Col A C B).
assert (~ Col A C B).

*****
H1 : not (Col A C B)
H0 : forall _ : not (Col A B C), not (Col A C B)
H : not (Col A B C)
A,B,C : Point
*****
not (eq A C)
+++++
eapply notcolnotegal_1.
-----
Theorem notcolnotegal_3 : forall A B C : Point, ~ Col A B C -> A <> C.
intros.
assert (~ Col A B C -> ~ Col A C B).
assert (~ Col A C B).
eapply notcolnotegal_1.

*****
H1 : not (Col A C B)
H0 : forall _ : not (Col A B C), not (Col A C B)
H : not (Col A B C)
A,B,C : Point
*****
not (Col A C ?C)
+++++
apply H1.
-----
Theorem notcolnotegal_3 : forall A B C : Point, ~ Col A B C -> A <> C.
intros.
assert (~ Col A B C -> ~ Col A C B).

*****

*****

+++++
Qed.
-----
Hint Resolve notcolnotegal_1 notcolnotegal_2 notcolnotegal_3: Geom.
-----
Theorem notparallelnotegal_1 : forall A B C D, \n ~ parallel A B C D -> A<>B.
-----
Theorem notparallelnotegal_1 : forall A B C D, ~ parallel A B C D -> A<>B.

*****

*****
forall (A B C D : Point) (_ : not (parallel A B C D)), not (eq A B)
+++++
Proof.
-----
Theorem notparallelnotegal_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.

*****

*****
forall (A B C D : Point) (_ : not (parallel A B C D)), not (eq A B)
+++++
intros.
-----
Theorem notparallelnotegal_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.

*****
H : not (parallel A B C D)
A,B,C,D : Point
*****
not (eq A B)
+++++
unfold not.
-----
Theorem notparallelnotegal_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.
unfold not.

*****
H : not (parallel A B C D)
A,B,C,D : Point
*****
forall _ : eq A B, False
+++++
intro.
-----
Theorem notparallelnotegal_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.
unfold not.
intro.

*****
H0 : eq A B
H : not (parallel A B C D)
A,B,C,D : Point
*****
False
+++++
subst.
-----
Theorem notparallelnotegal_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.
unfold not.
intro.
subst.

*****
H : not (parallel B B C D)
B,C,D : Point
*****
False
+++++
auto with Geom.
-----
Theorem notparallelnotegal_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.
unfold not.
intro.
subst.
auto with Geom.

*****

*****

+++++
Qed.
-----
Theorem notparallelnotegal_2 : forall A B C D, \n ~ parallel A B C D -> C<>D.
-----
Theorem notparallelnotegal_2 : forall A B C D, ~ parallel A B C D -> C<>D.

*****

*****
forall (A B C D : Point) (_ : not (parallel A B C D)), not (eq C D)
+++++
Proof.
-----
Theorem notparallelnotegal_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.

*****

*****
forall (A B C D : Point) (_ : not (parallel A B C D)), not (eq C D)
+++++
intros.
-----
Theorem notparallelnotegal_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.

*****
H : not (parallel A B C D)
A,B,C,D : Point
*****
not (eq C D)
+++++
unfold not.
-----
Theorem notparallelnotegal_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.
unfold not.

*****
H : not (parallel A B C D)
A,B,C,D : Point
*****
forall _ : eq C D, False
+++++
intro.
-----
Theorem notparallelnotegal_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.
unfold not.
intro.

*****
H0 : eq C D
H : not (parallel A B C D)
A,B,C,D : Point
*****
False
+++++
subst.
-----
Theorem notparallelnotegal_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.
unfold not.
intro.
subst.

*****
H : not (parallel A B D D)
A,B,D : Point
*****
False
+++++
auto with Geom.
-----
Theorem notparallelnotegal_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.
unfold not.
intro.
subst.
auto with Geom.

*****

*****

+++++
Qed.
-----
Hint Resolve notparallelnotegal_1 notparallelnotegal_2 : Geom.
-----
Theorem dirseg_1 :\n forall A B C D : Point, D ** C <> 0 -> A ** B / C ** D = B ** A / D ** C.
-----
Theorem dirseg_1 : forall A B C D : Point, D ** C <> 0 -> A ** B / C ** D = B ** A / D ** C.

*****

*****
forall (A B C D : Point) (_ : not (eq (DSeg D C) F0)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (DSeg B A) (DSeg D C))
+++++
Proof.
-----
Theorem dirseg_1 : forall A B C D : Point, D ** C <> 0 -> A ** B / C ** D = B ** A / D ** C.
Proof.

*****

*****
forall (A B C D : Point) (_ : not (eq (DSeg D C) F0)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (DSeg B A) (DSeg D C))
+++++
intros.
-----
Theorem dirseg_1 : forall A B C D : Point, D ** C <> 0 -> A ** B / C ** D = B ** A / D ** C.
Proof.
intros.

*****
H : not (eq (DSeg D C) F0)
A,B,C,D : Point
*****
eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (DSeg B A) (DSeg D C))
+++++
uniformize_dir_seg.
-----
Theorem dirseg_1 : forall A B C D : Point, D ** C <> 0 -> A ** B / C ** D = B ** A / D ** C.
Proof.
intros.
uniformize_dir_seg.

*****
H : not (eq (Fopp (DSeg C D)) F0)
A,B,C,D : Point
*****
eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (Fopp (DSeg A B)) (Fopp (DSeg C D)))
+++++
field.
-----
Theorem dirseg_1 : forall A B C D : Point, D ** C <> 0 -> A ** B / C ** D = B ** A / D ** C.
Proof.
intros.
uniformize_dir_seg.
field.

*****
H : not (eq (Fopp (DSeg C D)) F0)
A,B,C,D : Point
*****
and (not (eq (Fopp (DSeg C D)) F0)) (not (eq (DSeg C D) F0))
+++++
Geometry.
-----
Theorem dirseg_1 : forall A B C D : Point, D ** C <> 0 -> A ** B / C ** D = B ** A / D ** C.
Proof.
intros.
uniformize_dir_seg.
field.
Geometry.

*****

*****

+++++
Qed.
-----
Hint Resolve dirseg_1: Geom.
-----
Theorem dirseg_2 : forall A B C D : Point, A ** B = C ** D -> B ** A = D ** C.
-----
Theorem dirseg_2 : forall A B C D : Point, A ** B = C ** D -> B ** A = D ** C.

*****

*****
forall (A B C D : Point) (_ : eq (DSeg A B) (DSeg C D)), eq (DSeg B A) (DSeg D C)
+++++
Proof.
-----
Theorem dirseg_2 : forall A B C D : Point, A ** B = C ** D -> B ** A = D ** C.
Proof.

*****

*****
forall (A B C D : Point) (_ : eq (DSeg A B) (DSeg C D)), eq (DSeg B A) (DSeg D C)
+++++
intros.
-----
Theorem dirseg_2 : forall A B C D : Point, A ** B = C ** D -> B ** A = D ** C.
Proof.
intros.

*****
H : eq (DSeg A B) (DSeg C D)
A,B,C,D : Point
*****
eq (DSeg B A) (DSeg D C)
+++++
uniformize_dir_seg.
-----
Theorem dirseg_2 : forall A B C D : Point, A ** B = C ** D -> B ** A = D ** C.
Proof.
intros.
uniformize_dir_seg.

*****
H : eq (DSeg A B) (DSeg C D)
A,B,C,D : Point
*****
eq (Fopp (DSeg A B)) (Fopp (DSeg C D))
+++++
rewrite H.
-----
Theorem dirseg_2 : forall A B C D : Point, A ** B = C ** D -> B ** A = D ** C.
Proof.
intros.
uniformize_dir_seg.
rewrite H.

*****
H : eq (DSeg A B) (DSeg C D)
A,B,C,D : Point
*****
eq (Fopp (DSeg C D)) (Fopp (DSeg C D))
+++++
auto.
-----
Theorem dirseg_2 : forall A B C D : Point, A ** B = C ** D -> B ** A = D ** C.
Proof.
intros.
uniformize_dir_seg.
rewrite H.
auto.

*****

*****

+++++
Qed.
-----
Hint Resolve dirseg_2: Geom.
-----
Theorem dirseg_3 :\n forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (B ** A / C ** D).
-----
Theorem dirseg_3 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (B ** A / C ** D).

*****

*****
forall (A B C D : Point) (_ : not (eq (DSeg C D) F0)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fopp (Fdiv (DSeg B A) (DSeg C D)))
+++++
Proof.
-----
Theorem dirseg_3 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (B ** A / C ** D).
Proof.

*****

*****
forall (A B C D : Point) (_ : not (eq (DSeg C D) F0)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fopp (Fdiv (DSeg B A) (DSeg C D)))
+++++
intros.
-----
Theorem dirseg_3 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (B ** A / C ** D).
Proof.
intros.

*****
H : not (eq (DSeg C D) F0)
A,B,C,D : Point
*****
eq (Fdiv (DSeg A B) (DSeg C D)) (Fopp (Fdiv (DSeg B A) (DSeg C D)))
+++++
uniformize_dir_seg.
-----
Theorem dirseg_3 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (B ** A / C ** D).
Proof.
intros.
uniformize_dir_seg.

*****
H : not (eq (DSeg C D) F0)
A,B,C,D : Point
*****
eq (Fdiv (DSeg A B) (DSeg C D)) (Fopp (Fdiv (Fopp (DSeg A B)) (DSeg C D)))
+++++
field.
-----
Theorem dirseg_3 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (B ** A / C ** D).
Proof.
intros.
uniformize_dir_seg.
field.

*****
H : not (eq (DSeg C D) F0)
A,B,C,D : Point
*****
not (eq (DSeg C D) F0)
+++++
Geometry.
-----
Theorem dirseg_3 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (B ** A / C ** D).
Proof.
intros.
uniformize_dir_seg.
field.
Geometry.

*****

*****

+++++
Qed.
-----
Theorem dirseg_4 :\n forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (A ** B / D ** C).
-----
Theorem dirseg_4 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (A ** B / D ** C).

*****

*****
forall (A B C D : Point) (_ : not (eq (DSeg C D) F0)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fopp (Fdiv (DSeg A B) (DSeg D C)))
+++++
Proof.
-----
Theorem dirseg_4 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (A ** B / D ** C).
Proof.

*****

*****
forall (A B C D : Point) (_ : not (eq (DSeg C D) F0)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fopp (Fdiv (DSeg A B) (DSeg D C)))
+++++
intros.
-----
Theorem dirseg_4 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (A ** B / D ** C).
Proof.
intros.

*****
H : not (eq (DSeg C D) F0)
A,B,C,D : Point
*****
eq (Fdiv (DSeg A B) (DSeg C D)) (Fopp (Fdiv (DSeg A B) (DSeg D C)))
+++++
Geometry.
-----
Theorem dirseg_4 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (A ** B / D ** C).
Proof.
intros.
Geometry.

*****
H : not (eq (DSeg C D) F0)
A,B,C,D : Point
*****
eq (Fdiv (DSeg A B) (DSeg C D)) (Fopp (Fdiv (DSeg A B) (DSeg D C)))
+++++
uniformize_dir_seg.
-----
Theorem dirseg_4 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (A ** B / D ** C).
Proof.
intros.
Geometry.
uniformize_dir_seg.

*****
H : not (eq (DSeg C D) F0)
A,B,C,D : Point
*****
eq (Fdiv (DSeg A B) (DSeg C D)) (Fopp (Fdiv (DSeg A B) (Fopp (DSeg C D))))
+++++
field.
-----
Theorem dirseg_4 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (A ** B / D ** C).
Proof.
intros.
Geometry.
uniformize_dir_seg.
field.

*****
H : not (eq (DSeg C D) F0)
A,B,C,D : Point
*****
and (not (eq (Fopp (DSeg C D)) F0)) (not (eq (DSeg C D) F0))
+++++
Geometry.
-----
Theorem dirseg_4 : forall A B C D : Point, C ** D <> 0 -> A ** B / C ** D = - (A ** B / D ** C).
Proof.
intros.
Geometry.
uniformize_dir_seg.
field.
Geometry.

*****

*****

+++++
Qed.
-----
Hint Resolve dirseg_3 dirseg_4: Geom.
-----
Theorem dirseg_simpl_1 : \n forall A B, A<>B -> A**B / A**B = 1.
-----
Theorem dirseg_simpl_1 : forall A B, A<>B -> A**B / A**B = 1.

*****

*****
forall (A B : Point) (_ : not (eq A B)), eq (Fdiv (DSeg A B) (DSeg A B)) F1
+++++
Proof.
-----
Theorem dirseg_simpl_1 : forall A B, A<>B -> A**B / A**B = 1.
Proof.

*****

*****
forall (A B : Point) (_ : not (eq A B)), eq (Fdiv (DSeg A B) (DSeg A B)) F1
+++++
intros.
-----
Theorem dirseg_simpl_1 : forall A B, A<>B -> A**B / A**B = 1.
Proof.
intros.

*****
H : not (eq A B)
A,B : Point
*****
eq (Fdiv (DSeg A B) (DSeg A B)) F1
+++++
field.
-----
Theorem dirseg_simpl_1 : forall A B, A<>B -> A**B / A**B = 1.
Proof.
intros.
field.

*****
H : not (eq A B)
A,B : Point
*****
not (eq (DSeg A B) F0)
+++++
auto with Geom.
-----
Theorem dirseg_simpl_1 : forall A B, A<>B -> A**B / A**B = 1.
Proof.
intros.
field.
auto with Geom.

*****

*****

+++++
Qed.
-----
Theorem dirseg_simpl_2 : \n forall A B, A<>B -> B**A / A**B = -(1).
-----
Theorem dirseg_simpl_2 : forall A B, A<>B -> B**A / A**B = -(1).

*****

*****
forall (A B : Point) (_ : not (eq A B)), eq (Fdiv (DSeg B A) (DSeg A B)) (Fopp F1)
+++++
Proof.
-----
Theorem dirseg_simpl_2 : forall A B, A<>B -> B**A / A**B = -(1).
Proof.

*****

*****
forall (A B : Point) (_ : not (eq A B)), eq (Fdiv (DSeg B A) (DSeg A B)) (Fopp F1)
+++++
intros.
-----
Theorem dirseg_simpl_2 : forall A B, A<>B -> B**A / A**B = -(1).
Proof.
intros.

*****
H : not (eq A B)
A,B : Point
*****
eq (Fdiv (DSeg B A) (DSeg A B)) (Fopp F1)
+++++
replace (B**A) with (- A**B).
-----
Theorem dirseg_simpl_2 : forall A B, A<>B -> B**A / A**B = -(1).
Proof.
intros.
replace (B**A) with (- A**B).

*****
H : not (eq A B)
A,B : Point
*****
eq (Fdiv (Fopp (DSeg A B)) (DSeg A B)) (Fopp F1)
+++++
field.
-----
Theorem dirseg_simpl_2 : forall A B, A<>B -> B**A / A**B = -(1).
Proof.
intros.
replace (B**A) with (- A**B).
field.

*****
H : not (eq A B)
A,B : Point
*****
not (eq (DSeg A B) F0)
+++++
auto with Geom.
-----
Theorem dirseg_simpl_2 : forall A B, A<>B -> B**A / A**B = -(1).
Proof.
intros.
replace (B**A) with (- A**B).

*****
H : not (eq A B)
A,B : Point
*****
eq (Fopp (DSeg A B)) (DSeg B A)
+++++
symmetry.
-----
Theorem dirseg_simpl_2 : forall A B, A<>B -> B**A / A**B = -(1).
Proof.
intros.
replace (B**A) with (- A**B).
symmetry.

*****
H : not (eq A B)
A,B : Point
*****
eq (DSeg B A) (Fopp (DSeg A B))
+++++
auto with Geom.
-----
Theorem dirseg_simpl_2 : forall A B, A<>B -> B**A / A**B = -(1).
Proof.
intros.
replace (B**A) with (- A**B).

*****

*****

+++++
Qed.
-----
Theorem dirsur_1 :\n forall A B C D E F : Point,\n ~ Col D E F -> S A B C / S D E F = S A C B / S D F E.
-----
Theorem dirsur_1 : forall A B C D E F : Point, ~ Col D E F -> S A B C / S D E F = S A C B / S D F E.

*****

*****
forall (A B C D E F0 : Point) (_ : not (Col D E F0)), eq (Fdiv (S A B C) (S D E F0)) (Fdiv (S A C B) (S D F0 E))
+++++
Proof.
-----
Theorem dirsur_1 : forall A B C D E F : Point, ~ Col D E F -> S A B C / S D E F = S A C B / S D F E.
Proof.

*****

*****
forall (A B C D E F0 : Point) (_ : not (Col D E F0)), eq (Fdiv (S A B C) (S D E F0)) (Fdiv (S A C B) (S D F0 E))
+++++
intros.
-----
Theorem dirsur_1 : forall A B C D E F : Point, ~ Col D E F -> S A B C / S D E F = S A C B / S D F E.
Proof.
intros.

*****
H : not (Col D E F)
A,B,C,D,E,F : Point
*****
eq (Fdiv (S A B C) (S D E F)) (Fdiv (S A C B) (S D F E))
+++++
uniformize_signed_areas.
-----
Theorem dirsur_1 : forall A B C D E F : Point, ~ Col D E F -> S A B C / S D E F = S A C B / S D F E.
Proof.
intros.
uniformize_signed_areas.

*****
H : not (Col D E F)
A,B,C,D,E,F : Point
*****
eq (Fdiv (S A B C) (S D E F)) (Fdiv (Fopp (S A B C)) (Fopp (S D E F)))
+++++
field.
-----
Theorem dirsur_1 : forall A B C D E F : Point, ~ Col D E F -> S A B C / S D E F = S A C B / S D F E.
Proof.
intros.
uniformize_signed_areas.
field.

*****
H : not (Col D E F)
A,B,C,D,E,F : Point
*****
and (not (eq (Fopp (S D E F)) F0)) (not (eq (S D E F) F0))
+++++
Geometry.
-----
Theorem dirsur_1 : forall A B C D E F : Point, ~ Col D E F -> S A B C / S D E F = S A C B / S D F E.
Proof.
intros.
uniformize_signed_areas.
field.
Geometry.

*****

*****

+++++
Qed.
-----
Hint Resolve dirsur_1: Geom.
-----
Theorem col_trans_1 :\n forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.

*****

*****
forall (A B C D : Point) (_ : not (eq A B)) (_ : Col A B C) (_ : Col A B D), Col A C D
+++++
Proof.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.

*****

*****
forall (A B C D : Point) (_ : not (eq A B)) (_ : Col A B C) (_ : Col A B D), Col A C D
+++++
intros.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.

*****
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
assert (S A B C = S A B D + S A D C + S D B C).
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).

*****
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq (S A B C) (Fplus (Fplus (S A B D) (S A D C)) (S D B C))
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).

*****
H2 : eq (S A B C) (Fplus (Fplus (S A B D) (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.

*****
H2 : eq (S A B C) (Fplus (Fplus (S A B D) (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
rewrite H0 in H2.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.

*****
H2 : eq F0 (Fplus (Fplus (S A B D) (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
rewrite H1 in H2.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.

*****
H2 : eq F0 (Fplus (Fplus F0 (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
cases_col A D C.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.

*****
H3 : Col A D C
H2 : eq F0 (Fplus (Fplus F0 (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.

*****
H3 : not (Col A D C)
H2 : eq F0 (Fplus (Fplus F0 (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.

*****
H3 : not (Col A D C)
H2 : eq F0 (Fplus (Fplus F0 (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
cases_equality C A.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.

*****
H4 : eq C A
H3 : not (Col A D C)
H2 : eq F0 (Fplus (Fplus F0 (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.

*****
H4 : eq C A
H3 : not (Col A D C)
H2 : eq F0 (Fplus (Fplus F0 (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
apply egalcol.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
apply egalcol.

*****
H4 : eq C A
H3 : not (Col A D C)
H2 : eq F0 (Fplus (Fplus F0 (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq A C
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.

*****
H4 : not (eq C A)
H3 : not (Col A D C)
H2 : eq F0 (Fplus (Fplus F0 (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.

*****
H4 : not (eq C A)
H3 : not (Col A D C)
H2 : eq F0 (Fplus (Fplus F0 (S A D C)) (S D B C))
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
NormalizeRing H2.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.

*****
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.

*****
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
assert (C ** B / C ** A = S D C B / S D C A).
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).

*****
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S D C B) (S D C A))
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).

*****
H5 : eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.

*****
H5 : eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
assert (C ** A + A ** B = C ** B).
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).

*****
H5 : eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).

*****
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.

*****
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
rewrite <- H6 in H5.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.

*****
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.

*****
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).

*****
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A)) (Fplus F1 (Fdiv (DSeg A B) (DSeg C A)))
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.

*****
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A)) (Fplus F1 (Fdiv (DSeg A B) (DSeg C A)))
+++++
field.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
field.

*****
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
not (eq (DSeg C A) F0)
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).

*****
H7 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fplus F1 (Fdiv (DSeg A B) (DSeg C A)))
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.

*****
H7 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fplus F1 (Fdiv (DSeg A B) (DSeg C A)))
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
rewrite H7 in H5.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.

*****
H7 : eq (Fdiv (Fplus (DSeg C A) (DSeg A B)) (DSeg C A))\n (Fplus F1 (Fdiv (DSeg A B) (DSeg C A)))
H6 : eq (Fplus (DSeg C A) (DSeg A B)) (DSeg C B)
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
clear H7 H6.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.

*****
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
assert (S D B C = - S D C B).
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).

*****
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq (S D B C) (Fopp (S D C B))
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).

*****
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.

*****
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (S D B C))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
rewrite H6 in H2.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.

*****
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (Fopp (S D C B)))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.

*****
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (Fopp (S D C B)))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
assert (S A D C = S D C A).
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).

*****
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (Fopp (S D C B)))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq (S A D C) (S D C A)
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).

*****
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (Fopp (S D C B)))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.

*****
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S A D C) (Fopp (S D C B)))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
rewrite H7 in H2.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.

*****
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S D C A) (Fopp (S D C B)))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.

*****
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H2 : eq F0 (Fplus (S D C A) (Fopp (S D C B)))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
IsoleVarRing (S D C B) H2.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.

*****
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.

*****
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C B) (S D C A))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
rewrite H2 in H5.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.

*****
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C A) (S D C A))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.

*****
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C A) (S D C A))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
assert (S D C A / S D C A = 1).
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).

*****
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C A) (S D C A))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq (Fdiv (S D C A) (S D C A)) F1
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.

*****
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C A) (S D C A))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq (Fdiv (S D C A) (S D C A)) F1
+++++
field.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.
field.

*****
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C A) (S D C A))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
not (eq (S D C A) F0)
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).

*****
H8 : eq (Fdiv (S D C A) (S D C A)) F1
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C A) (S D C A))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.

*****
H8 : eq (Fdiv (S D C A) (S D C A)) F1
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) (Fdiv (S D C A) (S D C A))
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
rewrite H8 in H5.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.
rewrite H8 in H5.

*****
H8 : eq (Fdiv (S D C A) (S D C A)) F1
H2 : eq (S D C B) (S D C A)
H7 : eq (S A D C) (S D C A)
H6 : eq (S D B C) (Fopp (S D C B))
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) F1
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
clear H6 H7 H8.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.
rewrite H8 in H5.
clear H6 H7 H8.

*****
H2 : eq (S D C B) (S D C A)
H5 : eq (Fplus F1 (Fdiv (DSeg A B) (DSeg C A))) F1
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
IsoleVarRing (A ** B) H5.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.
rewrite H8 in H5.
clear H6 H7 H8.
IsoleVarRing (A ** B) H5.

*****
H5 : eq (DSeg A B) F0
H6 : not (eq (DSeg C A) F0)
H2 : eq (S D C B) (S D C A)
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.
rewrite H8 in H5.
clear H6 H7 H8.
IsoleVarRing (A ** B) H5.
Geometry.

*****
H5 : eq (DSeg A B) F0
H6 : not (eq (DSeg C A) F0)
H2 : eq (S D C B) (S D C A)
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
assert (A = B).
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.
rewrite H8 in H5.
clear H6 H7 H8.
IsoleVarRing (A ** B) H5.
Geometry.
assert (A = B).

*****
H5 : eq (DSeg A B) F0
H6 : not (eq (DSeg C A) F0)
H2 : eq (S D C B) (S D C A)
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
eq A B
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.
rewrite H8 in H5.
clear H6 H7 H8.
IsoleVarRing (A ** B) H5.
Geometry.
assert (A = B).

*****
H7 : eq A B
H5 : eq (DSeg A B) F0
H6 : not (eq (DSeg C A) F0)
H2 : eq (S D C B) (S D C A)
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.
rewrite H8 in H5.
clear H6 H7 H8.
IsoleVarRing (A ** B) H5.
Geometry.
assert (A = B).
Geometry.

*****
H7 : eq A B
H5 : eq (DSeg A B) F0
H6 : not (eq (DSeg C A) F0)
H2 : eq (S D C B) (S D C A)
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
Col A C D
+++++
intuition.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).
Geometry.
rewrite H0 in H2.
rewrite H1 in H2.
cases_col A D C.
Geometry.
cases_equality C A.
Geometry.
NormalizeRing H2.
Geometry.
assert (C ** B / C ** A = S D C B / S D C A).
Geometry.
assert (C ** A + A ** B = C ** B).
Geometry.
rewrite <- H6 in H5.
Geometry.
assert ((C ** A + A ** B) / C ** A = 1 + A ** B / C ** A).
Geometry.
rewrite H7 in H5.
clear H7 H6.
assert (S D B C = - S D C B).
Geometry.
rewrite H6 in H2.
Geometry.
assert (S A D C = S D C A).
Geometry.
rewrite H7 in H2.
Geometry.
IsoleVarRing (S D C B) H2.
Geometry.
rewrite H2 in H5.
Geometry.
assert (S D C A / S D C A = 1).
Geometry.
rewrite H8 in H5.
clear H6 H7 H8.
IsoleVarRing (A ** B) H5.

*****
H5 : eq (Fplus (Fdiv (DSeg A B) (DSeg C A)) F1) F1
H2 : eq (S D C B) (S D C A)
H4 : not (eq C A)
H3 : not (Col A D C)
H1 : Col A B D
H0 : Col A B C
H : not (eq A B)
A,B,C,D : Point
*****
not (eq (DSeg C A) F0)
+++++
Geometry.
-----
Theorem col_trans_1 : forall A B C D : Point, A <> B -> Col A B C -> Col A B D -> Col A C D.
Proof.
intros.
assert (S A B C = S A B D + S A D C + S D B C).

*****

*****

+++++
Qed.
-----
Hint Resolve col_trans_1.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.

*****

*****
forall (A B : Point) (_ : not (eq A B)), ex (fun C : Point => not (Col A B C))
+++++
Proof.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.

*****

*****
forall (A B : Point) (_ : not (eq A B)), ex (fun C : Point => not (Col A B C))
+++++
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).

*****

*****
sigT (fun A : Point => sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
+++++
apply A4.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).

*****
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
forall (A B : Point) (_ : not (eq A B)), ex (fun C : Point => not (Col A B C))
+++++
intros.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.

*****
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
elim H.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.

*****
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
forall (x : Point) (_ : sigT (fun B : Point => sig (fun C : Point => not (Col x B C)))), ex (fun C : Point => not (Col A B C))
+++++
intro X.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.

*****
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
forall _ : sigT (fun B : Point => sig (fun C : Point => not (Col X B C))), ex (fun C : Point => not (Col A B C))
+++++
intros.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.

*****
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
elim p.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.

*****
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
forall (x : Point) (_ : sig (fun C : Point => not (Col X x C))), ex (fun C : Point => not (Col A B C))
+++++
intro Y.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.

*****
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
forall _ : sig (fun C : Point => not (Col X Y C)), ex (fun C : Point => not (Col A B C))
+++++
intros.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.

*****
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
elim p0.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.

*****
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
forall (x : Point) (_ : not (Col X Y x)), ex (fun C : Point => not (Col A B C))
+++++
intro Z.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.

*****
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
forall _ : not (Col X Y Z), ex (fun C : Point => not (Col A B C))
+++++
intros.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.

*****
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
cases_col A B X.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.

*****
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
cases_col A B Y.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.

*****
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
cases_col A B Z.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.

*****
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
cases_equality Y A.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.

*****
H4 : eq Y A
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
subst Y.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
subst Y.

*****
H3 : Col A B Z
H2 : Col A B A
H1 : Col A B X
p1 : not (Col X A Z)
Z : Point
p0 : sig (fun C : Point => not (Col X A C))
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
assert (Col A X Z).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
subst Y.
assert (Col A X Z).

*****
H3 : Col A B Z
H2 : Col A B A
H1 : Col A B X
p1 : not (Col X A Z)
Z : Point
p0 : sig (fun C : Point => not (Col X A C))
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col A X Z
+++++
eapply col_trans_1 with (B:=B).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
subst Y.
assert (Col A X Z).
eapply col_trans_1 with (B:=B).

*****
H3 : Col A B Z
H2 : Col A B A
H1 : Col A B X
p1 : not (Col X A Z)
Z : Point
p0 : sig (fun C : Point => not (Col X A C))
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
not (eq A B)
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
subst Y.
assert (Col A X Z).
eapply col_trans_1 with (B:=B).

*****
H3 : Col A B Z
H2 : Col A B A
H1 : Col A B X
p1 : not (Col X A Z)
Z : Point
p0 : sig (fun C : Point => not (Col X A C))
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col A B X
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
subst Y.
assert (Col A X Z).
eapply col_trans_1 with (B:=B).

*****
H3 : Col A B Z
H2 : Col A B A
H1 : Col A B X
p1 : not (Col X A Z)
Z : Point
p0 : sig (fun C : Point => not (Col X A C))
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col A B Z
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
subst Y.
assert (Col A X Z).

*****
H4 : Col A X Z
H3 : Col A B Z
H2 : Col A B A
H1 : Col A B X
p1 : not (Col X A Z)
Z : Point
p0 : sig (fun C : Point => not (Col X A C))
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
assert (Col X A Z).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
subst Y.
assert (Col A X Z).
assert (Col X A Z).

*****
H4 : Col A X Z
H3 : Col A B Z
H2 : Col A B A
H1 : Col A B X
p1 : not (Col X A Z)
Z : Point
p0 : sig (fun C : Point => not (Col X A C))
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col X A Z
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
subst Y.
assert (Col A X Z).
assert (Col X A Z).

*****
H5 : Col X A Z
H4 : Col A X Z
H3 : Col A B Z
H2 : Col A B A
H1 : Col A B X
p1 : not (Col X A Z)
Z : Point
p0 : sig (fun C : Point => not (Col X A C))
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
subst Y.
assert (Col A X Z).
assert (Col X A Z).
Geometry.

*****
H5 : Col X A Z
H4 : Col A X Z
H3 : Col A B Z
H2 : Col A B A
H1 : Col A B X
p1 : not (Col X A Z)
Z : Point
p0 : sig (fun C : Point => not (Col X A C))
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
intuition.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.

*****
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
assert (Col A Y Z).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).

*****
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col A Y Z
+++++
eapply col_trans_1 with (B:=B).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
eapply col_trans_1 with (B:=B).

*****
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
not (eq A B)
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
eapply col_trans_1 with (B:=B).

*****
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col A B Y
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
eapply col_trans_1 with (B:=B).

*****
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col A B Z
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).

*****
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
assert (Col A Y X).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).

*****
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col A Y X
+++++
eapply col_trans_1 with (B:=B).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
eapply col_trans_1 with (B:=B).

*****
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
not (eq A B)
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
eapply col_trans_1 with (B:=B).

*****
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col A B Y
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
eapply col_trans_1 with (B:=B).

*****
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col A B X
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).

*****
H6 : Col A Y X
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
assert (Col Y X Z).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
assert (Col Y X Z).

*****
H6 : Col A Y X
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col Y X Z
+++++
eapply col_trans_1 with (B:=A).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
assert (Col Y X Z).
eapply col_trans_1 with (B:=A).

*****
H6 : Col A Y X
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
not (eq Y A)
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
assert (Col Y X Z).
eapply col_trans_1 with (B:=A).

*****
H6 : Col A Y X
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col Y A X
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
assert (Col Y X Z).
eapply col_trans_1 with (B:=A).

*****
H6 : Col A Y X
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col Y A Z
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
assert (Col Y X Z).

*****
H7 : Col Y X Z
H6 : Col A Y X
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
assert (Col X Y Z).
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
assert (Col Y X Z).
assert (Col X Y Z).

*****
H7 : Col Y X Z
H6 : Col A Y X
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
Col X Y Z
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
assert (Col Y X Z).
assert (Col X Y Z).

*****
H8 : Col X Y Z
H7 : Col Y X Z
H6 : Col A Y X
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
cases_equality Y A.
assert (Col A Y Z).
assert (Col A Y X).
assert (Col Y X Z).
assert (Col X Y Z).
Geometry.

*****
H8 : Col X Y Z
H7 : Col Y X Z
H6 : Col A Y X
H5 : Col A Y Z
H4 : not (eq Y A)
H3 : Col A B Z
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
intuition.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.

*****
H3 : not (Col A B Z)
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
exists Z.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
cases_col A B Z.
exists Z.

*****
H3 : not (Col A B Z)
H2 : Col A B Y
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
not (Col A B Z)
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.

*****
H2 : not (Col A B Y)
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
exists Y.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
cases_col A B Y.
exists Y.

*****
H2 : not (Col A B Y)
H1 : Col A B X
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
not (Col A B Y)
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.

*****
H1 : not (Col A B X)
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
ex (fun C : Point => not (Col A B C))
+++++
exists X.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
intros.
elim H.
intro X.
intros.
elim p.
intro Y.
intros.
elim p0.
intro Z.
intros.
cases_col A B X.
exists X.

*****
H1 : not (Col A B X)
p1 : not (Col X Y Z)
Z : Point
p0 : sig (fun C : Point => not (Col X Y C))
Y : Point
p : sigT (fun B : Point => sig (fun C : Point => not (Col X B C)))
X : Point
H0 : not (eq A B)
A,B : Point
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
*****
not (Col A B X)
+++++
Geometry.
-----
Lemma build_point_not_collinear_1 : forall A B, A<>B -> exists C, ~ Col A B C.
Proof.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).

*****

*****

+++++
Qed.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.

*****

*****
forall A : Point, ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
Proof.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.

*****

*****
forall A : Point, ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
intros.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.

*****
A : Point
*****
ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).

*****
A : Point
*****
sigT (fun A : Point => sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
+++++
apply A4.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).

*****
H : sigT\n (fun A : Point =>\n sigT (fun B : Point => sig (fun C : Point => not (Col A B C))))
A : Point
*****
ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
DecompEx H A1.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.

*****
p : sigT (fun B : Point => sig (fun C : Point => not (Col A1 B C)))
A,A1 : Point
*****
ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
DecompEx p B.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.

*****
p0 : sig (fun C : Point => not (Col A1 B C))
A,A1,B : Point
*****
ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
DecompEx p0 C.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.

*****
p : not (Col A1 B C)
A,A1,B,C : Point
*****
ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
cases_equality A B.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.
cases_equality A B.

*****
H : eq A B
p : not (Col A1 B C)
A,A1,B,C : Point
*****
ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
subst A.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.
cases_equality A B.
subst A.

*****
p : not (Col A1 B C)
A1,B,C : Point
*****
ex (fun B0 : Point => ex (fun C : Point => not (Col B B0 C)))
+++++
exists A1.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.
cases_equality A B.
subst A.
exists A1.

*****
p : not (Col A1 B C)
A1,B,C : Point
*****
ex (fun C : Point => not (Col B A1 C))
+++++
exists C.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.
cases_equality A B.
subst A.
exists A1.
exists C.

*****
p : not (Col A1 B C)
A1,B,C : Point
*****
not (Col B A1 C)
+++++
Geometry.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.
cases_equality A B.

*****
H : not (eq A B)
p : not (Col A1 B C)
A,A1,B,C : Point
*****
ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
assert (T:=build_point_not_collinear_1 A B H).
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.
cases_equality A B.
assert (T:=build_point_not_collinear_1 A B H).

*****
T : ex (fun C : Point => not (Col A B C))
H : not (eq A B)
p : not (Col A1 B C)
A,A1,B,C : Point
*****
ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
DecompEx T C1.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.
cases_equality A B.
assert (T:=build_point_not_collinear_1 A B H).
DecompEx T C1.

*****
H0 : not (Col A B C1)
C1 : Point
H : not (eq A B)
p : not (Col A1 B C)
A,A1,B,C : Point
*****
ex (fun B : Point => ex (fun C : Point => not (Col A B C)))
+++++
exists B.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.
cases_equality A B.
assert (T:=build_point_not_collinear_1 A B H).
DecompEx T C1.
exists B.

*****
H0 : not (Col A B C1)
C1 : Point
H : not (eq A B)
p : not (Col A1 B C)
A,A1,B,C : Point
*****
ex (fun C : Point => not (Col A B C))
+++++
exists C1.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).
DecompEx H A1.
DecompEx p B.
DecompEx p0 C.
cases_equality A B.
assert (T:=build_point_not_collinear_1 A B H).
DecompEx T C1.
exists B.
exists C1.

*****
H0 : not (Col A B C1)
C1 : Point
H : not (eq A B)
p : not (Col A1 B C)
A,A1,B,C : Point
*****
not (Col A B C1)
+++++
Geometry.
-----
Lemma build_point_not_collinear_2 : forall A, exists B, exists C, ~ Col A B C.
Proof.
intros.
assert ({A : Point & {B : Point & {C : Point | ~ Col A B C}}}).

*****

*****

+++++
Qed.
-----
Theorem col_not_col_1 :\n forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.

*****

*****
forall (A B O P : Point) (_ : not (eq A O)) (_ : Col A P O) (_ : not (Col P A B)), not (Col O A B)
+++++
Proof.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.

*****

*****
forall (A B O P : Point) (_ : not (eq A O)) (_ : Col A P O) (_ : not (Col P A B)), not (Col O A B)
+++++
intros.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.

*****
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
not (Col O A B)
+++++
unfold not in |- *.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.

*****
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
forall _ : Col O A B, False
+++++
intro.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.

*****
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
False
+++++
assert (Col A O P).
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).

*****
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
Col A O P
+++++
Geometry.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).

*****
H3 : Col A O P
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
False
+++++
Geometry.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).
Geometry.

*****
H3 : Col A O P
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
False
+++++
assert (Col A O B).
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).
Geometry.
assert (Col A O B).

*****
H3 : Col A O P
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
Col A O B
+++++
Geometry.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).
Geometry.
assert (Col A O B).

*****
H4 : Col A O B
H3 : Col A O P
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
False
+++++
Geometry.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).
Geometry.
assert (Col A O B).
Geometry.

*****
H4 : Col A O B
H3 : Col A O P
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
False
+++++
assert (Col A P B).
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).
Geometry.
assert (Col A O B).
Geometry.
assert (Col A P B).

*****
H4 : Col A O B
H3 : Col A O P
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
Col A P B
+++++
Geometry.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).
Geometry.
assert (Col A O B).
Geometry.
assert (Col A P B).
Geometry.

*****
H4 : Col A O B
H3 : Col A O P
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
Col A P B
+++++
eauto with Geom.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).
Geometry.
assert (Col A O B).
Geometry.
assert (Col A P B).

*****
H5 : Col A P B
H4 : Col A O B
H3 : Col A O P
H2 : Col O A B
H1 : not (Col P A B)
H0 : Col A P O
H : not (eq A O)
A,B,O,P : Point
*****
False
+++++
Geometry.
-----
Theorem col_not_col_1 : forall A B O P : Point, A <> O -> Col A P O -> ~ Col P A B -> ~ Col O A B.
Proof.
intros.
unfold not in |- *.
intro.
assert (Col A O P).

*****

*****

+++++
Qed.
-----
Hint Resolve col_not_col_1.
-----
Theorem A6_1 :\n forall P Q A M : Point,\n M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.

*****

*****
forall (P Q A M : Point) (_ : not (eq M Q)) (_ : not (Col Q A M)) (_ : Col P Q M), eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
Proof.
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.

*****

*****
forall (P Q A M : Point) (_ : not (eq M Q)) (_ : not (Col Q A M)) (_ : Col P Q M), eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
intros.
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.

*****
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].

*****
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
assert (P ** M / Q ** M = M ** P / M ** Q).
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).

*****
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).

*****
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).
try solve [ Geometry | congruence ].

*****
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
assert (M ** P / M ** Q = S A M P / S A M Q).
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).
try solve [ Geometry | congruence ].
assert (M ** P / M ** Q = S A M P / S A M Q).

*****
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg M P) (DSeg M Q)) (Fdiv (S A M P) (S A M Q))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).
try solve [ Geometry | congruence ].
assert (M ** P / M ** Q = S A M P / S A M Q).

*****
H3 : eq (Fdiv (DSeg M P) (DSeg M Q)) (Fdiv (S A M P) (S A M Q))
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).
try solve [ Geometry | congruence ].
assert (M ** P / M ** Q = S A M P / S A M Q).
try solve [ Geometry | congruence ].

*****
H3 : eq (Fdiv (DSeg M P) (DSeg M Q)) (Fdiv (S A M P) (S A M Q))
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
assert (S A M P = S P A M).
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).
try solve [ Geometry | congruence ].
assert (M ** P / M ** Q = S A M P / S A M Q).
try solve [ Geometry | congruence ].
assert (S A M P = S P A M).

*****
H3 : eq (Fdiv (DSeg M P) (DSeg M Q)) (Fdiv (S A M P) (S A M Q))
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (S A M P) (S P A M)
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).
try solve [ Geometry | congruence ].
assert (M ** P / M ** Q = S A M P / S A M Q).
try solve [ Geometry | congruence ].
assert (S A M P = S P A M).

*****
H4 : eq (S A M P) (S P A M)
H3 : eq (Fdiv (DSeg M P) (DSeg M Q)) (Fdiv (S A M P) (S A M Q))
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).
try solve [ Geometry | congruence ].
assert (M ** P / M ** Q = S A M P / S A M Q).
try solve [ Geometry | congruence ].
assert (S A M P = S P A M).
try solve [ Geometry | congruence ].

*****
H4 : eq (S A M P) (S P A M)
H3 : eq (Fdiv (DSeg M P) (DSeg M Q)) (Fdiv (S A M P) (S A M Q))
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
assert (S A M Q = S Q A M).
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).
try solve [ Geometry | congruence ].
assert (M ** P / M ** Q = S A M P / S A M Q).
try solve [ Geometry | congruence ].
assert (S A M P = S P A M).
try solve [ Geometry | congruence ].
assert (S A M Q = S Q A M).

*****
H4 : eq (S A M P) (S P A M)
H3 : eq (Fdiv (DSeg M P) (DSeg M Q)) (Fdiv (S A M P) (S A M Q))
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (S A M Q) (S Q A M)
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).
try solve [ Geometry | congruence ].
assert (M ** P / M ** Q = S A M P / S A M Q).
try solve [ Geometry | congruence ].
assert (S A M P = S P A M).
try solve [ Geometry | congruence ].
assert (S A M Q = S Q A M).

*****
H5 : eq (S A M Q) (S Q A M)
H4 : eq (S A M P) (S P A M)
H3 : eq (Fdiv (DSeg M P) (DSeg M Q)) (Fdiv (S A M P) (S A M Q))
H2 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg M P) (DSeg M Q))
H1 : Col P Q M
H0 : not (Col Q A M)
H : not (eq M Q)
P,Q,A,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_1 : forall P Q A M : Point, M <> Q -> ~ Col Q A M -> Col P Q M -> P ** M / Q ** M = S P A M / S Q A M.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** M / Q ** M = M ** P / M ** Q).

*****

*****

+++++
Qed.
-----
Hint Resolve A6_1: Geom.
-----
Theorem A6_2 :\n forall P Q R A : Point,\n P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.

*****

*****
forall (P Q R A : Point) (_ : not (eq P Q)) (_ : not (Col Q A P)) (_ : Col P Q R), eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
Proof.
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.

*****

*****
forall (P Q R A : Point) (_ : not (eq P Q)) (_ : not (Col Q A P)) (_ : Col P Q R), eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
intros.
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.

*****
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].

*****
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
assert (P ** R / P ** Q = S A P R / S A P Q).
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** R / P ** Q = S A P R / S A P Q).

*****
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S A P R) (S A P Q))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** R / P ** Q = S A P R / S A P Q).

*****
H2 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S A P R) (S A P Q))
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** R / P ** Q = S A P R / S A P Q).
try solve [ Geometry | congruence ].

*****
H2 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S A P R) (S A P Q))
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
assert (S A P R = S R A P).
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** R / P ** Q = S A P R / S A P Q).
try solve [ Geometry | congruence ].
assert (S A P R = S R A P).

*****
H2 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S A P R) (S A P Q))
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (S A P R) (S R A P)
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** R / P ** Q = S A P R / S A P Q).
try solve [ Geometry | congruence ].
assert (S A P R = S R A P).

*****
H3 : eq (S A P R) (S R A P)
H2 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S A P R) (S A P Q))
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** R / P ** Q = S A P R / S A P Q).
try solve [ Geometry | congruence ].
assert (S A P R = S R A P).
try solve [ Geometry | congruence ].

*****
H3 : eq (S A P R) (S R A P)
H2 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S A P R) (S A P Q))
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
assert (S A P Q = S Q A P).
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** R / P ** Q = S A P R / S A P Q).
try solve [ Geometry | congruence ].
assert (S A P R = S R A P).
try solve [ Geometry | congruence ].
assert (S A P Q = S Q A P).

*****
H3 : eq (S A P R) (S R A P)
H2 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S A P R) (S A P Q))
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (S A P Q) (S Q A P)
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** R / P ** Q = S A P R / S A P Q).
try solve [ Geometry | congruence ].
assert (S A P R = S R A P).
try solve [ Geometry | congruence ].
assert (S A P Q = S Q A P).

*****
H4 : eq (S A P Q) (S Q A P)
H3 : eq (S A P R) (S R A P)
H2 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S A P R) (S A P Q))
H1 : Col P Q R
H0 : not (Col Q A P)
H : not (eq P Q)
P,Q,R,A : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
try solve [ Geometry | congruence ].
-----
Theorem A6_2 : forall P Q R A : Point, P <> Q -> ~ Col Q A P -> Col P Q R -> P ** R / P ** Q = S R A P / S Q A P.
Proof.
intros.
try solve [ Geometry | congruence ].
assert (P ** R / P ** Q = S A P R / S A P Q).

*****

*****

+++++
Qed.
-----
Hint Resolve A6_2: Geom.
-----
Theorem A6_3 :\n forall A B C P : Point,\n A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.

*****

*****
forall (A B C P : Point) (_ : not (eq A C)) (_ : not (Col P A C)) (_ : Col A B C), eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
Proof.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.

*****

*****
forall (A B C P : Point) (_ : not (eq A C)) (_ : not (Col P A C)) (_ : Col A B C), eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
intros.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.

*****
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.

*****
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
assert (C ** A = - A ** C).
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).

*****
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (DSeg C A) (Fopp (DSeg A C))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).

*****
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.

*****
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
assert (S P C A = - S P A C).
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).

*****
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (S P C A) (Fopp (S P A C))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).

*****
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.

*****
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
assert (C ** B / C ** A = S P C B / S P C A).
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).

*****
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S P C B) (S P C A))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).

*****
H4 : eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S P C B) (S P C A))
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).
Geometry.

*****
H4 : eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S P C B) (S P C A))
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
rewrite H3 in H4.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).
Geometry.
rewrite H3 in H4.

*****
H4 : eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S P C B) (Fopp (S P A C)))
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).
Geometry.
rewrite H3 in H4.
Geometry.

*****
H4 : eq (Fdiv (DSeg C B) (DSeg C A)) (Fdiv (S P C B) (Fopp (S P A C)))
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
rewrite H2 in H4.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).
Geometry.
rewrite H3 in H4.
Geometry.
rewrite H2 in H4.

*****
H4 : eq (Fdiv (DSeg C B) (Fopp (DSeg A C)))\n (Fdiv (S P C B) (Fopp (S P A C)))
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).
Geometry.
rewrite H3 in H4.
Geometry.
rewrite H2 in H4.
Geometry.

*****
H4 : eq (Fdiv (DSeg C B) (Fopp (DSeg A C)))\n (Fdiv (S P C B) (Fopp (S P A C)))
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C B) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
RewriteVar (C ** B) H4.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).
Geometry.
rewrite H3 in H4.
Geometry.
rewrite H2 in H4.
Geometry.
RewriteVar (C ** B) H4.

*****
H4 : eq (DSeg C B)\n (Fmult (Fopp (DSeg A C)) (Fdiv (S P C B) (Fopp (S P A C))))
H5 : not (eq (Fopp (DSeg A C)) F0)
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (Fmult (Fopp (DSeg A C)) (Fdiv (S P C B) (Fopp (S P A C)))) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).
Geometry.
rewrite H3 in H4.
Geometry.
rewrite H2 in H4.
Geometry.
RewriteVar (C ** B) H4.
Geometry.

*****
H4 : eq (DSeg C B)\n (Fmult (Fopp (DSeg A C)) (Fdiv (S P C B) (Fopp (S P A C))))
H5 : not (eq (Fopp (DSeg A C)) F0)
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
eq (Fdiv (Fmult (Fopp (DSeg A C)) (Fdiv (S P C B) (Fopp (S P A C)))) (DSeg A C)) (Fdiv (S P C B) (S P A C))
+++++
field.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).
Geometry.
rewrite H3 in H4.
Geometry.
rewrite H2 in H4.
Geometry.
RewriteVar (C ** B) H4.
Geometry.
field.

*****
H4 : eq (DSeg C B)\n (Fmult (Fopp (DSeg A C)) (Fdiv (S P C B) (Fopp (S P A C))))
H5 : not (eq (Fopp (DSeg A C)) F0)
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
and (not (eq (S P A C) F0)) (and (not (eq (Fopp (S P A C)) F0)) (not (eq (DSeg A C) F0)))
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).
Geometry.
assert (S P C A = - S P A C).
Geometry.
assert (C ** B / C ** A = S P C B / S P C A).
Geometry.
rewrite H3 in H4.
Geometry.
rewrite H2 in H4.
Geometry.
RewriteVar (C ** B) H4.

*****
H4 : eq (Fdiv (DSeg C B) (Fopp (DSeg A C)))\n (Fdiv (S P C B) (Fopp (S P A C)))
H3 : eq (S P C A) (Fopp (S P A C))
H2 : eq (DSeg C A) (Fopp (DSeg A C))
H1 : Col A B C
H0 : not (Col P A C)
H : not (eq A C)
A,B,C,P : Point
*****
not (eq (Fopp (DSeg A C)) F0)
+++++
Geometry.
-----
Theorem A6_3 : forall A B C P : Point, A <> C -> ~ Col P A C -> Col A B C -> C ** B / A ** C = S P C B / S P A C.
Proof.
intros.
Geometry.
assert (C ** A = - A ** C).

*****

*****

+++++
Qed.
-----
Hint Resolve A6_3: Geom.
-----
Theorem A6_4 :\n forall A B C P : Point,\n A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.

*****

*****
forall (A B C P : Point) (_ : not (eq A B)) (_ : not (Col P A B)) (_ : Col A B C), eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
Proof.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.

*****

*****
forall (A B C P : Point) (_ : not (eq A B)) (_ : not (Col P A B)) (_ : Col A B C), eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
intros.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.

*****
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
Geometry.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.

*****
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
assert (A ** C / B ** A = S P A C / S P B A).
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).

*****
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (S P A C) (S P B A))
+++++
Geometry.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).

*****
H2 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (S P A C) (S P B A))
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
Geometry.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).
Geometry.

*****
H2 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (S P A C) (S P B A))
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
assert (A ** C / B ** A = C ** A / A ** B).
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).
Geometry.
assert (A ** C / B ** A = C ** A / A ** B).

*****
H2 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (S P A C) (S P B A))
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (DSeg C A) (DSeg A B))
+++++
Geometry.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).
Geometry.
assert (A ** C / B ** A = C ** A / A ** B).

*****
H3 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (DSeg C A) (DSeg A B))
H2 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (S P A C) (S P B A))
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
Geometry.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).
Geometry.
assert (A ** C / B ** A = C ** A / A ** B).
Geometry.

*****
H3 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (DSeg C A) (DSeg A B))
H2 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (S P A C) (S P B A))
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
assert (S P C A / S P A B = S P A C / S P B A).
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).
Geometry.
assert (A ** C / B ** A = C ** A / A ** B).
Geometry.
assert (S P C A / S P A B = S P A C / S P B A).

*****
H3 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (DSeg C A) (DSeg A B))
H2 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (S P A C) (S P B A))
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (S P C A) (S P A B)) (Fdiv (S P A C) (S P B A))
+++++
Geometry.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).
Geometry.
assert (A ** C / B ** A = C ** A / A ** B).
Geometry.
assert (S P C A / S P A B = S P A C / S P B A).

*****
H4 : eq (Fdiv (S P C A) (S P A B)) (Fdiv (S P A C) (S P B A))
H3 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (DSeg C A) (DSeg A B))
H2 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (S P A C) (S P B A))
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
Geometry.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).
Geometry.
assert (A ** C / B ** A = C ** A / A ** B).
Geometry.
assert (S P C A / S P A B = S P A C / S P B A).
Geometry.

*****
H4 : eq (Fdiv (S P C A) (S P A B)) (Fdiv (S P A C) (S P B A))
H3 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (DSeg C A) (DSeg A B))
H2 : eq (Fdiv (DSeg A C) (DSeg B A)) (Fdiv (S P A C) (S P B A))
H1 : Col A B C
H0 : not (Col P A B)
H : not (eq A B)
A,B,C,P : Point
*****
eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
+++++
congruence.
-----
Theorem A6_4 : forall A B C P : Point, A <> B -> ~ Col P A B -> Col A B C -> C ** A / A ** B = S P C A / S P A B.
Proof.
intros.
Geometry.
assert (A ** C / B ** A = S P A C / S P B A).

*****

*****

+++++
Qed.
-----
Hint Resolve A6_4: Geom.
-----
Theorem A6_5 :\n forall A B O P : Point,\n O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.

*****

*****
forall (A B O P : Point) (_ : not (eq O A)) (_ : not (Col O A B)) (_ : Col P A O), eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
Proof.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.

*****

*****
forall (A B O P : Point) (_ : not (eq O A)) (_ : not (Col O A B)) (_ : Col P A O), eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
intros.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.

*****
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.

*****
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
assert (P ** A / O ** A = S P B A / S O B A).
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).

*****
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).

*****
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.

*****
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
assert (S P A B = - S P B A).
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).

*****
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (S P A B) (Fopp (S P B A))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).

*****
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.

*****
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
assert (S O A B = - S O B A).
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).

*****
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (S O A B) (Fopp (S O B A))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).

*****
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.

*****
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
rewrite H3.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.

*****
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (Fopp (S P B A)) (S O A B))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.
Geometry.

*****
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (Fopp (S P B A)) (S O A B))
+++++
rewrite H4.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.
Geometry.
rewrite H4.

*****
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (Fopp (S P B A)) (Fopp (S O B A)))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.
Geometry.
rewrite H4.
Geometry.

*****
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (Fopp (S P B A)) (Fopp (S O B A)))
+++++
rewrite H2.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.
Geometry.
rewrite H4.
Geometry.
rewrite H2.

*****
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (S P B A) (S O B A)) (Fdiv (Fopp (S P B A)) (Fopp (S O B A)))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.
Geometry.
rewrite H4.
Geometry.
rewrite H2.
Geometry.

*****
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (S P B A) (S O B A)) (Fdiv (Fopp (S P B A)) (Fopp (S O B A)))
+++++
assert (S O B A <> 0).
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.
Geometry.
rewrite H4.
Geometry.
rewrite H2.
Geometry.
assert (S O B A <> 0).

*****
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
not (eq (S O B A) F0)
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.
Geometry.
rewrite H4.
Geometry.
rewrite H2.
Geometry.
assert (S O B A <> 0).

*****
H5 : not (eq (S O B A) F0)
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (S P B A) (S O B A)) (Fdiv (Fopp (S P B A)) (Fopp (S O B A)))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.
Geometry.
rewrite H4.
Geometry.
rewrite H2.
Geometry.
assert (S O B A <> 0).
Geometry.

*****
H5 : not (eq (S O B A) F0)
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
eq (Fdiv (S P B A) (S O B A)) (Fdiv (Fopp (S P B A)) (Fopp (S O B A)))
+++++
field.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
assert (S O A B = - S O B A).
Geometry.
rewrite H3.
Geometry.
rewrite H4.
Geometry.
rewrite H2.
Geometry.
assert (S O B A <> 0).
Geometry.
field.

*****
H5 : not (eq (S O B A) F0)
H4 : eq (S O A B) (Fopp (S O B A))
H3 : eq (S P A B) (Fopp (S P B A))
H2 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P B A) (S O B A))
H1 : Col P A O
H0 : not (Col O A B)
H : not (eq O A)
A,B,O,P : Point
*****
and (not (eq (Fopp (S O B A)) F0)) (not (eq (S O B A) F0))
+++++
Geometry.
-----
Theorem A6_5 : forall A B O P : Point, O <> A -> ~ Col O A B -> Col P A O -> P ** A / O ** A = S P A B / S O A B.
Proof.
intros.
Geometry.
assert (P ** A / O ** A = S P B A / S O B A).

*****

*****

+++++
Qed.
-----
Hint Resolve A6_5: Geom.
-----
Theorem A6_6 :\n forall A B R Q : Point,\n A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.
-----
Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.

*****

*****
forall (A B R Q : Point) (_ : not (eq A Q)) (_ : not (Col Q A B)) (_ : Col A R Q), eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
+++++
Proof.
-----
Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.
Proof.

*****

*****
forall (A B R Q : Point) (_ : not (eq A Q)) (_ : not (Col Q A B)) (_ : Col A R Q), eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
+++++
intros.
-----
Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.
Proof.
intros.

*****
H1 : Col A R Q
H0 : not (Col Q A B)
H : not (eq A Q)
A,B,R,Q : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
+++++
Geometry.
-----
Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.
Proof.
intros.
Geometry.

*****
H1 : Col A R Q
H0 : not (Col Q A B)
H : not (eq A Q)
A,B,R,Q : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
+++++
assert (S R A B / S Q A B = S R B A / S Q B A).
-----
Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.
Proof.
intros.
Geometry.
assert (S R A B / S Q A B = S R B A / S Q B A).

*****
H1 : Col A R Q
H0 : not (Col Q A B)
H : not (eq A Q)
A,B,R,Q : Point
*****
eq (Fdiv (S R A B) (S Q A B)) (Fdiv (S R B A) (S Q B A))
+++++
Geometry.
-----
Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.
Proof.
intros.
Geometry.
assert (S R A B / S Q A B = S R B A / S Q B A).

*****
H2 : eq (Fdiv (S R A B) (S Q A B)) (Fdiv (S R B A) (S Q B A))
H1 : Col A R Q
H0 : not (Col Q A B)
H : not (eq A Q)
A,B,R,Q : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
+++++
Geometry.
-----
Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.
Proof.
intros.
Geometry.
assert (S R A B / S Q A B = S R B A / S Q B A).
Geometry.

*****
H2 : eq (Fdiv (S R A B) (S Q A B)) (Fdiv (S R B A) (S Q B A))
H1 : Col A R Q
H0 : not (Col Q A B)
H : not (eq A Q)
A,B,R,Q : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
+++++
rewrite H2.
-----
Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.
Proof.
intros.
Geometry.
assert (S R A B / S Q A B = S R B A / S Q B A).
Geometry.
rewrite H2.

*****
H2 : eq (Fdiv (S R A B) (S Q A B)) (Fdiv (S R B A) (S Q B A))
H1 : Col A R Q
H0 : not (Col Q A B)
H : not (eq A Q)
A,B,R,Q : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R B A) (S Q B A))
+++++
Geometry.
-----
Theorem A6_6 : forall A B R Q : Point, A <> Q -> ~ Col Q A B -> Col A R Q -> A ** R / A ** Q = S R A B / S Q A B.
Proof.
intros.
Geometry.
assert (S R A B / S Q A B = S R B A / S Q B A).

*****

*****

+++++
Qed.
-----
Hint Resolve A6_6: Geom.
-----
Theorem l2_7 :\n forall A B C D P : Point,\n Col C A B ->\n Col D A B ->\n ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.

*****

*****
forall (A B C D P : Point) (_ : Col C A B) (_ : Col D A B) (_ : not (Col P C A)) (_ : not (Col P A B)) (_ : not (eq A B)), eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
Proof with try solve [ Geometry | congruence | field; Geometry ].
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].

*****

*****
forall (A B C D P : Point) (_ : Col C A B) (_ : Col D A B) (_ : not (Col P C A)) (_ : not (Col P A B)) (_ : not (eq A B)), eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
intros...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...

*****
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
cases_equality C A...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...

*****
H4 : eq C A
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
assert (Col A B D)...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...

*****
H5 : Col A B D
H4 : eq C A
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
rewrite H4...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...

*****
H5 : Col A B D
H4 : eq C A
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P A D) (S P A B)) (Fdiv (DSeg A D) (DSeg A B))
+++++
symmetry in |- *...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...
symmetry in |- *...

*****
H4 : not (eq C A)
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...
symmetry in |- *...
assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))...

*****
H5 : eq (Fdiv (S P C D) (S P A B))\n (Fmult (Fdiv (S P C D) (S P C A)) (Fdiv (S P C A) (S P A B)))
H4 : not (eq C A)
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
assert (A <> C)...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...
symmetry in |- *...
assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))...
assert (A <> C)...

*****
H6 : not (eq A C)
H5 : eq (Fdiv (S P C D) (S P A B))\n (Fmult (Fdiv (S P C D) (S P C A)) (Fdiv (S P C A) (S P A B)))
H4 : not (eq C A)
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
assert (Col C D A)...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...
symmetry in |- *...
assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))...
assert (A <> C)...
assert (Col C D A)...

*****
H6 : not (eq A C)
H5 : eq (Fdiv (S P C D) (S P A B))\n (Fmult (Fdiv (S P C D) (S P C A)) (Fdiv (S P C A) (S P A B)))
H4 : not (eq C A)
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
Col C D A
+++++
eauto with Geom...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...
symmetry in |- *...
assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))...
assert (A <> C)...
assert (Col C D A)...
eauto with Geom...

*****
H7 : Col C D A
H6 : not (eq A C)
H5 : eq (Fdiv (S P C D) (S P A B))\n (Fmult (Fdiv (S P C D) (S P C A)) (Fdiv (S P C A) (S P A B)))
H4 : not (eq C A)
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
assert (C ** D / C ** A = S P C D / S P C A)...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...
symmetry in |- *...
assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))...
assert (A <> C)...
assert (Col C D A)...
eauto with Geom...
assert (C ** D / C ** A = S P C D / S P C A)...

*****
H8 : eq (Fdiv (DSeg C D) (DSeg C A)) (Fdiv (S P C D) (S P C A))
H7 : Col C D A
H6 : not (eq A C)
H5 : eq (Fdiv (S P C D) (S P A B))\n (Fmult (Fdiv (S P C D) (S P C A)) (Fdiv (S P C A) (S P A B)))
H4 : not (eq C A)
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
assert (A ** C / A ** B = S P A C / S P A B)...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...
symmetry in |- *...
assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))...
assert (A <> C)...
assert (Col C D A)...
eauto with Geom...
assert (C ** D / C ** A = S P C D / S P C A)...
assert (A ** C / A ** B = S P A C / S P A B)...

*****
H9 : eq (Fdiv (DSeg A C) (DSeg A B)) (Fdiv (S P A C) (S P A B))
H8 : eq (Fdiv (DSeg C D) (DSeg C A)) (Fdiv (S P C D) (S P C A))
H7 : Col C D A
H6 : not (eq A C)
H5 : eq (Fdiv (S P C D) (S P A B))\n (Fmult (Fdiv (S P C D) (S P C A)) (Fdiv (S P C A) (S P A B)))
H4 : not (eq C A)
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
assert (C ** A / A ** B = S P C A / S P A B)...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...
symmetry in |- *...
assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))...
assert (A <> C)...
assert (Col C D A)...
eauto with Geom...
assert (C ** D / C ** A = S P C D / S P C A)...
assert (A ** C / A ** B = S P A C / S P A B)...
assert (C ** A / A ** B = S P C A / S P A B)...

*****
H10 : eq (Fdiv (DSeg C A) (DSeg A B)) (Fdiv (S P C A) (S P A B))
H9 : eq (Fdiv (DSeg A C) (DSeg A B)) (Fdiv (S P A C) (S P A B))
H8 : eq (Fdiv (DSeg C D) (DSeg C A)) (Fdiv (S P C D) (S P C A))
H7 : Col C D A
H6 : not (eq A C)
H5 : eq (Fdiv (S P C D) (S P A B))\n (Fmult (Fdiv (S P C D) (S P C A)) (Fdiv (S P C A) (S P A B)))
H4 : not (eq C A)
H3 : not (eq A B)
H2 : not (Col P A B)
H1 : not (Col P C A)
H0 : Col D A B
H : Col C A B
A,B,C,D,P : Point
*****
eq (Fdiv (S P C D) (S P A B)) (Fdiv (DSeg C D) (DSeg A B))
+++++
assert (C ** D / C ** A * (C ** A / A ** B) = C ** D / A ** B)...
-----
Theorem l2_7 : forall A B C D P : Point, Col C A B -> Col D A B -> ~ Col P C A -> ~ Col P A B -> A <> B -> S P C D / S P A B = C ** D / A ** B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
cases_equality C A...
assert (Col A B D)...
rewrite H4...
symmetry in |- *...
assert (S P C D / S P A B = S P C D / S P C A * (S P C A / S P A B))...
assert (A <> C)...
assert (Col C D A)...
eauto with Geom...
assert (C ** D / C ** A = S P C D / S P C A)...
assert (A ** C / A ** B = S P A C / S P A B)...
assert (C ** A / A ** B = S P C A / S P A B)...
assert (C ** D / C ** A * (C ** A / A ** B) = C ** D / A ** B)...

*****

*****

+++++
Qed.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.

*****

*****
forall (P Q U V : Point) (_ : not (parallel P Q U V)), not (eq P Q)
+++++
Proof.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.

*****

*****
forall (P Q U V : Point) (_ : not (parallel P Q U V)), not (eq P Q)
+++++
intros.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.

*****
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.

*****
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (eq P Q)
+++++
unfold parallel in H.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.

*****
H : not (eq (S4 P U Q V) F0)
P,Q,U,V : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.

*****
H : not (eq (S4 P U Q V) F0)
P,Q,U,V : Point
*****
not (eq P Q)
+++++
unfold S4 in H.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.

*****
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.

*****
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
not (eq P Q)
+++++
unfold not in |- *.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.

*****
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
forall _ : eq P Q, False
+++++
intro.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.

*****
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
False
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.

*****
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
False
+++++
assert (S P U Q = 0).
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).

*****
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
eq (S P U Q) F0
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.

*****
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
eq (S P U Q) F0
+++++
rewrite H0.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.
rewrite H0.

*****
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
eq (S Q U Q) F0
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).

*****
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
False
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.

*****
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
False
+++++
assert (S P Q V = 0).
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.
assert (S P Q V = 0).

*****
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
eq (S P Q V) F0
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.
assert (S P Q V = 0).
Geometry.

*****
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
eq (S P Q V) F0
+++++
rewrite H0.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.
assert (S P Q V = 0).
Geometry.
rewrite H0.

*****
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
eq (S Q Q V) F0
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.
assert (S P Q V = 0).

*****
H2 : eq (S P Q V) F0
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
False
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.
assert (S P Q V = 0).
Geometry.

*****
H2 : eq (S P Q V) F0
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
False
+++++
rewrite H1 in H.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.
assert (S P Q V = 0).
Geometry.
rewrite H1 in H.

*****
H2 : eq (S P Q V) F0
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus F0 (S P Q V)) F0)
P,Q,U,V : Point
*****
False
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.
assert (S P Q V = 0).
Geometry.
rewrite H1 in H.
Geometry.

*****
H2 : eq (S P Q V) F0
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus F0 (S P Q V)) F0)
P,Q,U,V : Point
*****
False
+++++
rewrite H2 in H.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).
Geometry.
assert (S P Q V = 0).
Geometry.
rewrite H1 in H.
Geometry.
rewrite H2 in H.

*****
H2 : eq (S P Q V) F0
H1 : eq (S P U Q) F0
H0 : eq P Q
H : not (eq (Fplus F0 F0) F0)
P,Q,U,V : Point
*****
False
+++++
Geometry.
-----
Theorem par_aux_1 : forall P Q U V : Point, ~ parallel P Q U V -> P <> Q.
Proof.
intros.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P U Q = 0).

*****

*****

+++++
Qed.
-----
Theorem par_not_all_col :\n forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \/ ~ Col P Q V.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.

*****

*****
forall (P Q U V : Point) (_ : not (parallel P Q U V)), or (not (Col P U Q)) (not (Col P Q V))
+++++
intros.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.

*****
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
or (not (Col P U Q)) (not (Col P Q V))
+++++
cases_col P U Q.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.

*****
H0 : Col P U Q
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
or (not (Col P U Q)) (not (Col P Q V))
+++++
unfold parallel in H.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.
unfold parallel in H.

*****
H0 : Col P U Q
H : not (eq (S4 P U Q V) F0)
P,Q,U,V : Point
*****
or (not (Col P U Q)) (not (Col P Q V))
+++++
unfold S4 in H.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.
unfold parallel in H.
unfold S4 in H.

*****
H0 : Col P U Q
H : not (eq (Fplus (S P U Q) (S P Q V)) F0)
P,Q,U,V : Point
*****
or (not (Col P U Q)) (not (Col P Q V))
+++++
rewrite H0 in H.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.
unfold parallel in H.
unfold S4 in H.
rewrite H0 in H.

*****
H0 : Col P U Q
H : not (eq (Fplus F0 (S P Q V)) F0)
P,Q,U,V : Point
*****
or (not (Col P U Q)) (not (Col P Q V))
+++++
assert (0 + S P Q V = S P Q V).
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.
unfold parallel in H.
unfold S4 in H.
rewrite H0 in H.
assert (0 + S P Q V = S P Q V).

*****
H0 : Col P U Q
H : not (eq (Fplus F0 (S P Q V)) F0)
P,Q,U,V : Point
*****
eq (Fplus F0 (S P Q V)) (S P Q V)
+++++
ring.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.
unfold parallel in H.
unfold S4 in H.
rewrite H0 in H.
assert (0 + S P Q V = S P Q V).

*****
H1 : eq (Fplus F0 (S P Q V)) (S P Q V)
H0 : Col P U Q
H : not (eq (Fplus F0 (S P Q V)) F0)
P,Q,U,V : Point
*****
or (not (Col P U Q)) (not (Col P Q V))
+++++
rewrite H1 in H.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.
unfold parallel in H.
unfold S4 in H.
rewrite H0 in H.
assert (0 + S P Q V = S P Q V).
rewrite H1 in H.

*****
H1 : eq (Fplus F0 (S P Q V)) (S P Q V)
H0 : Col P U Q
H : not (eq (S P Q V) F0)
P,Q,U,V : Point
*****
or (not (Col P U Q)) (not (Col P Q V))
+++++
right.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.
unfold parallel in H.
unfold S4 in H.
rewrite H0 in H.
assert (0 + S P Q V = S P Q V).
rewrite H1 in H.
right.

*****
H1 : eq (Fplus F0 (S P Q V)) (S P Q V)
H0 : Col P U Q
H : not (eq (S P Q V) F0)
P,Q,U,V : Point
*****
not (Col P Q V)
+++++
unfold Col in |- *.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.
unfold parallel in H.
unfold S4 in H.
rewrite H0 in H.
assert (0 + S P Q V = S P Q V).
rewrite H1 in H.
right.
unfold Col in |- *.

*****
H1 : eq (Fplus F0 (S P Q V)) (S P Q V)
H0 : Col P U Q
H : not (eq (S P Q V) F0)
P,Q,U,V : Point
*****
not (eq (S P Q V) F0)
+++++
trivial.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.

*****
H0 : not (Col P U Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
or (not (Col P U Q)) (not (Col P Q V))
+++++
left.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.
left.

*****
H0 : not (Col P U Q)
H : not (parallel P Q U V)
P,Q,U,V : Point
*****
not (Col P U Q)
+++++
trivial.
-----
Theorem par_not_all_col : forall P Q U V : Point, ~ parallel P Q U V -> ~ Col P U Q \\/ ~ Col P Q V.
intros.
cases_col P U Q.

*****

*****

+++++
Qed.
-----
Theorem co_side_main :\n forall A B P Q M : Point,\n ~ Col Q A B ->\n ~ Col P A M ->\n ~ Col Q A M ->\n Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.

*****

*****
forall (A B P Q M : Point) (_ : not (Col Q A B)) (_ : not (Col P A M)) (_ : not (Col Q A M)) (_ : not (eq Q M)) (_ : Col A B M) (_ : Col P Q M), eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Proof with try solve [ Geometry | congruence | field; Geometry ].
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof with try solve [ Geometry | congruence | field; Geometry ].

*****

*****
forall (A B P Q M : Point) (_ : not (Col Q A B)) (_ : not (Col P A M)) (_ : not (Col Q A M)) (_ : not (eq Q M)) (_ : Col A B M) (_ : Col P Q M), eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
intros...
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...

*****
H4 : Col P Q M
H3 : Col A B M
H2 : not (eq Q M)
H1 : not (Col Q A M)
H0 : not (Col P A M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (S P A B / S Q A B = S P A B / S P A M * (S P A M / S Q A M * (S Q A M / S Q A B)))...
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
assert (S P A B / S Q A B = S P A B / S P A M * (S P A M / S Q A M * (S Q A M / S Q A B)))...

*****
H5 : eq (Fdiv (S P A B) (S Q A B))\n (Fmult (Fdiv (S P A B) (S P A M))\n (Fmult (Fdiv (S P A M) (S Q A M)) (Fdiv (S Q A M) (S Q A B))))
H4 : Col P Q M
H3 : Col A B M
H2 : not (eq Q M)
H1 : not (Col Q A M)
H0 : not (Col P A M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (A <> B); eauto with Geom...
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
assert (S P A B / S Q A B = S P A B / S P A M * (S P A M / S Q A M * (S Q A M / S Q A B)))...
assert (A <> B); eauto with Geom...

*****
H6 : not (eq A B)
H5 : eq (Fdiv (S P A B) (S Q A B))\n (Fmult (Fdiv (S P A B) (S P A M))\n (Fmult (Fdiv (S P A M) (S Q A M)) (Fdiv (S Q A M) (S Q A B))))
H4 : Col P Q M
H3 : Col A B M
H2 : not (eq Q M)
H1 : not (Col Q A M)
H0 : not (Col P A M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (A <> M); eauto with Geom...
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
assert (S P A B / S Q A B = S P A B / S P A M * (S P A M / S Q A M * (S Q A M / S Q A B)))...
assert (A <> B); eauto with Geom...
assert (A <> M); eauto with Geom...

*****
H7 : not (eq A M)
H6 : not (eq A B)
H5 : eq (Fdiv (S P A B) (S Q A B))\n (Fmult (Fdiv (S P A B) (S P A M))\n (Fmult (Fdiv (S P A M) (S Q A M)) (Fdiv (S Q A M) (S Q A B))))
H4 : Col P Q M
H3 : Col A B M
H2 : not (eq Q M)
H1 : not (Col Q A M)
H0 : not (Col P A M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (A ** B / A ** M * (P ** M / Q ** M * (A ** M / A ** B)) = P ** M / Q ** M)...
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
assert (S P A B / S Q A B = S P A B / S P A M * (S P A M / S Q A M * (S Q A M / S Q A B)))...
assert (A <> B); eauto with Geom...
assert (A <> M); eauto with Geom...
assert (A ** B / A ** M * (P ** M / Q ** M * (A ** M / A ** B)) = P ** M / Q ** M)...

*****
H8 : eq\n (Fmult (Fdiv (DSeg A B) (DSeg A M))\n (Fmult (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg A M) (DSeg A B))))\n (Fdiv (DSeg P M) (DSeg Q M))
H7 : not (eq A M)
H6 : not (eq A B)
H5 : eq (Fdiv (S P A B) (S Q A B))\n (Fmult (Fdiv (S P A B) (S P A M))\n (Fmult (Fdiv (S P A M) (S Q A M)) (Fdiv (S Q A M) (S Q A B))))
H4 : Col P Q M
H3 : Col A B M
H2 : not (eq Q M)
H1 : not (Col Q A M)
H0 : not (Col P A M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (A ** B / A ** M = S P A B / S P A M)...
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
assert (S P A B / S Q A B = S P A B / S P A M * (S P A M / S Q A M * (S Q A M / S Q A B)))...
assert (A <> B); eauto with Geom...
assert (A <> M); eauto with Geom...
assert (A ** B / A ** M * (P ** M / Q ** M * (A ** M / A ** B)) = P ** M / Q ** M)...
assert (A ** B / A ** M = S P A B / S P A M)...

*****
H9 : eq (Fdiv (DSeg A B) (DSeg A M)) (Fdiv (S P A B) (S P A M))
H8 : eq\n (Fmult (Fdiv (DSeg A B) (DSeg A M))\n (Fmult (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg A M) (DSeg A B))))\n (Fdiv (DSeg P M) (DSeg Q M))
H7 : not (eq A M)
H6 : not (eq A B)
H5 : eq (Fdiv (S P A B) (S Q A B))\n (Fmult (Fdiv (S P A B) (S P A M))\n (Fmult (Fdiv (S P A M) (S Q A M)) (Fdiv (S Q A M) (S Q A B))))
H4 : Col P Q M
H3 : Col A B M
H2 : not (eq Q M)
H1 : not (Col Q A M)
H0 : not (Col P A M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (P ** M / Q ** M = S P A M / S Q A M)...
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
assert (S P A B / S Q A B = S P A B / S P A M * (S P A M / S Q A M * (S Q A M / S Q A B)))...
assert (A <> B); eauto with Geom...
assert (A <> M); eauto with Geom...
assert (A ** B / A ** M * (P ** M / Q ** M * (A ** M / A ** B)) = P ** M / Q ** M)...
assert (A ** B / A ** M = S P A B / S P A M)...
assert (P ** M / Q ** M = S P A M / S Q A M)...

*****
H10 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A M) (S Q A M))
H9 : eq (Fdiv (DSeg A B) (DSeg A M)) (Fdiv (S P A B) (S P A M))
H8 : eq\n (Fmult (Fdiv (DSeg A B) (DSeg A M))\n (Fmult (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (DSeg A M) (DSeg A B))))\n (Fdiv (DSeg P M) (DSeg Q M))
H7 : not (eq A M)
H6 : not (eq A B)
H5 : eq (Fdiv (S P A B) (S Q A B))\n (Fmult (Fdiv (S P A B) (S P A M))\n (Fmult (Fdiv (S P A M) (S Q A M)) (Fdiv (S Q A M) (S Q A B))))
H4 : Col P Q M
H3 : Col A B M
H2 : not (eq Q M)
H1 : not (Col Q A M)
H0 : not (Col P A M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (A ** M / A ** B = S Q A M / S Q A B)...
-----
Theorem co_side_main : forall A B P Q M : Point, ~ Col Q A B -> ~ Col P A M -> ~ Col Q A M -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof with try solve [ Geometry | congruence | field; Geometry ].
intros...
assert (S P A B / S Q A B = S P A B / S P A M * (S P A M / S Q A M * (S Q A M / S Q A B)))...
assert (A <> B); eauto with Geom...
assert (A <> M); eauto with Geom...
assert (A ** B / A ** M * (P ** M / Q ** M * (A ** M / A ** B)) = P ** M / Q ** M)...
assert (A ** B / A ** M = S P A B / S P A M)...
assert (P ** M / Q ** M = S P A M / S Q A M)...
assert (A ** M / A ** B = S Q A M / S Q A B)...

*****

*****

+++++
Qed.
-----
Theorem co_side :\n forall A B P Q M : Point,\n ~ Col Q A B ->\n Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.

*****

*****
forall (A B P Q M : Point) (_ : not (Col Q A B)) (_ : not (eq Q M)) (_ : Col A B M) (_ : Col P Q M), eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Proof.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.

*****

*****
forall (A B P Q M : Point) (_ : not (Col Q A B)) (_ : not (eq Q M)) (_ : Col A B M) (_ : Col P Q M), eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
intros.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.

*****
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.

*****
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
cases_equality M A.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.

*****
H3 : eq M A
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.

*****
H3 : eq M A
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
rewrite H3.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
rewrite H3.

*****
H3 : eq M A
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P A) (DSeg Q A)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
rewrite H3.
Geometry.

*****
H3 : eq M A
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P A) (DSeg Q A)) (Fdiv (S P A B) (S Q A B))
+++++
rewrite H3 in H0.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
rewrite H3.
Geometry.
rewrite H3 in H0.

*****
H3 : eq M A
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q A)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P A) (DSeg Q A)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
rewrite H3.
Geometry.
rewrite H3 in H0.
Geometry.

*****
H3 : eq M A
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q A)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P A) (DSeg Q A)) (Fdiv (S P A B) (S Q A B))
+++++
rewrite H3 in H2.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
rewrite H3.
Geometry.
rewrite H3 in H0.
Geometry.
rewrite H3 in H2.

*****
H3 : eq M A
H2 : Col P Q A
H1 : Col A B M
H0 : not (eq Q A)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P A) (DSeg Q A)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.

*****
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.

*****
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (~ Col Q A M).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).

*****
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
not (Col Q A M)
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.

*****
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
not (Col Q A M)
+++++
unfold not in |- *.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.

*****
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
forall _ : Col Q A M, False
+++++
intro.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.

*****
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.

*****
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col Q M A).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).

*****
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col Q M A
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).

*****
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.

*****
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col Q M P).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).

*****
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col Q M P
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).

*****
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.

*****
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col Q A P).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).

*****
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col Q A P
+++++
eauto with Geom.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).

*****
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
eauto with Geom.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.

*****
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.

*****
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col A M Q).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A M Q).

*****
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col A M Q
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A M Q).

*****
H8 : Col A M Q
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A M Q).
Geometry.

*****
H8 : Col A M Q
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col A M B).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A M Q).
Geometry.
assert (Col A M B).

*****
H8 : Col A M Q
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col A M B
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A M Q).
Geometry.
assert (Col A M B).

*****
H9 : Col A M B
H8 : Col A M Q
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A M Q).
Geometry.
assert (Col A M B).
Geometry.

*****
H9 : Col A M B
H8 : Col A M Q
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col A B Q).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A M Q).
Geometry.
assert (Col A M B).
Geometry.
assert (Col A B Q).

*****
H9 : Col A M B
H8 : Col A M Q
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col A B Q
+++++
eauto with Geom.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A M Q).
Geometry.
assert (Col A M B).
Geometry.
assert (Col A B Q).

*****
H10 : Col A B Q
H9 : Col A M B
H8 : Col A M Q
H7 : Col Q A P
H6 : Col Q M P
H5 : Col Q M A
H4 : Col Q A M
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
eauto with Geom.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).

*****
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.

*****
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
cases_equality P M.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.

*****
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.

*****
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
rewrite <- H5 in H1.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.

*****
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.

*****
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (Col P A B).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).

*****
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col P A B
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).

*****
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).
Geometry.

*****
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
rewrite H6.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).
Geometry.
rewrite H6.

*****
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv F0 (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).
Geometry.
rewrite H6.
Geometry.

*****
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv F0 (S Q A B))
+++++
assert (P ** M = 0).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).
Geometry.
rewrite H6.
Geometry.
assert (P ** M = 0).

*****
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (DSeg P M) F0
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).
Geometry.
rewrite H6.
Geometry.
assert (P ** M = 0).

*****
H7 : eq (DSeg P M) F0
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv F0 (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).
Geometry.
rewrite H6.
Geometry.
assert (P ** M = 0).
Geometry.

*****
H7 : eq (DSeg P M) F0
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv F0 (S Q A B))
+++++
rewrite H7.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).
Geometry.
rewrite H6.
Geometry.
assert (P ** M = 0).
Geometry.
rewrite H7.

*****
H7 : eq (DSeg P M) F0
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg Q M)) (Fdiv F0 (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).
Geometry.
rewrite H6.
Geometry.
assert (P ** M = 0).
Geometry.
rewrite H7.
Geometry.

*****
H7 : eq (DSeg P M) F0
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg Q M)) (Fdiv F0 (S Q A B))
+++++
field.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
rewrite <- H5 in H1.
Geometry.
assert (Col P A B).
Geometry.
rewrite H6.
Geometry.
assert (P ** M = 0).
Geometry.
rewrite H7.
Geometry.
field.

*****
H7 : eq (DSeg P M) F0
H6 : Col P A B
H5 : eq P M
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B P
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
and (not (eq (S Q A B) F0)) (not (eq (DSeg Q M) F0))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.

*****
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.

*****
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
cases_equality P Q.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.

*****
H6 : eq P Q
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.

*****
H6 : eq P Q
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
rewrite H6.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
rewrite H6.

*****
H6 : eq P Q
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg Q M)) (Fdiv (S Q A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
rewrite H6.
Geometry.

*****
H6 : eq P Q
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg Q M)) (Fdiv (S Q A B) (S Q A B))
+++++
field.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
rewrite H6.
Geometry.
field.

*****
H6 : eq P Q
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
and (not (eq (S Q A B) F0)) (not (eq (DSeg Q M) F0))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.

*****
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.

*****
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
assert (~ Col P A M).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).

*****
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
not (Col P A M)
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.

*****
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
not (Col P A M)
+++++
unfold not in |- *.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.

*****
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
forall _ : Col P A M, False
+++++
intro.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.

*****
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.
Geometry.

*****
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col P M A).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col P M A).

*****
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col P M A
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col P M A).

*****
H8 : Col P M A
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col P M A).
Geometry.

*****
H8 : Col P M A
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col P M Q).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col P M A).
Geometry.
assert (Col P M Q).

*****
H8 : Col P M A
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col P M Q
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col P M A).
Geometry.
assert (Col P M Q).

*****
H9 : Col P M Q
H8 : Col P M A
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col P M A).
Geometry.
assert (Col P M Q).
Geometry.

*****
H9 : Col P M Q
H8 : Col P M A
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col P A Q).
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col P M A).
Geometry.
assert (Col P M Q).
Geometry.
assert (Col P A Q).

*****
H9 : Col P M Q
H8 : Col P M A
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col P A Q
+++++
eauto with Geom.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (Col P M A).
Geometry.
assert (Col P M Q).
Geometry.
assert (Col P A Q).

*****
H10 : Col P A Q
H9 : Col P M Q
H8 : Col P M A
H7 : Col P A M
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
False
+++++
eauto with Geom.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).

*****
H7 : not (Col P A M)
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.

*****
H7 : not (Col P A M)
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
apply co_side_main.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
apply co_side_main.

*****
H7 : not (Col P A M)
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
not (Col Q A B)
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
apply co_side_main.

*****
H7 : not (Col P A M)
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
not (Col P A M)
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
apply co_side_main.

*****
H7 : not (Col P A M)
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
not (Col Q A M)
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
apply co_side_main.

*****
H7 : not (Col P A M)
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
not (eq Q M)
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
apply co_side_main.

*****
H7 : not (Col P A M)
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col A B M
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.
Geometry.
assert (~ Col Q A M).
Geometry.
cases_equality P M.
Geometry.
cases_equality P Q.
Geometry.
assert (~ Col P A M).
Geometry.
apply co_side_main.

*****
H7 : not (Col P A M)
H6 : not (eq P Q)
H5 : not (eq P M)
H4 : not (Col Q A M)
H3 : not (eq M A)
H2 : Col P Q M
H1 : Col A B M
H0 : not (eq Q M)
H : not (Col Q A B)
A,B,P,Q,M : Point
*****
Col P Q M
+++++
Geometry.
-----
Theorem co_side : forall A B P Q M : Point, ~ Col Q A B -> Q <> M -> Col A B M -> Col P Q M -> P ** M / Q ** M = S P A B / S Q A B.
Proof.
intros.
Geometry.
cases_equality M A.

*****

*****

+++++
Qed.
-----
Hint Resolve co_side: Geom.
-----
Theorem inter_unicity :\n forall A B P Q M : Point,\n ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.

*****

*****
forall (A B P Q M : Point) (_ : not (parallel P Q A B)) (_ : Col A B M) (_ : Col P Q M) (_ : eq A Q), eq A M
+++++
Proof.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.

*****

*****
forall (A B P Q M : Point) (_ : not (parallel P Q A B)) (_ : Col A B M) (_ : Col P Q M) (_ : eq A Q), eq A M
+++++
intros.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.

*****
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.

*****
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
cases_equality A M.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.

*****
H3 : eq A M
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.

*****
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.

*****
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
assert (Col A M B).
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).

*****
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
Col A M B
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).

*****
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.

*****
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
assert (Col Q M P).
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).

*****
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
Col Q M P
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).

*****
H5 : Col Q M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.

*****
H5 : Col Q M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
rewrite <- H2 in H5.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.

*****
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.

*****
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
assert (Col A B P).
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).

*****
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
Col A B P
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.

*****
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
Col A B P
+++++
eauto with Geom.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).

*****
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.

*****
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
assert (~ Col P A Q \/ ~ Col P Q B).
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).

*****
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
or (not (Col P A Q)) (not (Col P Q B))
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.

*****
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
or (not (Col P A Q)) (not (Col P Q B))
+++++
apply par_not_all_col.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
apply par_not_all_col.

*****
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (parallel P Q A B)
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).

*****
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.

*****
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
case H7.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.

*****
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
forall _ : not (Col P A Q), eq A M
+++++
intro.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.

*****
H8 : not (Col P A Q)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.

*****
H8 : not (Col P A Q)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
assert (Col P A A).
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
assert (Col P A A).

*****
H8 : not (Col P A Q)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
Col P A A
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
assert (Col P A A).

*****
H9 : Col P A A
H8 : not (Col P A Q)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
assert (Col P A A).
Geometry.

*****
H9 : Col P A A
H8 : not (Col P A Q)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
rewrite <- H2 in H8.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
assert (Col P A A).
Geometry.
rewrite <- H2 in H8.

*****
H9 : Col P A A
H8 : not (Col P A A)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
assert (Col P A A).
Geometry.
rewrite <- H2 in H8.
Geometry.

*****
H9 : Col P A A
H8 : not (Col P A A)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
intuition.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.

*****
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
forall _ : not (Col P Q B), eq A M
+++++
intro.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.

*****
H8 : not (Col P Q B)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.

*****
H8 : not (Col P Q B)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col A B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
rewrite H2 in H6.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
rewrite H2 in H6.

*****
H8 : not (Col P Q B)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col Q B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
rewrite H2 in H6.
Geometry.

*****
H8 : not (Col P Q B)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col Q B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
assert (Col P Q B).
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
rewrite H2 in H6.
Geometry.
assert (Col P Q B).

*****
H8 : not (Col P Q B)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col Q B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
Col P Q B
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
rewrite H2 in H6.
Geometry.
assert (Col P Q B).

*****
H9 : Col P Q B
H8 : not (Col P Q B)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col Q B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.
Geometry.
assert (Col A M B).
Geometry.
assert (Col Q M P).
Geometry.
rewrite <- H2 in H5.
Geometry.
assert (Col A B P).
Geometry.
assert (~ Col P A Q \\/ ~ Col P Q B).
Geometry.
case H7.
intro.
Geometry.
rewrite H2 in H6.
Geometry.
assert (Col P Q B).
Geometry.

*****
H9 : Col P Q B
H8 : not (Col P Q B)
H7 : or (not (Col P A Q)) (not (Col P Q B))
H6 : Col Q B P
H5 : Col A M P
H4 : Col A M B
H3 : not (eq A M)
H2 : eq A Q
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
intuition.
-----
Theorem inter_unicity : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> A = Q -> A = M.
Proof.
intros.
Geometry.
cases_equality A M.

*****

*****

+++++
Qed.
-----
Theorem inter_unicity_2 :\n forall A B P Q M N: Point,\n ~ parallel P Q A B -> \n Col A B M -> Col P Q M -> \n Col A B N -> Col P Q N -> \n M = N.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.

*****

*****
forall (A B P Q M N : Point) (_ : not (parallel P Q A B)) (_ : Col A B M) (_ : Col P Q M) (_ : Col A B N) (_ : Col P Q N), eq M N
+++++
Proof.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.

*****

*****
forall (A B P Q M N : Point) (_ : not (parallel P Q A B)) (_ : Col A B M) (_ : Col P Q M) (_ : Col A B N) (_ : Col P Q N), eq M N
+++++
intros.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.

*****
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (A<>B).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).

*****
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
not (eq A B)
+++++
intro.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
intro.

*****
H4 : eq A B
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
False
+++++
subst.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
intro.
subst.

*****
H3 : Col P Q N
H2 : Col B B N
H1 : Col P Q M
H : not (parallel P Q B B)
H0 : Col B B M
B,P,Q,M,N : Point
*****
False
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).

*****
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.

*****
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (P<>Q).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).

*****
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
not (eq P Q)
+++++
intro.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
intro.

*****
H5 : eq P Q
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
False
+++++
subst.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
intro.
subst.

*****
H4 : not (eq A B)
H3 : Col Q Q N
H2 : Col A B N
H1 : Col Q Q M
H0 : Col A B M
H : not (parallel Q Q A B)
A,B,Q,M,N : Point
*****
False
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).

*****
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.

*****
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (Col A M N).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).

*****
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col A M N
+++++
apply (col_trans_1 A B M N).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
apply (col_trans_1 A B M N).

*****
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
not (eq A B)
+++++
auto.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
apply (col_trans_1 A B M N).

*****
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col A B M
+++++
auto.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
apply (col_trans_1 A B M N).

*****
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col A B N
+++++
auto.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).

*****
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.

*****
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (Col P M N).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).

*****
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col P M N
+++++
apply (col_trans_1 P Q M N).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
apply (col_trans_1 P Q M N).

*****
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
not (eq P Q)
+++++
auto.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
apply (col_trans_1 P Q M N).

*****
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col P Q M
+++++
auto.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
apply (col_trans_1 P Q M N).

*****
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col P Q N
+++++
auto.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).

*****
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.

*****
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
cases_equality M N.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.

*****
H8 : eq M N
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
auto.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.

*****
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
auto.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.

*****
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (Col M A P).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).

*****
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col M A P
+++++
apply (col_trans_1 M N A P).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
apply (col_trans_1 M N A P).

*****
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
not (eq M N)
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
apply (col_trans_1 M N A P).

*****
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col M N A
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
apply (col_trans_1 M N A P).

*****
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col M N P
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).

*****
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.

*****
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (Col B M N).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).

*****
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col B M N
+++++
apply (col_trans_1 B A M N).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
apply (col_trans_1 B A M N).

*****
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
not (eq B A)
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
apply (col_trans_1 B A M N).

*****
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col B A M
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
apply (col_trans_1 B A M N).

*****
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col B A N
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).

*****
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.

*****
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (Col Q M N).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).

*****
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col Q M N
+++++
apply (col_trans_1 Q P M N).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
apply (col_trans_1 Q P M N).

*****
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
not (eq Q P)
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
apply (col_trans_1 Q P M N).

*****
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col Q P M
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
apply (col_trans_1 Q P M N).

*****
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col Q P N
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).

*****
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.

*****
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (Col M Q B).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).

*****
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col M Q B
+++++
apply (col_trans_1 M N Q B).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
apply (col_trans_1 M N Q B).

*****
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
not (eq M N)
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
apply (col_trans_1 M N Q B).

*****
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col M N Q
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
apply (col_trans_1 M N Q B).

*****
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col M N B
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
cases_equality P M.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.

*****
H13 : eq P M
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
subst.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A M
H8 : not (eq M N)
H7 : Col M M N
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H3 : Col M Q N
H2 : Col A B N
H1 : Col M Q M
H0 : Col A B M
H : not (parallel M Q A B)
A,B,Q,M,N : Point
*****
eq M N
+++++
unfold parallel in *.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A M
H8 : not (eq M N)
H7 : Col M M N
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H3 : Col M Q N
H2 : Col A B N
H1 : Col M Q M
H0 : Col A B M
H : not (eq (S4 M A Q B) F0)
A,B,Q,M,N : Point
*****
eq M N
+++++
unfold S4 in *.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A M
H8 : not (eq M N)
H7 : Col M M N
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H3 : Col M Q N
H2 : Col A B N
H1 : Col M Q M
H0 : Col A B M
H : not (eq (Fplus (S M A Q) (S M Q B)) F0)
A,B,Q,M,N : Point
*****
eq M N
+++++
rewrite H12 in H.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.
rewrite H12 in H.

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A M
H8 : not (eq M N)
H7 : Col M M N
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H3 : Col M Q N
H2 : Col A B N
H1 : Col M Q M
H0 : Col A B M
H : not (eq (Fplus (S M A Q) F0) F0)
A,B,Q,M,N : Point
*****
eq M N
+++++
basic_simpl.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.
rewrite H12 in H.
basic_simpl.

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A M
H8 : not (eq M N)
H7 : Col M M N
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H3 : Col M Q N
H2 : Col A B N
H1 : Col M Q M
H0 : Col A B M
H : not (eq (S M A Q) F0)
A,B,Q,M,N : Point
*****
eq M N
+++++
clear H7 H9 H1 H3.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.
rewrite H12 in H.
basic_simpl.
clear H7 H9 H1 H3.

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H8 : not (eq M N)
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H2 : Col A B N
H0 : Col A B M
H : not (eq (S M A Q) F0)
A,B,Q,M,N : Point
*****
eq M N
+++++
assert (Col M A Q).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.
rewrite H12 in H.
basic_simpl.
clear H7 H9 H1 H3.
assert (Col M A Q).

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H8 : not (eq M N)
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H2 : Col A B N
H0 : Col A B M
H : not (eq (S M A Q) F0)
A,B,Q,M,N : Point
*****
Col M A Q
+++++
apply (col_trans_1 M N A Q).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.
rewrite H12 in H.
basic_simpl.
clear H7 H9 H1 H3.
assert (Col M A Q).
apply (col_trans_1 M N A Q).

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H8 : not (eq M N)
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H2 : Col A B N
H0 : Col A B M
H : not (eq (S M A Q) F0)
A,B,Q,M,N : Point
*****
not (eq M N)
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.
rewrite H12 in H.
basic_simpl.
clear H7 H9 H1 H3.
assert (Col M A Q).
apply (col_trans_1 M N A Q).

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H8 : not (eq M N)
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H2 : Col A B N
H0 : Col A B M
H : not (eq (S M A Q) F0)
A,B,Q,M,N : Point
*****
Col M N A
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.
rewrite H12 in H.
basic_simpl.
clear H7 H9 H1 H3.
assert (Col M A Q).
apply (col_trans_1 M N A Q).

*****
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H8 : not (eq M N)
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H2 : Col A B N
H0 : Col A B M
H : not (eq (S M A Q) F0)
A,B,Q,M,N : Point
*****
Col M N Q
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.
rewrite H12 in H.
basic_simpl.
clear H7 H9 H1 H3.
assert (Col M A Q).

*****
H1 : Col M A Q
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H8 : not (eq M N)
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H2 : Col A B N
H0 : Col A B M
H : not (eq (S M A Q) F0)
A,B,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
subst.
unfold parallel in *.
unfold S4 in *.
rewrite H12 in H.
basic_simpl.
clear H7 H9 H1 H3.
assert (Col M A Q).
idtac.

*****
H1 : Col M A Q
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H8 : not (eq M N)
H6 : Col A M N
H5 : not (eq M Q)
H4 : not (eq A B)
H2 : Col A B N
H0 : Col A B M
H : not (eq (S M A Q) F0)
A,B,Q,M,N : Point
*****
eq M N
+++++
intuition.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.

*****
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (Col P A Q).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).

*****
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col P A Q
+++++
apply (col_trans_1 P M A Q).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
apply (col_trans_1 P M A Q).

*****
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
not (eq P M)
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
apply (col_trans_1 P M A Q).

*****
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col P M A
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
apply (col_trans_1 P M A Q).

*****
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
Col P M Q
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).

*****
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.

*****
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
unfold parallel in *.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.

*****
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S4 P A Q B) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
unfold S4 in *.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.

*****
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
rewrite H14 in H.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.

*****
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus F0 (S P Q B)) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
basic_simpl.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.

*****
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
cases_equality Q M.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.

*****
H15 : eq Q M
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
subst.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.

*****
H14 : Col P A M
H13 : not (eq P M)
H11 : Col M M N
H12 : Col M M B
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H1 : Col P M M
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
eq M N
+++++
clear H1 H11 H12 H14.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.

*****
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
eq M N
+++++
assert (Col M P B).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.
assert (Col M P B).

*****
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
Col M P B
+++++
apply (col_trans_1 M N P B).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.
assert (Col M P B).
apply (col_trans_1 M N P B).

*****
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
not (eq M N)
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.
assert (Col M P B).
apply (col_trans_1 M N P B).

*****
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
Col M N P
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.
assert (Col M P B).
apply (col_trans_1 M N P B).

*****
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
Col M N B
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.
assert (Col M P B).

*****
H1 : Col M P B
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.
assert (Col M P B).
idtac.

*****
H1 : Col M P B
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
eq M N
+++++
assert (Col P M B).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.
assert (Col M P B).
idtac.
assert (Col P M B).

*****
H1 : Col M P B
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
Col P M B
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.
assert (Col M P B).
idtac.
assert (Col P M B).

*****
H11 : Col P M B
H1 : Col M P B
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
subst.
clear H1 H11 H12 H14.
assert (Col M P B).
idtac.
assert (Col P M B).
idtac.

*****
H11 : Col P M B
H1 : Col M P B
H13 : not (eq P M)
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P M)
H4 : not (eq A B)
H3 : Col P M N
H2 : Col A B N
H0 : Col A B M
H : not (eq (S P M B) F0)
A,B,P,M,N : Point
*****
eq M N
+++++
intuition.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.

*****
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (Col Q B P).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
assert (Col Q B P).

*****
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
Col Q B P
+++++
apply (col_trans_1 Q M B P).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
assert (Col Q B P).
apply (col_trans_1 Q M B P).

*****
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
not (eq Q M)
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
assert (Col Q B P).
apply (col_trans_1 Q M B P).

*****
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
Col Q M B
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
assert (Col Q B P).
apply (col_trans_1 Q M B P).

*****
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
Col Q M P
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
assert (Col Q B P).

*****
H16 : Col Q B P
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
assert (Col Q B P).
idtac.

*****
H16 : Col Q B P
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
assert (Col P Q B).
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
assert (Col Q B P).
idtac.
assert (Col P Q B).

*****
H16 : Col Q B P
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
Col P Q B
+++++
auto with Geom.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
assert (Col Q B P).
idtac.
assert (Col P Q B).

*****
H17 : Col P Q B
H16 : Col Q B P
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
idtac.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).
idtac.
assert (P<>Q).
idtac.
assert (Col A M N).
idtac.
assert (Col P M N).
idtac.
cases_equality M N.
auto.
assert (Col M A P).
idtac.
assert (Col B M N).
idtac.
assert (Col Q M N).
idtac.
assert (Col M Q B).
idtac.
cases_equality P M.
assert (Col P A Q).
idtac.
unfold parallel in *.
unfold S4 in *.
rewrite H14 in H.
basic_simpl.
cases_equality Q M.
assert (Col Q B P).
idtac.
assert (Col P Q B).
idtac.

*****
H17 : Col P Q B
H16 : Col Q B P
H15 : not (eq Q M)
H14 : Col P A Q
H13 : not (eq P M)
H12 : Col M Q B
H11 : Col Q M N
H10 : Col B M N
H9 : Col M A P
H8 : not (eq M N)
H7 : Col P M N
H6 : Col A M N
H5 : not (eq P Q)
H4 : not (eq A B)
H3 : Col P Q N
H2 : Col A B N
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P Q B) F0)
A,B,P,Q,M,N : Point
*****
eq M N
+++++
intuition.
-----
Theorem inter_unicity_2 : forall A B P Q M N: Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Col A B N -> Col P Q N -> M = N.
Proof.
intros.
assert (A<>B).

*****

*****

+++++
Qed.
-----
Theorem co_side_bis :\n forall A B P Q M : Point,\n ~ parallel P Q A B ->\n Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.

*****

*****
forall (A B P Q M : Point) (_ : not (parallel P Q A B)) (_ : Col A B M) (_ : Col P Q M), eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Proof.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.

*****

*****
forall (A B P Q M : Point) (_ : not (parallel P Q A B)) (_ : Col A B M) (_ : Col P Q M), eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
intros.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.

*****
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.

*****
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
assert (P <> Q).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).

*****
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.

*****
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq P Q)
+++++
eapply par_aux_1.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
eapply par_aux_1.

*****
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (parallel P Q ?U ?V)
+++++
apply H.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).

*****
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.

*****
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
cases_equality Q M.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.

*****
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.

*****
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
assert (Q ** M = 0).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).

*****
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (DSeg Q M) F0
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).

*****
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.

*****
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
rewrite H4.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.

*****
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.

*****
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
rewrite <- H3 in H0.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.
rewrite <- H3 in H0.

*****
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B Q
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.
rewrite <- H3 in H0.
Geometry.

*****
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B Q
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
assert (Col Q A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.
rewrite <- H3 in H0.
Geometry.
assert (Col Q A B).

*****
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B Q
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
Col Q A B
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.
rewrite <- H3 in H0.
Geometry.
assert (Col Q A B).

*****
H5 : Col Q A B
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B Q
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.
rewrite <- H3 in H0.
Geometry.
assert (Col Q A B).
Geometry.

*****
H5 : Col Q A B
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B Q
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
unfold parallel in H.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.
rewrite <- H3 in H0.
Geometry.
assert (Col Q A B).
Geometry.
unfold parallel in H.

*****
H5 : Col Q A B
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B Q
H : not (eq (S4 P A Q B) F0)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.
rewrite <- H3 in H0.
Geometry.
assert (Col Q A B).
Geometry.
unfold parallel in H.
Geometry.

*****
H5 : Col Q A B
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B Q
H : not (eq (S4 P A Q B) F0)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
rewrite H5.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.
rewrite <- H3 in H0.
Geometry.
assert (Col Q A B).
Geometry.
unfold parallel in H.
Geometry.
rewrite H5.

*****
H5 : Col Q A B
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B Q
H : not (eq (S4 P A Q B) F0)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv F0 (S4 P A Q B))
+++++
field.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
assert (Q ** M = 0).
Geometry.
rewrite H4.
Geometry.
rewrite <- H3 in H0.
Geometry.
assert (Col Q A B).
Geometry.
unfold parallel in H.
Geometry.
rewrite H5.
field.

*****
H5 : Col Q A B
H4 : eq (DSeg Q M) F0
H3 : eq Q M
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B Q
H : not (eq (S4 P A Q B) F0)
A,B,P,Q,M : Point
*****
and (not (eq (S4 P A Q B) F0)) (not (eq (DSeg P Q) F0))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.

*****
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.

*****
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
cases_equality A Q.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.

*****
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.

*****
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
assert (A = M).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).

*****
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.

*****
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq A M
+++++
apply (inter_unicity A B P Q M H H0 H1 H4).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).

*****
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.

*****
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
rewrite H4.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.

*****
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.

*****
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
assert (Q = M).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).

*****
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq Q M
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.

*****
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq Q M
+++++
congruence.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).

*****
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.

*****
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
assert (Q ** M = 0).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).

*****
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (DSeg Q M) F0
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).

*****
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).
Geometry.

*****
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
assert (S Q Q B = 0).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).
Geometry.
assert (S Q Q B = 0).

*****
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (S Q Q B) F0
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).
Geometry.
assert (S Q Q B = 0).

*****
H8 : eq (S Q Q B) F0
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).
Geometry.
assert (S Q Q B = 0).
Geometry.

*****
H8 : eq (S Q Q B) F0
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
rewrite H7.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).
Geometry.
assert (S Q Q B = 0).
Geometry.
rewrite H7.

*****
H8 : eq (S Q Q B) F0
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).
Geometry.
assert (S Q Q B = 0).
Geometry.
rewrite H7.
Geometry.

*****
H8 : eq (S Q Q B) F0
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv (S Q Q B) (S4 P Q Q B))
+++++
rewrite H8.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).
Geometry.
assert (S Q Q B = 0).
Geometry.
rewrite H7.
Geometry.
rewrite H8.

*****
H8 : eq (S Q Q B) F0
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv F0 (S4 P Q Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).
Geometry.
assert (S Q Q B = 0).
Geometry.
rewrite H7.
Geometry.
rewrite H8.
Geometry.

*****
H8 : eq (S Q Q B) F0
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F0 (DSeg P Q)) (Fdiv F0 (S4 P Q Q B))
+++++
field.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (A = M).
Geometry.
rewrite H4.
Geometry.
assert (Q = M).
Geometry.
assert (Q ** M = 0).
Geometry.
assert (S Q Q B = 0).
Geometry.
rewrite H7.
Geometry.
rewrite H8.
Geometry.
field.

*****
H8 : eq (S Q Q B) F0
H7 : eq (DSeg Q M) F0
H6 : eq Q M
H5 : eq A M
H4 : eq A Q
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
and (not (eq (S4 P Q Q B) F0)) (not (eq (DSeg P Q) F0))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.

*****
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.

*****
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
assert (~ Col Q A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).

*****
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (Col Q A B)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.

*****
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (Col Q A B)
+++++
unfold not in |- *.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.

*****
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
forall _ : Col Q A B, False
+++++
intro.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
False
+++++
unfold parallel in H.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S4 P A Q B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S4 P A Q B) F0)
A,B,P,Q,M : Point
*****
False
+++++
unfold S4 in H.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (S P A B = S P A Q + S P Q B + S Q A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).

*****
H6 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.

*****
H6 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
rewrite H5 in H6.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.

*****
H6 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) F0)
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.

*****
H6 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) F0)
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
IsoleVar (S P A Q) H6.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.

*****
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.

*****
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (S P A Q) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
rewrite H6 in H.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.

*****
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.

*****
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).

*****
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) (S P A B)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.

*****
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) (S P A B)
+++++
ring.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).

*****
H7 : eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) (S P A B)
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.

*****
H7 : eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) (S P A B)
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) F0)
A,B,P,Q,M : Point
*****
False
+++++
rewrite H7 in H.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.

*****
H7 : eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) (S P A B)
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.

*****
H7 : eq (Fplus (Fminus (Fminus (S P A B) F0) (S P Q B)) (S P Q B)) (S P A B)
H6 : eq (S P A Q) (Fminus (Fminus (S P A B) F0) (S P Q B))
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
clear H6 H7.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col A B Q).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).

*****
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
Col A B Q
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).

*****
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.

*****
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (A <> B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).

*****
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
not (eq A B)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.

*****
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
not (eq A B)
+++++
unfold not in |- *.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
unfold not in |- *.

*****
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
forall _ : eq A B, False
+++++
intro.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
unfold not in |- *.
intro.

*****
H7 : eq A B
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
unfold not in |- *.
intro.
Geometry.

*****
H7 : eq A B
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (S P A B = 0).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P A B = 0).

*****
H7 : eq A B
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
eq (S P A B) F0
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P A B = 0).
Geometry.

*****
H7 : eq A B
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
eq (S P A B) F0
+++++
rewrite H7.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P A B = 0).
Geometry.
rewrite H7.

*****
H7 : eq A B
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
eq (S P B B) F0
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (S P A B = 0).

*****
H8 : eq (S P A B) F0
H7 : eq A B
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).

*****
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.

*****
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col A M Q).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).

*****
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
Col A M Q
+++++
eauto with Geom.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).

*****
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
eauto with Geom.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.

*****
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.

*****
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col Q M P).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).

*****
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
Col Q M P
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).

*****
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.

*****
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col Q M A).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).

*****
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
Col Q M A
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).

*****
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.

*****
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col Q A P).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).

*****
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
Col Q A P
+++++
eauto with Geom.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).

*****
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
eauto with Geom.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.

*****
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.

*****
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col A Q B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).

*****
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
Col A Q B
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).

*****
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.

*****
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col A Q P).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.
assert (Col A Q P).

*****
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
Col A Q P
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.
assert (Col A Q P).

*****
H13 : Col A Q P
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.
assert (Col A Q P).
Geometry.

*****
H13 : Col A Q P
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col A B P).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.
assert (Col A Q P).
Geometry.
assert (Col A B P).

*****
H13 : Col A Q P
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
Col A B P
+++++
eauto with Geom.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.
assert (Col A Q P).
Geometry.
assert (Col A B P).

*****
H14 : Col A B P
H13 : Col A Q P
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
eauto with Geom.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.
assert (Col A Q P).
Geometry.
assert (Col A B P).
eauto with Geom.

*****
H14 : Col A B P
H13 : Col A Q P
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.
assert (Col A Q P).
Geometry.
assert (Col A B P).
eauto with Geom.
Geometry.

*****
H14 : Col A B P
H13 : Col A Q P
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
assert (Col P A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.
assert (Col A Q P).
Geometry.
assert (Col A B P).
eauto with Geom.
Geometry.
assert (Col P A B).

*****
H14 : Col A B P
H13 : Col A Q P
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
Col P A B
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
unfold not in |- *.
intro.
Geometry.
unfold parallel in H.
Geometry.
unfold S4 in H.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5 in H6.
Geometry.
IsoleVar (S P A Q) H6.
Geometry.
rewrite H6 in H.
Geometry.
assert (S P A B - 0 - S P Q B + S P Q B = S P A B).
Geometry.
rewrite H7 in H.
Geometry.
clear H6 H7.
Geometry.
assert (Col A B Q).
Geometry.
assert (A <> B).
Geometry.
assert (Col A M Q).
eauto with Geom.
Geometry.
assert (Col Q M P).
Geometry.
assert (Col Q M A).
Geometry.
assert (Col Q A P).
eauto with Geom.
Geometry.
assert (Col A Q B).
Geometry.
assert (Col A Q P).
Geometry.
assert (Col A B P).
eauto with Geom.
Geometry.
assert (Col P A B).

*****
H15 : Col P A B
H14 : Col A B P
H13 : Col A Q P
H12 : Col A Q B
H11 : Col Q A P
H10 : Col Q M A
H9 : Col Q M P
H8 : Col A M Q
H7 : not (eq A B)
H6 : Col A B Q
H5 : Col Q A B
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S P A B) F0)
A,B,P,Q,M : Point
*****
False
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).

*****
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.

*****
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
assert (P ** M / Q ** M = S P A B / S Q A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).

*****
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).

*****
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.

*****
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).

*****
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.

*****
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
+++++
field.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
field.

*****
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
and (not (eq (DSeg Q M) F0)) (not (eq (DSeg P Q) F0))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).

*****
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.

*****
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).

*****
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fminus (Fdiv (DSeg P M) (DSeg Q M)) F1) (Fdiv (DSeg P Q) (DSeg Q M))
+++++
replace (P ** Q) with (P ** M - Q ** M).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
replace (P ** Q) with (P ** M - Q ** M).

*****
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fminus (Fdiv (DSeg P M) (DSeg Q M)) F1) (Fdiv (Fminus (DSeg P M) (DSeg Q M)) (DSeg Q M))
+++++
field.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
replace (P ** Q) with (P ** M - Q ** M).
field.

*****
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (DSeg Q M) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
replace (P ** Q) with (P ** M - Q ** M).

*****
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fminus (DSeg P M) (DSeg Q M)) (DSeg P Q)
+++++
assert (Q ** M = - M ** Q).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
replace (P ** Q) with (P ** M - Q ** M).
assert (Q ** M = - M ** Q).

*****
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (DSeg Q M) (Fopp (DSeg M Q))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
replace (P ** Q) with (P ** M - Q ** M).
assert (Q ** M = - M ** Q).

*****
H8 : eq (DSeg Q M) (Fopp (DSeg M Q))
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fminus (DSeg P M) (DSeg Q M)) (DSeg P Q)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
replace (P ** Q) with (P ** M - Q ** M).
assert (Q ** M = - M ** Q).
Geometry.

*****
H8 : eq (DSeg Q M) (Fopp (DSeg M Q))
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fminus (DSeg P M) (DSeg Q M)) (DSeg P Q)
+++++
rewrite H8 in |- *.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
replace (P ** Q) with (P ** M - Q ** M).
assert (Q ** M = - M ** Q).
Geometry.
rewrite H8 in |- *.

*****
H8 : eq (DSeg Q M) (Fopp (DSeg M Q))
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fminus (DSeg P M) (Fopp (DSeg M Q))) (DSeg P Q)
+++++
ring_simplify.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
replace (P ** Q) with (P ** M - Q ** M).
assert (Q ** M = - M ** Q).
Geometry.
rewrite H8 in |- *.
ring_simplify.

*****
H8 : eq (DSeg Q M) (Fopp (DSeg M Q))
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fplus (DSeg P M) (DSeg M Q)) (DSeg P Q)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).

*****
H8 : eq (Fminus (Fdiv (DSeg P M) (DSeg Q M)) F1)\n (Fdiv (DSeg P Q) (DSeg Q M))
H7 : eq (Fmult (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (DSeg P Q) (DSeg Q M))) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
rewrite <- H8 in H7.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.

*****
H8 : eq (Fminus (Fdiv (DSeg P M) (DSeg Q M)) F1)\n (Fdiv (DSeg P Q) (DSeg Q M))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (DSeg P M) (DSeg Q M)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
clear H8.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.

*****
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (DSeg P M) (DSeg Q M)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
rewrite H6 in H7.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.

*****
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
assert (S4 P A Q B = S P A B - S Q A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).

*****
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).

*****
H8 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.

*****
H8 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
rewrite H8.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.

*****
H8 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (Fminus (S P A B) (S Q A B)))
+++++
clear H8.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.

*****
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (Fminus (S P A B) (S Q A B)))
+++++
IsoleVar (Q ** M / P ** Q) H7.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.

*****
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (Fminus (S P A B) (S Q A B)))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.

*****
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (Fminus (S P A B) (S Q A B)))
+++++
rewrite H7.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.

*****
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1)) (Fdiv (S Q A B) (Fminus (S P A B) (S Q A B)))
+++++
field.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.

*****
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
and (not (eq (Fminus (S P A B) (S Q A B)) F0)) (not (eq (S Q A B) F0))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.
Geometry.

*****
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
and (not (eq (Fminus (S P A B) (S Q A B)) F0)) (not (eq (S Q A B) F0))
+++++
split.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.
Geometry.
split.

*****
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.
Geometry.
split.
Geometry.

*****
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
assert (S4 P A Q B = S P A B - S Q A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.
Geometry.
split.
Geometry.
assert (S4 P A Q B = S P A B - S Q A B).

*****
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.
Geometry.
split.
Geometry.
assert (S4 P A Q B = S P A B - S Q A B).

*****
H9 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.
Geometry.
split.
Geometry.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.

*****
H9 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
unfold parallel in H.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.
Geometry.
split.
Geometry.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
unfold parallel in H.

*****
H9 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (S4 P A Q B) F0)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
rewrite H9 in H.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.
Geometry.
split.
Geometry.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
unfold parallel in H.
rewrite H9 in H.

*****
H9 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (eq (Fminus (S P A B) (S Q A B)) F0)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
rewrite H7.
field.
Geometry.
split.

*****
H7 : eq (Fdiv (DSeg Q M) (DSeg P Q))\n (Fdiv F1 (Fminus (Fdiv (S P A B) (S Q A B)) F1))
H8 : not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (S Q A B) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.

*****
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.

*****
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
+++++
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).

*****
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
+++++
field.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
field.

*****
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (S Q A B) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).

*****
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (Fdiv (S P A B) (S Q A B)) F1) F0)
+++++
rewrite H8.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
rewrite H8.

*****
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B)) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
rewrite H8.
Geometry.

*****
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B)) F0)
+++++
apply nonzerodiv.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
rewrite H8.
Geometry.
apply nonzerodiv.

*****
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
rewrite H8.
Geometry.
apply nonzerodiv.
Geometry.

*****
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
assert (S4 P A Q B = S P A B - S Q A B).
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
rewrite H8.
Geometry.
apply nonzerodiv.
Geometry.
assert (S4 P A Q B = S P A B - S Q A B).

*****
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
rewrite H8.
Geometry.
apply nonzerodiv.
Geometry.
assert (S4 P A Q B = S P A B - S Q A B).

*****
H9 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
rewrite H8.
Geometry.
apply nonzerodiv.
Geometry.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.

*****
H9 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (Fminus (S P A B) (S Q A B)) F0)
+++++
rewrite <- H9.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
rewrite H8.
Geometry.
apply nonzerodiv.
Geometry.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite <- H9.

*****
H9 : eq (S4 P A Q B) (Fminus (S P A B) (S Q A B))
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (S4 P A Q B) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).
Geometry.
cases_equality Q M.
Geometry.
cases_equality A Q.
Geometry.
assert (~ Col Q A B).
Geometry.
assert (P ** M / Q ** M = S P A B / S Q A B).
Geometry.
assert (Q ** M / P ** Q * (P ** Q / Q ** M) = 1).
Geometry.
assert (P ** M / Q ** M - 1 = P ** Q / Q ** M).
rewrite <- H8 in H7.
clear H8.
rewrite H6 in H7.
assert (S4 P A Q B = S P A B - S Q A B).
Geometry.
rewrite H8.
clear H8.
IsoleVar (Q ** M / P ** Q) H7.
Geometry.
assert (S P A B / S Q A B - 1 = (S P A B - S Q A B) / S Q A B).
rewrite H8.
Geometry.
apply nonzerodiv.

*****
H8 : eq (Fminus (Fdiv (S P A B) (S Q A B)) F1)\n (Fdiv (Fminus (S P A B) (S Q A B)) (S Q A B))
H7 : eq\n (Fmult (Fdiv (DSeg Q M) (DSeg P Q))\n (Fminus (Fdiv (S P A B) (S Q A B)) F1)) F1
H6 : eq (Fdiv (DSeg P M) (DSeg Q M)) (Fdiv (S P A B) (S Q A B))
H5 : not (Col Q A B)
H4 : not (eq A Q)
H3 : not (eq Q M)
H2 : not (eq P Q)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (S Q A B) F0)
+++++
Geometry.
-----
Theorem co_side_bis : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> Q ** M / P ** Q = S Q A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (P <> Q).

*****

*****

+++++
Qed.
-----
Hint Resolve co_side_bis: Geom.
-----
Theorem co_side_ter :\n forall A B P Q M : Point,\n ~ parallel P Q A B ->\n Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.

*****

*****
forall (A B P Q M : Point) (_ : not (parallel P Q A B)) (_ : Col A B M) (_ : Col P Q M), eq (Fdiv (DSeg P M) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
Proof.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.

*****

*****
forall (A B P Q M : Point) (_ : not (parallel P Q A B)) (_ : Col A B M) (_ : Col P Q M), eq (Fdiv (DSeg P M) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
intros.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.

*****
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.

*****
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).

*****
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).

*****
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.

*****
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
assert (P ** Q + Q ** M = P ** M).
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).

*****
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (DSeg P M) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
rewrite <- H3.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.

*****
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
RewriteVar (Q ** M) H2.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.

*****
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.

*****
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
assert (S P A B = S P A Q + S P Q B + S Q A B).
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).

*****
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).

*****
H5 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.

*****
H5 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))) (DSeg P Q)) (Fdiv (S P A B) (S4 P A Q B))
+++++
rewrite H5.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5.

*****
H5 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))) (DSeg P Q)) (Fdiv (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B)) (S4 P A Q B))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5.
Geometry.

*****
H5 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))) (DSeg P Q)) (Fdiv (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B)) (S4 P A Q B))
+++++
unfold S4 in |- *.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5.
Geometry.
unfold S4 in |- *.

*****
H5 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (Fplus (S P A Q) (S P Q B))))) (DSeg P Q)) (Fdiv (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B)) (Fplus (S P A Q) (S P Q B)))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5.
Geometry.
unfold S4 in |- *.
Geometry.

*****
H5 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (Fplus (S P A Q) (S P Q B))))) (DSeg P Q)) (Fdiv (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B)) (Fplus (S P A Q) (S P Q B)))
+++++
field.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (S P A B = S P A Q + S P Q B + S Q A B).
Geometry.
rewrite H5.
Geometry.
unfold S4 in |- *.
Geometry.
field.

*****
H5 : eq (S P A B) (Fplus (Fplus (S P A Q) (S P Q B)) (S Q A B))
H2 : eq (DSeg Q M) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B)))
H4 : not (eq (DSeg P Q) F0)
H3 : eq (Fplus (DSeg P Q) (Fmult (DSeg P Q) (Fdiv (S Q A B) (S4 P A Q B))))\n (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
and (not (eq (Fplus (S P A Q) (S P Q B)) F0)) (not (eq (DSeg P Q) F0))
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.

*****
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (DSeg P Q) F0)
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.

*****
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (DSeg P Q) F0)
+++++
assert (P <> Q).
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (P <> Q).

*****
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (P <> Q).
Geometry.

*****
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq P Q)
+++++
eapply par_aux_1.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (P <> Q).
Geometry.
eapply par_aux_1.

*****
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (parallel P Q ?U ?V)
+++++
apply H.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).
Geometry.
assert (P ** Q + Q ** M = P ** M).
Geometry.
rewrite <- H3.
Geometry.
RewriteVar (Q ** M) H2.
Geometry.
assert (P <> Q).

*****
H4 : not (eq P Q)
H2 : eq (Fdiv (DSeg Q M) (DSeg P Q)) (Fdiv (S Q A B) (S4 P A Q B))
H3 : eq (Fplus (DSeg P Q) (DSeg Q M)) (DSeg P M)
H1 : Col P Q M
H0 : Col A B M
H : not (parallel P Q A B)
A,B,P,Q,M : Point
*****
not (eq (DSeg P Q) F0)
+++++
Geometry.
-----
Theorem co_side_ter : forall A B P Q M : Point, ~ parallel P Q A B -> Col A B M -> Col P Q M -> P ** M / P ** Q = S P A B / S4 P A Q B.
Proof.
intros.
Geometry.
assert (Q ** M / P ** Q = S Q A B / S4 P A Q B).

*****

*****

+++++
Qed.
-----
Hint Resolve co_side_ter: Geom.
-----
Theorem l2_9_weak :\n forall A B P Q R : Point,\n P <> Q ->\n ~ Col Q A P ->\n ~ Col Q P B ->\n Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.

*****

*****
forall (A B P Q R : Point) (_ : not (eq P Q)) (_ : not (Col Q A P)) (_ : not (Col Q P B)) (_ : Col R P Q), eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Proof.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.

*****

*****
forall (A B P Q R : Point) (_ : not (eq P Q)) (_ : not (Col Q A P)) (_ : not (Col Q P B)) (_ : Col R P Q), eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
intros.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.

*****
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.

*****
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S R A B = S R A P + S R P B + S P A B).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).

*****
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fplus (S R A P) (S R P B)) (S P A B))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).

*****
H3 : eq (S R A B) (Fplus (Fplus (S R A P) (S R P B)) (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.

*****
H3 : eq (S R A B) (Fplus (Fplus (S R A P) (S R P B)) (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (P ** R / P ** Q = S R A P / S Q A P).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).

*****
H3 : eq (S R A B) (Fplus (Fplus (S R A P) (S R P B)) (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).

*****
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
H3 : eq (S R A B) (Fplus (Fplus (S R A P) (S R P B)) (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.

*****
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
H3 : eq (S R A B) (Fplus (Fplus (S R A P) (S R P B)) (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
RewriteVar (S R A P) H4.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.

*****
H4 : eq (S R A P) (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.

*****
H4 : eq (S R A P) (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
clear H4.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.

*****
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.

*****
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (P ** R / P ** Q = S B P R / S B P Q).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).

*****
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S B P R) (S B P Q))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).

*****
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S B P R) (S B P Q))
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.

*****
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S B P R) (S B P Q))
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (- S B P R = S R P B).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).

*****
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S B P R) (S B P Q))
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fopp (S B P R)) (S R P B)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).

*****
H6 : eq (Fopp (S B P R)) (S R P B)
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S B P R) (S B P Q))
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.

*****
H6 : eq (Fopp (S B P R)) (S R P B)
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S B P R) (S B P Q))
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (S R P B))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite <- H6 in H3.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.

*****
H6 : eq (Fopp (S B P R)) (S R P B)
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S B P R) (S B P Q))
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (S B P R))) (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.

*****
H6 : eq (Fopp (S B P R)) (S R P B)
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S B P R) (S B P Q))
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (S B P R))) (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
RewriteVar (S B P R) H4.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.

*****
H4 : eq (S B P R) (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))
H7 : not (eq (S B P Q) F0)
H6 : eq (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))) (S R P B)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.

*****
H4 : eq (S B P R) (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))
H7 : not (eq (S B P Q) F0)
H6 : eq (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))) (S R P B)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
clear H4 H6.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.

*****
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.

*****
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).

*****
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q))) (S P A B))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.

*****
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q))) (S P A B))
+++++
rewrite H3.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
rewrite H3.

*****
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q))))) (S P A B)) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q))) (S P A B))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
rewrite H3.
Geometry.

*****
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q))) (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q))))) (S P A B)) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q))) (S P A B))
+++++
field.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
rewrite H3.
Geometry.
field.

*****
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq (DSeg P Q) F0)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (DSeg P R) (DSeg P Q)))\n (Fopp (Fmult (S B P Q) (Fdiv (DSeg P R) (DSeg P Q)))))\n (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
clear H3.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S A P Q - S B P Q = S4 A P B Q).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus (S A P Q) (S B P Q)) (S4 A P B Q)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).

*****
H3 : eq (Fminus (S A P Q) (S B P Q)) (S4 A P B Q)
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.

*****
H3 : eq (Fminus (S A P Q) (S B P Q)) (S4 A P B Q)
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
unfold S4 in H3.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.

*****
H3 : eq (Fminus (S A P Q) (S B P Q)) (Fplus (S A P B) (S A B Q))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.

*****
H3 : eq (Fminus (S A P Q) (S B P Q)) (Fplus (S A P B) (S A B Q))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S Q A P = S A P Q).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).

*****
H3 : eq (Fminus (S A P Q) (S B P Q)) (Fplus (S A P B) (S A B Q))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S Q A P) (S A P Q)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).

*****
H6 : eq (S Q A P) (S A P Q)
H3 : eq (Fminus (S A P Q) (S B P Q)) (Fplus (S A P B) (S A B Q))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.

*****
H6 : eq (S Q A P) (S A P Q)
H3 : eq (Fminus (S A P Q) (S B P Q)) (Fplus (S A P B) (S A B Q))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite <- H6 in H3.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.

*****
H6 : eq (S Q A P) (S A P Q)
H3 : eq (Fminus (S Q A P) (S B P Q)) (Fplus (S A P B) (S A B Q))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.

*****
H6 : eq (S Q A P) (S A P Q)
H3 : eq (Fminus (S Q A P) (S B P Q)) (Fplus (S A P B) (S A B Q))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fminus (S Q A P) (S B P Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H3 in H4.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.

*****
H6 : eq (S Q A P) (S A P Q)
H3 : eq (Fminus (S Q A P) (S B P Q)) (Fplus (S A P B) (S A B Q))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S A B Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.

*****
H6 : eq (S Q A P) (S A P Q)
H3 : eq (Fminus (S Q A P) (S B P Q)) (Fplus (S A P B) (S A B Q))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S A B Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
clear H3 H6.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S A B Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S A B Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S A B Q = S Q A B).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S A B Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S A B Q) (S Q A B)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).

*****
H3 : eq (S A B Q) (S Q A B)
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S A B Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.

*****
H3 : eq (S A B Q) (S Q A B)
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S A B Q)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H3 in H4.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.

*****
H3 : eq (S A B Q) (S Q A B)
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S Q A B)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.

*****
H3 : eq (S A B Q) (S Q A B)
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S Q A B)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
clear H3.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S Q A B)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S Q A B)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S A P B = - S P A B).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S Q A B)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S A P B) (Fopp (S P A B))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).

*****
H3 : eq (S A P B) (Fopp (S P A B))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S Q A B)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.

*****
H3 : eq (S A P B) (Fopp (S P A B))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (S A P B) (S Q A B)))\n (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H3 in H4.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.

*****
H3 : eq (S A P B) (Fopp (S P A B))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.

*****
H3 : eq (S A P B) (Fopp (S P A B))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
clear H3.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B)) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B)) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
+++++
field.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
field.

*****
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq (DSeg P Q) F0)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).

*****
H3 : eq\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.

*****
H3 : eq\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H4 : eq (S R A B)\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H3 in H4.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.

*****
H3 : eq\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.

*****
H3 : eq\n (Fplus\n (Fmult (Fdiv (DSeg P R) (DSeg P Q))\n (Fplus (Fopp (S P A B)) (S Q A B))) (S P A B))\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
clear H3.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.

*****
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.

*****
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).

*****
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (Fdiv (DSeg R Q) (DSeg P Q))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.

*****
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (Fdiv (DSeg R Q) (DSeg P Q))
+++++
assert (R ** P + P ** Q = R ** Q).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).

*****
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).

*****
H3 : eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (Fdiv (DSeg R Q) (DSeg P Q))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).
Geometry.

*****
H3 : eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (Fdiv (DSeg R Q) (DSeg P Q))
+++++
rewrite <- H3.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).
Geometry.
rewrite <- H3.

*****
H3 : eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (Fdiv (Fplus (DSeg R P) (DSeg P Q)) (DSeg P Q))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).
Geometry.
rewrite <- H3.
Geometry.

*****
H3 : eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (Fdiv (Fplus (DSeg R P) (DSeg P Q)) (DSeg P Q))
+++++
assert (R ** P = - P ** R).
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).
Geometry.
rewrite <- H3.
Geometry.
assert (R ** P = - P ** R).

*****
H3 : eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (DSeg R P) (Fopp (DSeg P R))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).
Geometry.
rewrite <- H3.
Geometry.
assert (R ** P = - P ** R).

*****
H6 : eq (DSeg R P) (Fopp (DSeg P R))
H3 : eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (Fdiv (Fplus (DSeg R P) (DSeg P Q)) (DSeg P Q))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).
Geometry.
rewrite <- H3.
Geometry.
assert (R ** P = - P ** R).
Geometry.

*****
H6 : eq (DSeg R P) (Fopp (DSeg P R))
H3 : eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (Fdiv (Fplus (DSeg R P) (DSeg P Q)) (DSeg P Q))
+++++
rewrite H6.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).
Geometry.
rewrite <- H3.
Geometry.
assert (R ** P = - P ** R).
Geometry.
rewrite H6.

*****
H6 : eq (DSeg R P) (Fopp (DSeg P R))
H3 : eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (Fdiv (Fplus (Fopp (DSeg P R)) (DSeg P Q)) (DSeg P Q))
+++++
field.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.
assert (R ** P + P ** Q = R ** Q).
Geometry.
rewrite <- H3.
Geometry.
assert (R ** P = - P ** R).
Geometry.
rewrite H6.
field.

*****
H6 : eq (DSeg R P) (Fopp (DSeg P R))
H3 : eq (Fplus (DSeg R P) (DSeg P Q)) (DSeg R Q)
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq (DSeg P Q) F0)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).

*****
H3 : eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q)))\n (Fdiv (DSeg R Q) (DSeg P Q))
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.
Geometry.
clear H4 H6.
Geometry.
assert (S R A B = P ** R / P ** Q * (S Q A P - S B P Q) + S P A B).
Geometry.
clear H3.
Geometry.
assert (S A P Q - S B P Q = S4 A P B Q).
Geometry.
unfold S4 in H3.
Geometry.
assert (S Q A P = S A P Q).
Geometry.
rewrite <- H6 in H3.
Geometry.
rewrite H3 in H4.
Geometry.
clear H3 H6.
Geometry.
assert (S A B Q = S Q A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (S A P B = - S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (P ** R / P ** Q * (- S P A B + S Q A B) + S P A B = P ** R / P ** Q * S Q A B + (1 - P ** R / P ** Q) * S P A B).
Geometry.
rewrite H3 in H4.
Geometry.
clear H3.
Geometry.
assert (1 - P ** R / P ** Q = R ** Q / P ** Q).
Geometry.

*****
H3 : eq (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q)))\n (Fdiv (DSeg R Q) (DSeg P Q))
H4 : eq (S R A B)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B))\n (Fmult (Fminus F1 (Fdiv (DSeg P R) (DSeg P Q))) (S P A B)))
H7 : not (eq (S B P Q) F0)
H5 : not (eq (S Q A P) F0)
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
congruence.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.
Geometry.
clear H4.
Geometry.
assert (P ** R / P ** Q = S B P R / S B P Q).
Geometry.
assert (- S B P R = S R P B).
Geometry.
rewrite <- H6 in H3.
Geometry.
RewriteVar (S B P R) H4.

*****
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S B P R) (S B P Q))
H6 : eq (Fopp (S B P R)) (S R P B)
H5 : not (eq (S Q A P) F0)
H3 : eq (S R A B)\n (Fplus\n (Fplus (Fmult (S Q A P) (Fdiv (S B P R) (S B P Q)))\n (Fopp (S B P R))) (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq (S B P Q) F0)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).
Geometry.
assert (P ** R / P ** Q = S R A P / S Q A P).
Geometry.
RewriteVar (S R A P) H4.

*****
H4 : eq (Fdiv (DSeg P R) (DSeg P Q)) (Fdiv (S R A P) (S Q A P))
H3 : eq (S R A B) (Fplus (Fplus (S R A P) (S R P B)) (S P A B))
H2 : Col R P Q
H1 : not (Col Q P B)
H0 : not (Col Q A P)
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq (S Q A P) F0)
+++++
Geometry.
-----
Theorem l2_9_weak : forall A B P Q R : Point, P <> Q -> ~ Col Q A P -> ~ Col Q P B -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
Geometry.
assert (S R A B = S R A P + S R P B + S P A B).

*****

*****

+++++
Qed.
-----
Theorem l2_9aux :\n forall A B P Q R : Point,\n P <> Q ->\n Col R P Q ->\n Col Q A P ->\n ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.

*****

*****
forall (A B P Q R : Point) (_ : not (eq P Q)) (_ : Col R P Q) (_ : Col Q A P) (_ : not (Col Q P B)), eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Proof.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.

*****

*****
forall (A B P Q R : Point) (_ : not (eq P Q)) (_ : Col R P Q) (_ : Col Q A P) (_ : not (Col Q P B)), eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
intros.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.

*****
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
cases_equality Q A.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.

*****
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (Col Q A B).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).

*****
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q A B
+++++
apply egalcol.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).
apply egalcol.

*****
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq Q A
+++++
auto.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).

*****
H4 : Col Q A B
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H4.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).
rewrite H4.

*****
H4 : Col Q A B
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) F0) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
ring_simplify.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).
rewrite H4.
ring_simplify.

*****
H4 : Col Q A B
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B))
+++++
rewrite <- H3.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).
rewrite H4.
ring_simplify.
rewrite <- H3.

*****
H4 : Col Q A B
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R Q B) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P Q B))
+++++
assert (R ** Q / P ** Q = S R Q B / S P Q B).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).
rewrite H4.
ring_simplify.
rewrite <- H3.
assert (R ** Q / P ** Q = S R Q B / S P Q B).

*****
H4 : Col Q A B
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (S R Q B) (S P Q B))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).
rewrite H4.
ring_simplify.
rewrite <- H3.
assert (R ** Q / P ** Q = S R Q B / S P Q B).

*****
H5 : eq (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (S R Q B) (S P Q B))
H4 : Col Q A B
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R Q B) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P Q B))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).
rewrite H4.
ring_simplify.
rewrite <- H3.
assert (R ** Q / P ** Q = S R Q B / S P Q B).
Geometry.

*****
H5 : eq (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (S R Q B) (S P Q B))
H4 : Col Q A B
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R Q B) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P Q B))
+++++
rewrite H5.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).
rewrite H4.
ring_simplify.
rewrite <- H3.
assert (R ** Q / P ** Q = S R Q B / S P Q B).
Geometry.
rewrite H5.

*****
H5 : eq (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (S R Q B) (S P Q B))
H4 : Col Q A B
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R Q B) (Fmult (Fdiv (S R Q B) (S P Q B)) (S P Q B))
+++++
field.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (Col Q A B).
rewrite H4.
ring_simplify.
rewrite <- H3.
assert (R ** Q / P ** Q = S R Q B / S P Q B).
Geometry.
rewrite H5.
field.

*****
H5 : eq (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (S R Q B) (S P Q B))
H4 : Col Q A B
H3 : eq Q A
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq (S P Q B) F0)
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.

*****
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (~ Col Q A B).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).

*****
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (Col Q A B)
+++++
unfold not in |- *.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
unfold not in |- *.

*****
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
forall _ : Col Q A B, False
+++++
intro.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
unfold not in |- *.
intro.

*****
H4 : Col Q A B
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
False
+++++
assert (Col Q P B).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
unfold not in |- *.
intro.
assert (Col Q P B).

*****
H4 : Col Q A B
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q P B
+++++
eauto with Geom.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
unfold not in |- *.
intro.
assert (Col Q P B).

*****
H5 : Col Q P B
H4 : Col Q A B
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
False
+++++
auto.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).

*****
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (Col Q R A).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).

*****
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q R A
+++++
assert (Col P Q R).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (Col P Q R).

*****
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col P Q R
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (Col P Q R).

*****
H5 : Col P Q R
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q R A
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (Col P Q R).
Geometry.

*****
H5 : Col P Q R
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q R A
+++++
assert (Col P Q A).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (Col P Q R).
Geometry.
assert (Col P Q A).

*****
H5 : Col P Q R
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col P Q A
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (Col P Q R).
Geometry.
assert (Col P Q A).

*****
H6 : Col P Q A
H5 : Col P Q R
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q R A
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (Col P Q R).
Geometry.
assert (Col P Q A).
Geometry.

*****
H6 : Col P Q A
H5 : Col P Q R
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q R A
+++++
eauto with Geom.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).

*****
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (A ** R / A ** Q = S R A B / S Q A B).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).

*****
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).

*****
H6 : eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.

*****
H6 : eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (A ** P / A ** Q = S P A B / S Q A B).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).

*****
H6 : eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A P) (DSeg A Q)) (Fdiv (S P A B) (S Q A B))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).

*****
H7 : eq (Fdiv (DSeg A P) (DSeg A Q)) (Fdiv (S P A B) (S Q A B))
H6 : eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.

*****
H7 : eq (Fdiv (DSeg A P) (DSeg A Q)) (Fdiv (S P A B) (S Q A B))
H6 : eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
RewriteVar (S R A B) H6.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.

*****
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H7 : eq (Fdiv (DSeg A P) (DSeg A Q)) (Fdiv (S P A B) (S Q A B))
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q))) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
RewriteVar (S P A B) H7.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.

*****
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q))) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))))
+++++
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).

*****
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
assert (A ** Q + Q ** R = A ** R).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).

*****
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
+++++
apply chasles.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
apply chasles.

*****
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col A Q R
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).

*****
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).

*****
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fmult (DSeg A R) (DSeg P Q)) (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))
+++++
rewrite <- H9.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
rewrite <- H9.

*****
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fmult (Fplus (DSeg A Q) (DSeg Q R)) (DSeg P Q)) (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))
+++++
ring.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).

*****
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
assert (P ** R + R ** Q = P ** Q).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).

*****
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
+++++
apply chasles.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
apply chasles.

*****
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col P R Q
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).

*****
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).

*****
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q))) (Fplus (Fmult (DSeg A Q) (Fplus (DSeg P R) (DSeg R Q))) (Fmult (DSeg Q R) (DSeg P Q)))
+++++
rewrite <- H11.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite <- H11.

*****
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (DSeg A Q) (Fplus (DSeg P R) (DSeg R Q))) (Fmult (DSeg Q R) (Fplus (DSeg P R) (DSeg R Q)))) (Fplus (Fmult (DSeg A Q) (Fplus (DSeg P R) (DSeg R Q))) (Fmult (DSeg Q R) (Fplus (DSeg P R) (DSeg R Q))))
+++++
ring.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).

*****
H12 : eq (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))\n (Fplus (Fmult (DSeg A Q) (Fplus (DSeg P R) (DSeg R Q)))\n (Fmult (DSeg Q R) (DSeg P Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
rewrite H12 in H10.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.

*****
H12 : eq (Fplus (Fmult (DSeg A Q) (DSeg P Q)) (Fmult (DSeg Q R) (DSeg P Q)))\n (Fplus (Fmult (DSeg A Q) (Fplus (DSeg P R) (DSeg R Q)))\n (Fmult (DSeg Q R) (DSeg P Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus (Fmult (DSeg A Q) (Fplus (DSeg P R) (DSeg R Q)))\n (Fmult (DSeg Q R) (DSeg P Q)))
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
clear H12.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.

*****
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus (Fmult (DSeg A Q) (Fplus (DSeg P R) (DSeg R Q)))\n (Fmult (DSeg Q R) (DSeg P Q)))
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
NormalizeRing H10.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.

*****
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).

*****
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q))) (Fmult (DSeg R Q) (DSeg A P))
+++++
assert (A ** Q + Q ** P = A ** P).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).

*****
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
+++++
apply chasles.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
apply chasles.

*****
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col A Q P
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).

*****
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q))) (Fmult (DSeg R Q) (DSeg A P))
+++++
rewrite <- H12.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
rewrite <- H12.

*****
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q))) (Fmult (DSeg R Q) (Fplus (DSeg A Q) (DSeg Q P)))
+++++
assert (P ** Q = - Q ** P).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
rewrite <- H12.
assert (P ** Q = - Q ** P).

*****
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (DSeg P Q) (Fopp (DSeg Q P))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
rewrite <- H12.
assert (P ** Q = - Q ** P).

*****
H13 : eq (DSeg P Q) (Fopp (DSeg Q P))
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q))) (Fmult (DSeg R Q) (Fplus (DSeg A Q) (DSeg Q P)))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
rewrite <- H12.
assert (P ** Q = - Q ** P).
Geometry.

*****
H13 : eq (DSeg P Q) (Fopp (DSeg Q P))
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q))) (Fmult (DSeg R Q) (Fplus (DSeg A Q) (DSeg Q P)))
+++++
rewrite H13.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
rewrite <- H12.
assert (P ** Q = - Q ** P).
Geometry.
rewrite H13.

*****
H13 : eq (DSeg P Q) (Fopp (DSeg Q P))
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (Fopp (DSeg Q P)) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q))) (Fmult (DSeg R Q) (Fplus (DSeg A Q) (DSeg Q P)))
+++++
assert (Q ** R = - R ** Q).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
rewrite <- H12.
assert (P ** Q = - Q ** P).
Geometry.
rewrite H13.
assert (Q ** R = - R ** Q).

*****
H13 : eq (DSeg P Q) (Fopp (DSeg Q P))
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (DSeg Q R) (Fopp (DSeg R Q))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
rewrite <- H12.
assert (P ** Q = - Q ** P).
Geometry.
rewrite H13.
assert (Q ** R = - R ** Q).

*****
H14 : eq (DSeg Q R) (Fopp (DSeg R Q))
H13 : eq (DSeg P Q) (Fopp (DSeg Q P))
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (Fopp (DSeg Q P)) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q))) (Fmult (DSeg R Q) (Fplus (DSeg A Q) (DSeg Q P)))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
rewrite <- H12.
assert (P ** Q = - Q ** P).
Geometry.
rewrite H13.
assert (Q ** R = - R ** Q).
Geometry.

*****
H14 : eq (DSeg Q R) (Fopp (DSeg R Q))
H13 : eq (DSeg P Q) (Fopp (DSeg Q P))
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (Fopp (DSeg Q P)) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q))) (Fmult (DSeg R Q) (Fplus (DSeg A Q) (DSeg Q P)))
+++++
rewrite H14.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (A ** Q + Q ** P = A ** P).
rewrite <- H12.
assert (P ** Q = - Q ** P).
Geometry.
rewrite H13.
assert (Q ** R = - R ** Q).
Geometry.
rewrite H14.

*****
H14 : eq (DSeg Q R) (Fopp (DSeg R Q))
H13 : eq (DSeg P Q) (Fopp (DSeg Q P))
H12 : eq (Fplus (DSeg A Q) (DSeg Q P)) (DSeg A P)
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fmult (Fopp (DSeg Q P)) (Fopp (DSeg R Q))) (Fmult (DSeg A Q) (DSeg R Q))) (Fmult (DSeg R Q) (Fplus (DSeg A Q) (DSeg Q P)))
+++++
ring.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).

*****
H12 : eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q)))\n (Fmult (DSeg R Q) (DSeg A P))
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).

*****
H12 : eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q)))\n (Fmult (DSeg R Q) (DSeg A P))
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fmult (DSeg P Q) (DSeg A R)) (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P)))
+++++
replace (P ** Q * A ** R) with (A ** R * P ** Q) by ring.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).
replace (P ** Q * A ** R) with (A ** R * P ** Q) by ring.

*****
H12 : eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q)))\n (Fmult (DSeg R Q) (DSeg A P))
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fmult (DSeg A R) (DSeg P Q)) (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P)))
+++++
rewrite H10.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).
replace (P ** Q * A ** R) with (A ** R * P ** Q) by ring.
rewrite H10.

*****
H12 : eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q)))\n (Fmult (DSeg R Q) (DSeg A P))
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R))) (Fmult (DSeg A Q) (DSeg R Q))) (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P)))
+++++
rewrite <- H12.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).
replace (P ** Q * A ** R) with (A ** R * P ** Q) by ring.
rewrite H10.
rewrite <- H12.

*****
H12 : eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q)))\n (Fmult (DSeg R Q) (DSeg A P))
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fplus (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R))) (Fmult (DSeg A Q) (DSeg R Q))) (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q))))
+++++
ring.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).

*****
H13 : eq (Fmult (DSeg P Q) (DSeg A R))\n (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P)))
H12 : eq (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg R Q)))\n (Fmult (DSeg R Q) (DSeg A P))
H10 : eq (Fmult (DSeg A R) (DSeg P Q))\n (Fplus\n (Fplus (Fmult (DSeg P Q) (DSeg Q R)) (Fmult (DSeg A Q) (DSeg P R)))\n (Fmult (DSeg A Q) (DSeg R Q)))
H11 : eq (Fplus (DSeg P R) (DSeg R Q)) (DSeg P Q)
H9 : eq (Fplus (DSeg A Q) (DSeg Q R)) (DSeg A R)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
clear H9 H10 H11 H12.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).
clear H9 H10 H11 H12.

*****
H13 : eq (Fmult (DSeg P Q) (DSeg A R))\n (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P)))
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
IsoleVar (A ** R) H13.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).
clear H9 H10 H11 H12.
IsoleVar (A ** R) H13.

*****
H13 : eq (DSeg A R)\n (Fdiv\n (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P)))\n (DSeg P Q))
H9 : not (eq (DSeg P Q) F0)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (DSeg A R) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
rewrite H13.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).
clear H9 H10 H11 H12.
IsoleVar (A ** R) H13.
rewrite H13.

*****
H13 : eq (DSeg A R)\n (Fdiv\n (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P)))\n (DSeg P Q))
H9 : not (eq (DSeg P Q) F0)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fdiv (Fdiv (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P))) (DSeg P Q)) (DSeg A Q)) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
+++++
field.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).
clear H9 H10 H11 H12.
IsoleVar (A ** R) H13.
rewrite H13.
field.

*****
H13 : eq (DSeg A R)\n (Fdiv\n (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P)))\n (DSeg P Q))
H9 : not (eq (DSeg P Q) F0)
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
and (not (eq (DSeg A Q) F0)) (not (eq (DSeg P Q) F0))
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
assert (A ** Q + Q ** R = A ** R).
assert (A ** R * P ** Q = A ** Q * P ** Q + Q ** R * P ** Q).
assert (P ** R + R ** Q = P ** Q).
assert (A ** Q * P ** Q + Q ** R * P ** Q = A ** Q * (P ** R + R ** Q) + Q ** R * P ** Q).
rewrite H12 in H10.
clear H12.
NormalizeRing H10.
assert (P ** Q * Q ** R + A ** Q * R ** Q = R ** Q * A ** P).
assert (P ** Q * A ** R = A ** Q * P ** R + R ** Q * A ** P).
clear H9 H10 H11 H12.
IsoleVar (A ** R) H13.

*****
H13 : eq (Fmult (DSeg P Q) (DSeg A R))\n (Fplus (Fmult (DSeg A Q) (DSeg P R)) (Fmult (DSeg R Q) (DSeg A P)))
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq (DSeg P Q) F0)
+++++
Geometry.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).

*****
H9 : eq (Fdiv (DSeg A R) (DSeg A Q))\n (Fplus (Fdiv (DSeg P R) (DSeg P Q))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q))) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))))
+++++
rewrite H9.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.
RewriteVar (S P A B) H7.
assert (A ** R / A ** Q = P ** R / P ** Q + R ** Q / P ** Q * (A ** P / A ** Q)).
rewrite H9.

*****
H9 : eq (Fdiv (DSeg A R) (DSeg A Q))\n (Fplus (Fdiv (DSeg P R) (DSeg P Q))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))
H7 : eq (S P A B) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))
H6 : eq (S R A B) (Fmult (S Q A B) (Fdiv (DSeg A R) (DSeg A Q)))
H8 : not (eq (S Q A B) F0)
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fmult (S Q A B) (Fplus (Fdiv (DSeg P R) (DSeg P Q)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fdiv (DSeg A P) (DSeg A Q))))) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fmult (S Q A B) (Fdiv (DSeg A P) (DSeg A Q)))))
+++++
ring.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.
assert (~ Col Q A B).
assert (Col Q R A).
assert (A ** R / A ** Q = S R A B / S Q A B).
Geometry.
assert (A ** P / A ** Q = S P A B / S Q A B).
Geometry.
RewriteVar (S R A B) H6.

*****
H6 : eq (Fdiv (DSeg A R) (DSeg A Q)) (Fdiv (S R A B) (S Q A B))
H7 : eq (Fdiv (DSeg A P) (DSeg A Q)) (Fdiv (S P A B) (S Q A B))
H5 : Col Q R A
H4 : not (Col Q A B)
H3 : not (eq Q A)
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq (S Q A B) F0)
+++++
trivial.
-----
Theorem l2_9aux : forall A B P Q R : Point, P <> Q -> Col R P Q -> Col Q A P -> ~ Col Q P B -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_equality Q A.

*****

*****

+++++
Qed.
-----
Theorem l2_9 :\n forall A B P Q R : Point,\n P <> Q ->\n Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.

*****

*****
forall (A B P Q R : Point) (_ : not (eq P Q)) (_ : Col R P Q), eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Proof.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.

*****

*****
forall (A B P Q R : Point) (_ : not (eq P Q)) (_ : Col R P Q), eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
intros.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.

*****
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
cases_col Q A P.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.

*****
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
cases_col Q P B.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.

*****
H2 : Col Q P B
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (Col Q P A).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).

*****
H2 : Col Q P B
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q P A
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).

*****
H3 : Col Q P A
H2 : Col Q P B
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.

*****
H3 : Col Q P A
H2 : Col Q P B
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
clear H1.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.

*****
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (Col Q A B).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).

*****
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q A B
+++++
eauto with Geom.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).

*****
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (Col P A B).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).

*****
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col P A B
+++++
eauto with Geom.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).

*****
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H1.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.

*****
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) F0) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H4.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.

*****
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) F0) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) F0))
+++++
ring_simplify.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.

*****
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) F0
+++++
change (Col R A B) in |- *.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.

*****
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R A B
+++++
assert (Col Q R B).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).

*****
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q R B
+++++
eauto with Geom.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).

*****
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R A B
+++++
assert (Col Q R A).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).

*****
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q R A
+++++
eauto with Geom.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).

*****
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R A B
+++++
assert (Col R Q B).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).
assert (Col R Q B).

*****
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R Q B
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).
assert (Col R Q B).

*****
H7 : Col R Q B
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R A B
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).
assert (Col R Q B).
Geometry.

*****
H7 : Col R Q B
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R A B
+++++
assert (Col R Q A).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).
assert (Col R Q B).
Geometry.
assert (Col R Q A).

*****
H7 : Col R Q B
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R Q A
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).
assert (Col R Q B).
Geometry.
assert (Col R Q A).

*****
H8 : Col R Q A
H7 : Col R Q B
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R A B
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).
assert (Col R Q B).
Geometry.
assert (Col R Q A).
Geometry.

*****
H8 : Col R Q A
H7 : Col R Q B
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R A B
+++++
cases_equality R Q.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).
assert (Col R Q B).
Geometry.
assert (Col R Q A).
Geometry.
cases_equality R Q.

*****
H9 : eq R Q
H8 : Col R Q A
H7 : Col R Q B
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R A B
+++++
rewrite H9.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).
assert (Col R Q B).
Geometry.
assert (Col R Q A).
Geometry.
cases_equality R Q.
rewrite H9.

*****
H9 : eq R Q
H8 : Col R Q A
H7 : Col R Q B
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q A B
+++++
trivial.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (Col Q P A).
Geometry.
clear H1.
assert (Col Q A B).
assert (Col P A B).
rewrite H1.
rewrite H4.
ring_simplify.
change (Col R A B) in |- *.
assert (Col Q R B).
assert (Col Q R A).
assert (Col R Q B).
Geometry.
assert (Col R Q A).
Geometry.
cases_equality R Q.

*****
H9 : not (eq R Q)
H8 : Col R Q A
H7 : Col R Q B
H6 : Col Q R A
H5 : Col Q R B
H4 : Col P A B
H1 : Col Q A B
H3 : Col Q P A
H2 : Col Q P B
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R A B
+++++
eauto with Geom.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.

*****
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
apply l2_9aux.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
apply l2_9aux.

*****
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq P Q)
+++++
auto.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
apply l2_9aux.

*****
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R P Q
+++++
auto.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
apply l2_9aux.

*****
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q A P
+++++
auto.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
apply l2_9aux.

*****
H2 : not (Col Q P B)
H1 : Col Q A P
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (Col Q P B)
+++++
auto.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.

*****
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
cases_col Q P B.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.

*****
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).

*****
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R B A) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
+++++
apply l2_9aux.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
apply l2_9aux.

*****
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq P Q)
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
apply l2_9aux.

*****
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R P Q
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
apply l2_9aux.

*****
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col Q B P
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
apply l2_9aux.

*****
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (Col Q P A)
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).

*****
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S R A B = - S R B A).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).

*****
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fopp (S R B A))
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).

*****
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.

*****
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S Q A B = - S Q B A).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).

*****
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S Q A B) (Fopp (S Q B A))
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).

*****
H5 : eq (S Q A B) (Fopp (S Q B A))
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).
Geometry.

*****
H5 : eq (S Q A B) (Fopp (S Q B A))
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
assert (S P A B = - S P B A).
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).
Geometry.
assert (S P A B = - S P B A).

*****
H5 : eq (S Q A B) (Fopp (S Q B A))
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S P A B) (Fopp (S P B A))
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).
Geometry.
assert (S P A B = - S P B A).

*****
H6 : eq (S P A B) (Fopp (S P B A))
H5 : eq (S Q A B) (Fopp (S Q B A))
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
Geometry.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.

*****
H6 : eq (S P A B) (Fopp (S P B A))
H5 : eq (S Q A B) (Fopp (S Q B A))
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H4.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
rewrite H4.

*****
H6 : eq (S P A B) (Fopp (S P B A))
H5 : eq (S Q A B) (Fopp (S Q B A))
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fopp (S R B A)) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H5.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
rewrite H4.
rewrite H5.

*****
H6 : eq (S P A B) (Fopp (S P B A))
H5 : eq (S Q A B) (Fopp (S Q B A))
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fopp (S R B A)) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fopp (S Q B A))) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
rewrite H6.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
rewrite H4.
rewrite H5.
rewrite H6.

*****
H6 : eq (S P A B) (Fopp (S P B A))
H5 : eq (S Q A B) (Fopp (S Q B A))
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fopp (S R B A)) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fopp (S Q B A))) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fopp (S P B A))))
+++++
rewrite H3.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
assert (S R B A = P ** R / P ** Q * S Q B A + R ** Q / P ** Q * S P B A).
assert (S R A B = - S R B A).
Geometry.
assert (S Q A B = - S Q B A).
Geometry.
assert (S P A B = - S P B A).
Geometry.
rewrite H4.
rewrite H5.
rewrite H6.
rewrite H3.

*****
H6 : eq (S P A B) (Fopp (S P B A))
H5 : eq (S Q A B) (Fopp (S Q B A))
H4 : eq (S R A B) (Fopp (S R B A))
H3 : eq (S R B A)\n (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A))\n (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))
H2 : Col Q P B
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (Fopp (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q B A)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P B A)))) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (Fopp (S Q B A))) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (Fopp (S P B A))))
+++++
ring.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.

*****
H2 : not (Col Q P B)
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
eq (S R A B) (Fplus (Fmult (Fdiv (DSeg P R) (DSeg P Q)) (S Q A B)) (Fmult (Fdiv (DSeg R Q) (DSeg P Q)) (S P A B)))
+++++
apply l2_9_weak.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
apply l2_9_weak.

*****
H2 : not (Col Q P B)
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (eq P Q)
+++++
auto.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
apply l2_9_weak.

*****
H2 : not (Col Q P B)
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (Col Q A P)
+++++
auto.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
apply l2_9_weak.

*****
H2 : not (Col Q P B)
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
not (Col Q P B)
+++++
auto.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.
cases_col Q P B.
apply l2_9_weak.

*****
H2 : not (Col Q P B)
H1 : not (Col Q A P)
H0 : Col R P Q
H : not (eq P Q)
A,B,P,Q,R : Point
*****
Col R P Q
+++++
auto.
-----
Theorem l2_9 : forall A B P Q R : Point, P <> Q -> Col R P Q -> S R A B = P ** R / P ** Q * S Q A B + R ** Q / P ** Q * S P A B.
Proof.
intros.
cases_col Q A P.

*****

*****

+++++
Qed.
-----
Theorem A2bgen :\n forall (A B P P' : Point) (r : F),\n Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.

*****

*****
forall (A B P P' : Point) (r : F) (_ : Col A B P) (_ : eq (DSeg A P) (Fmult r (DSeg A B))) (_ : Col A B P') (_ : eq (DSeg A P') (Fmult r (DSeg A B))), eq P P'
+++++
Proof.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.

*****

*****
forall (A B P P' : Point) (r : F) (_ : Col A B P) (_ : eq (DSeg A P) (Fmult r (DSeg A B))) (_ : Col A B P') (_ : eq (DSeg A P') (Fmult r (DSeg A B))), eq P P'
+++++
intros.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.

*****
H2 : eq (DSeg A P') (Fmult r (DSeg A B))
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.

*****
H2 : eq (DSeg A P') (Fmult r (DSeg A B))
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
cases_equality A B.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.

*****
H3 : eq A B
H2 : eq (DSeg A P') (Fmult r (DSeg A B))
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.

*****
H3 : eq A B
H2 : eq (DSeg A P') (Fmult r (DSeg A B))
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
assert (A ** B = 0).
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).

*****
H3 : eq A B
H2 : eq (DSeg A P') (Fmult r (DSeg A B))
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq (DSeg A B) F0
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).

*****
H4 : eq (DSeg A B) F0
H3 : eq A B
H2 : eq (DSeg A P') (Fmult r (DSeg A B))
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.

*****
H4 : eq (DSeg A B) F0
H3 : eq A B
H2 : eq (DSeg A P') (Fmult r (DSeg A B))
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
rewrite H4 in H2.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.

*****
H4 : eq (DSeg A B) F0
H3 : eq A B
H2 : eq (DSeg A P') (Fmult r F0)
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.

*****
H4 : eq (DSeg A B) F0
H3 : eq A B
H2 : eq (DSeg A P') (Fmult r F0)
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
rewrite H4 in H0.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.

*****
H4 : eq (DSeg A B) F0
H3 : eq A B
H2 : eq (DSeg A P') (Fmult r F0)
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r F0)
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.

*****
H4 : eq (DSeg A B) F0
H3 : eq A B
H2 : eq (DSeg A P') (Fmult r F0)
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r F0)
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
NormalizeRing H2.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.

*****
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r F0)
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.
Geometry.

*****
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r F0)
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
NormalizeRing H0.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.
Geometry.
NormalizeRing H0.

*****
H0 : eq (DSeg A P) F0
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.
Geometry.
NormalizeRing H0.
Geometry.

*****
H0 : eq (DSeg A P) F0
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
assert (A = P').
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.
Geometry.
NormalizeRing H0.
Geometry.
assert (A = P').

*****
H0 : eq (DSeg A P) F0
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq A P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.
Geometry.
NormalizeRing H0.
Geometry.
assert (A = P').

*****
H5 : eq A P'
H0 : eq (DSeg A P) F0
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.
Geometry.
NormalizeRing H0.
Geometry.
assert (A = P').
Geometry.

*****
H5 : eq A P'
H0 : eq (DSeg A P) F0
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
assert (A = P).
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.
Geometry.
NormalizeRing H0.
Geometry.
assert (A = P').
Geometry.
assert (A = P).

*****
H5 : eq A P'
H0 : eq (DSeg A P) F0
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq A P
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.
Geometry.
NormalizeRing H0.
Geometry.
assert (A = P').
Geometry.
assert (A = P).

*****
H6 : eq A P
H5 : eq A P'
H0 : eq (DSeg A P) F0
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.
assert (A ** B = 0).
Geometry.
rewrite H4 in H2.
Geometry.
rewrite H4 in H0.
Geometry.
NormalizeRing H2.
Geometry.
NormalizeRing H0.
Geometry.
assert (A = P').
Geometry.
assert (A = P).
Geometry.

*****
H6 : eq A P
H5 : eq A P'
H0 : eq (DSeg A P) F0
H2 : eq (DSeg A P') F0
H4 : eq (DSeg A B) F0
H3 : eq A B
H1 : Col A B P'
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
congruence.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.

*****
H3 : not (eq A B)
H2 : eq (DSeg A P') (Fmult r (DSeg A B))
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
Geometry.
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.
Geometry.

*****
H3 : not (eq A B)
H2 : eq (DSeg A P') (Fmult r (DSeg A B))
H1 : Col A B P'
H0 : eq (DSeg A P) (Fmult r (DSeg A B))
H : Col A B P
r : F
A,B,P,P' : Point
*****
eq P P'
+++++
apply (A2b A B P P' r H3 H H0 H1 H2).
-----
Theorem A2bgen : forall (A B P P' : Point) (r : F), Col A B P -> A ** P = r * A ** B -> Col A B P' -> A ** P' = r * A ** B -> P = P'.
Proof.
intros.
Geometry.
cases_equality A B.

*****

*****

+++++
Qed.
-----
Definition mid_point (I A B : Point) : Prop := \n  Col A B I /\ A ** I = I ** B.
-----
Definition symmetric_point (I A B : Point) : Prop :=\n  Col A B I /\ A ** B = B ** I.
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.

*****

*****
forall A B : Point, sig (fun O : Point => mid_point O A B)
+++++
Proof with try solve [ Geometry | field; Geometry | congruence ].
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].

*****

*****
forall A B : Point, sig (fun O : Point => mid_point O A B)
+++++
intros...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...

*****
A,B : Point
*****
sig (fun O : Point => mid_point O A B)
+++++
assert (T := A2a A B (1 / 2))...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...
assert (T := A2a A B (1 / 2))...

*****
T : sig\n (fun P : Point =>\n and (Col A B P)\n (eq (DSeg A P) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))))
A,B : Point
*****
sig (fun O : Point => mid_point O A B)
+++++
elim T; intros; clear T...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...
assert (T := A2a A B (1 / 2))...
elim T; intros; clear T...

*****
p : and (Col A B x)\n (eq (DSeg A x) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B)))
A,B,x : Point
*****
sig (fun O : Point => mid_point O A B)
+++++
exists x...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...
assert (T := A2a A B (1 / 2))...
elim T; intros; clear T...
exists x...

*****
p : and (Col A B x)\n (eq (DSeg A x) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B)))
A,B,x : Point
*****
mid_point x A B
+++++
intuition...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...
assert (T := A2a A B (1 / 2))...
elim T; intros; clear T...
exists x...
intuition...

*****
H0 : eq (DSeg A x) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))
H : Col A B x
A,B,x : Point
*****
mid_point x A B
+++++
assert (A ** x + x ** B = A ** B)...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...
assert (T := A2a A B (1 / 2))...
elim T; intros; clear T...
exists x...
intuition...
assert (A ** x + x ** B = A ** B)...

*****
H1 : eq (Fplus (DSeg A x) (DSeg x B)) (DSeg A B)
H0 : eq (DSeg A x) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))
H : Col A B x
A,B,x : Point
*****
mid_point x A B
+++++
unfold mid_point in |- *...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...
assert (T := A2a A B (1 / 2))...
elim T; intros; clear T...
exists x...
intuition...
assert (A ** x + x ** B = A ** B)...
unfold mid_point in |- *...

*****
H1 : eq (Fplus (DSeg A x) (DSeg x B)) (DSeg A B)
H0 : eq (DSeg A x) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))
H : Col A B x
A,B,x : Point
*****
and (Col A B x) (eq (DSeg A x) (DSeg x B))
+++++
intuition...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...
assert (T := A2a A B (1 / 2))...
elim T; intros; clear T...
exists x...
intuition...
assert (A ** x + x ** B = A ** B)...
unfold mid_point in |- *...
intuition...

*****
H1 : eq (Fplus (DSeg A x) (DSeg x B)) (DSeg A B)
H0 : eq (DSeg A x) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))
H : Col A B x
A,B,x : Point
*****
eq (DSeg A x) (DSeg x B)
+++++
RewriteVar (A ** x) H0...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...
assert (T := A2a A B (1 / 2))...
elim T; intros; clear T...
exists x...
intuition...
assert (A ** x + x ** B = A ** B)...
unfold mid_point in |- *...
intuition...
RewriteVar (A ** x) H0...

*****
H0 : eq (DSeg A x) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))
H1 : eq (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B)) (DSeg x B))\n (DSeg A B)
H : Col A B x
A,B,x : Point
*****
eq (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B)) (DSeg x B)
+++++
RewriteVar (x ** B) H1...
-----
Theorem mid_point_ex : forall A B : Point, {O : Point | mid_point O A B}.
Proof with try solve [ Geometry | field; Geometry | congruence ].
intros...
assert (T := A2a A B (1 / 2))...
elim T; intros; clear T...
exists x...
intuition...
assert (A ** x + x ** B = A ** B)...
unfold mid_point in |- *...
intuition...
RewriteVar (A ** x) H0...
RewriteVar (x ** B) H1...

*****

*****

+++++
Qed.
-----
Theorem symmetric_point_ex :\n forall A O : Point, {A' : Point | Col A O A' /\ A ** O = O ** A'}.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.

*****

*****
forall A O : Point, sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
Proof.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.

*****

*****
forall A O : Point, sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
intros.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.

*****
A,O : Point
*****
sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].

*****
A,O : Point
*****
sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
assert (T := A2a A O 2).
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).

*****
T : sig\n (fun P : Point =>\n and (Col A O P) (eq (DSeg A P) (Fmult (Fplus F1 F1) (DSeg A O))))
A,O : Point
*****
sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].

*****
T : sig\n (fun P : Point =>\n and (Col A O P) (eq (DSeg A P) (Fmult (Fplus F1 F1) (DSeg A O))))
A,O : Point
*****
sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
elim T.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.

*****
T : sig\n (fun P : Point =>\n and (Col A O P) (eq (DSeg A P) (Fmult (Fplus F1 F1) (DSeg A O))))
A,O : Point
*****
forall (x : Point) (_ : and (Col A O x) (eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O)))), sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
intros.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.

*****
p : and (Col A O x) (eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O)))
x : Point
T : sig\n (fun P : Point =>\n and (Col A O P) (eq (DSeg A P) (Fmult (Fplus F1 F1) (DSeg A O))))
A,O : Point
*****
sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
clear T.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.

*****
p : and (Col A O x) (eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O)))
A,O,x : Point
*****
sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].

*****
p : and (Col A O x) (eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O)))
A,O,x : Point
*****
sig (fun A' : Point => and (Col A O A') (eq (DSeg A O) (DSeg O A')))
+++++
exists x.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.

*****
p : and (Col A O x) (eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O)))
A,O,x : Point
*****
and (Col A O x) (eq (DSeg A O) (DSeg O x))
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].

*****
p : and (Col A O x) (eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O)))
A,O,x : Point
*****
and (Col A O x) (eq (DSeg A O) (DSeg O x))
+++++
unfold symmetric_point in |- *.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.

*****
p : and (Col A O x) (eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O)))
A,O,x : Point
*****
and (Col A O x) (eq (DSeg A O) (DSeg O x))
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].

*****
p : and (Col A O x) (eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O)))
A,O,x : Point
*****
and (Col A O x) (eq (DSeg A O) (DSeg O x))
+++++
intuition.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.

*****
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (DSeg O x)
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].

*****
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (DSeg O x)
+++++
assert (O ** x = - x ** O).
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).

*****
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg O x) (Fopp (DSeg x O))
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).

*****
H1 : eq (DSeg O x) (Fopp (DSeg x O))
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (DSeg O x)
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].

*****
H1 : eq (DSeg O x) (Fopp (DSeg x O))
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (DSeg O x)
+++++
assert (A ** x + x ** O = A ** O).
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].
assert (A ** x + x ** O = A ** O).

*****
H1 : eq (DSeg O x) (Fopp (DSeg x O))
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (Fplus (DSeg A x) (DSeg x O)) (DSeg A O)
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].
assert (A ** x + x ** O = A ** O).

*****
H2 : eq (Fplus (DSeg A x) (DSeg x O)) (DSeg A O)
H1 : eq (DSeg O x) (Fopp (DSeg x O))
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (DSeg O x)
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].
assert (A ** x + x ** O = A ** O).
try solve [ Geometry | ring | congruence ].

*****
H2 : eq (Fplus (DSeg A x) (DSeg x O)) (DSeg A O)
H1 : eq (DSeg O x) (Fopp (DSeg x O))
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (DSeg O x)
+++++
rewrite H1.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].
assert (A ** x + x ** O = A ** O).
try solve [ Geometry | ring | congruence ].
rewrite H1.

*****
H2 : eq (Fplus (DSeg A x) (DSeg x O)) (DSeg A O)
H1 : eq (DSeg O x) (Fopp (DSeg x O))
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (Fopp (DSeg x O))
+++++
clear H1.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].
assert (A ** x + x ** O = A ** O).
try solve [ Geometry | ring | congruence ].
rewrite H1.
clear H1.

*****
H2 : eq (Fplus (DSeg A x) (DSeg x O)) (DSeg A O)
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (Fopp (DSeg x O))
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].
assert (A ** x + x ** O = A ** O).
try solve [ Geometry | ring | congruence ].
rewrite H1.
clear H1.
try solve [ Geometry | ring | congruence ].

*****
H2 : eq (Fplus (DSeg A x) (DSeg x O)) (DSeg A O)
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (Fopp (DSeg x O))
+++++
RewriteVar (A ** x) H0.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].
assert (A ** x + x ** O = A ** O).
try solve [ Geometry | ring | congruence ].
rewrite H1.
clear H1.
try solve [ Geometry | ring | congruence ].
RewriteVar (A ** x) H0.

*****
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H2 : eq (Fplus (Fmult (Fplus F1 F1) (DSeg A O)) (DSeg x O)) (DSeg A O)
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (Fopp (DSeg x O))
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].
assert (A ** x + x ** O = A ** O).
try solve [ Geometry | ring | congruence ].
rewrite H1.
clear H1.
try solve [ Geometry | ring | congruence ].
RewriteVar (A ** x) H0.
try solve [ Geometry | ring | congruence ].

*****
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H2 : eq (Fplus (Fmult (Fplus F1 F1) (DSeg A O)) (DSeg x O)) (DSeg A O)
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (Fopp (DSeg x O))
+++++
RewriteVar (x ** O) H2.
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).
try solve [ Geometry | ring | congruence ].
assert (A ** x + x ** O = A ** O).
try solve [ Geometry | ring | congruence ].
rewrite H1.
clear H1.
try solve [ Geometry | ring | congruence ].
RewriteVar (A ** x) H0.
try solve [ Geometry | ring | congruence ].
RewriteVar (x ** O) H2.

*****
H2 : eq (DSeg x O) (Fopp (DSeg A O))
H0 : eq (DSeg A x) (Fmult (Fplus F1 F1) (DSeg A O))
H : Col A O x
A,O,x : Point
*****
eq (DSeg A O) (Fopp (Fopp (DSeg A O)))
+++++
try solve [ Geometry | ring | congruence ].
-----
Theorem symmetric_point_ex : forall A O : Point, {A' : Point | Col A O A' /\\ A ** O = O ** A'}.
Proof.
intros.
try solve [ Geometry | ring | congruence ].
assert (T := A2a A O 2).
try solve [ Geometry | ring | congruence ].
elim T.
intros.
clear T.
try solve [ Geometry | ring | congruence ].
exists x.
try solve [ Geometry | ring | congruence ].
unfold symmetric_point in |- *.
try solve [ Geometry | ring | congruence ].
intuition.
try solve [ Geometry | ring | congruence ].
assert (O ** x = - x ** O).

*****

*****

+++++
Qed.
-----
Lemma mid_point_comm :\n  forall A B C,\n  mid_point A B C -> mid_point A C B.
-----
Lemma mid_point_comm : forall A B C, mid_point A B C -> mid_point A C B.

*****

*****
forall (A B C : Point) (_ : mid_point A B C), mid_point A C B
+++++
Proof.
-----
Lemma mid_point_comm : forall A B C, mid_point A B C -> mid_point A C B.
Proof.

*****

*****
forall (A B C : Point) (_ : mid_point A B C), mid_point A C B
+++++
unfold mid_point.
-----
Lemma mid_point_comm : forall A B C, mid_point A B C -> mid_point A C B.
Proof.
unfold mid_point.

*****

*****
forall (A B C : Point) (_ : and (Col B C A) (eq (DSeg B A) (DSeg A C))), and (Col C B A) (eq (DSeg C A) (DSeg A B))
+++++
intuition.
-----
Lemma mid_point_comm : forall A B C, mid_point A B C -> mid_point A C B.
Proof.
unfold mid_point.
intuition.

*****

*****

+++++
Qed.
-----
Hint Immediate mid_point_comm : Geom.
-----
Theorem diag_mid_point_parallel : forall O A P B Q,\nmid_point O A P -> mid_point O B Q -> parallel A B P Q.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.

*****

*****
forall (O A P B Q : Point) (_ : mid_point O A P) (_ : mid_point O B Q), parallel A B P Q
+++++
Proof.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.

*****

*****
forall (O A P B Q : Point) (_ : mid_point O A P) (_ : mid_point O B Q), parallel A B P Q
+++++
intros.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.

*****
H0 : mid_point O B Q
H : mid_point O A P
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
unfold mid_point in *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.

*****
H0 : and (Col B Q O) (eq (DSeg B O) (DSeg O Q))
H : and (Col A P O) (eq (DSeg A O) (DSeg O P))
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
DecompAndAll.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.

*****
H3 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B Q O
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
rename H0 into H.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.

*****
H3 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B Q O
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (Col B O Q).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).

*****
H3 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B Q O
O,A,P,B,Q : Point
*****
Col B O Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).

*****
H0 : Col B O Q
H3 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B Q O
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.

*****
H0 : Col B O Q
H3 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B Q O
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
clear H1.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.

*****
H0 : Col B O Q
H3 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
rename H0 into H1.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.

*****
H1 : Col B O Q
H3 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
rename H3 into H0.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.

*****
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
cases_equality A P.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.

*****
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.

*****
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (A = O).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).

*****
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.

*****
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
assert (A ** O + O ** P = A ** P).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).

*****
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).

*****
H4 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.

*****
H4 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
assert (A ** P = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).

*****
H4 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg A P) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).

*****
H5 : eq (DSeg A P) F0
H4 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.

*****
H5 : eq (DSeg A P) F0
H4 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
rewrite H5 in H4.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.

*****
H5 : eq (DSeg A P) F0
H4 : eq (Fplus (DSeg A O) (DSeg O P)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
clear H5.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.

*****
H4 : eq (Fplus (DSeg A O) (DSeg O P)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.

*****
H4 : eq (Fplus (DSeg A O) (DSeg O P)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
rewrite <- H0 in H4.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.

*****
H4 : eq (Fplus (DSeg A O) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.

*****
H4 : eq (Fplus (DSeg A O) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
assert (A ** O + A ** O = 2 * A ** O).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).

*****
H4 : eq (Fplus (DSeg A O) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (DSeg A O) (DSeg A O)) (Fmult (Fplus F1 F1) (DSeg A O))
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.

*****
H4 : eq (Fplus (DSeg A O) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (DSeg A O) (DSeg A O)) (Fmult (Fplus F1 F1) (DSeg A O))
+++++
ring.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).

*****
H5 : eq (Fplus (DSeg A O) (DSeg A O)) (Fmult (Fplus F1 F1) (DSeg A O))
H4 : eq (Fplus (DSeg A O) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.

*****
H5 : eq (Fplus (DSeg A O) (DSeg A O)) (Fmult (Fplus F1 F1) (DSeg A O))
H4 : eq (Fplus (DSeg A O) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
rewrite H5 in H4.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.

*****
H5 : eq (Fplus (DSeg A O) (DSeg A O)) (Fmult (Fplus F1 F1) (DSeg A O))
H4 : eq (Fmult (Fplus F1 F1) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
clear H5.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.

*****
H4 : eq (Fmult (Fplus F1 F1) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.

*****
H4 : eq (Fmult (Fplus F1 F1) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
IsoleVar (A ** O) H4.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
IsoleVar (A ** O) H4.

*****
H4 : eq (DSeg A O) (Fdiv F0 (Fplus F1 F1))
H5 : not (eq (Fplus F1 F1) F0)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
IsoleVar (A ** O) H4.
Geometry.

*****
H4 : eq (DSeg A O) (Fdiv F0 (Fplus F1 F1))
H5 : not (eq (Fplus F1 F1) F0)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
assert (0 / 2 = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
IsoleVar (A ** O) H4.
Geometry.
assert (0 / 2 = 0).

*****
H4 : eq (DSeg A O) (Fdiv F0 (Fplus F1 F1))
H5 : not (eq (Fplus F1 F1) F0)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv F0 (Fplus F1 F1)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
IsoleVar (A ** O) H4.
Geometry.
assert (0 / 2 = 0).
Geometry.

*****
H4 : eq (DSeg A O) (Fdiv F0 (Fplus F1 F1))
H5 : not (eq (Fplus F1 F1) F0)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv F0 (Fplus F1 F1)) F0
+++++
field.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
IsoleVar (A ** O) H4.
Geometry.
assert (0 / 2 = 0).
Geometry.
field.

*****
H4 : eq (DSeg A O) (Fdiv F0 (Fplus F1 F1))
H5 : not (eq (Fplus F1 F1) F0)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
IsoleVar (A ** O) H4.
Geometry.
assert (0 / 2 = 0).

*****
H6 : eq (Fdiv F0 (Fplus F1 F1)) F0
H4 : eq (DSeg A O) (Fdiv F0 (Fplus F1 F1))
H5 : not (eq (Fplus F1 F1) F0)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
IsoleVar (A ** O) H4.
Geometry.
assert (0 / 2 = 0).
Geometry.

*****
H6 : eq (Fdiv F0 (Fplus F1 F1)) F0
H4 : eq (DSeg A O) (Fdiv F0 (Fplus F1 F1))
H5 : not (eq (Fplus F1 F1) F0)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
rewrite H6 in H4.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
IsoleVar (A ** O) H4.
Geometry.
assert (0 / 2 = 0).
Geometry.
rewrite H6 in H4.

*****
H6 : eq (Fdiv F0 (Fplus F1 F1)) F0
H4 : eq (DSeg A O) F0
H5 : not (eq (Fplus F1 F1) F0)
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A O
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
assert (A ** P = 0).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
rewrite <- H0 in H4.
Geometry.
assert (A ** O + A ** O = 2 * A ** O).
Geometry.
rewrite H5 in H4.
clear H5.
Geometry.
IsoleVar (A ** O) H4.

*****
H4 : eq (Fmult (Fplus F1 F1) (DSeg A O)) F0
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).

*****
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.

*****
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
unfold parallel in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.

*****
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.

*****
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
unfold S4 in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.

*****
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.

*****
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
rewrite H3.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.

*****
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S P P B) (S P B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.

*****
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S P P B) (S P B Q)) F0
+++++
assert (S P P B = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).

*****
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S P P B) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S P P B) (S P B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S P P B) (S P B Q)) F0
+++++
rewrite H5.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.
rewrite H5.

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S P B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.
rewrite H5.
Geometry.

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S P B Q)) F0
+++++
ring_simplify.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.
rewrite H5.
Geometry.
ring_simplify.

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S P B Q) F0
+++++
assert (Col P B Q).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.
rewrite H5.
Geometry.
ring_simplify.
assert (Col P B Q).

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col P B Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.
rewrite H5.
Geometry.
ring_simplify.
assert (Col P B Q).
Geometry.

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col P B Q
+++++
rewrite <- H3.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.
rewrite H5.
Geometry.
ring_simplify.
assert (Col P B Q).
Geometry.
rewrite <- H3.

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col A B Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.
rewrite H5.
Geometry.
ring_simplify.
assert (Col P B Q).
Geometry.
rewrite <- H3.
Geometry.

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col A B Q
+++++
rewrite <- H4 in H1.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.
rewrite H5.
Geometry.
ring_simplify.
assert (Col P B Q).
Geometry.
rewrite <- H3.
Geometry.
rewrite <- H4 in H1.

*****
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B A Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col A B Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A = O).
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
rewrite H3.
Geometry.
assert (S P P B = 0).
Geometry.
rewrite H5.
Geometry.
ring_simplify.
assert (Col P B Q).

*****
H6 : Col P B Q
H5 : eq (S P P B) F0
H4 : eq A O
H3 : eq A P
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S P B Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.

*****
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.

*****
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (A <> O).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).

*****
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq A O)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.

*****
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq A O)
+++++
unfold not in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.

*****
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
forall _ : eq A O, False
+++++
intro.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.

*****
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.

*****
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
assert (A ** O = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).

*****
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg A O) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).

*****
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).
Geometry.

*****
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
rewrite H5 in H0.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).
Geometry.
rewrite H5 in H0.

*****
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq F0 (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).
Geometry.
rewrite H5 in H0.
Geometry.

*****
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq F0 (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
assert (O = P).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).
Geometry.
rewrite H5 in H0.
Geometry.
assert (O = P).

*****
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq F0 (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq O P
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).
Geometry.
rewrite H5 in H0.
Geometry.
assert (O = P).

*****
H6 : eq O P
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq F0 (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).
Geometry.
rewrite H5 in H0.
Geometry.
assert (O = P).
Geometry.

*****
H6 : eq O P
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq F0 (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
assert (A = P).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).
Geometry.
rewrite H5 in H0.
Geometry.
assert (O = P).
Geometry.
assert (A = P).

*****
H6 : eq O P
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq F0 (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A P
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).
Geometry.
rewrite H5 in H0.
Geometry.
assert (O = P).
Geometry.
assert (A = P).
Geometry.

*****
H6 : eq O P
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq F0 (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq A P
+++++
congruence.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (A ** O = 0).
Geometry.
rewrite H5 in H0.
Geometry.
assert (O = P).
Geometry.
assert (A = P).

*****
H7 : eq A P
H6 : eq O P
H5 : eq (DSeg A O) F0
H4 : eq A O
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq F0 (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).

*****
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.

*****
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
cases_equality B O.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.

*****
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.

*****
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
unfold parallel in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.

*****
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.

*****
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
unfold S4 in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.

*****
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.

*****
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
assert (B ** O = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).

*****
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg B O) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).

*****
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.

*****
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
rewrite H6 in H2.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.

*****
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.

*****
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
assert (O = Q).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).

*****
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq O Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).

*****
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.

*****
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
assert (B = Q).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).

*****
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq B Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.

*****
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq B Q
+++++
congruence.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).

*****
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.

*****
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
rewrite H7 in H.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.

*****
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.
Geometry.

*****
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
rewrite H8.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.
Geometry.
rewrite H8.

*****
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P Q) (S A Q Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.
Geometry.
rewrite H8.
Geometry.

*****
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P Q) (S A Q Q)) F0
+++++
rewrite H.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.
Geometry.
rewrite H8.
Geometry.
rewrite H.

*****
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S A Q Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.
Geometry.
rewrite H8.
Geometry.
rewrite H.
Geometry.

*****
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S A Q Q)) F0
+++++
assert (S A Q Q = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.
Geometry.
rewrite H8.
Geometry.
rewrite H.
Geometry.
assert (S A Q Q = 0).

*****
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S A Q Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.
Geometry.
rewrite H8.
Geometry.
rewrite H.
Geometry.
assert (S A Q Q = 0).

*****
H9 : eq (S A Q Q) F0
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S A Q Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.
Geometry.
rewrite H8.
Geometry.
rewrite H.
Geometry.
assert (S A Q Q = 0).
Geometry.

*****
H9 : eq (S A Q Q) F0
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S A Q Q)) F0
+++++
rewrite H9.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (B ** O = 0).
Geometry.
rewrite H6 in H2.
Geometry.
assert (O = Q).
Geometry.
assert (B = Q).
Geometry.
rewrite H7 in H.
Geometry.
rewrite H8.
Geometry.
rewrite H.
Geometry.
assert (S A Q Q = 0).
Geometry.
rewrite H9.

*****
H9 : eq (S A Q Q) F0
H8 : eq B Q
H7 : eq O Q
H6 : eq (DSeg B O) F0
H5 : eq B O
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P Q
H2 : eq F0 (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 F0) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.

*****
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.

*****
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
cases_col O A B.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.

*****
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.

*****
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
unfold parallel in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.

*****
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.

*****
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
unfold S4 in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.

*****
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.

*****
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
assert (Col A O B).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).

*****
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col A O B
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).

*****
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.

*****
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
assert (Col A O P).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).

*****
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col A O P
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).

*****
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.

*****
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
assert (Col A P B).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).

*****
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col A P B
+++++
eauto with Geom.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).

*****
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
eauto with Geom.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.

*****
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.

*****
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
assert (Col B O Q).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).

*****
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col B O Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).

*****
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.

*****
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
assert (Col B O A).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).

*****
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col B O A
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).

*****
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.

*****
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
assert (Col B Q A).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).

*****
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col B Q A
+++++
eauto with Geom.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).

*****
H12 : Col B Q A
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
eauto with Geom.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).
eauto with Geom.

*****
H12 : Col B Q A
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).
eauto with Geom.
Geometry.

*****
H12 : Col B Q A
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
rewrite H9.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).
eauto with Geom.
Geometry.
rewrite H9.

*****
H12 : Col B Q A
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).
eauto with Geom.
Geometry.
rewrite H9.
Geometry.

*****
H12 : Col B Q A
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S A B Q)) F0
+++++
assert (Col A B Q).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).
eauto with Geom.
Geometry.
rewrite H9.
Geometry.
assert (Col A B Q).

*****
H12 : Col B Q A
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
Col A B Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).
eauto with Geom.
Geometry.
rewrite H9.
Geometry.
assert (Col A B Q).

*****
H13 : Col A B Q
H12 : Col B Q A
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).
eauto with Geom.
Geometry.
rewrite H9.
Geometry.
assert (Col A B Q).
Geometry.

*****
H13 : Col A B Q
H12 : Col B Q A
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 (S A B Q)) F0
+++++
rewrite H13.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
unfold parallel in |- *.
Geometry.
unfold S4 in |- *.
Geometry.
assert (Col A O B).
Geometry.
assert (Col A O P).
Geometry.
assert (Col A P B).
eauto with Geom.
Geometry.
assert (Col B O Q).
Geometry.
assert (Col B O A).
Geometry.
assert (Col B Q A).
eauto with Geom.
Geometry.
rewrite H9.
Geometry.
assert (Col A B Q).
Geometry.
rewrite H13.

*****
H13 : Col A B Q
H12 : Col B Q A
H11 : Col B O A
H10 : Col B O Q
H9 : Col A P B
H8 : Col A O P
H7 : Col A O B
H6 : Col O A B
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus F0 F0) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.

*****
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.

*****
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (Q ** B / O ** B = S Q A B / S O A B).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).

*****
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).

*****
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.

*****
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (Q <> O).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).

*****
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq Q O)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.

*****
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq Q O)
+++++
unfold not in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
unfold not in |- *.

*****
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
forall _ : eq Q O, False
+++++
intro.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
unfold not in |- *.
intro.

*****
H8 : eq Q O
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.

*****
H8 : eq Q O
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
assert (O ** Q = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** Q = 0).

*****
H8 : eq Q O
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg O Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** Q = 0).

*****
H9 : eq (DSeg O Q) F0
H8 : eq Q O
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** Q = 0).
Geometry.

*****
H9 : eq (DSeg O Q) F0
H8 : eq Q O
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
assert (B ** O = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** Q = 0).
Geometry.
assert (B ** O = 0).

*****
H9 : eq (DSeg O Q) F0
H8 : eq Q O
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg B O) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** Q = 0).
Geometry.
assert (B ** O = 0).
Geometry.

*****
H9 : eq (DSeg O Q) F0
H8 : eq Q O
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg B O) F0
+++++
congruence.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** Q = 0).
Geometry.
assert (B ** O = 0).

*****
H10 : eq (DSeg B O) F0
H9 : eq (DSeg O Q) F0
H8 : eq Q O
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).

*****
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.

*****
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (Q ** B / O ** B = 2).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).

*****
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.

*****
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
+++++
assert (Q ** B = Q ** O + O ** B).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).

*****
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.

*****
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
+++++
symmetry in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.
symmetry in |- *.

*****
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (DSeg Q O) (DSeg O B)) (DSeg Q B)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).

*****
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.

*****
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
+++++
rewrite H9.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.
rewrite H9.

*****
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (Fplus (DSeg Q O) (DSeg O B)) (DSeg O B)) (Fplus F1 F1)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.
rewrite H9.
Geometry.

*****
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (Fplus (DSeg Q O) (DSeg O B)) (DSeg O B)) (Fplus F1 F1)
+++++
assert (O ** B = Q ** O).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.
rewrite H9.
Geometry.
assert (O ** B = Q ** O).

*****
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg O B) (DSeg Q O)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.
rewrite H9.
Geometry.
assert (O ** B = Q ** O).

*****
H10 : eq (DSeg O B) (DSeg Q O)
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (Fplus (DSeg Q O) (DSeg O B)) (DSeg O B)) (Fplus F1 F1)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.
rewrite H9.
Geometry.
assert (O ** B = Q ** O).
Geometry.

*****
H10 : eq (DSeg O B) (DSeg Q O)
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (Fplus (DSeg Q O) (DSeg O B)) (DSeg O B)) (Fplus F1 F1)
+++++
rewrite H10.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.
rewrite H9.
Geometry.
assert (O ** B = Q ** O).
Geometry.
rewrite H10.

*****
H10 : eq (DSeg O B) (DSeg Q O)
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (Fplus (DSeg Q O) (DSeg Q O)) (DSeg Q O)) (Fplus F1 F1)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.
rewrite H9.
Geometry.
assert (O ** B = Q ** O).
Geometry.
rewrite H10.
Geometry.

*****
H10 : eq (DSeg O B) (DSeg Q O)
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (Fplus (DSeg Q O) (DSeg Q O)) (DSeg Q O)) (Fplus F1 F1)
+++++
field.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (Q ** B = Q ** O + O ** B).
Geometry.
rewrite H9.
Geometry.
assert (O ** B = Q ** O).
Geometry.
rewrite H10.
Geometry.
field.

*****
H10 : eq (DSeg O B) (DSeg Q O)
H9 : eq (DSeg Q B) (Fplus (DSeg Q O) (DSeg O B))
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq (DSeg Q O) F0)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).

*****
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.

*****
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (O <> P).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).

*****
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq O P)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.

*****
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq O P)
+++++
unfold not in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
unfold not in |- *.

*****
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
forall _ : eq O P, False
+++++
intro.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
unfold not in |- *.
intro.

*****
H10 : eq O P
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
unfold not in |- *.
intro.
Geometry.

*****
H10 : eq O P
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
assert (O ** P = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** P = 0).

*****
H10 : eq O P
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg O P) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** P = 0).

*****
H11 : eq (DSeg O P) F0
H10 : eq O P
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** P = 0).
Geometry.

*****
H11 : eq (DSeg O P) F0
H10 : eq O P
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
assert (A ** O = 0).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** P = 0).
Geometry.
assert (A ** O = 0).

*****
H11 : eq (DSeg O P) F0
H10 : eq O P
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg A O) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** P = 0).
Geometry.
assert (A ** O = 0).
Geometry.

*****
H11 : eq (DSeg O P) F0
H10 : eq O P
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (DSeg A O) F0
+++++
congruence.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
unfold not in |- *.
intro.
Geometry.
assert (O ** P = 0).
Geometry.
assert (A ** O = 0).

*****
H12 : eq (DSeg A O) F0
H11 : eq (DSeg O P) F0
H10 : eq O P
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
False
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).

*****
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.

*****
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (P ** A / O ** A = S P A B / S O A B).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).

*****
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).

*****
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.

*****
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (P ** A / O ** A = A ** P / A ** O).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).

*****
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (DSeg A P) (DSeg A O))
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).

*****
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (DSeg A P) (DSeg A O))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.

*****
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (DSeg A P) (DSeg A O))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert (A ** O + O ** P = A ** P).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).

*****
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (DSeg A P) (DSeg A O))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).

*****
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (DSeg A P) (DSeg A O))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.

*****
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (DSeg A P) (DSeg A O))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
rewrite <- H13 in H12.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.

*****
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A))\n (Fdiv (Fplus (DSeg A O) (DSeg O P)) (DSeg A O))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.

*****
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A))\n (Fdiv (Fplus (DSeg A O) (DSeg O P)) (DSeg A O))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
rewrite H0 in H12.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.

*****
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A))\n (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.

*****
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A))\n (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
assert ((O ** P + O ** P) / O ** P = 2).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).

*****
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A))\n (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.

*****
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A))\n (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
+++++
field.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
field.

*****
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A))\n (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq (DSeg O P) F0)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).

*****
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A))\n (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.

*****
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A))\n (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P))
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
rewrite H14 in H12.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.

*****
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.

*****
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
parallel A B P Q
+++++
unfold parallel in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.

*****
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.

*****
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
assert (S Q A B / S O A B = S P A B / S O A B).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).

*****
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.

*****
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
+++++
congruence.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).

*****
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.

*****
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
assert (S Q A B = S A B Q).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).

*****
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S Q A B) (S A B Q)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).

*****
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.

*****
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
assert (S A P B = - S P A B).
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).

*****
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S A P B) (Fopp (S P A B))
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).

*****
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.

*****
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (S4 A P B Q) F0
+++++
unfold S4 in |- *.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.

*****
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.
Geometry.

*****
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S A B Q)) F0
+++++
rewrite <- H16.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.
Geometry.
rewrite <- H16.

*****
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S Q A B)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.
Geometry.
rewrite <- H16.
Geometry.

*****
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (S A P B) (S Q A B)) F0
+++++
rewrite H17.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.
Geometry.
rewrite <- H16.
Geometry.
rewrite H17.

*****
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (Fopp (S P A B)) (S Q A B)) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.
Geometry.
rewrite <- H16.
Geometry.
rewrite H17.
Geometry.

*****
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (S Q A B) (S A B Q)
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S Q A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (Fopp (S P A B)) (S Q A B)) F0
+++++
RewriteVar (S Q A B) H15.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.
Geometry.
rewrite <- H16.
Geometry.
rewrite H17.
Geometry.
RewriteVar (S Q A B) H15.

*****
H15 : eq (S Q A B) (Fmult (S O A B) (Fdiv (S P A B) (S O A B)))
H18 : not (eq (S O A B) F0)
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (Fmult (S O A B) (Fdiv (S P A B) (S O A B))) (S A B Q)
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B))\n (Fdiv (Fmult (S O A B) (Fdiv (S P A B) (S O A B))) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (Fopp (S P A B)) (Fmult (S O A B) (Fdiv (S P A B) (S O A B)))) F0
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.
Geometry.
rewrite <- H16.
Geometry.
rewrite H17.
Geometry.
RewriteVar (S Q A B) H15.
Geometry.

*****
H15 : eq (S Q A B) (Fmult (S O A B) (Fdiv (S P A B) (S O A B)))
H18 : not (eq (S O A B) F0)
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (Fmult (S O A B) (Fdiv (S P A B) (S O A B))) (S A B Q)
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B))\n (Fdiv (Fmult (S O A B) (Fdiv (S P A B) (S O A B))) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
eq (Fplus (Fopp (S P A B)) (Fmult (S O A B) (Fdiv (S P A B) (S O A B)))) F0
+++++
field.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.
Geometry.
rewrite <- H16.
Geometry.
rewrite H17.
Geometry.
RewriteVar (S Q A B) H15.
Geometry.
field.

*****
H15 : eq (S Q A B) (Fmult (S O A B) (Fdiv (S P A B) (S O A B)))
H18 : not (eq (S O A B) F0)
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (Fmult (S O A B) (Fdiv (S P A B) (S O A B))) (S A B Q)
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B))\n (Fdiv (Fmult (S O A B) (Fdiv (S P A B) (S O A B))) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq (S O A B) F0)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).
Geometry.
clear H1.
rename H0 into H1.
rename H3 into H0.
cases_equality A P.
Geometry.
assert (A <> O).
Geometry.
cases_equality B O.
Geometry.
cases_col O A B.
Geometry.
assert (Q ** B / O ** B = S Q A B / S O A B).
Geometry.
assert (Q <> O).
Geometry.
assert (Q ** B / O ** B = 2).
Geometry.
assert (O <> P).
Geometry.
assert (P ** A / O ** A = S P A B / S O A B).
Geometry.
assert (P ** A / O ** A = A ** P / A ** O).
Geometry.
assert (A ** O + O ** P = A ** P).
Geometry.
rewrite <- H13 in H12.
Geometry.
rewrite H0 in H12.
Geometry.
assert ((O ** P + O ** P) / O ** P = 2).
Geometry.
rewrite H14 in H12.
Geometry.
unfold parallel in |- *.
Geometry.
assert (S Q A B / S O A B = S P A B / S O A B).
Geometry.
assert (S Q A B = S A B Q).
Geometry.
assert (S A P B = - S P A B).
Geometry.
unfold S4 in |- *.
Geometry.
rewrite <- H16.
Geometry.
rewrite H17.
Geometry.
RewriteVar (S Q A B) H15.

*****
H15 : eq (Fdiv (S Q A B) (S O A B)) (Fdiv (S P A B) (S O A B))
H17 : eq (S A P B) (Fopp (S P A B))
H16 : eq (S Q A B) (S A B Q)
H14 : eq (Fdiv (Fplus (DSeg O P) (DSeg O P)) (DSeg O P)) (Fplus F1 F1)
H13 : eq (Fplus (DSeg A O) (DSeg O P)) (DSeg A P)
H12 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fplus F1 F1)
H11 : eq (Fdiv (DSeg P A) (DSeg O A)) (Fdiv (S P A B) (S O A B))
H10 : not (eq O P)
H9 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fplus F1 F1)
H8 : not (eq Q O)
H7 : eq (Fdiv (DSeg Q B) (DSeg O B)) (Fdiv (S P A B) (S O A B))
H6 : not (Col O A B)
H5 : not (eq B O)
H4 : not (eq A O)
H3 : not (eq A P)
H1 : Col B O Q
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
H2 : eq (DSeg B O) (DSeg O Q)
O,A,P,B,Q : Point
*****
not (eq (S O A B) F0)
+++++
Geometry.
-----
Theorem diag_mid_point_parallel : forall O A P B Q, mid_point O A P -> mid_point O B Q -> parallel A B P Q.
Proof.
intros.
unfold mid_point in *.
DecompAndAll.
rename H0 into H.
assert (Col B O Q).

*****

*****

+++++
Qed.
-----
Theorem euclid_parallel_existence_strong :\n forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\ P<>Q}.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.

*****

*****
forall (A B P : Point) (_ : not (eq A B)), sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
Proof.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.

*****

*****
forall (A B P : Point) (_ : not (eq A B)), sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
intros.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.

*****
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
assert (Op := mid_point_ex A P).
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).

*****
Op : sig (fun O : Point => mid_point O A P)
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.

*****
Op : sig (fun O : Point => mid_point O A P)
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
elim Op.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.

*****
Op : sig (fun O : Point => mid_point O A P)
H : not (eq A B)
A,B,P : Point
*****
forall (x : Point) (_ : mid_point x A P), sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
intro O.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.

*****
O : Point
Op : sig (fun O : Point => mid_point O A P)
H : not (eq A B)
A,B,P : Point
*****
forall _ : mid_point O A P, sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
clear Op.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.

*****
O : Point
H : not (eq A B)
A,B,P : Point
*****
forall _ : mid_point O A P, sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.

*****
O : Point
H : not (eq A B)
A,B,P : Point
*****
forall _ : mid_point O A P, sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
intros.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.

*****
p : mid_point O A P
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.

*****
p : mid_point O A P
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
elim p.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.

*****
p : mid_point O A P
O : Point
H : not (eq A B)
A,B,P : Point
*****
forall (_ : Col A P O) (_ : eq (DSeg A O) (DSeg O P)), sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
intros.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.

*****
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
p : mid_point O A P
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
clear p.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.

*****
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.

*****
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
assert (Op := symmetric_point_ex B O).
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).

*****
Op : sig (fun A' : Point => and (Col B O A') (eq (DSeg B O) (DSeg O A')))
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.

*****
Op : sig (fun A' : Point => and (Col B O A') (eq (DSeg B O) (DSeg O A')))
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
elim Op.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.

*****
Op : sig (fun A' : Point => and (Col B O A') (eq (DSeg B O) (DSeg O A')))
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
forall (x : Point) (_ : and (Col B O x) (eq (DSeg B O) (DSeg O x))), sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
intro Q.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.

*****
Q : Point
Op : sig (fun A' : Point => and (Col B O A') (eq (DSeg B O) (DSeg O A')))
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
forall _ : and (Col B O Q) (eq (DSeg B O) (DSeg O Q)), sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
clear Op.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.

*****
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
forall _ : and (Col B O Q) (eq (DSeg B O) (DSeg O Q)), sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.

*****
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
forall _ : and (Col B O Q) (eq (DSeg B O) (DSeg O Q)), sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
intros.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.

*****
p : and (Col B O Q) (eq (DSeg B O) (DSeg O Q))
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.

*****
p : and (Col B O Q) (eq (DSeg B O) (DSeg O Q))
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
elim p.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.

*****
p : and (Col B O Q) (eq (DSeg B O) (DSeg O Q))
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
forall (_ : Col B O Q) (_ : eq (DSeg B O) (DSeg O Q)), sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
intros.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
p : and (Col B O Q) (eq (DSeg B O) (DSeg O Q))
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
clear p.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
sig (fun Q : Point => and (parallel A B P Q) (not (eq P Q)))
+++++
exists Q.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
and (parallel A B P Q) (not (eq P Q))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
and (parallel A B P Q) (not (eq P Q))
+++++
split.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
parallel A B P Q
+++++
eapply diag_mid_point_parallel.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
eapply diag_mid_point_parallel.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
mid_point ?O A P
+++++
unfold mid_point.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
eapply diag_mid_point_parallel.
unfold mid_point.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
and (Col A P ?O) (eq (DSeg A ?O) (DSeg ?O P))
+++++
split.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
eapply diag_mid_point_parallel.
unfold mid_point.
split.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
Col A P ?O
+++++
apply H0.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
eapply diag_mid_point_parallel.
unfold mid_point.
split.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
eq (DSeg A O) (DSeg O P)
+++++
assumption.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
eapply diag_mid_point_parallel.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
mid_point O B Q
+++++
unfold mid_point.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
eapply diag_mid_point_parallel.
unfold mid_point.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
and (Col B Q O) (eq (DSeg B O) (DSeg O Q))
+++++
split.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
eapply diag_mid_point_parallel.
unfold mid_point.
split.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
Col B Q O
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
eapply diag_mid_point_parallel.
unfold mid_point.
split.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
eq (DSeg B O) (DSeg O Q)
+++++
assumption.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
not (eq P Q)
+++++
unfold not.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.

*****
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
forall _ : eq P Q, False
+++++
intro.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.

*****
H4 : eq P Q
H3 : eq (DSeg B O) (DSeg O Q)
H2 : Col B O Q
Q : Point
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
subst Q.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.

*****
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg O P)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
rewrite <- H1 in H3.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.

*****
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
cases_equality O P.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.

*****
H4 : eq O P
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
subst P.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.

*****
H2 : Col B O O
H3 : eq (DSeg B O) (DSeg A O)
H0 : Col A O O
H1 : eq (DSeg A O) (DSeg O O)
O : Point
H : not (eq A B)
A,B : Point
*****
False
+++++
replace (O**O) with 0 in H1.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.

*****
H2 : Col B O O
H3 : eq (DSeg B O) (DSeg A O)
H0 : Col A O O
H1 : eq (DSeg A O) F0
O : Point
H : not (eq A B)
A,B : Point
*****
False
+++++
assert (A=O).
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.
assert (A=O).

*****
H2 : Col B O O
H3 : eq (DSeg B O) (DSeg A O)
H0 : Col A O O
H1 : eq (DSeg A O) F0
O : Point
H : not (eq A B)
A,B : Point
*****
eq A O
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.
assert (A=O).

*****
H4 : eq A O
H2 : Col B O O
H3 : eq (DSeg B O) (DSeg A O)
H0 : Col A O O
H1 : eq (DSeg A O) F0
O : Point
H : not (eq A B)
A,B : Point
*****
False
+++++
subst A.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.
assert (A=O).
subst A.

*****
H2 : Col B O O
H : not (eq O B)
H1 : eq (DSeg O O) F0
H0 : Col O O O
H3 : eq (DSeg B O) (DSeg O O)
B,O : Point
*****
False
+++++
replace (O**O) with 0 in H3.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.
assert (A=O).
subst A.
replace (O**O) with 0 in H3.

*****
H2 : Col B O O
H : not (eq O B)
H1 : eq (DSeg O O) F0
H0 : Col O O O
H3 : eq (DSeg B O) F0
B,O : Point
*****
False
+++++
assert (B=O).
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.
assert (A=O).
subst A.
replace (O**O) with 0 in H3.
assert (B=O).

*****
H2 : Col B O O
H : not (eq O B)
H1 : eq (DSeg O O) F0
H0 : Col O O O
H3 : eq (DSeg B O) F0
B,O : Point
*****
eq B O
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.
assert (A=O).
subst A.
replace (O**O) with 0 in H3.
assert (B=O).

*****
H4 : eq B O
H2 : Col B O O
H : not (eq O B)
H1 : eq (DSeg O O) F0
H0 : Col O O O
H3 : eq (DSeg B O) F0
B,O : Point
*****
False
+++++
subst B.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.
assert (A=O).
subst A.
replace (O**O) with 0 in H3.
assert (B=O).
subst B.

*****
H : not (eq O O)
H2 : Col O O O
H1 : eq (DSeg O O) F0
H0 : Col O O O
H3 : eq (DSeg O O) F0
O : Point
*****
False
+++++
intuition.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.

*****
H2 : Col B O O
H3 : eq (DSeg B O) (DSeg A O)
H0 : Col A O O
H1 : eq (DSeg A O) (DSeg O O)
O : Point
H : not (eq A B)
A,B : Point
*****
eq F0 (DSeg O O)
+++++
symmetry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
subst P.
replace (O**O) with 0 in H1.
symmetry.

*****
H2 : Col B O O
H3 : eq (DSeg B O) (DSeg A O)
H0 : Col A O O
H1 : eq (DSeg A O) (DSeg O O)
O : Point
H : not (eq A B)
A,B : Point
*****
eq (DSeg O O) F0
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.

*****
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
assert (Col O A B).
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).

*****
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
Col O A B
+++++
eapply col_trans_1 with (B:=P).
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
eapply col_trans_1 with (B:=P).

*****
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
not (eq O P)
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
eapply col_trans_1 with (B:=P).

*****
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
Col O P A
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
eapply col_trans_1 with (B:=P).

*****
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
Col O P B
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).

*****
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
assert (A**O+O**B=A**B).
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).

*****
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
eq (Fplus (DSeg A O) (DSeg O B)) (DSeg A B)
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).

*****
H6 : eq (Fplus (DSeg A O) (DSeg O B)) (DSeg A B)
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).
Geometry.

*****
H6 : eq (Fplus (DSeg A O) (DSeg O B)) (DSeg A B)
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
rewrite <- H3 in H6.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).
Geometry.
rewrite <- H3 in H6.

*****
H6 : eq (Fplus (DSeg B O) (DSeg O B)) (DSeg A B)
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
replace (B**O) with (-O**B) in H6.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).
Geometry.
rewrite <- H3 in H6.
replace (B**O) with (-O**B) in H6.

*****
H6 : eq (Fplus (Fopp (DSeg O B)) (DSeg O B)) (DSeg A B)
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
NormalizeRing H6.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).
Geometry.
rewrite <- H3 in H6.
replace (B**O) with (-O**B) in H6.
NormalizeRing H6.

*****
H6 : eq F0 (DSeg A B)
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
assert (A=B).
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).
Geometry.
rewrite <- H3 in H6.
replace (B**O) with (-O**B) in H6.
NormalizeRing H6.
assert (A=B).

*****
H6 : eq F0 (DSeg A B)
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
eq A B
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).
Geometry.
rewrite <- H3 in H6.
replace (B**O) with (-O**B) in H6.
NormalizeRing H6.
assert (A=B).

*****
H7 : eq A B
H6 : eq F0 (DSeg A B)
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
False
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).
Geometry.
rewrite <- H3 in H6.
replace (B**O) with (-O**B) in H6.

*****
H6 : eq (Fplus (DSeg B O) (DSeg O B)) (DSeg A B)
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
eq (Fopp (DSeg O B)) (DSeg B O)
+++++
symmetry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.
unfold not.
intro.
subst Q.
rewrite <- H1 in H3.
cases_equality O P.
assert (Col O A B).
assert (A**O+O**B=A**B).
Geometry.
rewrite <- H3 in H6.
replace (B**O) with (-O**B) in H6.
symmetry.

*****
H6 : eq (Fplus (DSeg B O) (DSeg O B)) (DSeg A B)
H5 : Col O A B
H4 : not (eq O P)
H2 : Col B O P
H3 : eq (DSeg B O) (DSeg A O)
H1 : eq (DSeg A O) (DSeg O P)
H0 : Col A P O
O : Point
H : not (eq A B)
A,B,P : Point
*****
eq (DSeg B O) (Fopp (DSeg O B))
+++++
Geometry.
-----
Theorem euclid_parallel_existence_strong : forall A B P : Point, A<>B -> {Q : Point | parallel A B P Q /\\ P<>Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
split.

*****

*****

+++++
Qed.
-----
Theorem euclid_parallel_existence :\n forall A B P : Point, {Q : Point | parallel A B P Q}.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.

*****

*****
forall A B P : Point, sig (fun Q : Point => parallel A B P Q)
+++++
Proof.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.

*****

*****
forall A B P : Point, sig (fun Q : Point => parallel A B P Q)
+++++
intros.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.

*****
A,B,P : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
assert (Op := mid_point_ex A P).
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).

*****
Op : sig (fun O : Point => mid_point O A P)
A,B,P : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.

*****
Op : sig (fun O : Point => mid_point O A P)
A,B,P : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
elim Op.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.

*****
Op : sig (fun O : Point => mid_point O A P)
A,B,P : Point
*****
forall (x : Point) (_ : mid_point x A P), sig (fun Q : Point => parallel A B P Q)
+++++
intro O.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.

*****
O : Point
Op : sig (fun O : Point => mid_point O A P)
A,B,P : Point
*****
forall _ : mid_point O A P, sig (fun Q : Point => parallel A B P Q)
+++++
clear Op.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.

*****
A,B,P,O : Point
*****
forall _ : mid_point O A P, sig (fun Q : Point => parallel A B P Q)
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.

*****
A,B,P,O : Point
*****
forall _ : mid_point O A P, sig (fun Q : Point => parallel A B P Q)
+++++
intros.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.

*****
p : mid_point O A P
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.

*****
p : mid_point O A P
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
elim p.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.

*****
p : mid_point O A P
A,B,P,O : Point
*****
forall (_ : Col A P O) (_ : eq (DSeg A O) (DSeg O P)), sig (fun Q : Point => parallel A B P Q)
+++++
intros.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.

*****
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
p : mid_point O A P
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
clear p.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.

*****
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.

*****
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
assert (Op := symmetric_point_ex B O).
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).

*****
Op : sig (fun A' : Point => and (Col B O A') (eq (DSeg B O) (DSeg O A')))
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.

*****
Op : sig (fun A' : Point => and (Col B O A') (eq (DSeg B O) (DSeg O A')))
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
elim Op.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.

*****
Op : sig (fun A' : Point => and (Col B O A') (eq (DSeg B O) (DSeg O A')))
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
forall (x : Point) (_ : and (Col B O x) (eq (DSeg B O) (DSeg O x))), sig (fun Q : Point => parallel A B P Q)
+++++
intro Q.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.

*****
Q : Point
Op : sig (fun A' : Point => and (Col B O A') (eq (DSeg B O) (DSeg O A')))
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
forall _ : and (Col B O Q) (eq (DSeg B O) (DSeg O Q)), sig (fun Q : Point => parallel A B P Q)
+++++
clear Op.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.

*****
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
forall _ : and (Col B O Q) (eq (DSeg B O) (DSeg O Q)), sig (fun Q : Point => parallel A B P Q)
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.

*****
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
forall _ : and (Col B O Q) (eq (DSeg B O) (DSeg O Q)), sig (fun Q : Point => parallel A B P Q)
+++++
intros.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.

*****
p : and (Col B O Q) (eq (DSeg B O) (DSeg O Q))
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.

*****
p : and (Col B O Q) (eq (DSeg B O) (DSeg O Q))
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
elim p.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.

*****
p : and (Col B O Q) (eq (DSeg B O) (DSeg O Q))
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
forall (_ : Col B O Q) (_ : eq (DSeg B O) (DSeg O Q)), sig (fun Q : Point => parallel A B P Q)
+++++
intros.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
p : and (Col B O Q) (eq (DSeg B O) (DSeg O Q))
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
clear p.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
sig (fun Q : Point => parallel A B P Q)
+++++
exists Q.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
parallel A B P Q
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
parallel A B P Q
+++++
eapply diag_mid_point_parallel.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
eapply diag_mid_point_parallel.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
mid_point ?O A P
+++++
unfold mid_point.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
eapply diag_mid_point_parallel.
unfold mid_point.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
and (Col A P ?O) (eq (DSeg A ?O) (DSeg ?O P))
+++++
split.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
eapply diag_mid_point_parallel.
unfold mid_point.
split.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
Col A P ?O
+++++
apply H.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
eapply diag_mid_point_parallel.
unfold mid_point.
split.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
eq (DSeg A O) (DSeg O P)
+++++
assumption.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
eapply diag_mid_point_parallel.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
mid_point O B Q
+++++
unfold mid_point.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
eapply diag_mid_point_parallel.
unfold mid_point.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
and (Col B Q O) (eq (DSeg B O) (DSeg O Q))
+++++
split.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
eapply diag_mid_point_parallel.
unfold mid_point.
split.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
Col B Q O
+++++
Geometry.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
eapply diag_mid_point_parallel.
unfold mid_point.
split.

*****
H2 : eq (DSeg B O) (DSeg O Q)
H1 : Col B O Q
Q : Point
H0 : eq (DSeg A O) (DSeg O P)
H : Col A P O
A,B,P,O : Point
*****
eq (DSeg B O) (DSeg O Q)
+++++
assumption.
-----
Theorem euclid_parallel_existence : forall A B P : Point, {Q : Point | parallel A B P Q}.
Proof.
intros.
assert (Op := mid_point_ex A P).
Geometry.
elim Op.
intro O.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
assert (Op := symmetric_point_ex B O).
Geometry.
elim Op.
intro Q.
clear Op.
Geometry.
intros.
Geometry.
elim p.
intros.
clear p.
Geometry.
exists Q.
Geometry.
eapply diag_mid_point_parallel.

*****

*****

+++++
Qed.
-----
Theorem par_1 : forall A B C D : Point, \n   parallel A B C D -> parallel B A C D.
-----
Theorem par_1 : forall A B C D : Point, parallel A B C D -> parallel B A C D.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D), parallel B A C D
+++++
Proof.
-----
Theorem par_1 : forall A B C D : Point, parallel A B C D -> parallel B A C D.
Proof.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D), parallel B A C D
+++++
unfold parallel in |- *.
-----
Theorem par_1 : forall A B C D : Point, parallel A B C D -> parallel B A C D.
Proof.
unfold parallel in |- *.

*****

*****
forall (A B C D : Point) (_ : eq (S4 A C B D) F0), eq (S4 B C A D) F0
+++++
unfold S4 in |- *.
-----
Theorem par_1 : forall A B C D : Point, parallel A B C D -> parallel B A C D.
Proof.
unfold parallel in |- *.
unfold S4 in |- *.

*****

*****
forall (A B C D : Point) (_ : eq (Fplus (S A C B) (S A B D)) F0), eq (Fplus (S B C A) (S B A D)) F0
+++++
intros.
-----
Theorem par_1 : forall A B C D : Point, parallel A B C D -> parallel B A C D.
Proof.
unfold parallel in |- *.
unfold S4 in |- *.
intros.

*****
H : eq (Fplus (S A C B) (S A B D)) F0
A,B,C,D : Point
*****
eq (Fplus (S B C A) (S B A D)) F0
+++++
uniformize_signed_areas.
-----
Theorem par_1 : forall A B C D : Point, parallel A B C D -> parallel B A C D.
Proof.
unfold parallel in |- *.
unfold S4 in |- *.
intros.
uniformize_signed_areas.

*****
H : eq (Fplus (S A C B) (S A B D)) F0
A,B,C,D : Point
*****
eq (Fplus (Fopp (S A C B)) (Fopp (S A B D))) F0
+++++
RewriteVar (S A C B) H.
-----
Theorem par_1 : forall A B C D : Point, parallel A B C D -> parallel B A C D.
Proof.
unfold parallel in |- *.
unfold S4 in |- *.
intros.
uniformize_signed_areas.
RewriteVar (S A C B) H.

*****
H : eq (S A C B) (Fopp (S A B D))
A,B,C,D : Point
*****
eq (Fplus (Fopp (Fopp (S A B D))) (Fopp (S A B D))) F0
+++++
ring.
-----
Theorem par_1 : forall A B C D : Point, parallel A B C D -> parallel B A C D.
Proof.
unfold parallel in |- *.
unfold S4 in |- *.
intros.
uniformize_signed_areas.
RewriteVar (S A C B) H.
ring.

*****

*****

+++++
Qed.
-----
Hint Resolve par_1: Geom.
-----
Theorem par_2 : forall A B C D : Point, \n   parallel A B C D -> parallel C D A B.
-----
Theorem par_2 : forall A B C D : Point, parallel A B C D -> parallel C D A B.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D), parallel C D A B
+++++
Proof.
-----
Theorem par_2 : forall A B C D : Point, parallel A B C D -> parallel C D A B.
Proof.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D), parallel C D A B
+++++
unfold parallel in |- *.
-----
Theorem par_2 : forall A B C D : Point, parallel A B C D -> parallel C D A B.
Proof.
unfold parallel in |- *.

*****

*****
forall (A B C D : Point) (_ : eq (S4 A C B D) F0), eq (S4 C A D B) F0
+++++
intros.
-----
Theorem par_2 : forall A B C D : Point, parallel A B C D -> parallel C D A B.
Proof.
unfold parallel in |- *.
intros.

*****
H : eq (S4 A C B D) F0
A,B,C,D : Point
*****
eq (S4 C A D B) F0
+++++
assert (S4 A C B D = - S4 C A D B).
-----
Theorem par_2 : forall A B C D : Point, parallel A B C D -> parallel C D A B.
Proof.
unfold parallel in |- *.
intros.
assert (S4 A C B D = - S4 C A D B).

*****
H : eq (S4 A C B D) F0
A,B,C,D : Point
*****
eq (S4 A C B D) (Fopp (S4 C A D B))
+++++
Geometry.
-----
Theorem par_2 : forall A B C D : Point, parallel A B C D -> parallel C D A B.
Proof.
unfold parallel in |- *.
intros.
assert (S4 A C B D = - S4 C A D B).

*****
H0 : eq (S4 A C B D) (Fopp (S4 C A D B))
H : eq (S4 A C B D) F0
A,B,C,D : Point
*****
eq (S4 C A D B) F0
+++++
Geometry.
-----
Theorem par_2 : forall A B C D : Point, parallel A B C D -> parallel C D A B.
Proof.
unfold parallel in |- *.
intros.
assert (S4 A C B D = - S4 C A D B).
Geometry.

*****
H0 : eq (S4 A C B D) (Fopp (S4 C A D B))
H : eq (S4 A C B D) F0
A,B,C,D : Point
*****
eq (S4 C A D B) F0
+++++
rewrite H0 in H.
-----
Theorem par_2 : forall A B C D : Point, parallel A B C D -> parallel C D A B.
Proof.
unfold parallel in |- *.
intros.
assert (S4 A C B D = - S4 C A D B).
Geometry.
rewrite H0 in H.

*****
H0 : eq (S4 A C B D) (Fopp (S4 C A D B))
H : eq (Fopp (S4 C A D B)) F0
A,B,C,D : Point
*****
eq (S4 C A D B) F0
+++++
Geometry.
-----
Theorem par_2 : forall A B C D : Point, parallel A B C D -> parallel C D A B.
Proof.
unfold parallel in |- *.
intros.
assert (S4 A C B D = - S4 C A D B).

*****

*****

+++++
Qed.
-----
Hint Resolve par_2: Geom.
-----
Theorem not_parallel_not_eq_1 : forall A B C D,\n  ~ parallel A B C D -> A<>B.
-----
Theorem not_parallel_not_eq_1 : forall A B C D, ~ parallel A B C D -> A<>B.

*****

*****
forall (A B C D : Point) (_ : not (parallel A B C D)), not (eq A B)
+++++
Proof.
-----
Theorem not_parallel_not_eq_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.

*****

*****
forall (A B C D : Point) (_ : not (parallel A B C D)), not (eq A B)
+++++
intros.
-----
Theorem not_parallel_not_eq_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.

*****
H : not (parallel A B C D)
A,B,C,D : Point
*****
not (eq A B)
+++++
unfold not.
-----
Theorem not_parallel_not_eq_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.
unfold not.

*****
H : not (parallel A B C D)
A,B,C,D : Point
*****
forall _ : eq A B, False
+++++
intro.
-----
Theorem not_parallel_not_eq_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.
unfold not.
intro.

*****
H0 : eq A B
H : not (parallel A B C D)
A,B,C,D : Point
*****
False
+++++
subst A.
-----
Theorem not_parallel_not_eq_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.
unfold not.
intro.
subst A.

*****
H : not (parallel B B C D)
B,C,D : Point
*****
False
+++++
Geometry.
-----
Theorem not_parallel_not_eq_1 : forall A B C D, ~ parallel A B C D -> A<>B.
Proof.
intros.
unfold not.
intro.
subst A.
Geometry.

*****

*****

+++++
Qed.
-----
Theorem not_parallel_not_eq_2 : forall A B C D,\n  ~ parallel A B C D -> C<>D.
-----
Theorem not_parallel_not_eq_2 : forall A B C D, ~ parallel A B C D -> C<>D.

*****

*****
forall (A B C D : Point) (_ : not (parallel A B C D)), not (eq C D)
+++++
Proof.
-----
Theorem not_parallel_not_eq_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.

*****

*****
forall (A B C D : Point) (_ : not (parallel A B C D)), not (eq C D)
+++++
intros.
-----
Theorem not_parallel_not_eq_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.

*****
H : not (parallel A B C D)
A,B,C,D : Point
*****
not (eq C D)
+++++
unfold not.
-----
Theorem not_parallel_not_eq_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.
unfold not.

*****
H : not (parallel A B C D)
A,B,C,D : Point
*****
forall _ : eq C D, False
+++++
intro.
-----
Theorem not_parallel_not_eq_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.
unfold not.
intro.

*****
H0 : eq C D
H : not (parallel A B C D)
A,B,C,D : Point
*****
False
+++++
subst C.
-----
Theorem not_parallel_not_eq_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.
unfold not.
intro.
subst C.

*****
H : not (parallel A B D D)
A,B,D : Point
*****
False
+++++
Geometry.
-----
Theorem not_parallel_not_eq_2 : forall A B C D, ~ parallel A B C D -> C<>D.
Proof.
intros.
unfold not.
intro.
subst C.
Geometry.

*****

*****

+++++
Qed.
-----
Hint Resolve not_parallel_not_eq_1 not_parallel_not_eq_2 : Geom.
-----
Lemma mid_point_degenerated_1 : forall A B, mid_point A A B -> A=B.
-----
Lemma mid_point_degenerated_1 : forall A B, mid_point A A B -> A=B.

*****

*****
forall (A B : Point) (_ : mid_point A A B), eq A B
+++++
Proof.
-----
Lemma mid_point_degenerated_1 : forall A B, mid_point A A B -> A=B.
Proof.

*****

*****
forall (A B : Point) (_ : mid_point A A B), eq A B
+++++
intros.
-----
Lemma mid_point_degenerated_1 : forall A B, mid_point A A B -> A=B.
Proof.
intros.

*****
H : mid_point A A B
A,B : Point
*****
eq A B
+++++
unfold mid_point in H.
-----
Lemma mid_point_degenerated_1 : forall A B, mid_point A A B -> A=B.
Proof.
intros.
unfold mid_point in H.

*****
H : and (Col A B A) (eq (DSeg A A) (DSeg A B))
A,B : Point
*****
eq A B
+++++
DecompAndAll.
-----
Lemma mid_point_degenerated_1 : forall A B, mid_point A A B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.

*****
H1 : eq (DSeg A A) (DSeg A B)
H0 : Col A B A
A,B : Point
*****
eq A B
+++++
basic_simpl.
-----
Lemma mid_point_degenerated_1 : forall A B, mid_point A A B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
basic_simpl.

*****
H1 : eq F0 (DSeg A B)
H0 : Col A B A
A,B : Point
*****
eq A B
+++++
Geometry.
-----
Lemma mid_point_degenerated_1 : forall A B, mid_point A A B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
basic_simpl.
Geometry.

*****

*****

+++++
Qed.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.

*****

*****
forall (A B : Point) (_ : mid_point A B B), eq A B
+++++
Proof.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.

*****

*****
forall (A B : Point) (_ : mid_point A B B), eq A B
+++++
intros.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.

*****
H : mid_point A B B
A,B : Point
*****
eq A B
+++++
unfold mid_point in H.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.

*****
H : and (Col B B A) (eq (DSeg B A) (DSeg A B))
A,B : Point
*****
eq A B
+++++
DecompAndAll.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.

*****
H1 : eq (DSeg B A) (DSeg A B)
H0 : Col B B A
A,B : Point
*****
eq A B
+++++
replace (A**B) with (- B**A) in H1.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
replace (A**B) with (- B**A) in H1.

*****
H1 : eq (DSeg B A) (Fopp (DSeg B A))
H0 : Col B B A
A,B : Point
*****
eq A B
+++++
assert (B**A = 0).
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
replace (A**B) with (- B**A) in H1.
assert (B**A = 0).

*****
H1 : eq (DSeg B A) (Fopp (DSeg B A))
H0 : Col B B A
A,B : Point
*****
eq (DSeg B A) F0
+++++
Geometry.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
replace (A**B) with (- B**A) in H1.
assert (B**A = 0).

*****
H : eq (DSeg B A) F0
H1 : eq (DSeg B A) (Fopp (DSeg B A))
H0 : Col B B A
A,B : Point
*****
eq A B
+++++
Geometry.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
replace (A**B) with (- B**A) in H1.
assert (B**A = 0).
Geometry.

*****
H : eq (DSeg B A) F0
H1 : eq (DSeg B A) (Fopp (DSeg B A))
H0 : Col B B A
A,B : Point
*****
eq A B
+++++
symmetry.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
replace (A**B) with (- B**A) in H1.
assert (B**A = 0).
Geometry.
symmetry.

*****
H : eq (DSeg B A) F0
H1 : eq (DSeg B A) (Fopp (DSeg B A))
H0 : Col B B A
A,B : Point
*****
eq B A
+++++
Geometry.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
replace (A**B) with (- B**A) in H1.

*****
H1 : eq (DSeg B A) (DSeg A B)
H0 : Col B B A
A,B : Point
*****
eq (Fopp (DSeg B A)) (DSeg A B)
+++++
symmetry.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
replace (A**B) with (- B**A) in H1.
symmetry.

*****
H1 : eq (DSeg B A) (DSeg A B)
H0 : Col B B A
A,B : Point
*****
eq (DSeg A B) (Fopp (DSeg B A))
+++++
Geometry.
-----
Lemma mid_point_degenerated_2 : forall A B, mid_point A B B -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
replace (A**B) with (- B**A) in H1.

*****

*****

+++++
Qed.
-----
Lemma mid_point_degenerated_3 : forall A B, mid_point A B A -> A=B.
-----
Lemma mid_point_degenerated_3 : forall A B, mid_point A B A -> A=B.

*****

*****
forall (A B : Point) (_ : mid_point A B A), eq A B
+++++
Proof.
-----
Lemma mid_point_degenerated_3 : forall A B, mid_point A B A -> A=B.
Proof.

*****

*****
forall (A B : Point) (_ : mid_point A B A), eq A B
+++++
intros.
-----
Lemma mid_point_degenerated_3 : forall A B, mid_point A B A -> A=B.
Proof.
intros.

*****
H : mid_point A B A
A,B : Point
*****
eq A B
+++++
unfold mid_point in H.
-----
Lemma mid_point_degenerated_3 : forall A B, mid_point A B A -> A=B.
Proof.
intros.
unfold mid_point in H.

*****
H : and (Col B A A) (eq (DSeg B A) (DSeg A A))
A,B : Point
*****
eq A B
+++++
DecompAndAll.
-----
Lemma mid_point_degenerated_3 : forall A B, mid_point A B A -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.

*****
H1 : eq (DSeg B A) (DSeg A A)
H0 : Col B A A
A,B : Point
*****
eq A B
+++++
basic_simpl.
-----
Lemma mid_point_degenerated_3 : forall A B, mid_point A B A -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
basic_simpl.

*****
H1 : eq (DSeg B A) F0
H0 : Col B A A
A,B : Point
*****
eq A B
+++++
symmetry.
-----
Lemma mid_point_degenerated_3 : forall A B, mid_point A B A -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
basic_simpl.
symmetry.

*****
H1 : eq (DSeg B A) F0
H0 : Col B A A
A,B : Point
*****
eq B A
+++++
Geometry.
-----
Lemma mid_point_degenerated_3 : forall A B, mid_point A B A -> A=B.
Proof.
intros.
unfold mid_point in H.
DecompAndAll.
basic_simpl.
symmetry.
Geometry.

*****

*****

+++++
Qed.
-----
Hint Resolve mid_point_degenerated_1 mid_point_degenerated_2 mid_point_degenerated_3:Geom.
-----
Lemma eq_diff_diff : forall A B C D, A<>B -> A**B=C**D -> C<>D.
-----
Lemma eq_diff_diff : forall A B C D, A<>B -> A**B=C**D -> C<>D.

*****

*****
forall (A B C D : Point) (_ : not (eq A B)) (_ : eq (DSeg A B) (DSeg C D)), not (eq C D)
+++++
Proof.
-----
Lemma eq_diff_diff : forall A B C D, A<>B -> A**B=C**D -> C<>D.
Proof.

*****

*****
forall (A B C D : Point) (_ : not (eq A B)) (_ : eq (DSeg A B) (DSeg C D)), not (eq C D)
+++++
intuition idtac.
-----
Lemma eq_diff_diff : forall A B C D, A<>B -> A**B=C**D -> C<>D.
Proof.
intuition idtac.

*****
H1 : eq C D
H0 : eq (DSeg A B) (DSeg C D)
H : forall _ : eq A B, False
A,B,C,D : Point
*****
False
+++++
subst C.
-----
Lemma eq_diff_diff : forall A B C D, A<>B -> A**B=C**D -> C<>D.
Proof.
intuition idtac.
subst C.

*****
H0 : eq (DSeg A B) (DSeg D D)
H : forall _ : eq A B, False
A,B,D : Point
*****
False
+++++
basic_simpl.
-----
Lemma eq_diff_diff : forall A B C D, A<>B -> A**B=C**D -> C<>D.
Proof.
intuition idtac.
subst C.
basic_simpl.

*****
H0 : eq (DSeg A B) F0
H : forall _ : eq A B, False
A,B,D : Point
*****
False
+++++
Geometry.
-----
Lemma eq_diff_diff : forall A B C D, A<>B -> A**B=C**D -> C<>D.
Proof.
intuition idtac.
subst C.
basic_simpl.
Geometry.

*****

*****

+++++
Qed.
-----
Hint Resolve eq_diff_diff : Geom.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D,\n  parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.

*****

*****
forall (P Q C D : Point) (_ : parallel P Q C D) (_ : eq (DSeg P Q) (DSeg C D)), parallel D Q P C
+++++
Proof.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.

*****

*****
forall (P Q C D : Point) (_ : parallel P Q C D) (_ : eq (DSeg P Q) (DSeg C D)), parallel D Q P C
+++++
intros.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.

*****
H0 : eq (DSeg P Q) (DSeg C D)
H : parallel P Q C D
P,Q,C,D : Point
*****
parallel D Q P C
+++++
cases_equality C D.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.

*****
H1 : eq C D
H0 : eq (DSeg P Q) (DSeg C D)
H : parallel P Q C D
P,Q,C,D : Point
*****
parallel D Q P C
+++++
subst.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.

*****
H : parallel P Q D D
H0 : eq (DSeg P Q) (DSeg D D)
P,Q,D : Point
*****
parallel D Q P D
+++++
basic_simpl.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.
basic_simpl.

*****
H : parallel P Q D D
H0 : eq (DSeg P Q) F0
P,Q,D : Point
*****
parallel D Q P D
+++++
assert (P=Q).
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.
basic_simpl.
assert (P=Q).

*****
H : parallel P Q D D
H0 : eq (DSeg P Q) F0
P,Q,D : Point
*****
eq P Q
+++++
apply A1b.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.
basic_simpl.
assert (P=Q).
apply A1b.

*****
H : parallel P Q D D
H0 : eq (DSeg P Q) F0
P,Q,D : Point
*****
eq (DSeg P Q) F0
+++++
assumption.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.
basic_simpl.
assert (P=Q).

*****
H1 : eq P Q
H : parallel P Q D D
H0 : eq (DSeg P Q) F0
P,Q,D : Point
*****
parallel D Q P D
+++++
subst.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.
basic_simpl.
assert (P=Q).
subst.

*****
H0 : eq (DSeg Q Q) F0
H : parallel Q Q D D
Q,D : Point
*****
parallel D Q Q D
+++++
clear H0.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.
basic_simpl.
assert (P=Q).
subst.
clear H0.

*****
H : parallel Q Q D D
Q,D : Point
*****
parallel D Q Q D
+++++
unfold parallel in *.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.
basic_simpl.
assert (P=Q).
subst.
clear H0.
unfold parallel in *.

*****
H : eq (S4 Q D Q D) F0
Q,D : Point
*****
eq (S4 D Q Q D) F0
+++++
unfold S4 in *.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.
basic_simpl.
assert (P=Q).
subst.
clear H0.
unfold parallel in *.
unfold S4 in *.

*****
H : eq (Fplus (S Q D Q) (S Q Q D)) F0
Q,D : Point
*****
eq (Fplus (S D Q Q) (S D Q D)) F0
+++++
basic_simpl.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
subst.
basic_simpl.
assert (P=Q).
subst.
clear H0.
unfold parallel in *.
unfold S4 in *.
basic_simpl.

*****
H : eq F0 F0
Q,D : Point
*****
eq F0 F0
+++++
trivial.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.

*****
H1 : not (eq C D)
H0 : eq (DSeg P Q) (DSeg C D)
H : parallel P Q C D
P,Q,C,D : Point
*****
parallel D Q P C
+++++
apply parallel_side_eq_parallel.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
apply parallel_side_eq_parallel.

*****
H1 : not (eq C D)
H0 : eq (DSeg P Q) (DSeg C D)
H : parallel P Q C D
P,Q,C,D : Point
*****
parallel P Q C D
+++++
auto.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
apply parallel_side_eq_parallel.

*****
H1 : not (eq C D)
H0 : eq (DSeg P Q) (DSeg C D)
H : parallel P Q C D
P,Q,C,D : Point
*****
eq (DSeg P Q) (DSeg C D)
+++++
auto.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.
apply parallel_side_eq_parallel.

*****
H1 : not (eq C D)
H0 : eq (DSeg P Q) (DSeg C D)
H : parallel P Q C D
P,Q,C,D : Point
*****
not (eq C D)
+++++
auto.
-----
Lemma parallel_side_eq_parallel' : forall P Q C D, parallel P Q C D -> P**Q=C**D -> parallel D Q P C.
Proof.
intros.
cases_equality C D.

*****

*****

+++++
Qed.
-----
