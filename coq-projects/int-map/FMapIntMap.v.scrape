From Coq Require Import Bool.
-----
Require Import Coq.NArith.NArith Coq.NArith.Ndigits Coq.NArith.Ndec Coq.NArith.Nnat.
-----
Require Import Allmaps.
-----
Require Import Coq.Structures.OrderedType.
-----
Require Import Coq.Structures.OrderedTypeEx.
-----
Require Import Coq.FSets.FMapInterface Coq.FSets.FMapList.
-----
Set Implicit Arguments.
-----
Module NUsualOrderedType <: UsualOrderedType.
-----
Definition t:=N.
-----
Definition eq:=@eq N.
-----
Definition eq_refl := @refl_equal t.
-----
Definition eq_sym := @sym_eq t.
-----
Definition eq_trans := @trans_eq t.
-----
Definition lt p q:= Nless p q = true.
-----
Definition lt_trans := Nless_trans.
-----
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
-----
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.

*****

*****
forall (x y : t) (_ : lt x y), not (eq x y)
+++++
Proof.
-----
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Proof.

*****

*****
forall (x y : t) (_ : lt x y), not (eq x y)
+++++
intros.
-----
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Proof.
intros.

*****
H : lt x y
x,y : True
*****
not (eq x y)
+++++
intro.
-----
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Proof.
intros.
intro.

*****
H0 : eq x y
H : lt x y
x,y : True
*****
False
+++++
rewrite H0 in H.
-----
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Proof.
intros.
intro.
rewrite H0 in H.

*****
H0 : eq x y
H : lt y y
x,y : True
*****
False
+++++
red in H.
-----
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Proof.
intros.
intro.
rewrite H0 in H.
red in H.

*****
H0 : eq x y
H : Logic.eq (Nless y y) true
x,y : True
*****
False
+++++
rewrite Nless_not_refl in H.
-----
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Proof.
intros.
intro.
rewrite H0 in H.
red in H.
rewrite Nless_not_refl in H.

*****
H0 : eq x y
H : Logic.eq false true
x,y : True
*****
False
+++++
discriminate.
-----
Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
Proof.
intros.
intro.
rewrite H0 in H.
red in H.
rewrite Nless_not_refl in H.
discriminate.

*****

*****

+++++
Qed.
-----
Definition compare : forall x y : t, Compare lt eq x y.
-----
Definition compare : forall x y : t, Compare lt eq x y.

*****

*****
forall x y : t, Compare lt eq x y
+++++
Proof.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.

*****

*****
forall x y : t, Compare lt eq x y
+++++
intros x y.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.

*****
x,y : True
*****
Compare lt eq x y
+++++
destruct (Nless_total x y) as [[H|H]|H].
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.
destruct (Nless_total x y) as [[H|H]|H].

*****
H : Logic.eq (Nless x y) true
x,y : True
*****
Compare lt eq x y
+++++
apply LT.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.
destruct (Nless_total x y) as [[H|H]|H].
apply LT.

*****
H : Logic.eq (Nless x y) true
x,y : True
*****
lt x y
+++++
unfold lt.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.
destruct (Nless_total x y) as [[H|H]|H].
apply LT.
unfold lt.

*****
H : Logic.eq (Nless x y) true
x,y : True
*****
Logic.eq (Nless x y) true
+++++
auto.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.
destruct (Nless_total x y) as [[H|H]|H].

*****
H : Logic.eq (Nless y x) true
x,y : True
*****
Compare lt eq x y
+++++
apply GT.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.
destruct (Nless_total x y) as [[H|H]|H].
apply GT.

*****
H : Logic.eq (Nless y x) true
x,y : True
*****
lt y x
+++++
unfold lt.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.
destruct (Nless_total x y) as [[H|H]|H].
apply GT.
unfold lt.

*****
H : Logic.eq (Nless y x) true
x,y : True
*****
Logic.eq (Nless y x) true
+++++
auto.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.
destruct (Nless_total x y) as [[H|H]|H].

*****
H : Logic.eq x y
x,y : True
*****
Compare lt eq x y
+++++
apply EQ.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.
destruct (Nless_total x y) as [[H|H]|H].
apply EQ.

*****
H : Logic.eq x y
x,y : True
*****
eq x y
+++++
auto.
-----
Definition compare : forall x y : t, Compare lt eq x y.
Proof.
intros x y.
destruct (Nless_total x y) as [[H|H]|H].

*****

*****

+++++
Qed.
-----
Definition eq_dec := N_as_OT.eq_dec.
-----
End NUsualOrderedType.
-----
Module MapIntMap <: S with Module E:=NUsualOrderedType.
-----
Module E:=NUsualOrderedType.
-----
Module ME:=OrderedTypeFacts(E).
-----
Module PE:=KeyOrderedType(E).
-----
Definition key := N.
-----
Definition t := Map.
-----
Section A.
-----
Variable A:Type.
-----
Definition empty : t A := M0 A.
-----
Definition is_empty (m : t A) : bool := \n    MapEmptyp _ (MapCanonicalize _ m).
-----
Definition find (x:key)(m: t A) : option A := MapGet _ m x.
-----
Definition mem (x:key)(m: t A) : bool := \n    match find x m with \n     | Some _ => true\n     | None => false\n    end.
-----
Definition add (x:key)(v:A)(m:t A) : t A := MapPut _ m x v.
-----
Definition remove (x:key)(m:t A) : t A := MapRemove _ m x.
-----
Definition elements (m : t A) : list (N*A) := alist_of_Map _ m.
-----
Definition cardinal (m : t A) : nat := MapCard _ m.
-----
Definition MapsTo (x:key)(v:A)(m:t A) := find x m = Some v.
-----
Definition In (x:key)(m:t A) := exists e:A, MapsTo x e m.
-----
Definition Empty m := forall (a : key)(e:A) , ~ MapsTo a e m.
-----
Definition eq_key (p p':key*A) := E.eq (fst p) (fst p').
-----
Definition eq_key_elt (p p':key*A) := \n          E.eq (fst p) (fst p') /\ (snd p) = (snd p').
-----
Definition lt_key (p p':key*A) := E.lt (fst p) (fst p').
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.

*****
A : Type
*****
forall m : t A, iff (Empty m) (forall a : key, eq (find a m) None)
+++++
Proof.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.

*****
A : Type
*****
forall m : t A, iff (Empty m) (forall a : key, eq (find a m) None)
+++++
unfold Empty.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.

*****
A : Type
*****
forall m : t A, iff (forall (a : key) (e : A), not (MapsTo a e m)) (forall a : key, eq (find a m) None)
+++++
unfold MapsTo.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.

*****
A : Type
*****
forall m : t A, iff (forall (a : key) (e : A), not (eq (find a m) (Some e))) (forall a : key, eq (find a m) None)
+++++
intuition.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.
intuition.

*****
a : key
H : forall (a : key) (e : A) (_ : eq (find a m) (Some e)), False
m : t A
A : Type
*****
eq (find a m) None
+++++
generalize (H a).
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.
intuition.
generalize (H a).

*****
a : key
H : forall (a : key) (e : A) (_ : eq (find a m) (Some e)), False
m : t A
A : Type
*****
forall _ : forall (e : A) (_ : eq (find a m) (Some e)), False, eq (find a m) None
+++++
destruct (find a m).
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.
intuition.
generalize (H a).
destruct (find a m).

*****
a0 : A
a : key
H : forall (a : key) (e : A) (_ : eq (find a m) (Some e)), False
m : t A
A : Type
*****
forall _ : forall (e : A) (_ : eq (Some a0) (Some e)), False, eq (Some a0) None
+++++
intuition.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.
intuition.
generalize (H a).
destruct (find a m).
intuition.

*****
H0 : forall (e : A) (_ : eq (Some a0) (Some e)), False
a0 : A
a : key
H : forall (a : key) (e : A) (_ : eq (find a m) (Some e)), False
m : t A
A : Type
*****
eq (Some a0) None
+++++
elim (H0 a0).
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.
intuition.
generalize (H a).
destruct (find a m).
intuition.
elim (H0 a0).

*****
H0 : forall (e : A) (_ : eq (Some a0) (Some e)), False
a0 : A
a : key
H : forall (a : key) (e : A) (_ : eq (find a m) (Some e)), False
m : t A
A : Type
*****
eq (Some a0) (Some a0)
+++++
auto.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.
intuition.
generalize (H a).
destruct (find a m).

*****
a : key
H : forall (a : key) (e : A) (_ : eq (find a m) (Some e)), False
m : t A
A : Type
*****
forall _ : forall (e : A) (_ : eq None (Some e)), False, eq None None
+++++
intuition.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.
intuition.

*****
H0 : eq (find a m) (Some e)
e : A
a : key
H : forall a : key, eq (find a m) None
m : t A
A : Type
*****
False
+++++
rewrite H in H0.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.
intuition.
rewrite H in H0.

*****
H0 : eq None (Some e)
e : A
a : key
H : forall a : key, eq (find a m) None
m : t A
A : Type
*****
False
+++++
discriminate.
-----
Lemma Empty_alt : forall m, Empty m <-> forall a, find a m = None.
Proof.
unfold Empty.
unfold MapsTo.
intuition.

*****

*****

+++++
Qed.
-----
Section Spec.
-----
Variable  m m' m'' : t A.
-----
Variable x y z : key.
-----
Variable e e' : A.
-----
Lemma MapsTo_1 : E.eq x y -> MapsTo x e m -> MapsTo y e m.
-----
Lemma MapsTo_1 : E.eq x y -> MapsTo x e m -> MapsTo y e m.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : E.eq x y) (_ : MapsTo x e m), MapsTo y e m
+++++
Proof.
-----
Lemma MapsTo_1 : E.eq x y -> MapsTo x e m -> MapsTo y e m.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : E.eq x y) (_ : MapsTo x e m), MapsTo y e m
+++++
intros.
-----
Lemma MapsTo_1 : E.eq x y -> MapsTo x e m -> MapsTo y e m.
Proof.
intros.

*****
H0 : MapsTo x e m
H : E.eq x y
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
MapsTo y e m
+++++
rewrite <- H.
-----
Lemma MapsTo_1 : E.eq x y -> MapsTo x e m -> MapsTo y e m.
Proof.
intros.
rewrite <- H.

*****
H0 : MapsTo x e m
H : E.eq x y
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
MapsTo x e m
+++++
auto.
-----
Lemma MapsTo_1 : E.eq x y -> MapsTo x e m -> MapsTo y e m.
Proof.
intros.
rewrite <- H.
auto.

*****

*****

+++++
Qed.
-----
Lemma find_1 : MapsTo x e m -> find x m = Some e.
-----
Lemma find_1 : MapsTo x e m -> find x m = Some e.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : MapsTo x e m, eq (find x m) (Some e)
+++++
Proof.
-----
Lemma find_1 : MapsTo x e m -> find x m = Some e.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : MapsTo x e m, eq (find x m) (Some e)
+++++
unfold MapsTo.
-----
Lemma find_1 : MapsTo x e m -> find x m = Some e.
Proof.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (find x m) (Some e), eq (find x m) (Some e)
+++++
auto.
-----
Lemma find_1 : MapsTo x e m -> find x m = Some e.
Proof.
unfold MapsTo.
auto.

*****

*****

+++++
Qed.
-----
Lemma find_2 : find x m = Some e -> MapsTo x e m.
-----
Lemma find_2 : find x m = Some e -> MapsTo x e m.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (find x m) (Some e), MapsTo x e m
+++++
Proof.
-----
Lemma find_2 : find x m = Some e -> MapsTo x e m.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (find x m) (Some e), MapsTo x e m
+++++
red.
-----
Lemma find_2 : find x m = Some e -> MapsTo x e m.
Proof.
red.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (find x m) (Some e), eq (find x m) (Some e)
+++++
auto.
-----
Lemma find_2 : find x m = Some e -> MapsTo x e m.
Proof.
red.
auto.

*****

*****

+++++
Qed.
-----
Lemma empty_1 : Empty empty.
-----
Lemma empty_1 : Empty empty.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
Empty empty
+++++
Proof.
-----
Lemma empty_1 : Empty empty.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
Empty empty
+++++
rewrite Empty_alt.
-----
Lemma empty_1 : Empty empty.
Proof.
rewrite Empty_alt.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall a : key, eq (find a empty) None
+++++
intros.
-----
Lemma empty_1 : Empty empty.
Proof.
rewrite Empty_alt.
intros.

*****
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (find a empty) None
+++++
unfold empty.
-----
Lemma empty_1 : Empty empty.
Proof.
rewrite Empty_alt.
intros.
unfold empty.

*****
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (find a (M0 A)) None
+++++
unfold find.
-----
Lemma empty_1 : Empty empty.
Proof.
rewrite Empty_alt.
intros.
unfold empty.
unfold find.

*****
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A (M0 A) a) None
+++++
simpl.
-----
Lemma empty_1 : Empty empty.
Proof.
rewrite Empty_alt.
intros.
unfold empty.
unfold find.
simpl.

*****
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq None None
+++++
auto.
-----
Lemma empty_1 : Empty empty.
Proof.
rewrite Empty_alt.
intros.
unfold empty.
unfold find.
simpl.
auto.

*****

*****

+++++
Qed.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : Empty m, eq (is_empty m) true
+++++
Proof.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : Empty m, eq (is_empty m) true
+++++
unfold Empty.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall (a : key) (e : A), not (MapsTo a e m), eq (is_empty m) true
+++++
unfold is_empty.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall (a : key) (e : A), not (MapsTo a e m), eq (MapEmptyp A (MapCanonicalize A m)) true
+++++
unfold find.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall (a : key) (e : A), not (MapsTo a e m), eq (MapEmptyp A (MapCanonicalize A m)) true
+++++
intros.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.

*****
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapEmptyp A (MapCanonicalize A m)) true
+++++
cut (MapCanonicalize _ m = M0 _).
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).

*****
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (MapCanonicalize A m) (M0 A), eq (MapEmptyp A (MapCanonicalize A m)) true
+++++
intros.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
intros.

*****
H0 : eq (MapCanonicalize A m) (M0 A)
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapEmptyp A (MapCanonicalize A m)) true
+++++
rewrite H0.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
intros.
rewrite H0.

*****
H0 : eq (MapCanonicalize A m) (M0 A)
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapEmptyp A (M0 A)) true
+++++
simpl.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
intros.
rewrite H0.
simpl.

*****
H0 : eq (MapCanonicalize A m) (M0 A)
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq true true
+++++
auto.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).

*****
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapCanonicalize A m) (M0 A)
+++++
apply mapcanon_unique.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.

*****
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
mapcanon A (MapCanonicalize A m)
+++++
apply mapcanon_exists_2.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.

*****
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
mapcanon A (M0 A)
+++++
constructor.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.

*****
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eqmap A (MapCanonicalize A m) (M0 A)
+++++
red.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.

*****
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eqm A (MapGet A (MapCanonicalize A m)) (MapGet A (M0 A))
+++++
red.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.

*****
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall a : ad, eq (MapGet A (MapCanonicalize A m) a) (MapGet A (M0 A) a)
+++++
simpl.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.

*****
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall a : ad, eq (MapGet A (MapCanonicalize A m) a) None
+++++
intros.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.

*****
a : ad
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A (MapCanonicalize A m) a) None
+++++
rewrite <- (mapcanon_exists_1 _ m).
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).

*****
a : ad
H : forall (a : key) (e : A), not (MapsTo a e m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m a) None
+++++
unfold MapsTo in *.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).
unfold MapsTo in *.

*****
a : ad
H : forall (a : key) (e : A), not (eq (find a m) (Some e))
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m a) None
+++++
unfold find in *.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).
unfold MapsTo in *.
unfold find in *.

*****
a : ad
H : forall (a : key) (e : A), not (eq (MapGet A m a) (Some e))
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m a) None
+++++
generalize (H a).
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).
unfold MapsTo in *.
unfold find in *.
generalize (H a).

*****
a : ad
H : forall (a : key) (e : A), not (eq (MapGet A m a) (Some e))
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall e : A, not (eq (MapGet A m a) (Some e)), eq (MapGet A m a) None
+++++
destruct (MapGet _ m a).
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).
unfold MapsTo in *.
unfold find in *.
generalize (H a).
destruct (MapGet _ m a).

*****
a0 : A
a : ad
H : forall (a : key) (e : A), not (eq (MapGet A m a) (Some e))
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall e : A, not (eq (Some a0) (Some e)), eq (Some a0) None
+++++
auto.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).
unfold MapsTo in *.
unfold find in *.
generalize (H a).
destruct (MapGet _ m a).
auto.

*****
a0 : A
a : ad
H : forall (a : key) (e : A), not (eq (MapGet A m a) (Some e))
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall e : A, not (eq (Some a0) (Some e)), eq (Some a0) None
+++++
intros.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).
unfold MapsTo in *.
unfold find in *.
generalize (H a).
destruct (MapGet _ m a).
auto.
intros.

*****
H0 : forall e : A, not (eq (Some a0) (Some e))
a0 : A
a : ad
H : forall (a : key) (e : A), not (eq (MapGet A m a) (Some e))
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (Some a0) None
+++++
generalize (H0 a0).
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).
unfold MapsTo in *.
unfold find in *.
generalize (H a).
destruct (MapGet _ m a).
auto.
intros.
generalize (H0 a0).

*****
H0 : forall e : A, not (eq (Some a0) (Some e))
a0 : A
a : ad
H : forall (a : key) (e : A), not (eq (MapGet A m a) (Some e))
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : not (eq (Some a0) (Some a0)), eq (Some a0) None
+++++
destruct 1.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).
unfold MapsTo in *.
unfold find in *.
generalize (H a).
destruct (MapGet _ m a).
auto.
intros.
generalize (H0 a0).
destruct 1.

*****
H0 : forall e : A, not (eq (Some a0) (Some e))
a0 : A
a : ad
H : forall (a : key) (e : A), not (eq (MapGet A m a) (Some e))
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (Some a0) (Some a0)
+++++
auto.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).
apply mapcanon_unique.
red.
red.
simpl.
intros.
rewrite <- (mapcanon_exists_1 _ m).
unfold MapsTo in *.
unfold find in *.
generalize (H a).
destruct (MapGet _ m a).

*****
a : ad
H : forall (a : key) (e : A), not (eq (MapGet A m a) (Some e))
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall e : A, not (eq None (Some e)), eq None None
+++++
auto.
-----
Lemma is_empty_1 : Empty m -> is_empty m = true.
Proof.
unfold Empty.
unfold is_empty.
unfold find.
intros.
cut (MapCanonicalize _ m = M0 _).

*****

*****

+++++
Qed.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (is_empty m) true, Empty m
+++++
Proof.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (is_empty m) true, Empty m
+++++
unfold Empty.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : eq (is_empty m) true) (a : key) (e : A), not (MapsTo a e m)
+++++
unfold is_empty.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : eq (MapEmptyp A (MapCanonicalize A m)) true) (a : key) (e : A), not (MapsTo a e m)
+++++
unfold MapsTo.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : eq (MapEmptyp A (MapCanonicalize A m)) true) (a : key) (e : A), not (eq (find a m) (Some e))
+++++
unfold find.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : eq (MapEmptyp A (MapCanonicalize A m)) true) (a : key) (e : A), not (eq (MapGet A m a) (Some e))
+++++
intros.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.
intros.

*****
e0 : A
a : key
H : eq (MapEmptyp A (MapCanonicalize A m)) true
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
not (eq (MapGet A m a) (Some e0))
+++++
generalize (MapEmptyp_complete _ _ H).
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.
intros.
generalize (MapEmptyp_complete _ _ H).

*****
e0 : A
a : key
H : eq (MapEmptyp A (MapCanonicalize A m)) true
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (MapCanonicalize A m) (M0 A), not (eq (MapGet A m a) (Some e0))
+++++
clear H.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.
intros.
generalize (MapEmptyp_complete _ _ H).
clear H.

*****
e0 : A
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (MapCanonicalize A m) (M0 A), not (eq (MapGet A m a) (Some e0))
+++++
intros.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.
intros.
generalize (MapEmptyp_complete _ _ H).
clear H.
intros.

*****
H : eq (MapCanonicalize A m) (M0 A)
e0 : A
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
not (eq (MapGet A m a) (Some e0))
+++++
rewrite (mapcanon_exists_1 _ m).
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.
intros.
generalize (MapEmptyp_complete _ _ H).
clear H.
intros.
rewrite (mapcanon_exists_1 _ m).

*****
H : eq (MapCanonicalize A m) (M0 A)
e0 : A
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
not (eq (MapGet A (MapCanonicalize A m) a) (Some e0))
+++++
rewrite H.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.
intros.
generalize (MapEmptyp_complete _ _ H).
clear H.
intros.
rewrite (mapcanon_exists_1 _ m).
rewrite H.

*****
H : eq (MapCanonicalize A m) (M0 A)
e0 : A
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
not (eq (MapGet A (M0 A) a) (Some e0))
+++++
simpl.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.
intros.
generalize (MapEmptyp_complete _ _ H).
clear H.
intros.
rewrite (mapcanon_exists_1 _ m).
rewrite H.
simpl.

*****
H : eq (MapCanonicalize A m) (M0 A)
e0 : A
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
not (eq None (Some e0))
+++++
auto.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.
intros.
generalize (MapEmptyp_complete _ _ H).
clear H.
intros.
rewrite (mapcanon_exists_1 _ m).
rewrite H.
simpl.
auto.

*****
H : eq (MapCanonicalize A m) (M0 A)
e0 : A
a : key
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
not (eq None (Some e0))
+++++
discriminate.
-----
Lemma is_empty_2 : is_empty m = true -> Empty m.
Proof.
unfold Empty.
unfold is_empty.
unfold MapsTo.
unfold find.
intros.
generalize (MapEmptyp_complete _ _ H).
clear H.
intros.
rewrite (mapcanon_exists_1 _ m).
rewrite H.
simpl.
auto.
discriminate.

*****

*****

+++++
Qed.
-----
Lemma mem_1 : In x m -> mem x m = true.
-----
Lemma mem_1 : In x m -> mem x m = true.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : In x m, eq (mem x m) true
+++++
Proof.
-----
Lemma mem_1 : In x m -> mem x m = true.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : In x m, eq (mem x m) true
+++++
unfold In.
-----
Lemma mem_1 : In x m -> mem x m = true.
Proof.
unfold In.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : ex (fun e : A => MapsTo x e m), eq (mem x m) true
+++++
unfold MapsTo.
-----
Lemma mem_1 : In x m -> mem x m = true.
Proof.
unfold In.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : ex (fun e : A => eq (find x m) (Some e)), eq (mem x m) true
+++++
unfold mem.
-----
Lemma mem_1 : In x m -> mem x m = true.
Proof.
unfold In.
unfold MapsTo.
unfold mem.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : ex (fun e : A => eq (find x m) (Some e)), eq match find x m with | Some _ => true | None => false end true
+++++
destruct (find x m).
-----
Lemma mem_1 : In x m -> mem x m = true.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
destruct (find x m).

*****
e,e',a : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : ex (fun e : A => eq (Some a) (Some e)), eq true true
+++++
auto.
-----
Lemma mem_1 : In x m -> mem x m = true.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
destruct (find x m).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : ex (fun e : A => eq None (Some e)), eq false true
+++++
auto.
-----
Lemma mem_1 : In x m -> mem x m = true.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
destruct (find x m).
auto.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : ex (fun e : A => eq None (Some e)), eq false true
+++++
destruct 1.
-----
Lemma mem_1 : In x m -> mem x m = true.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
destruct (find x m).
auto.
destruct 1.

*****
H : eq None (Some x0)
e,e',x0 : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
Logic.eq false true
+++++
discriminate.
-----
Lemma mem_1 : In x m -> mem x m = true.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
destruct (find x m).

*****

*****

+++++
Qed.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (m : t A) (x : key) (_ : eq (mem x m) true), In x m
+++++
Proof.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (m : t A) (x : key) (_ : eq (mem x m) true), In x m
+++++
unfold In.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (m : t A) (x : key) (_ : eq (mem x m) true), ex (fun e : A => MapsTo x e m)
+++++
unfold MapsTo.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (m : t A) (x : key) (_ : eq (mem x m) true), ex (fun e : A => eq (find x m) (Some e))
+++++
unfold mem.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.
unfold mem.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (m : t A) (x : key) (_ : eq match find x m with | Some _ => true | None => false end true), ex (fun e : A => eq (find x m) (Some e))
+++++
intros.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
intros.

*****
H : eq match find x0 m0 with\n | Some _ => true\n | None => false\n end true
x0 : key
m0 : t A
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
ex (fun e : A => eq (find x0 m0) (Some e))
+++++
destruct (find x0 m0).
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
intros.
destruct (find x0 m0).

*****
H : eq true true
a : A
x0 : key
m0 : t A
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
ex (fun e : A => eq (Some a) (Some e))
+++++
auto.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
intros.
destruct (find x0 m0).
auto.

*****
H : eq true true
a : A
x0 : key
m0 : t A
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
ex (fun e : A => eq (Some a) (Some e))
+++++
try discriminate.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
intros.
destruct (find x0 m0).
auto.
try discriminate.

*****
H : eq true true
a : A
x0 : key
m0 : t A
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
ex (fun e : A => eq (Some a) (Some e))
+++++
exists a.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
intros.
destruct (find x0 m0).
auto.
try discriminate.
exists a.

*****
H : eq true true
a : A
x0 : key
m0 : t A
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (Some a) (Some a)
+++++
auto.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
intros.
destruct (find x0 m0).

*****
H : Logic.eq false true
x0 : key
m0 : t A
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
ex (fun e : A => eq None (Some e))
+++++
auto.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
intros.
destruct (find x0 m0).
auto.

*****
H : Logic.eq false true
x0 : key
m0 : t A
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
ex (fun e : A => eq None (Some e))
+++++
try discriminate.
-----
Lemma mem_2 : forall m x, mem x m = true -> In x m.
Proof.
unfold In.
unfold MapsTo.
unfold mem.
intros.
destruct (find x0 m0).

*****

*****

+++++
Qed.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, MapsTo y e (add x e m)
+++++
Proof.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, MapsTo y e (add x e m)
+++++
unfold MapsTo.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, eq (find y (add x e m)) (Some e)
+++++
unfold find.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.
unfold MapsTo.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, eq (MapGet A (add x e m) y) (Some e)
+++++
unfold add.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.
unfold MapsTo.
unfold find.
unfold add.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, eq (MapGet A (MapPut A m x e) y) (Some e)
+++++
intro H.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intro H.

*****
H : E.eq x y
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A (MapPut A m x e) y) (Some e)
+++++
rewrite H.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intro H.
rewrite H.

*****
H : E.eq x y
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A (MapPut A m y e) y) (Some e)
+++++
clear H.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intro H.
rewrite H.
clear H.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A (MapPut A m y e) y) (Some e)
+++++
rewrite MapPut_semantics.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intro H.
rewrite H.
clear H.
rewrite MapPut_semantics.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (if N.eqb y y then Some e else MapGet A m y) (Some e)
+++++
rewrite Neqb_correct.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intro H.
rewrite H.
clear H.
rewrite MapPut_semantics.
rewrite Neqb_correct.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (Some e) (Some e)
+++++
auto.
-----
Lemma add_1 : E.eq x y -> MapsTo y e (add x e m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intro H.
rewrite H.
clear H.
rewrite MapPut_semantics.
rewrite Neqb_correct.
auto.

*****

*****

+++++
Qed.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : MapsTo y e m), MapsTo y e (add x e' m)
+++++
Proof.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : MapsTo y e m), MapsTo y e (add x e' m)
+++++
unfold MapsTo.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (find y m) (Some e)), eq (find y (add x e' m)) (Some e)
+++++
unfold find.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (MapGet A m y) (Some e)), eq (MapGet A (add x e' m) y) (Some e)
+++++
unfold add.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (MapGet A m y) (Some e)), eq (MapGet A (MapPut A m x e') y) (Some e)
+++++
intros.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A (MapPut A m x e') y) (Some e)
+++++
rewrite MapPut_semantics.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (if N.eqb x y then Some e' else MapGet A m y) (Some e)
+++++
rewrite H0.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (if N.eqb x y then Some e' else Some e) (Some e)
+++++
generalize (Neqb_complete x y).
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.
generalize (Neqb_complete x y).

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall _ : eq (N.eqb x y) true, eq x y, eq (if N.eqb x y then Some e' else Some e) (Some e)
+++++
destruct (Neqb x y).
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall _ : eq true true, eq x y, eq (Some e') (Some e)
+++++
auto.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall _ : eq true true, eq x y, eq (Some e') (Some e)
+++++
intros.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.

*****
H1 : forall _ : eq true true, eq x y
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (Some e') (Some e)
+++++
elim H.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.
elim H.

*****
H1 : forall _ : eq true true, eq x y
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
E.eq x y
+++++
auto.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.
elim H.
auto.

*****
H1 : forall _ : eq true true, eq x y
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
E.eq x y
+++++
apply H1.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.
elim H.
auto.
apply H1.

*****
H1 : forall _ : eq true true, eq x y
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq true true
+++++
auto.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall _ : eq false true, eq x y, eq (Some e) (Some e)
+++++
auto.
-----
Lemma add_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (add x e' m).
Proof.
unfold MapsTo.
unfold find.
unfold add.
intros.
rewrite MapPut_semantics.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).

*****

*****

+++++
Qed.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : MapsTo y e (add x e' m)), MapsTo y e m
+++++
Proof.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : MapsTo y e (add x e' m)), MapsTo y e m
+++++
unfold MapsTo.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (find y (add x e' m)) (Some e)), eq (find y m) (Some e)
+++++
unfold find.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (MapGet A (add x e' m) y) (Some e)), eq (MapGet A m y) (Some e)
+++++
unfold add.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (MapGet A (MapPut A m x e') y) (Some e)), eq (MapGet A m y) (Some e)
+++++
rewrite MapPut_semantics.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (if N.eqb x y then Some e' else MapGet A m y) (Some e)), eq (MapGet A m y) (Some e)
+++++
intro H.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.

*****
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (if N.eqb x y then Some e' else MapGet A m y) (Some e), eq (MapGet A m y) (Some e)
+++++
generalize (Neqb_complete x y).
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.
generalize (Neqb_complete x y).

*****
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : forall _ : eq (N.eqb x y) true, eq x y) (_ : eq (if N.eqb x y then Some e' else MapGet A m y) (Some e)), eq (MapGet A m y) (Some e)
+++++
destruct (Neqb x y).
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.
generalize (Neqb_complete x y).
destruct (Neqb x y).

*****
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : forall _ : eq true true, eq x y) (_ : eq (Some e') (Some e)), eq (MapGet A m y) (Some e)
+++++
auto.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.

*****
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : forall _ : eq true true, eq x y) (_ : eq (Some e') (Some e)), eq (MapGet A m y) (Some e)
+++++
intros.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.

*****
H1 : eq (Some e') (Some e)
H0 : forall _ : eq true true, eq x y
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m y) (Some e)
+++++
elim H.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.
elim H.

*****
H1 : eq (Some e') (Some e)
H0 : forall _ : eq true true, eq x y
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
E.eq x y
+++++
auto.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.
elim H.
auto.

*****
H1 : eq (Some e') (Some e)
H0 : forall _ : eq true true, eq x y
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
E.eq x y
+++++
apply H0.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.
elim H.
auto.
apply H0.

*****
H1 : eq (Some e') (Some e)
H0 : forall _ : eq true true, eq x y
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq true true
+++++
auto.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.
generalize (Neqb_complete x y).
destruct (Neqb x y).

*****
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : forall _ : eq false true, eq x y) (_ : eq (MapGet A m y) (Some e)), eq (MapGet A m y) (Some e)
+++++
auto.
-----
Lemma add_3 : ~ E.eq x y -> MapsTo y e (add x e' m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold add.
rewrite MapPut_semantics.
intro H.
generalize (Neqb_complete x y).
destruct (Neqb x y).

*****

*****

+++++
Qed.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, not (In y (remove x m))
+++++
Proof.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, not (In y (remove x m))
+++++
unfold In.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, not (ex (fun e : A => MapsTo y e (remove x m)))
+++++
unfold MapsTo.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, not (ex (fun e : A => eq (find y (remove x m)) (Some e)))
+++++
unfold find.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, not (ex (fun e : A => eq (MapGet A (remove x m) y) (Some e)))
+++++
unfold remove.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.
unfold find.
unfold remove.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, not (ex (fun e : A => eq (MapGet A (MapRemove A m x) y) (Some e)))
+++++
rewrite MapRemove_semantics.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : E.eq x y, not (ex (fun e : A => eq (if N.eqb x y then None else MapGet A m y) (Some e)))
+++++
intro H.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intro H.

*****
H : E.eq x y
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
not (ex (fun e : A => eq (if N.eqb x y then None else MapGet A m y) (Some e)))
+++++
rewrite H.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intro H.
rewrite H.

*****
H : E.eq x y
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
not (ex (fun e : A => eq (if N.eqb y y then None else MapGet A m y) (Some e)))
+++++
rewrite Neqb_correct.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intro H.
rewrite H.
rewrite Neqb_correct.

*****
H : E.eq x y
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
not (ex (fun e : A => eq None (Some e)))
+++++
red.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intro H.
rewrite H.
rewrite Neqb_correct.
red.

*****
H : E.eq x y
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : ex (fun e : A => eq None (Some e)), False
+++++
destruct 1.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intro H.
rewrite H.
rewrite Neqb_correct.
red.
destruct 1.

*****
H0 : eq None (Some x0)
x0 : A
H : E.eq x y
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
False
+++++
discriminate.
-----
Lemma remove_1 : E.eq x y -> ~ In y (remove x m).
Proof.
unfold In.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intro H.
rewrite H.
rewrite Neqb_correct.
red.
destruct 1.
discriminate.

*****

*****

+++++
Qed.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : MapsTo y e m), MapsTo y e (remove x m)
+++++
Proof.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : MapsTo y e m), MapsTo y e (remove x m)
+++++
unfold MapsTo.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (find y m) (Some e)), eq (find y (remove x m)) (Some e)
+++++
unfold find.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (MapGet A m y) (Some e)), eq (MapGet A (remove x m) y) (Some e)
+++++
unfold remove.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (MapGet A m y) (Some e)), eq (MapGet A (MapRemove A m x) y) (Some e)
+++++
rewrite MapRemove_semantics.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : not (E.eq x y)) (_ : eq (MapGet A m y) (Some e)), eq (if N.eqb x y then None else MapGet A m y) (Some e)
+++++
intros.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (if N.eqb x y then None else MapGet A m y) (Some e)
+++++
rewrite H0.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.
rewrite H0.

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (if N.eqb x y then None else Some e) (Some e)
+++++
generalize (Neqb_complete x y).
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.
rewrite H0.
generalize (Neqb_complete x y).

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall _ : eq (N.eqb x y) true, eq x y, eq (if N.eqb x y then None else Some e) (Some e)
+++++
destruct (Neqb x y).
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall _ : eq true true, eq x y, eq None (Some e)
+++++
auto.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall _ : eq true true, eq x y, eq None (Some e)
+++++
intros.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.

*****
H1 : forall _ : eq true true, eq x y
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq None (Some e)
+++++
elim H.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.
elim H.

*****
H1 : forall _ : eq true true, eq x y
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
E.eq x y
+++++
apply H1.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).
auto.
intros.
elim H.
apply H1.

*****
H1 : forall _ : eq true true, eq x y
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq true true
+++++
auto.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).

*****
H0 : eq (MapGet A m y) (Some e)
H : not (E.eq x y)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : forall _ : eq false true, eq x y, eq (Some e) (Some e)
+++++
auto.
-----
Lemma remove_2 : ~ E.eq x y -> MapsTo y e m -> MapsTo y e (remove x m).
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
intros.
rewrite H0.
generalize (Neqb_complete x y).
destruct (Neqb x y).

*****

*****

+++++
Qed.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : MapsTo y e (remove x m), MapsTo y e m
+++++
Proof.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : MapsTo y e (remove x m), MapsTo y e m
+++++
unfold MapsTo.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (find y (remove x m)) (Some e), eq (find y m) (Some e)
+++++
unfold find.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (MapGet A (remove x m) y) (Some e), eq (MapGet A m y) (Some e)
+++++
unfold remove.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold remove.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (MapGet A (MapRemove A m x) y) (Some e), eq (MapGet A m y) (Some e)
+++++
rewrite MapRemove_semantics.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (if N.eqb x y then None else MapGet A m y) (Some e), eq (MapGet A m y) (Some e)
+++++
destruct (Neqb x y).
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
destruct (Neqb x y).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq None (Some e), eq (MapGet A m y) (Some e)
+++++
intros.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
destruct (Neqb x y).
intros.

*****
H : eq None (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m y) (Some e)
+++++
auto.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
destruct (Neqb x y).
intros.
auto.

*****
H : eq None (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m y) (Some e)
+++++
discriminate.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
destruct (Neqb x y).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (MapGet A m y) (Some e), eq (MapGet A m y) (Some e)
+++++
intros.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
destruct (Neqb x y).
intros.

*****
H : eq (MapGet A m y) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m y) (Some e)
+++++
auto.
-----
Lemma remove_3 : MapsTo y e (remove x m) -> MapsTo y e m.
Proof.
unfold MapsTo.
unfold find.
unfold remove.
rewrite MapRemove_semantics.
destruct (Neqb x y).

*****

*****

+++++
Qed.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (l : alist A) (_ : eq (alist_sorted A l) true), Sorted lt_key l
+++++
Proof.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (l : alist A) (_ : eq (alist_sorted A l) true), Sorted lt_key l
+++++
induction l.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (alist_sorted A nil) true, Sorted lt_key nil
+++++
auto.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.

*****
IHl : forall _ : eq (alist_sorted A l) true, Sorted lt_key l
l : list (prod ad A)
a : prod ad A
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (alist_sorted A (cons a l)) true, Sorted lt_key (cons a l)
+++++
simpl.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.
simpl.

*****
IHl : forall _ : eq (alist_sorted A l) true, Sorted lt_key l
l : list (prod ad A)
a : prod ad A
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (let (a, _) := a in match l with | nil => true | cons (pair a' _) _ => andb (Nless a a') (alist_sorted A l) end) true, Sorted lt_key (cons a l)
+++++
destruct a.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.
simpl.
destruct a.

*****
IHl : forall _ : eq (alist_sorted A l) true, Sorted lt_key l
l : list (prod ad A)
a0 : A
a : ad
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq match l with | nil => true | cons (pair a' _) _ => andb (Nless a a') (alist_sorted A l) end true, Sorted lt_key (cons (pair a a0) l)
+++++
destruct l.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.
simpl.
destruct a.
destruct l.

*****
IHl : forall _ : eq (alist_sorted A nil) true, Sorted lt_key nil
a0 : A
a : ad
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq true true, Sorted lt_key (cons (pair a a0) nil)
+++++
auto.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.
simpl.
destruct a.
destruct l.

*****
IHl : forall _ : eq (alist_sorted A (cons p l)) true,\nSorted lt_key (cons p l)
l : list (prod ad A)
p : prod ad A
a0 : A
a : ad
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (let (a', _) := p in andb (Nless a a') (alist_sorted A (cons p l))) true, Sorted lt_key (cons (pair a a0) (cons p l))
+++++
destruct p.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.
simpl.
destruct a.
destruct l.
destruct p.

*****
IHl : forall _ : eq (alist_sorted A (cons (pair a1 a2) l)) true,\nSorted lt_key (cons (pair a1 a2) l)
l : list (prod ad A)
a2 : A
a1 : ad
a0 : A
a : ad
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (andb (Nless a a1) (alist_sorted A (cons (pair a1 a2) l))) true, Sorted lt_key (cons (pair a a0) (cons (pair a1 a2) l))
+++++
intros.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.
simpl.
destruct a.
destruct l.
destruct p.
intros.

*****
H : eq (andb (Nless a a1) (alist_sorted A (cons (pair a1 a2) l))) true
IHl : forall _ : eq (alist_sorted A (cons (pair a1 a2) l)) true,\nSorted lt_key (cons (pair a1 a2) l)
l : list (prod ad A)
a2 : A
a1 : ad
a0 : A
a : ad
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
Sorted lt_key (cons (pair a a0) (cons (pair a1 a2) l))
+++++
destruct (andb_prop _ _ H).
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.
simpl.
destruct a.
destruct l.
destruct p.
intros.
destruct (andb_prop _ _ H).

*****
H1 : eq (alist_sorted A (cons (pair a1 a2) l)) true
H0 : eq (Nless a a1) true
H : eq (andb (Nless a a1) (alist_sorted A (cons (pair a1 a2) l))) true
IHl : forall _ : eq (alist_sorted A (cons (pair a1 a2) l)) true,\nSorted lt_key (cons (pair a1 a2) l)
l : list (prod ad A)
a2 : A
a1 : ad
a0 : A
a : ad
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
Sorted lt_key (cons (pair a a0) (cons (pair a1 a2) l))
+++++
auto.
-----
Lemma alist_sorted_sort : forall l, alist_sorted A l=true -> sort lt_key l.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma elements_3 : sort lt_key (elements m).
-----
Lemma elements_3 : sort lt_key (elements m).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
Sorted lt_key (elements m)
+++++
Proof.
-----
Lemma elements_3 : sort lt_key (elements m).
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
Sorted lt_key (elements m)
+++++
unfold elements.
-----
Lemma elements_3 : sort lt_key (elements m).
Proof.
unfold elements.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
Sorted lt_key (alist_of_Map A m)
+++++
apply alist_sorted_sort.
-----
Lemma elements_3 : sort lt_key (elements m).
Proof.
unfold elements.
apply alist_sorted_sort.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (alist_sorted A (alist_of_Map A m)) true
+++++
apply alist_of_Map_sorts.
-----
Lemma elements_3 : sort lt_key (elements m).
Proof.
unfold elements.
apply alist_sorted_sort.
apply alist_of_Map_sorts.

*****

*****

+++++
Qed.
-----
Lemma elements_3w : NoDupA eq_key (elements m).
-----
Lemma elements_3w : NoDupA eq_key (elements m).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
NoDupA eq_key (elements m)
+++++
Proof.
-----
Lemma elements_3w : NoDupA eq_key (elements m).
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
NoDupA eq_key (elements m)
+++++
change eq_key with (@PE.eqk A).
-----
Lemma elements_3w : NoDupA eq_key (elements m).
Proof.
change eq_key with (@PE.eqk A).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
NoDupA (PE.eqk (elt:=A)) (elements m)
+++++
apply PE.Sort_NoDupA.
-----
Lemma elements_3w : NoDupA eq_key (elements m).
Proof.
change eq_key with (@PE.eqk A).
apply PE.Sort_NoDupA.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
Sorted (PE.ltk (elt:=A)) (elements m)
+++++
apply elements_3.
-----
Lemma elements_3w : NoDupA eq_key (elements m).
Proof.
change eq_key with (@PE.eqk A).
apply PE.Sort_NoDupA.
apply elements_3.

*****

*****

+++++
Qed.
-----
Lemma elements_1 : \n     MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : MapsTo x e m, InA eq_key_elt (pair x e) (elements m)
+++++
Proof.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : MapsTo x e m, InA eq_key_elt (pair x e) (elements m)
+++++
unfold MapsTo.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (find x m) (Some e), InA eq_key_elt (pair x e) (elements m)
+++++
unfold find.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (MapGet A m x) (Some e), InA eq_key_elt (pair x e) (elements m)
+++++
unfold elements.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (MapGet A m x) (Some e), InA eq_key_elt (pair x e) (alist_of_Map A m)
+++++
rewrite InA_alt.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (MapGet A m x) (Some e), ex (fun y : prod key A => and (eq_key_elt (pair x e) y) (List.In y (alist_of_Map A m)))
+++++
intro H.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.

*****
H : eq (MapGet A m x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
ex (fun y : prod key A => and (eq_key_elt (pair x e) y) (List.In y (alist_of_Map A m)))
+++++
exists (x,e).
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).

*****
H : eq (MapGet A m x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
and (eq_key_elt (pair x e) (pair x e)) (List.In (pair x e) (alist_of_Map A m))
+++++
split.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.

*****
H : eq (MapGet A m x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq_key_elt (pair x e) (pair x e)
+++++
red.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
red.

*****
H : eq (MapGet A m x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
and (E.eq (fst (pair x e)) (fst (pair x e))) (eq (snd (pair x e)) (snd (pair x e)))
+++++
simpl.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
red.
simpl.

*****
H : eq (MapGet A m x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
and (E.eq x x) (eq e e)
+++++
unfold E.eq.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
red.
simpl.
unfold E.eq.

*****
H : eq (MapGet A m x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
and (eq x x) (eq e e)
+++++
auto.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.

*****
H : eq (MapGet A m x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
List.In (pair x e) (alist_of_Map A m)
+++++
rewrite alist_of_Map_semantics in H.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.

*****
H : eq (alist_semantics A (alist_of_Map A m) x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
List.In (pair x e) (alist_of_Map A m)
+++++
generalize H.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.

*****
H : eq (alist_semantics A (alist_of_Map A m) x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (alist_semantics A (alist_of_Map A m) x) (Some e), List.In (pair x e) (alist_of_Map A m)
+++++
set (l:=alist_of_Map A m).
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).

*****
l : alist A
H : eq (alist_semantics A (alist_of_Map A m) x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
+++++
clearbody l.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.

*****
l : alist A
H : eq (alist_semantics A (alist_of_Map A m) x) (Some e)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
+++++
clear.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.

*****
l : alist A
e : A
x : key
A : Type
*****
forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
+++++
induction l.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.

*****
e : A
x : key
A : Type
*****
forall _ : eq (alist_semantics A nil x) (Some e), List.In (pair x e) nil
+++++
simpl.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.

*****
e : A
x : key
A : Type
*****
forall _ : eq None (Some e), False
+++++
auto.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.

*****
e : A
x : key
A : Type
*****
forall _ : eq None (Some e), False
+++++
intro.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intro.

*****
H : eq None (Some e)
e : A
x : key
A : Type
*****
False
+++++
discriminate.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a : prod ad A
e : A
x : key
A : Type
*****
forall _ : eq (alist_semantics A (cons a l) x) (Some e), List.In (pair x e) (cons a l)
+++++
simpl.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a : prod ad A
e : A
x : key
A : Type
*****
forall _ : eq ((let (a, y) := a in fun a0 : ad => if N.eqb a a0 then Some y else alist_semantics A l a0) x) (Some e), or (eq a (pair x e)) (List.In (pair x e) l)
+++++
auto.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a : prod ad A
e : A
x : key
A : Type
*****
forall _ : eq ((let (a, y) := a in fun a0 : ad => if N.eqb a a0 then Some y else alist_semantics A l a0) x) (Some e), or (eq a (pair x e)) (List.In (pair x e) l)
+++++
destruct a.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
forall _ : eq (if N.eqb a x then Some a0 else alist_semantics A l x) (Some e), or (eq (pair a a0) (pair x e)) (List.In (pair x e) l)
+++++
simpl.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
forall _ : eq (if N.eqb a x then Some a0 else alist_semantics A l x) (Some e), or (eq (pair a a0) (pair x e)) (List.In (pair x e) l)
+++++
auto.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
forall _ : eq (if N.eqb a x then Some a0 else alist_semantics A l x) (Some e), or (eq (pair a a0) (pair x e)) (List.In (pair x e) l)
+++++
generalize (Neqb_complete a x).
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
forall (_ : forall _ : eq (N.eqb a x) true, eq a x) (_ : eq (if N.eqb a x then Some a0 else alist_semantics A l x) (Some e)), or (eq (pair a a0) (pair x e)) (List.In (pair x e) l)
+++++
destruct (Neqb a x).
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).
destruct (Neqb a x).

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
forall (_ : forall _ : eq true true, eq a x) (_ : eq (Some a0) (Some e)), or (eq (pair a a0) (pair x e)) (List.In (pair x e) l)
+++++
auto.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).
destruct (Neqb a x).
auto.

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
forall (_ : forall _ : eq true true, eq a x) (_ : eq (Some a0) (Some e)), or (eq (pair a a0) (pair x e)) (List.In (pair x e) l)
+++++
left.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).
destruct (Neqb a x).
auto.
left.

*****
H0 : eq (Some a0) (Some e)
H : forall _ : eq true true, eq a x
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
eq (pair a a0) (pair x e)
+++++
injection H0.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).
destruct (Neqb a x).
auto.
left.
injection H0.

*****
H0 : eq (Some a0) (Some e)
H : forall _ : eq true true, eq a x
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
forall _ : eq a0 e, eq (pair a a0) (pair x e)
+++++
auto.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).
destruct (Neqb a x).
auto.
left.
injection H0.
auto.

*****
H0 : eq (Some a0) (Some e)
H : forall _ : eq true true, eq a x
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
forall _ : eq a0 e, eq (pair a a0) (pair x e)
+++++
intros.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).
destruct (Neqb a x).
auto.
left.
injection H0.
auto.
intros.

*****
H1 : eq a0 e
H0 : eq (Some a0) (Some e)
H : forall _ : eq true true, eq a x
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
eq (pair a a0) (pair x e)
+++++
f_equal.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).
destruct (Neqb a x).
auto.
left.
injection H0.
auto.
intros.
f_equal.

*****
H1 : eq a0 e
H0 : eq (Some a0) (Some e)
H : forall _ : eq true true, eq a x
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
eq a x
+++++
auto.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).
destruct (Neqb a x).
auto.
left.
injection H0.
auto.
intros.
f_equal.

*****
H1 : eq a0 e
H0 : eq (Some a0) (Some e)
H : forall _ : eq true true, eq a x
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
eq a0 e
+++++
auto.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.
rewrite alist_of_Map_semantics in H.
generalize H.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
destruct a.
simpl.
auto.
generalize (Neqb_complete a x).
destruct (Neqb a x).

*****
IHl : forall _ : eq (alist_semantics A l x) (Some e), List.In (pair x e) l
l : list (prod ad A)
a0 : A
a : ad
e : A
x : key
A : Type
*****
forall (_ : forall _ : eq false true, eq a x) (_ : eq (alist_semantics A l x) (Some e)), or (eq (pair a a0) (pair x e)) (List.In (pair x e) l)
+++++
auto.
-----
Lemma elements_1 : MapsTo x e m -> InA eq_key_elt (x,e) (elements m).
Proof.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intro H.
exists (x,e).
split.

*****

*****

+++++
Qed.
-----
Lemma elements_2 : \n     InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : InA eq_key_elt (pair x e) (elements m), MapsTo x e m
+++++
Proof.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall _ : InA eq_key_elt (pair x e) (elements m), MapsTo x e m
+++++
generalize elements_3.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : Sorted lt_key (elements m)) (_ : InA eq_key_elt (pair x e) (elements m)), MapsTo x e m
+++++
unfold MapsTo.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : Sorted lt_key (elements m)) (_ : InA eq_key_elt (pair x e) (elements m)), eq (find x m) (Some e)
+++++
unfold find.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : Sorted lt_key (elements m)) (_ : InA eq_key_elt (pair x e) (elements m)), eq (MapGet A m x) (Some e)
+++++
unfold elements.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : Sorted lt_key (alist_of_Map A m)) (_ : InA eq_key_elt (pair x e) (alist_of_Map A m)), eq (MapGet A m x) (Some e)
+++++
rewrite InA_alt.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : Sorted lt_key (alist_of_Map A m)) (_ : ex (fun y : prod key A => and (eq_key_elt (pair x e) y) (List.In y (alist_of_Map A m)))), eq (MapGet A m x) (Some e)
+++++
intros H ((e0,a),(H0,H1)).
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).

*****
H1 : List.In (pair e0 a) (alist_of_Map A m)
H0 : eq_key_elt (pair x e) (pair e0 a)
a : A
e0 : key
H : Sorted lt_key (alist_of_Map A m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m x) (Some e)
+++++
red in H0.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.

*****
H1 : List.In (pair e0 a) (alist_of_Map A m)
H0 : and (E.eq (fst (pair x e)) (fst (pair e0 a)))\n (eq (snd (pair x e)) (snd (pair e0 a)))
a : A
e0 : key
H : Sorted lt_key (alist_of_Map A m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m x) (Some e)
+++++
simpl in H0.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.

*****
H1 : List.In (pair e0 a) (alist_of_Map A m)
H0 : and (E.eq x e0) (eq e a)
a : A
e0 : key
H : Sorted lt_key (alist_of_Map A m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m x) (Some e)
+++++
unfold E.eq in H0.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.

*****
H1 : List.In (pair e0 a) (alist_of_Map A m)
H0 : and (eq x e0) (eq e a)
a : A
e0 : key
H : Sorted lt_key (alist_of_Map A m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m x) (Some e)
+++++
destruct H0.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.

*****
H1 : List.In (pair e0 a) (alist_of_Map A m)
H2 : eq e a
H0 : eq x e0
a : A
e0 : key
H : Sorted lt_key (alist_of_Map A m)
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m x) (Some e)
+++++
subst.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.

*****
H1 : List.In (pair e0 a) (alist_of_Map A m)
a : A
e0 : key
H : Sorted lt_key (alist_of_Map A m)
e' : A
y,z : key
m,m',m'' : t A
A : Type
*****
eq (MapGet A m e0) (Some a)
+++++
rewrite alist_of_Map_semantics.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.

*****
H1 : List.In (pair e0 a) (alist_of_Map A m)
a : A
e0 : key
H : Sorted lt_key (alist_of_Map A m)
e' : A
y,z : key
m,m',m'' : t A
A : Type
*****
eq (alist_semantics A (alist_of_Map A m) e0) (Some a)
+++++
generalize H H1.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.

*****
H1 : List.In (pair e0 a) (alist_of_Map A m)
a : A
e0 : key
H : Sorted lt_key (alist_of_Map A m)
e' : A
y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : Sorted lt_key (alist_of_Map A m)) (_ : List.In (pair e0 a) (alist_of_Map A m)), eq (alist_semantics A (alist_of_Map A m) e0) (Some a)
+++++
clear H H1.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.

*****
a : A
e0 : key
e' : A
y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : Sorted lt_key (alist_of_Map A m)) (_ : List.In (pair e0 a) (alist_of_Map A m)), eq (alist_semantics A (alist_of_Map A m) e0) (Some a)
+++++
set (l:=alist_of_Map A m).
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).

*****
l : alist A
a : A
e0 : key
e' : A
y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l), eq (alist_semantics A l e0) (Some a)
+++++
clearbody l.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.

*****
l : alist A
a : A
e0 : key
e' : A
y,z : key
m,m',m'' : t A
A : Type
*****
forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l), eq (alist_semantics A l e0) (Some a)
+++++
clear.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.

*****
l : alist A
a : A
e0 : key
A : Type
*****
forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l), eq (alist_semantics A l e0) (Some a)
+++++
induction l.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.

*****
a : A
e0 : key
A : Type
*****
forall (_ : Sorted lt_key nil) (_ : List.In (pair e0 a) nil), eq (alist_semantics A nil e0) (Some a)
+++++
simpl.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.

*****
a : A
e0 : key
A : Type
*****
forall (_ : Sorted lt_key nil) (_ : False), eq None (Some a)
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.

*****
a : A
e0 : key
A : Type
*****
forall (_ : Sorted lt_key nil) (_ : False), eq None (Some a)
+++++
intro.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intro.

*****
H : Sorted lt_key nil
a : A
e0 : key
A : Type
*****
forall _ : False, eq None (Some a)
+++++
contradiction.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.

*****
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a0 : prod ad A
a : A
e0 : key
A : Type
*****
forall (_ : Sorted lt_key (cons a0 l)) (_ : List.In (pair e0 a) (cons a0 l)), eq (alist_semantics A (cons a0 l) e0) (Some a)
+++++
simpl.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.

*****
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a0 : prod ad A
a : A
e0 : key
A : Type
*****
forall (_ : Sorted lt_key (cons a0 l)) (_ : or (eq a0 (pair e0 a)) (List.In (pair e0 a) l)), eq ((let (a, y) := a0 in fun a0 : ad => if N.eqb a a0 then Some y else alist_semantics A l a0) e0) (Some a)
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.

*****
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a0 : prod ad A
a : A
e0 : key
A : Type
*****
forall (_ : Sorted lt_key (cons a0 l)) (_ : or (eq a0 (pair e0 a)) (List.In (pair e0 a) l)), eq ((let (a, y) := a0 in fun a0 : ad => if N.eqb a a0 then Some y else alist_semantics A l a0) e0) (Some a)
+++++
intros.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.

*****
H1 : or (eq a0 (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons a0 l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a0 : prod ad A
a : A
e0 : key
A : Type
*****
eq ((let (a, y) := a0 in fun a0 : ad => if N.eqb a a0 then Some y else alist_semantics A l a0) e0) (Some a)
+++++
destruct a0.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.

*****
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
simpl.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.

*****
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
inversion H1.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.

*****
H0 : eq (pair a0 a1) (pair e0 a)
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
injection H0.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
injection H0.

*****
H0 : eq (pair a0 a1) (pair e0 a)
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall (_ : eq a1 a) (_ : eq a0 e0), eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
intros.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
injection H0.
intros.

*****
H3 : eq a0 e0
H2 : eq a1 a
H0 : eq (pair a0 a1) (pair e0 a)
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
subst.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
injection H0.
intros.
subst.

*****
H0 : eq (pair e0 a) (pair e0 a)
H1 : or (eq (pair e0 a) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair e0 a) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a : A
e0 : key
A : Type
*****
eq (if N.eqb e0 e0 then Some a else alist_semantics A l e0) (Some a)
+++++
rewrite Neqb_correct.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
injection H0.
intros.
subst.
rewrite Neqb_correct.

*****
H0 : eq (pair e0 a) (pair e0 a)
H1 : or (eq (pair e0 a) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair e0 a) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a : A
e0 : key
A : Type
*****
eq (Some a) (Some a)
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
assert (InA eq_key (e0,a) l).
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
InA eq_key (pair e0 a) l
+++++
rewrite InA_alt.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
rewrite InA_alt.

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
ex (fun y : prod key A => and (eq_key (pair e0 a) y) (List.In y l))
+++++
exists (e0,a).
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
rewrite InA_alt.
exists (e0,a).

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
and (eq_key (pair e0 a) (pair e0 a)) (List.In (pair e0 a) l)
+++++
split.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
rewrite InA_alt.
exists (e0,a).
split.

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq_key (pair e0 a) (pair e0 a)
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
rewrite InA_alt.
exists (e0,a).
split.
auto.

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq_key (pair e0 a) (pair e0 a)
+++++
red.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
rewrite InA_alt.
exists (e0,a).
split.
auto.
red.

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
E.eq (fst (pair e0 a)) (fst (pair e0 a))
+++++
simpl.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
rewrite InA_alt.
exists (e0,a).
split.
auto.
red.
simpl.

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
E.eq e0 e0
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
rewrite InA_alt.
exists (e0,a).
split.
auto.
red.
simpl.
auto.

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
E.eq e0 e0
+++++
red.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
rewrite InA_alt.
exists (e0,a).
split.
auto.
red.
simpl.
auto.
red.

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq e0 e0
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
rewrite InA_alt.
exists (e0,a).
split.

*****
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
List.In (pair e0 a) l
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).

*****
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
generalize (PE.Sort_In_cons_1 H H2).
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).

*****
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall _ : PE.ltk (pair a0 a1) (pair e0 a), eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
unfold PE.ltk.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.

*****
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall _ : eq (Nless (fst (pair a0 a1)) (fst (pair e0 a))) true, eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
simpl.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.

*****
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall _ : eq (Nless a0 e0) true, eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
intros H3.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.

*****
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
generalize (E.lt_not_eq H3).
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.
generalize (E.lt_not_eq H3).

*****
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall _ : not (E.eq a0 e0), eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
generalize (Neqb_complete a0 e0).
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.
generalize (E.lt_not_eq H3).
generalize (Neqb_complete a0 e0).

*****
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall (_ : forall _ : eq (N.eqb a0 e0) true, eq a0 e0) (_ : not (E.eq a0 e0)), eq (if N.eqb a0 e0 then Some a1 else alist_semantics A l e0) (Some a)
+++++
destruct (Neqb a0 e0).
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.
generalize (E.lt_not_eq H3).
generalize (Neqb_complete a0 e0).
destruct (Neqb a0 e0).

*****
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall (_ : forall _ : eq true true, eq a0 e0) (_ : not (E.eq a0 e0)), eq (Some a1) (Some a)
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.
generalize (E.lt_not_eq H3).
generalize (Neqb_complete a0 e0).
destruct (Neqb a0 e0).
auto.

*****
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall (_ : forall _ : eq true true, eq a0 e0) (_ : not (E.eq a0 e0)), eq (Some a1) (Some a)
+++++
destruct 2.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.
generalize (E.lt_not_eq H3).
generalize (Neqb_complete a0 e0).
destruct (Neqb a0 e0).
auto.
destruct 2.

*****
H4 : forall _ : eq true true, eq a0 e0
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
E.eq a0 e0
+++++
apply H4.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.
generalize (E.lt_not_eq H3).
generalize (Neqb_complete a0 e0).
destruct (Neqb a0 e0).
auto.
destruct 2.
apply H4.

*****
H4 : forall _ : eq true true, eq a0 e0
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
eq true true
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.
generalize (E.lt_not_eq H3).
generalize (Neqb_complete a0 e0).
destruct (Neqb a0 e0).

*****
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall (_ : forall _ : eq false true, eq a0 e0) (_ : not (E.eq a0 e0)), eq (alist_semantics A l e0) (Some a)
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.
generalize (E.lt_not_eq H3).
generalize (Neqb_complete a0 e0).
destruct (Neqb a0 e0).
auto.

*****
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall (_ : forall _ : eq false true, eq a0 e0) (_ : not (E.eq a0 e0)), eq (alist_semantics A l e0) (Some a)
+++++
inversion H.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.
simpl.
auto.
intros.
destruct a0.
simpl.
inversion H1.
assert (InA eq_key (e0,a) l).
generalize (PE.Sort_In_cons_1 H H2).
unfold PE.ltk.
simpl.
intros H3.
generalize (E.lt_not_eq H3).
generalize (Neqb_complete a0 e0).
destruct (Neqb a0 e0).
auto.
inversion H.

*****
H5 : eq l0 l
H4 : eq a2 (pair a0 a1)
H7 : HdRel lt_key (pair a0 a1) l
H6 : Sorted lt_key l
l0 : list (prod key A)
a2 : prod key A
H3 : eq (Nless a0 e0) true
H2 : InA eq_key (pair e0 a) l
H0 : List.In (pair e0 a) l
H1 : or (eq (pair a0 a1) (pair e0 a)) (List.In (pair e0 a) l)
H : Sorted lt_key (cons (pair a0 a1) l)
IHl : forall (_ : Sorted lt_key l) (_ : List.In (pair e0 a) l),\neq (alist_semantics A l e0) (Some a)
l : list (prod ad A)
a1 : A
a0 : ad
a : A
e0 : key
A : Type
*****
forall (_ : forall _ : eq false true, eq a0 e0) (_ : not (E.eq a0 e0)), eq (alist_semantics A l e0) (Some a)
+++++
auto.
-----
Lemma elements_2 : InA eq_key_elt (x,e) (elements m) -> MapsTo x e m.
Proof.
generalize elements_3.
unfold MapsTo.
unfold find.
unfold elements.
rewrite InA_alt.
intros H ((e0,a),(H0,H1)).
red in H0.
simpl in H0.
unfold E.eq in H0.
destruct H0.
subst.
rewrite alist_of_Map_semantics.
generalize H H1.
clear H H1.
set (l:=alist_of_Map A m).
clearbody l.
clear.
induction l.

*****

*****

+++++
Qed.
-----
Lemma cardinal_1 : forall m, cardinal m = length (elements m).
-----
Lemma cardinal_1 : forall m, cardinal m = length (elements m).

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall m : t A, eq (cardinal m) (length (elements m))
+++++
Proof.
-----
Lemma cardinal_1 : forall m, cardinal m = length (elements m).
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall m : t A, eq (cardinal m) (length (elements m))
+++++
exact (@MapCard_as_length _).
-----
Lemma cardinal_1 : forall m, cardinal m = length (elements m).
Proof.
exact (@MapCard_as_length _).

*****

*****

+++++
Qed.
-----
Definition Equal m m' := forall y, find y m = find y m'.
-----
Definition Equiv (eq_elt:A->A->Prop) m m' := \n    (forall k, In k m <-> In k m') /\ \n    (forall k e e', MapsTo k e m -> MapsTo k e' m' -> eq_elt e e').
-----
Definition Equivb (cmp: A->A->bool) := Equiv (Cmp cmp).
-----
Definition fold (B:Type)(f:key -> A -> B -> B)(m:t A)(i:B) : B := \n    fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
-----
Lemma fold_1 :\n	forall (B:Type) (i : B) (f : key -> A -> B -> B),\n        fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
-----
Lemma fold_1 : forall (B:Type) (i : B) (f : key -> A -> B -> B), fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (B : Type) (i : B) (f : forall (_ : key) (_ : A) (_ : B), B), eq (fold f m i) (fold_left (fun (a : B) (p : prod key A) => f (fst p) (snd p) a) (elements m) i)
+++++
Proof.
-----
Lemma fold_1 : forall (B:Type) (i : B) (f : key -> A -> B -> B), fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
Proof.

*****
e,e' : A
x,y,z : key
m,m',m'' : t A
A : Type
*****
forall (B : Type) (i : B) (f : forall (_ : key) (_ : A) (_ : B), B), eq (fold f m i) (fold_left (fun (a : B) (p : prod key A) => f (fst p) (snd p) a) (elements m) i)
+++++
auto.
-----
Lemma fold_1 : forall (B:Type) (i : B) (f : key -> A -> B -> B), fold f m i = fold_left (fun a p => f (fst p) (snd p) a) (elements m) i.
Proof.
auto.

*****

*****

+++++
Qed.
-----
End Spec.
-----
Variable B : Type.
-----
Fixpoint mapi_aux (pf:N->N)(f : N -> A -> B)(m:t A) { struct m }: t B := \n    match m with \n      | M0 => M0 _ \n      | M1 x y => M1 _ x (f (pf x) y)\n      | M2 m0 m1 =>  M2 _ (mapi_aux (fun n => pf (Ndouble n)) f m0)\n                                         (mapi_aux (fun n => pf (Ndouble_plus_one n)) f m1)\n    end.
-----
Definition mapi := mapi_aux (fun n => n).
-----
Definition map (f:A->B) := mapi (fun _ => f).
-----
End A.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt)\n        (f:key->elt->elt'), MapsTo x e m -> \n        exists y, E.eq y x /\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).

*****

*****
forall (elt elt' : Type) (m : t elt) (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : MapsTo x e m), ex (fun y : N => and (E.eq y x) (MapsTo x (f (pf y) e) (mapi_aux pf f m)))
+++++
Proof.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.

*****

*****
forall (elt elt' : Type) (m : t elt) (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : MapsTo x e m), ex (fun y : N => and (E.eq y x) (MapsTo x (f (pf y) e) (mapi_aux pf f m)))
+++++
unfold MapsTo.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.

*****

*****
forall (elt elt' : Type) (m : t elt) (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m) (Some e)), ex (fun y : N => and (E.eq y x) (eq (find x (mapi_aux pf f m)) (Some (f (pf y) e))))
+++++
induction m.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.

*****
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x (M0 elt)) (Some e)), ex (fun y : N => and (E.eq y x) (eq (find x (mapi_aux pf f (M0 elt))) (Some (f (pf y) e))))
+++++
simpl.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.

*****
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq None (Some e)), ex (fun y : N => and (E.eq y x) (eq None (Some (f (pf y) e))))
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.

*****
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq None (Some e)), ex (fun y : N => and (E.eq y x) (eq None (Some (f (pf y) e))))
+++++
inversion 1.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.

*****
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x (M1 elt a a0)) (Some e)), ex (fun y : N => and (E.eq y x) (eq (find x (mapi_aux pf f (M1 elt a a0))) (Some (f (pf y) e))))
+++++
simpl.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.

*****
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq (if N.eqb a x then Some a0 else None) (Some e)), ex (fun y : N => and (E.eq y x) (eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some (f (pf y) e))))
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.

*****
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq (if N.eqb a x then Some a0 else None) (Some e)), ex (fun y : N => and (E.eq y x) (eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some (f (pf y) e))))
+++++
intros.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.

*****
H : eq (if N.eqb a x then Some a0 else None) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
ex (fun y : N => and (E.eq y x) (eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some (f (pf y) e))))
+++++
exists x.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.

*****
H : eq (if N.eqb a x then Some a0 else None) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
and (E.eq x x) (eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some (f (pf x) e)))
+++++
split.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.

*****
H : eq (if N.eqb a x then Some a0 else None) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
E.eq x x
+++++
red.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
red.

*****
H : eq (if N.eqb a x then Some a0 else None) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
eq x x
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.

*****
H : eq (if N.eqb a x then Some a0 else None) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some (f (pf x) e))
+++++
idtac.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.

*****
H : eq (if N.eqb a x then Some a0 else None) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some (f (pf x) e))
+++++
generalize (Neqb_complete a x).
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).

*****
H : eq (if N.eqb a x then Some a0 else None) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall _ : forall _ : eq (N.eqb a x) true, eq a x, eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some (f (pf x) e))
+++++
destruct (Neqb a x).
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).
destruct (Neqb a x).

*****
H : eq (Some a0) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall _ : forall _ : eq true true, eq a x, eq (Some (f (pf a) a0)) (Some (f (pf x) e))
+++++
try discriminate.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).
destruct (Neqb a x).
try discriminate.

*****
H : eq (Some a0) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall _ : forall _ : eq true true, eq a x, eq (Some (f (pf a) a0)) (Some (f (pf x) e))
+++++
injection H.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).
destruct (Neqb a x).
try discriminate.
injection H.

*****
H : eq (Some a0) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall (_ : eq a0 e) (_ : forall _ : eq true true, eq a x), eq (Some (f (pf a) a0)) (Some (f (pf x) e))
+++++
intros.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).
destruct (Neqb a x).
try discriminate.
injection H.
intros.

*****
H1 : forall _ : eq true true, eq a x
H0 : eq a0 e
H : eq (Some a0) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
eq (Some (f (pf a) a0)) (Some (f (pf x) e))
+++++
subst.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).
destruct (Neqb a x).
try discriminate.
injection H.
intros.
subst.

*****
H1 : forall _ : eq true true, eq a x
H : eq (Some e) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a : ad
elt' : Type
elt : Type
*****
eq (Some (f (pf a) e)) (Some (f (pf x) e))
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).
destruct (Neqb a x).
try discriminate.
injection H.
intros.
subst.
auto.

*****
H1 : forall _ : eq true true, eq a x
H : eq (Some e) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a : ad
elt' : Type
elt : Type
*****
eq (Some (f (pf a) e)) (Some (f (pf x) e))
+++++
rewrite H1.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).
destruct (Neqb a x).
try discriminate.
injection H.
intros.
subst.
auto.
rewrite H1.

*****
H1 : forall _ : eq true true, eq a x
H : eq (Some e) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a : ad
elt' : Type
elt : Type
*****
eq (Some (f (pf x) e)) (Some (f (pf x) e))
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).
destruct (Neqb a x).
try discriminate.
injection H.
intros.
subst.
auto.
rewrite H1.

*****
H1 : forall _ : eq true true, eq a x
H : eq (Some e) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a : ad
elt' : Type
elt : Type
*****
eq true true
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
generalize (Neqb_complete a x).
destruct (Neqb a x).

*****
H : eq None (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall _ : forall _ : eq false true, eq a x, eq None (Some (f (pf x) e))
+++++
try discriminate.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.

*****
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x (M2 elt m1 m2)) (Some e)), ex (fun y : N => and (E.eq y x) (eq (find x (mapi_aux pf f (M2 elt m1 m2))) (Some (f (pf y) e))))
+++++
simpl.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.

*****
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq match x with | N0 => find N0 m1 | Npos (xI p) => find (Npos p) m2 | Npos (xO p) => find (Npos p) m1 | Npos xH => find N0 m2 end (Some e)), ex (fun y : N => and (E.eq y x) (eq match x with | N0 => find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos (xI p) => find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) | Npos (xO p) => find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) end (Some (f (pf y) e))))
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.

*****
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : eq match x with | N0 => find N0 m1 | Npos (xI p) => find (Npos p) m2 | Npos (xO p) => find (Npos p) m1 | Npos xH => find N0 m2 end (Some e)), ex (fun y : N => and (E.eq y x) (eq match x with | N0 => find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos (xI p) => find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) | Npos (xO p) => find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) end (Some (f (pf y) e))))
+++++
intros.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.

*****
H : eq\n match x with\n | N0 => find N0 m1\n | Npos (xI p) => find (Npos p) m2\n | Npos (xO p) => find (Npos p) m1\n | Npos xH => find N0 m2\n end (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
ex (fun y : N => and (E.eq y x) (eq match x with | N0 => find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos (xI p) => find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) | Npos (xO p) => find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) end (Some (f (pf y) e))))
+++++
exists x.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.

*****
H : eq\n match x with\n | N0 => find N0 m1\n | Npos (xI p) => find (Npos p) m2\n | Npos (xO p) => find (Npos p) m1\n | Npos xH => find N0 m2\n end (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
and (E.eq x x) (eq match x with | N0 => find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos (xI p) => find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) | Npos (xO p) => find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) end (Some (f (pf x) e)))
+++++
split.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.

*****
H : eq\n match x with\n | N0 => find N0 m1\n | Npos (xI p) => find (Npos p) m2\n | Npos (xO p) => find (Npos p) m1\n | Npos xH => find N0 m2\n end (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
E.eq x x
+++++
red.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
red.

*****
H : eq\n match x with\n | N0 => find N0 m1\n | Npos (xI p) => find (Npos p) m2\n | Npos (xO p) => find (Npos p) m1\n | Npos xH => find N0 m2\n end (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq x x
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.

*****
H : eq\n match x with\n | N0 => find N0 m1\n | Npos (xI p) => find (Npos p) m2\n | Npos (xO p) => find (Npos p) m1\n | Npos xH => find N0 m2\n end (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq match x with | N0 => find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos (xI p) => find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) | Npos (xO p) => find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) end (Some (f (pf x) e))
+++++
idtac.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.

*****
H : eq\n match x with\n | N0 => find N0 m1\n | Npos (xI p) => find (Npos p) m2\n | Npos (xO p) => find (Npos p) m1\n | Npos xH => find N0 m2\n end (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
x : key
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq match x with | N0 => find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos (xI p) => find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) | Npos (xO p) => find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) end (Some (f (pf x) e))
+++++
destruct x.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.

*****
H : eq (find N0 m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf N0) e))
+++++
simpl in *.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.

*****
H : eq (find N0 m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf N0) e))
+++++
destruct (IHm1 (fun n : N => pf (Ndouble n)) _ _ f H) as (y,(Hy,Hy')).
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct (IHm1 (fun n : N => pf (Ndouble n)) _ _ f H) as (y,(Hy,Hy')).

*****
Hy' : eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1))\n (Some (f (pf (N.double y)) e))
Hy : E.eq y N0
y : N
H : eq (find N0 m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf N0) e))
+++++
rewrite Hy in Hy'.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct (IHm1 (fun n : N => pf (Ndouble n)) _ _ f H) as (y,(Hy,Hy')).
rewrite Hy in Hy'.

*****
Hy' : eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1))\n (Some (f (pf (N.double N0)) e))
Hy : E.eq y N0
y : N
H : eq (find N0 m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf N0) e))
+++++
simpl in Hy'.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct (IHm1 (fun n : N => pf (Ndouble n)) _ _ f H) as (y,(Hy,Hy')).
rewrite Hy in Hy'.
simpl in Hy'.

*****
Hy' : eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1))\n (Some (f (pf N0) e))
Hy : E.eq y N0
y : N
H : eq (find N0 m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf N0) e))
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.

*****
H : eq\n match p with\n | xI p => find (Npos p) m2\n | xO p => find (Npos p) m1\n | xH => find N0 m2\n end (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq match p with | xI p => find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) | xO p => find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1) | xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) end (Some (f (pf (Npos p)) e))
+++++
simpl in *.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.

*****
H : eq\n match p with\n | xI p => find (Npos p) m2\n | xO p => find (Npos p) m1\n | xH => find N0 m2\n end (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq match p with | xI p => find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) | xO p => find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1) | xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) end (Some (f (pf (Npos p)) e))
+++++
destruct p.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.

*****
H : eq (find (Npos p) m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos (xI p))) e))
+++++
simpl in *.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.

*****
H : eq (find (Npos p) m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos (xI p))) e))
+++++
destruct (IHm2 (fun n : N => pf (Ndouble_plus_one n)) _ _ f H) as (y,(Hy,Hy')).
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.
destruct (IHm2 (fun n : N => pf (Ndouble_plus_one n)) _ _ f H) as (y,(Hy,Hy')).

*****
Hy' : eq (find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2))\n (Some (f (pf (N.succ_double y)) e))
Hy : E.eq y (Npos p)
y : N
H : eq (find (Npos p) m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos (xI p))) e))
+++++
rewrite Hy in Hy'.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.
destruct (IHm2 (fun n : N => pf (Ndouble_plus_one n)) _ _ f H) as (y,(Hy,Hy')).
rewrite Hy in Hy'.

*****
Hy' : eq (find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2))\n (Some (f (pf (N.succ_double (Npos p))) e))
Hy : E.eq y (Npos p)
y : N
H : eq (find (Npos p) m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos (xI p))) e))
+++++
simpl in Hy'.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.
destruct (IHm2 (fun n : N => pf (Ndouble_plus_one n)) _ _ f H) as (y,(Hy,Hy')).
rewrite Hy in Hy'.
simpl in Hy'.

*****
Hy' : eq (find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2))\n (Some (f (pf (Npos (xI p))) e))
Hy : E.eq y (Npos p)
y : N
H : eq (find (Npos p) m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos (xI p))) e))
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.

*****
H : eq (find (Npos p) m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf (Npos (xO p))) e))
+++++
simpl in *.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.

*****
H : eq (find (Npos p) m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf (Npos (xO p))) e))
+++++
destruct (IHm1 (fun n : N => pf (Ndouble n)) _ _ f H) as (y,(Hy,Hy')).
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.
destruct (IHm1 (fun n : N => pf (Ndouble n)) _ _ f H) as (y,(Hy,Hy')).

*****
Hy' : eq (find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1))\n (Some (f (pf (N.double y)) e))
Hy : E.eq y (Npos p)
y : N
H : eq (find (Npos p) m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf (Npos (xO p))) e))
+++++
rewrite Hy in Hy'.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.
destruct (IHm1 (fun n : N => pf (Ndouble n)) _ _ f H) as (y,(Hy,Hy')).
rewrite Hy in Hy'.

*****
Hy' : eq (find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1))\n (Some (f (pf (N.double (Npos p))) e))
Hy : E.eq y (Npos p)
y : N
H : eq (find (Npos p) m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf (Npos (xO p))) e))
+++++
simpl in Hy'.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.
destruct (IHm1 (fun n : N => pf (Ndouble n)) _ _ f H) as (y,(Hy,Hy')).
rewrite Hy in Hy'.
simpl in Hy'.

*****
Hy' : eq (find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1))\n (Some (f (pf (Npos (xO p))) e))
Hy : E.eq y (Npos p)
y : N
H : eq (find (Npos p) m1) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some (f (pf (Npos (xO p))) e))
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.

*****
H : eq (find N0 m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos xH)) e))
+++++
simpl in *.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.

*****
H : eq (find N0 m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos xH)) e))
+++++
destruct (IHm2 (fun n : N => pf (Ndouble_plus_one n)) _ _ f H) as (y,(Hy,Hy')).
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.
destruct (IHm2 (fun n : N => pf (Ndouble_plus_one n)) _ _ f H) as (y,(Hy,Hy')).

*****
Hy' : eq (find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2))\n (Some (f (pf (N.succ_double y)) e))
Hy : E.eq y N0
y : N
H : eq (find N0 m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos xH)) e))
+++++
rewrite Hy in Hy'.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.
destruct (IHm2 (fun n : N => pf (Ndouble_plus_one n)) _ _ f H) as (y,(Hy,Hy')).
rewrite Hy in Hy'.

*****
Hy' : eq (find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2))\n (Some (f (pf (N.succ_double N0)) e))
Hy : E.eq y N0
y : N
H : eq (find N0 m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos xH)) e))
+++++
simpl in Hy'.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.
simpl.
auto.
intros.
exists x.
split.
idtac.
destruct x.
simpl in *.
destruct p.
simpl in *.
destruct (IHm2 (fun n : N => pf (Ndouble_plus_one n)) _ _ f H) as (y,(Hy,Hy')).
rewrite Hy in Hy'.
simpl in Hy'.

*****
Hy' : eq (find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2))\n (Some (f (pf (Npos xH)) e))
Hy : E.eq y N0
y : N
H : eq (find N0 m2) (Some e)
f : forall (_ : key) (_ : elt), elt'
e : elt
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m2) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m2)) (Some (f (pf y) e))))
IHm1 : forall (pf : forall _ : N, N) (x : key) (e : elt)\n (f : forall (_ : key) (_ : elt), elt') (_ : eq (find x m1) (Some e)),\nex\n (fun y : N =>\n and (E.eq y x) (eq (find x (mapi_aux pf f m1)) (Some (f (pf y) e))))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
eq (find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)) (Some (f (pf (Npos xH)) e))
+++++
auto.
-----
Lemma mapi_aux_1 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f (pf y) e) (mapi_aux pf f m).
Proof.
unfold MapsTo.
induction m.

*****

*****

+++++
Qed.
-----
Lemma mapi_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)\n        (f:key->elt->elt'), MapsTo x e m -> \n        exists y, E.eq y x /\ MapsTo x (f y e) (mapi f m).
-----
Lemma mapi_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f y e) (mapi f m).

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : MapsTo x e m), ex (fun y : N => and (E.eq y x) (MapsTo x (f y e) (mapi f m)))
+++++
Proof.
-----
Lemma mapi_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f y e) (mapi f m).
Proof.

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : MapsTo x e m), ex (fun y : N => and (E.eq y x) (MapsTo x (f y e) (mapi f m)))
+++++
intros elt elt' m.
-----
Lemma mapi_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f y e) (mapi f m).
Proof.
intros elt elt' m.

*****
m : t elt
elt' : Type
elt : Type
*****
forall (x : key) (e : elt) (f : forall (_ : key) (_ : elt), elt') (_ : MapsTo x e m), ex (fun y : N => and (E.eq y x) (MapsTo x (f y e) (mapi f m)))
+++++
exact (mapi_aux_1 (fun n => n)).
-----
Lemma mapi_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt) (f:key->elt->elt'), MapsTo x e m -> exists y, E.eq y x /\\ MapsTo x (f y e) (mapi f m).
Proof.
intros elt elt' m.
exact (mapi_aux_1 (fun n => n)).

*****

*****

+++++
Qed.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key)\n        (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.

*****

*****
forall (elt elt' : Type) (m : t elt) (pf : forall _ : N, N) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : In x (mapi_aux pf f m)), In x m
+++++
Proof.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.

*****

*****
forall (elt elt' : Type) (m : t elt) (pf : forall _ : N, N) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : In x (mapi_aux pf f m)), In x m
+++++
unfold In.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.

*****

*****
forall (elt elt' : Type) (m : t elt) (pf : forall _ : N, N) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : ex (fun e : elt' => MapsTo x e (mapi_aux pf f m))), ex (fun e : elt => MapsTo x e m)
+++++
unfold MapsTo.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.

*****

*****
forall (elt elt' : Type) (m : t elt) (pf : forall _ : N, N) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m)) (Some e))), ex (fun e : elt => eq (find x m) (Some e))
+++++
induction m.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.

*****
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f (M0 elt))) (Some e))), ex (fun e : elt => eq (find x (M0 elt)) (Some e))
+++++
simpl in *.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.

*****
elt' : Type
elt : Type
*****
forall (_ : forall _ : N, N) (_ : key) (_ : forall (_ : key) (_ : elt), elt') (_ : ex (fun e : elt' => eq None (Some e))), ex (fun e : elt => eq None (Some e))
+++++
intros pf x f (e,He).
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).

*****
He : eq None (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
x : key
pf : forall _ : N, N
elt' : Type
elt : Type
*****
ex (fun e : elt => eq None (Some e))
+++++
inversion He.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.

*****
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f (M1 elt a a0))) (Some e))), ex (fun e : elt => eq (find x (M1 elt a a0)) (Some e))
+++++
simpl in *.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.

*****
a0 : elt
a : ad
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : ex (fun e : elt' => eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some e))), ex (fun e : elt => eq (if N.eqb a x then Some a0 else None) (Some e))
+++++
intros pf x f (e,He).
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).

*****
He : eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
ex (fun e : elt => eq (if N.eqb a x then Some a0 else None) (Some e))
+++++
exists a0.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
exists a0.

*****
He : eq (if N.eqb a x then Some (f (pf a) a0) else None) (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
eq (if N.eqb a x then Some a0 else None) (Some a0)
+++++
destruct (Neqb a x).
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
exists a0.
destruct (Neqb a x).

*****
He : eq (Some (f (pf a) a0)) (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
eq (Some a0) (Some a0)
+++++
try discriminate.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
exists a0.
destruct (Neqb a x).
try discriminate.

*****
He : eq (Some (f (pf a) a0)) (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
eq (Some a0) (Some a0)
+++++
auto.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
exists a0.
destruct (Neqb a x).

*****
He : eq None (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
x : key
pf : forall _ : N, N
a0 : elt
a : ad
elt' : Type
elt : Type
*****
eq None (Some a0)
+++++
try discriminate.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.

*****
IHm2 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m2)) (Some e))),\nex (fun e : elt => eq (find x m2) (Some e))
IHm1 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m1)) (Some e))),\nex (fun e : elt => eq (find x m1) (Some e))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f (M2 elt m1 m2))) (Some e))), ex (fun e : elt => eq (find x (M2 elt m1 m2)) (Some e))
+++++
simpl in *.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.

*****
IHm2 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m2)) (Some e))),\nex (fun e : elt => eq (find x m2) (Some e))
IHm1 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m1)) (Some e))),\nex (fun e : elt => eq (find x m1) (Some e))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
forall (pf : forall _ : N, N) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : ex (fun e : elt' => eq match x with | N0 => find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos (xI p) => find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) | Npos (xO p) => find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1) | Npos xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2) end (Some e))), ex (fun e : elt => eq match x with | N0 => find N0 m1 | Npos (xI p) => find (Npos p) m2 | Npos (xO p) => find (Npos p) m1 | Npos xH => find N0 m2 end (Some e))
+++++
intros pf x f (e,He).
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).

*****
He : eq\n match x with\n | N0 => find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1)\n | Npos (xI p) =>\n find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)\n | Npos (xO p) =>\n find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1)\n | Npos xH =>\n find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)\n end (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
x : key
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m2)) (Some e))),\nex (fun e : elt => eq (find x m2) (Some e))
IHm1 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m1)) (Some e))),\nex (fun e : elt => eq (find x m1) (Some e))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
ex (fun e : elt => eq match x with | N0 => find N0 m1 | Npos (xI p) => find (Npos p) m2 | Npos (xO p) => find (Npos p) m1 | Npos xH => find N0 m2 end (Some e))
+++++
destruct x.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
destruct x.

*****
He : eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m2)) (Some e))),\nex (fun e : elt => eq (find x m2) (Some e))
IHm1 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m1)) (Some e))),\nex (fun e : elt => eq (find x m1) (Some e))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
ex (fun e : elt => eq (find N0 m1) (Some e))
+++++
idtac.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
destruct x.
idtac.

*****
He : eq (find N0 (mapi_aux (fun n : N => pf (N.double n)) f m1)) (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m2)) (Some e))),\nex (fun e : elt => eq (find x m2) (Some e))
IHm1 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m1)) (Some e))),\nex (fun e : elt => eq (find x m1) (Some e))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
ex (fun e : elt => eq (find N0 m1) (Some e))
+++++
eauto.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
destruct x.

*****
He : eq\n match p with\n | xI p =>\n find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)\n | xO p =>\n find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1)\n | xH => find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2)\n end (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m2)) (Some e))),\nex (fun e : elt => eq (find x m2) (Some e))
IHm1 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m1)) (Some e))),\nex (fun e : elt => eq (find x m1) (Some e))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
ex (fun e : elt => eq match p with | xI p => find (Npos p) m2 | xO p => find (Npos p) m1 | xH => find N0 m2 end (Some e))
+++++
destruct p.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
destruct x.
destruct p.

*****
He : eq (find (Npos p) (mapi_aux (fun n : N => pf (N.succ_double n)) f m2))\n (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m2)) (Some e))),\nex (fun e : elt => eq (find x m2) (Some e))
IHm1 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m1)) (Some e))),\nex (fun e : elt => eq (find x m1) (Some e))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
ex (fun e : elt => eq (find (Npos p) m2) (Some e))
+++++
eauto.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
destruct x.
destruct p.

*****
He : eq (find (Npos p) (mapi_aux (fun n : N => pf (N.double n)) f m1))\n (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
p : positive
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m2)) (Some e))),\nex (fun e : elt => eq (find x m2) (Some e))
IHm1 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m1)) (Some e))),\nex (fun e : elt => eq (find x m1) (Some e))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
ex (fun e : elt => eq (find (Npos p) m1) (Some e))
+++++
eauto.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.
simpl in *.
intros pf x f (e,He).
destruct x.
destruct p.

*****
He : eq (find N0 (mapi_aux (fun n : N => pf (N.succ_double n)) f m2))\n (Some e)
e : elt'
f : forall (_ : key) (_ : elt), elt'
pf : forall _ : N, N
IHm2 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m2)) (Some e))),\nex (fun e : elt => eq (find x m2) (Some e))
IHm1 : forall (pf : forall _ : N, N) (x : key)\n (f : forall (_ : key) (_ : elt), elt')\n (_ : ex (fun e : elt' => eq (find x (mapi_aux pf f m1)) (Some e))),\nex (fun e : elt => eq (find x m1) (Some e))
m1,m2 : Map elt
elt' : Type
elt : Type
*****
ex (fun e : elt => eq (find N0 m2) (Some e))
+++++
eauto.
-----
Lemma mapi_aux_2 : forall (elt elt':Type)(m: t elt)(pf:N->N)(x:key) (f:key->elt->elt'), In x (mapi_aux pf f m) -> In x m.
Proof.
unfold In.
unfold MapsTo.
induction m.

*****

*****

+++++
Qed.
-----
Lemma mapi_2 : forall (elt elt':Type)(m: t elt)(x:key)\n        (f:key->elt->elt'), In x (mapi f m) -> In x m.
-----
Lemma mapi_2 : forall (elt elt':Type)(m: t elt)(x:key) (f:key->elt->elt'), In x (mapi f m) -> In x m.

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : In x (mapi f m)), In x m
+++++
Proof.
-----
Lemma mapi_2 : forall (elt elt':Type)(m: t elt)(x:key) (f:key->elt->elt'), In x (mapi f m) -> In x m.
Proof.

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : In x (mapi f m)), In x m
+++++
intros elt elt' m.
-----
Lemma mapi_2 : forall (elt elt':Type)(m: t elt)(x:key) (f:key->elt->elt'), In x (mapi f m) -> In x m.
Proof.
intros elt elt' m.

*****
m : t elt
elt' : Type
elt : Type
*****
forall (x : key) (f : forall (_ : key) (_ : elt), elt') (_ : In x (mapi f m)), In x m
+++++
exact (@mapi_aux_2 _ elt' m (fun n => n)).
-----
Lemma mapi_2 : forall (elt elt':Type)(m: t elt)(x:key) (f:key->elt->elt'), In x (mapi f m) -> In x m.
Proof.
intros elt elt' m.
exact (@mapi_aux_2 _ elt' m (fun n => n)).

*****

*****

+++++
Qed.
-----
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'),\n        MapsTo x e m -> MapsTo x (f e) (map f m).
-----
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'), MapsTo x e m -> MapsTo x (f e) (map f m).

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (e : elt) (f : forall _ : elt, elt') (_ : MapsTo x e m), MapsTo x (f e) (map f m)
+++++
Proof.
-----
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'), MapsTo x e m -> MapsTo x (f e) (map f m).
Proof.

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (e : elt) (f : forall _ : elt, elt') (_ : MapsTo x e m), MapsTo x (f e) (map f m)
+++++
unfold map.
-----
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'), MapsTo x e m -> MapsTo x (f e) (map f m).
Proof.
unfold map.

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (e : elt) (f : forall _ : elt, elt') (_ : MapsTo x e m), MapsTo x (f e) (mapi (fun _ : N => f) m)
+++++
intros.
-----
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'), MapsTo x e m -> MapsTo x (f e) (map f m).
Proof.
unfold map.
intros.

*****
H : MapsTo x e m
f : forall _ : elt, elt'
e : elt
x : key
m : t elt
elt' : Type
elt : Type
*****
MapsTo x (f e) (mapi (fun _ : N => f) m)
+++++
destruct (@mapi_1 _ _ m x e (fun _ => f)) as (e',(_,H0)).
-----
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'), MapsTo x e m -> MapsTo x (f e) (map f m).
Proof.
unfold map.
intros.
destruct (@mapi_1 _ _ m x e (fun _ => f)) as (e',(_,H0)).

*****
H : MapsTo x e m
f : forall _ : elt, elt'
e : elt
x : key
m : t elt
elt' : Type
elt : Type
*****
MapsTo x e m
+++++
auto.
-----
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'), MapsTo x e m -> MapsTo x (f e) (map f m).
Proof.
unfold map.
intros.
destruct (@mapi_1 _ _ m x e (fun _ => f)) as (e',(_,H0)).

*****
H0 : MapsTo x (f e) (mapi (fun _ : key => f) m)
e' : N
H : MapsTo x e m
f : forall _ : elt, elt'
e : elt
x : key
m : t elt
elt' : Type
elt : Type
*****
MapsTo x (f e) (mapi (fun _ : N => f) m)
+++++
auto.
-----
Lemma map_1 : forall (elt elt':Type)(m: t elt)(x:key)(e:elt)(f:elt->elt'), MapsTo x e m -> MapsTo x (f e) (map f m).
Proof.
unfold map.
intros.
destruct (@mapi_1 _ _ m x e (fun _ => f)) as (e',(_,H0)).

*****

*****

+++++
Qed.
-----
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'), \n        In x (map f m) -> In x m.
-----
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (f : forall _ : elt, elt') (_ : In x (map f m)), In x m
+++++
Proof.
-----
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.
Proof.

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (f : forall _ : elt, elt') (_ : In x (map f m)), In x m
+++++
unfold map.
-----
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.
Proof.
unfold map.

*****

*****
forall (elt elt' : Type) (m : t elt) (x : key) (f : forall _ : elt, elt') (_ : In x (mapi (fun _ : N => f) m)), In x m
+++++
intros.
-----
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.
Proof.
unfold map.
intros.

*****
H : In x (mapi (fun _ : N => f) m)
f : forall _ : elt, elt'
x : key
m : t elt
elt' : Type
elt : Type
*****
In x m
+++++
eapply mapi_2.
-----
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.
Proof.
unfold map.
intros.
eapply mapi_2.

*****
H : In x (mapi (fun _ : N => f) m)
f : forall _ : elt, elt'
x : key
m : t elt
elt' : Type
elt : Type
*****
In x (mapi ?f m)
+++++
eauto.
-----
Lemma map_2 : forall (elt elt':Type)(m: t elt)(x:key)(f:elt->elt'), In x (map f m) -> In x m.
Proof.
unfold map.
intros.
eapply mapi_2.
eauto.

*****

*****

+++++
Qed.
-----
Module L := FMapList.Raw E.
-----
Definition anti_elements (A:Type)(l:list (key*A)) := L.fold (@add _) l (empty _).
-----
Definition map2 (A B C:Type)(f:option A->option B -> option C)(m:t A)(m':t B) : t C := \n    anti_elements (L.map2 f (elements m) (elements m')).
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, \n    find x (add y e m) = if E.eq_dec x y then Some e else find x m.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.

*****

*****
forall (A : Type) (m : t A) (x y : key) (e : A), eq (find x (add y e m)) (if E.eq_dec x y then Some e else find x m)
+++++
Proof.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.

*****

*****
forall (A : Type) (m : t A) (x y : key) (e : A), eq (find x (add y e m)) (if E.eq_dec x y then Some e else find x m)
+++++
intros.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.

*****
e : A
x,y : key
m : t A
A : Type
*****
eq (find x (add y e m)) (if E.eq_dec x y then Some e else find x m)
+++++
destruct (E.eq_dec x y).
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
eq (find x (add y e m)) (Some e)
+++++
apply find_1.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
apply find_1.

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
MapsTo x e (add y e m)
+++++
eapply MapsTo_1 with y.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
apply find_1.
eapply MapsTo_1 with y.

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
E.eq y x
+++++
eauto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
apply find_1.
eapply MapsTo_1 with y.
eauto.

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
E.eq y x
+++++
red.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
apply find_1.
eapply MapsTo_1 with y.
eauto.
red.

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
eq y x
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
apply find_1.
eapply MapsTo_1 with y.

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
MapsTo y e (add y e m)
+++++
eauto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
apply find_1.
eapply MapsTo_1 with y.
eauto.

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
MapsTo y e (add y e m)
+++++
apply add_1.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
apply find_1.
eapply MapsTo_1 with y.
eauto.
apply add_1.

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
E.eq y y
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
apply find_1.
eapply MapsTo_1 with y.
eauto.
apply add_1.
auto.

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
E.eq y y
+++++
red.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
apply find_1.
eapply MapsTo_1 with y.
eauto.
apply add_1.
auto.
red.

*****
e0 : eq x y
e : A
x,y : key
m : t A
A : Type
*****
eq y y
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).

*****
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
eq (find x (add y e m)) (find x m)
+++++
case_eq (find x m).
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).

*****
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
forall (a : A) (_ : eq (find x m) (Some a)), eq (find x (add y e m)) (Some a)
+++++
intros.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.

*****
H : eq (find x m) (Some a)
a : A
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
eq (find x (add y e m)) (Some a)
+++++
apply find_1.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
apply find_1.

*****
H : eq (find x m) (Some a)
a : A
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
MapsTo x a (add y e m)
+++++
apply add_2.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
apply find_1.
apply add_2.

*****
H : eq (find x m) (Some a)
a : A
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
not (E.eq y x)
+++++
unfold E.eq in *.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
apply find_1.
apply add_2.
unfold E.eq in *.

*****
H : eq (find x m) (Some a)
a : A
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
not (eq y x)
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
apply find_1.
apply add_2.

*****
H : eq (find x m) (Some a)
a : A
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
MapsTo x a m
+++++
unfold E.eq in *.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
apply find_1.
apply add_2.
unfold E.eq in *.

*****
H : eq (find x m) (Some a)
a : A
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
MapsTo x a m
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).

*****
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
forall _ : eq (find x m) None, eq (find x (add y e m)) None
+++++
intros.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.

*****
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
eq (find x (add y e m)) None
+++++
case_eq (find x (add y e m)).
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).

*****
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
forall (a : A) (_ : eq (find x (add y e m)) (Some a)), eq (Some a) None
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.

*****
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
forall (a : A) (_ : eq (find x (add y e m)) (Some a)), eq (Some a) None
+++++
intros.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.
intros.

*****
H0 : eq (find x (add y e m)) (Some a)
a : A
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
eq (Some a) None
+++++
rewrite <- H.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.
intros.
rewrite <- H.

*****
H0 : eq (find x (add y e m)) (Some a)
a : A
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
eq (Some a) (find x m)
+++++
symmetry.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.
intros.
rewrite <- H.
symmetry.

*****
H0 : eq (find x (add y e m)) (Some a)
a : A
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
eq (find x m) (Some a)
+++++
apply find_1.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.

*****
H0 : eq (find x (add y e m)) (Some a)
a : A
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
MapsTo x a m
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.
auto.

*****
H0 : eq (find x (add y e m)) (Some a)
a : A
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
MapsTo x a m
+++++
apply (@add_3 _ m y x a e).
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.
auto.
apply (@add_3 _ m y x a e).

*****
H0 : eq (find x (add y e m)) (Some a)
a : A
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
not (E.eq y x)
+++++
unfold E.eq in *.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.
auto.
apply (@add_3 _ m y x a e).
unfold E.eq in *.

*****
H0 : eq (find x (add y e m)) (Some a)
a : A
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
not (eq y x)
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.
auto.
apply (@add_3 _ m y x a e).

*****
H0 : eq (find x (add y e m)) (Some a)
a : A
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
MapsTo x a (add y e m)
+++++
unfold E.eq in *.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.
auto.
apply (@add_3 _ m y x a e).
unfold E.eq in *.

*****
H0 : eq (find x (add y e m)) (Some a)
a : A
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
MapsTo x a (add y e m)
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).
case_eq (find x m).
intros.
case_eq (find x (add y e m)).

*****
H : eq (find x m) None
n : not (eq x y)
e : A
x,y : key
m : t A
A : Type
*****
forall _ : eq (find x (add y e m)) None, eq None None
+++++
auto.
-----
Lemma add_spec : forall (A:Type)(m:t A) x y e, find x (add y e m) = if E.eq_dec x y then Some e else find x m.
Proof.
intros.
destruct (E.eq_dec x y).

*****

*****

+++++
Qed.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e,\n    NoDupA (eq_key (A:=A)) l -> \n    (forall x, L.PX.In x l -> In x m -> False) -> \n    (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \/ MapsTo k e m).
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).

*****

*****
forall (A : Type) (l : list (prod key A)) (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l) (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False), iff (MapsTo k e (L.fold (add (A:=A)) l m)) (or (L.PX.MapsTo k e l) (MapsTo k e m))
+++++
Proof.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.

*****

*****
forall (A : Type) (l : list (prod key A)) (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l) (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False), iff (MapsTo k e (L.fold (add (A:=A)) l m)) (or (L.PX.MapsTo k e l) (MapsTo k e m))
+++++
induction l.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.

*****
A : Type
*****
forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) nil) (_ : forall (x : N) (_ : L.PX.In x nil) (_ : In x m), False), iff (MapsTo k e (L.fold (add (A:=A)) nil m)) (or (L.PX.MapsTo k e nil) (MapsTo k e m))
+++++
simpl.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.

*****
A : Type
*****
forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) nil) (_ : forall (x : N) (_ : L.PX.In x nil) (_ : In x m), False), iff (MapsTo k e m) (or (L.PX.MapsTo k e nil) (MapsTo k e m))
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
auto.

*****
A : Type
*****
forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) nil) (_ : forall (x : N) (_ : L.PX.In x nil) (_ : In x m), False), iff (MapsTo k e m) (or (L.PX.MapsTo k e nil) (MapsTo k e m))
+++++
intuition.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
auto.
intuition.

*****
H2 : L.PX.MapsTo k e nil
H0 : forall (x : N) (_ : L.PX.In x nil) (_ : In x m), False
H : NoDupA (eq_key (A:=A)) nil
e : A
k : key
m : t A
A : Type
*****
MapsTo k e m
+++++
inversion H2.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.

*****
IHl : forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l)\n (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False),\niff (MapsTo k e (L.fold (add (A:=A)) l m))\n (or (L.PX.MapsTo k e l) (MapsTo k e m))
l : list (prod key A)
a : prod key A
A : Type
*****
forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) (cons a l)) (_ : forall (x : N) (_ : L.PX.In x (cons a l)) (_ : In x m), False), iff (MapsTo k e (L.fold (add (A:=A)) (cons a l) m)) (or (L.PX.MapsTo k e (cons a l)) (MapsTo k e m))
+++++
simpl.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.

*****
IHl : forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l)\n (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False),\niff (MapsTo k e (L.fold (add (A:=A)) l m))\n (or (L.PX.MapsTo k e l) (MapsTo k e m))
l : list (prod key A)
a : prod key A
A : Type
*****
forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) (cons a l)) (_ : forall (x : N) (_ : L.PX.In x (cons a l)) (_ : In x m), False), iff (MapsTo k e (let (k0, e0) := a in L.fold (add (A:=A)) l (add k0 e0 m))) (or (L.PX.MapsTo k e (cons a l)) (MapsTo k e m))
+++++
destruct a.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.

*****
IHl : forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l)\n (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False),\niff (MapsTo k e (L.fold (add (A:=A)) l m))\n (or (L.PX.MapsTo k e l) (MapsTo k e m))
l : list (prod key A)
a : A
k : key
A : Type
*****
forall (m : t A) (k0 : key) (e : A) (_ : NoDupA (eq_key (A:=A)) (cons (pair k a) l)) (_ : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False), iff (MapsTo k0 e (L.fold (add (A:=A)) l (add k a m))) (or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m))
+++++
intros.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.

*****
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
H : NoDupA (eq_key (A:=A)) (cons (pair k a) l)
e : A
k0 : key
m : t A
IHl : forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l)\n (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False),\niff (MapsTo k e (L.fold (add (A:=A)) l m))\n (or (L.PX.MapsTo k e l) (MapsTo k e m))
l : list (prod key A)
a : A
k : key
A : Type
*****
iff (MapsTo k0 e (L.fold (add (A:=A)) l (add k a m))) (or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m))
+++++
inversion_clear H.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
IHl : forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l)\n (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False),\niff (MapsTo k e (L.fold (add (A:=A)) l m))\n (or (L.PX.MapsTo k e l) (MapsTo k e m))
l : list (prod key A)
a : A
k : key
A : Type
*****
iff (MapsTo k0 e (L.fold (add (A:=A)) l (add k a m))) (or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m))
+++++
rewrite IHl.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
IHl : forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l)\n (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False),\niff (MapsTo k e (L.fold (add (A:=A)) l m))\n (or (L.PX.MapsTo k e l) (MapsTo k e m))
l : list (prod key A)
a : A
k : key
A : Type
*****
iff (or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))) (or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m))
+++++
clear IHl.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
iff (or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))) (or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m))
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
iff (or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))) (or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m))
+++++
intuition.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.

*****
H3 : MapsTo k0 e (add k a m)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m)
+++++
red in H3.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
red in H3.

*****
H3 : eq (find k0 (add k a m)) (Some e)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m)
+++++
rewrite add_spec in H3.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
red in H3.
rewrite add_spec in H3.

*****
H3 : eq (if E.eq_dec k0 k then Some a else find k0 m) (Some e)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m)
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
red in H3.
rewrite add_spec in H3.
auto.

*****
H3 : eq (if E.eq_dec k0 k then Some a else find k0 m) (Some e)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m)
+++++
destruct (E.eq_dec k0 k).
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
red in H3.
rewrite add_spec in H3.
auto.
destruct (E.eq_dec k0 k).

*****
H3 : eq (Some a) (Some e)
e0 : eq k0 k
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m)
+++++
inversion_clear H3.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
red in H3.
rewrite add_spec in H3.
auto.
destruct (E.eq_dec k0 k).
inversion_clear H3.

*****
e0 : eq k0 k
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e (cons (pair k e) l)) (MapsTo k0 e m)
+++++
subst.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
red in H3.
rewrite add_spec in H3.
auto.
destruct (E.eq_dec k0 k).
inversion_clear H3.
subst.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k e (cons (pair k e) l)) (MapsTo k e m)
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
red in H3.
rewrite add_spec in H3.
auto.
destruct (E.eq_dec k0 k).

*****
H3 : eq (find k0 m) (Some e)
n : not (eq k0 k)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e (cons (pair k a) l)) (MapsTo k0 e m)
+++++
right.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
red in H3.
rewrite add_spec in H3.
auto.
destruct (E.eq_dec k0 k).
right.

*****
H3 : eq (find k0 m) (Some e)
n : not (eq k0 k)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
MapsTo k0 e m
+++++
apply find_2.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
red in H3.
rewrite add_spec in H3.
auto.
destruct (E.eq_dec k0 k).
right.
apply find_2.

*****
H3 : eq (find k0 m) (Some e)
n : not (eq k0 k)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
eq (find k0 m) (Some e)
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.

*****
H3 : L.PX.MapsTo k0 e (cons (pair k a) l)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))
+++++
inversion_clear H3.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.

*****
H : L.PX.eqke (pair k0 e) (pair k a)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.
auto.

*****
H : L.PX.eqke (pair k0 e) (pair k a)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))
+++++
compute in H.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.
auto.
compute in H.

*****
H : and (eq k0 k) (eq e a)
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))
+++++
destruct H.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.
auto.
compute in H.
destruct H.

*****
H3 : eq e a
H : eq k0 k
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))
+++++
subst.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.
auto.
compute in H.
destruct H.
subst.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k a l) (MapsTo k a (add k a m))
+++++
right.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.
auto.
compute in H.
destruct H.
subst.
right.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
MapsTo k a (add k a m)
+++++
apply add_1.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.
auto.
compute in H.
destruct H.
subst.
right.
apply add_1.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
E.eq k k
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.
auto.
compute in H.
destruct H.
subst.
right.
apply add_1.
auto.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
E.eq k k
+++++
red.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.
auto.
compute in H.
destruct H.
subst.
right.
apply add_1.
auto.
red.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
eq k k
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
inversion_clear H3.

*****
H : InA (L.PX.eqke (elt:=A)) (pair k0 e) l
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.

*****
H3 : MapsTo k0 e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))
+++++
destruct (E.eq_dec k0 k) as [H|H].
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].

*****
H : eq k0 k
H3 : MapsTo k0 e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))
+++++
subst.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
subst.

*****
H3 : MapsTo k e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k e l) (MapsTo k e (add k a m))
+++++
destruct (H0 k).
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
subst.
destruct (H0 k).

*****
H3 : MapsTo k e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
L.PX.In k (cons (pair k a) l)
+++++
eauto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
subst.
destruct (H0 k).

*****
H3 : MapsTo k e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
In k m
+++++
eauto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
subst.
destruct (H0 k).
eauto.

*****
H3 : MapsTo k e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
In k m
+++++
red.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
subst.
destruct (H0 k).
eauto.
red.

*****
H3 : MapsTo k e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
ex (fun e : A => MapsTo k e m)
+++++
eauto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].

*****
H : not (eq k0 k)
H3 : MapsTo k0 e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
or (L.PX.MapsTo k0 e l) (MapsTo k0 e (add k a m))
+++++
right.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
right.

*****
H : not (eq k0 k)
H3 : MapsTo k0 e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
MapsTo k0 e (add k a m)
+++++
apply add_2.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
right.
apply add_2.

*****
H : not (eq k0 k)
H3 : MapsTo k0 e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
not (E.eq k k0)
+++++
unfold E.eq in *.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
right.
apply add_2.
unfold E.eq in *.

*****
H : not (eq k0 k)
H3 : MapsTo k0 e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
not (eq k k0)
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
right.
apply add_2.

*****
H : not (eq k0 k)
H3 : MapsTo k0 e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
MapsTo k0 e m
+++++
unfold E.eq in *.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intuition.
destruct (E.eq_dec k0 k) as [H|H].
right.
apply add_2.
unfold E.eq in *.

*****
H : not (eq k0 k)
H3 : MapsTo k0 e m
H2 : NoDupA (eq_key (A:=A)) l
H1 : forall _ : InA (eq_key (A:=A)) (pair k a) l, False
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
MapsTo k0 e m
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
IHl : forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l)\n (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False),\niff (MapsTo k e (L.fold (add (A:=A)) l m))\n (or (L.PX.MapsTo k e l) (MapsTo k e m))
l : list (prod key A)
a : A
k : key
A : Type
*****
NoDupA (eq_key (A:=A)) l
+++++
clear IHl.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
NoDupA (eq_key (A:=A)) l
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
IHl : forall (m : t A) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l)\n (_ : forall (x : N) (_ : L.PX.In x l) (_ : In x m), False),\niff (MapsTo k e (L.fold (add (A:=A)) l m))\n (or (L.PX.MapsTo k e l) (MapsTo k e m))
l : list (prod key A)
a : A
k : key
A : Type
*****
forall (x : N) (_ : L.PX.In x l) (_ : In x (add k a m)), False
+++++
clear IHl.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
forall (x : N) (_ : L.PX.In x l) (_ : In x (add k a m)), False
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.

*****
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
forall (x : N) (_ : L.PX.In x l) (_ : In x (add k a m)), False
+++++
intros.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.

*****
H3 : In x (add k a m)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
False
+++++
assert (~E.eq x k).
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).

*****
H3 : In x (add k a m)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
not (E.eq x k)
+++++
contradict H1.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
contradict H1.

*****
H1 : E.eq x k
H3 : In x (add k a m)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
InA (eq_key (A:=A)) (pair k a) l
+++++
destruct H.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
contradict H1.
destruct H.

*****
H1 : E.eq x k
H3 : In x (add k a m)
H : L.PX.MapsTo x x0 l
x0 : A
x : N
H2 : NoDupA (eq_key (A:=A)) l
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
InA (eq_key (A:=A)) (pair k a) l
+++++
apply InA_eqA with (x,x0).
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
contradict H1.
destruct H.
apply InA_eqA with (x,x0).

*****
H1 : E.eq x k
H3 : In x (add k a m)
H : L.PX.MapsTo x x0 l
x0 : A
x : N
H2 : NoDupA (eq_key (A:=A)) l
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
Equivalence (eq_key (A:=A))
+++++
eauto with *.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
contradict H1.
destruct H.
apply InA_eqA with (x,x0).

*****
H1 : E.eq x k
H3 : In x (add k a m)
H : L.PX.MapsTo x x0 l
x0 : A
x : N
H2 : NoDupA (eq_key (A:=A)) l
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
eq_key (pair x x0) (pair k a)
+++++
eauto with *.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
contradict H1.
destruct H.
apply InA_eqA with (x,x0).

*****
H1 : E.eq x k
H3 : In x (add k a m)
H : L.PX.MapsTo x x0 l
x0 : A
x : N
H2 : NoDupA (eq_key (A:=A)) l
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
InA (eq_key (A:=A)) (pair x x0) l
+++++
eauto with *.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).

*****
H4 : not (E.eq x k)
H3 : In x (add k a m)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
False
+++++
apply (H0 x).
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).

*****
H4 : not (E.eq x k)
H3 : In x (add k a m)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
L.PX.In x (cons (pair k a) l)
+++++
destruct H.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
destruct H.

*****
H4 : not (E.eq x k)
H3 : In x (add k a m)
H : L.PX.MapsTo x x0 l
x0 : A
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
L.PX.In x (cons (pair k a) l)
+++++
exists x0.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
destruct H.
exists x0.

*****
H4 : not (E.eq x k)
H3 : In x (add k a m)
H : L.PX.MapsTo x x0 l
x0 : A
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
L.PX.MapsTo x x0 (cons (pair k a) l)
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).

*****
H4 : not (E.eq x k)
H3 : In x (add k a m)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
In x m
+++++
revert H3.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
revert H3.

*****
H4 : not (E.eq x k)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
forall _ : In x (add k a m), In x m
+++++
unfold In.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
revert H3.
unfold In.

*****
H4 : not (E.eq x k)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
forall _ : ex (fun e : A => MapsTo x e (add k a m)), ex (fun e : A => MapsTo x e m)
+++++
intros (e',He').
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
revert H3.
unfold In.
intros (e',He').

*****
He' : MapsTo x e' (add k a m)
e' : A
H4 : not (E.eq x k)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
ex (fun e : A => MapsTo x e m)
+++++
exists e'.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
revert H3.
unfold In.
intros (e',He').
exists e'.

*****
He' : MapsTo x e' (add k a m)
e' : A
H4 : not (E.eq x k)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
MapsTo x e' m
+++++
apply (@add_3 _ m k x e' a).
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
revert H3.
unfold In.
intros (e',He').
exists e'.
apply (@add_3 _ m k x e' a).

*****
He' : MapsTo x e' (add k a m)
e' : A
H4 : not (E.eq x k)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
not (E.eq k x)
+++++
unfold E.eq.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
revert H3.
unfold In.
intros (e',He').
exists e'.
apply (@add_3 _ m k x e' a).
unfold E.eq.

*****
He' : MapsTo x e' (add k a m)
e' : A
H4 : not (E.eq x k)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
not (eq k x)
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
revert H3.
unfold In.
intros (e',He').
exists e'.
apply (@add_3 _ m k x e' a).

*****
He' : MapsTo x e' (add k a m)
e' : A
H4 : not (E.eq x k)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
MapsTo x e' (add k a m)
+++++
unfold E.eq.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.
simpl.
destruct a.
intros.
inversion_clear H.
rewrite IHl.
clear IHl.
auto.
intros.
assert (~E.eq x k).
apply (H0 x).
revert H3.
unfold In.
intros (e',He').
exists e'.
apply (@add_3 _ m k x e' a).
unfold E.eq.

*****
He' : MapsTo x e' (add k a m)
e' : A
H4 : not (E.eq x k)
H : L.PX.In x l
x : N
H2 : NoDupA (eq_key (A:=A)) l
H1 : not (InA (eq_key (A:=A)) (pair k a) l)
H0 : forall (x : N) (_ : L.PX.In x (cons (pair k a) l)) (_ : In x m), False
e : A
k0 : key
m : t A
l : list (prod key A)
a : A
k : key
A : Type
*****
MapsTo x e' (add k a m)
+++++
auto.
-----
Lemma anti_elements_mapsto_aux : forall (A:Type)(l:list (key*A)) m k e, NoDupA (eq_key (A:=A)) l -> (forall x, L.PX.In x l -> In x m -> False) -> (MapsTo k e (L.fold (@add _) l m) <-> L.PX.MapsTo k e l \\/ MapsTo k e m).
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l ->\n    (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).

*****

*****
forall (A : Type) (l : list (prod key A)) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l), iff (MapsTo k e (anti_elements l)) (L.PX.MapsTo k e l)
+++++
Proof.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.

*****

*****
forall (A : Type) (l : list (prod key A)) (k : key) (e : A) (_ : NoDupA (eq_key (A:=A)) l), iff (MapsTo k e (anti_elements l)) (L.PX.MapsTo k e l)
+++++
intros.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
iff (MapsTo k e (anti_elements l)) (L.PX.MapsTo k e l)
+++++
unfold anti_elements.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
iff (MapsTo k e (L.fold (add (A:=A)) l (empty A))) (L.PX.MapsTo k e l)
+++++
rewrite anti_elements_mapsto_aux.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
iff (or (L.PX.MapsTo k e l) (MapsTo k e (empty A))) (L.PX.MapsTo k e l)
+++++
auto.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.
auto.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
iff (or (L.PX.MapsTo k e l) (MapsTo k e (empty A))) (L.PX.MapsTo k e l)
+++++
unfold empty.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.
auto.
unfold empty.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
iff (or (L.PX.MapsTo k e l) (MapsTo k e (M0 A))) (L.PX.MapsTo k e l)
+++++
auto.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.
auto.
unfold empty.
auto.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
iff (or (L.PX.MapsTo k e l) (MapsTo k e (M0 A))) (L.PX.MapsTo k e l)
+++++
intuition.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.
auto.
unfold empty.
auto.
intuition.

*****
H1 : MapsTo k e (M0 A)
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
L.PX.MapsTo k e l
+++++
inversion H1.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
NoDupA (eq_key (A:=A)) l
+++++
auto.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
forall (x : N) (_ : L.PX.In x l) (_ : In x (empty A)), False
+++++
auto.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.
auto.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
forall (x : N) (_ : L.PX.In x l) (_ : In x (empty A)), False
+++++
unfold empty.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.
auto.
unfold empty.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
forall (x : N) (_ : L.PX.In x l) (_ : In x (M0 A)), False
+++++
auto.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.
auto.
unfold empty.
auto.

*****
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
forall (x : N) (_ : L.PX.In x l) (_ : In x (M0 A)), False
+++++
inversion 2.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.
auto.
unfold empty.
auto.
inversion 2.

*****
H2 : MapsTo x x0 (M0 A)
x0 : A
H1 : In x (M0 A)
H0 : L.PX.In x l
x : N
H : NoDupA (eq_key (A:=A)) l
e : A
k : key
l : list (prod key A)
A : Type
*****
False
+++++
inversion H2.
-----
Lemma anti_elements_mapsto : forall (A:Type) l k e, NoDupA (eq_key (A:=A)) l -> (MapsTo k e (anti_elements l) <-> L.PX.MapsTo k e l).
Proof.
intros.
unfold anti_elements.
rewrite anti_elements_mapsto_aux.

*****

*****

+++++
Qed.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> \n    find x (anti_elements l) = L.find x l.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.

*****

*****
forall (A : Type) (l : list (prod key A)) (x : key) (_ : Sorted (lt_key (A:=A)) l), eq (find x (anti_elements l)) (L.find (elt:=A) x l)
+++++
Proof.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.

*****

*****
forall (A : Type) (l : list (prod key A)) (x : key) (_ : Sorted (lt_key (A:=A)) l), eq (find x (anti_elements l)) (L.find (elt:=A) x l)
+++++
intros.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.

*****
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
eq (find x (anti_elements l)) (L.find (elt:=A) x l)
+++++
case_eq (L.find x l).
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).

*****
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
forall (a : A) (_ : eq (L.find (elt:=A) x l) (Some a)), eq (find x (anti_elements l)) (Some a)
+++++
intros.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.

*****
H0 : eq (L.find (elt:=A) x l) (Some a)
a : A
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
eq (find x (anti_elements l)) (Some a)
+++++
apply find_1.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
apply find_1.

*****
H0 : eq (L.find (elt:=A) x l) (Some a)
a : A
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
MapsTo x a (anti_elements l)
+++++
rewrite anti_elements_mapsto.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
apply find_1.
rewrite anti_elements_mapsto.

*****
H0 : eq (L.find (elt:=A) x l) (Some a)
a : A
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
L.PX.MapsTo x a l
+++++
auto using L.PX.Sort_NoDupA, L.find_2.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
apply find_1.
rewrite anti_elements_mapsto.

*****
H0 : eq (L.find (elt:=A) x l) (Some a)
a : A
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
NoDupA (eq_key (A:=A)) l
+++++
auto using L.PX.Sort_NoDupA, L.find_2.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).

*****
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
forall _ : eq (L.find (elt:=A) x l) None, eq (find x (anti_elements l)) None
+++++
intros.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.

*****
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
eq (find x (anti_elements l)) None
+++++
case_eq (find x (anti_elements l)).
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).

*****
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
forall (a : A) (_ : eq (find x (anti_elements l)) (Some a)), eq (Some a) None
+++++
auto.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).
auto.

*****
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
forall (a : A) (_ : eq (find x (anti_elements l)) (Some a)), eq (Some a) None
+++++
intros.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).
auto.
intros.

*****
H1 : eq (find x (anti_elements l)) (Some a)
a : A
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
eq (Some a) None
+++++
rewrite <- H0.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).
auto.
intros.
rewrite <- H0.

*****
H1 : eq (find x (anti_elements l)) (Some a)
a : A
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
eq (Some a) (L.find (elt:=A) x l)
+++++
symmetry.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).
auto.
intros.
rewrite <- H0.
symmetry.

*****
H1 : eq (find x (anti_elements l)) (Some a)
a : A
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
eq (L.find (elt:=A) x l) (Some a)
+++++
apply L.find_1.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).
auto.
intros.
rewrite <- H0.
symmetry.
apply L.find_1.

*****
H1 : eq (find x (anti_elements l)) (Some a)
a : A
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) l
+++++
auto.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).
auto.
intros.
rewrite <- H0.
symmetry.
apply L.find_1.

*****
H1 : eq (find x (anti_elements l)) (Some a)
a : A
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
L.PX.MapsTo x a l
+++++
auto.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).
auto.
intros.
rewrite <- H0.
symmetry.
apply L.find_1.
auto.

*****
H1 : eq (find x (anti_elements l)) (Some a)
a : A
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
L.PX.MapsTo x a l
+++++
rewrite <- anti_elements_mapsto.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).
auto.
intros.
rewrite <- H0.
symmetry.
apply L.find_1.
auto.
rewrite <- anti_elements_mapsto.

*****
H1 : eq (find x (anti_elements l)) (Some a)
a : A
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
MapsTo x a (anti_elements l)
+++++
auto using L.PX.Sort_NoDupA, find_2.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).
auto.
intros.
rewrite <- H0.
symmetry.
apply L.find_1.
auto.
rewrite <- anti_elements_mapsto.

*****
H1 : eq (find x (anti_elements l)) (Some a)
a : A
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
NoDupA (eq_key (A:=A)) l
+++++
auto using L.PX.Sort_NoDupA, find_2.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).
intros.
case_eq (find x (anti_elements l)).

*****
H0 : eq (L.find (elt:=A) x l) None
H : Sorted (lt_key (A:=A)) l
x : key
l : list (prod key A)
A : Type
*****
forall _ : eq (find x (anti_elements l)) None, eq None None
+++++
auto.
-----
Lemma find_anti_elements : forall (A:Type)(l: list (key*A)) x, sort (@lt_key _) l -> find x (anti_elements l) = L.find x l.
Proof.
intros.
case_eq (L.find x l).

*****

*****

+++++
Qed.
-----
Lemma find_elements : forall (A:Type)(m: t A) x,  \n    L.find x (elements m) = find x m.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.

*****

*****
forall (A : Type) (m : t A) (x : L.key), eq (L.find (elt:=A) x (elements m)) (find x m)
+++++
Proof.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.

*****

*****
forall (A : Type) (m : t A) (x : L.key), eq (L.find (elt:=A) x (elements m)) (find x m)
+++++
intros.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.

*****
x : L\.key
m : t A
A : Type
*****
eq (L.find (elt:=A) x (elements m)) (find x m)
+++++
case_eq (find x m).
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).

*****
x : L\.key
m : t A
A : Type
*****
forall (a : A) (_ : eq (find x m) (Some a)), eq (L.find (elt:=A) x (elements m)) (Some a)
+++++
intros.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.

*****
H : eq (find x m) (Some a)
a : A
x : L\.key
m : t A
A : Type
*****
eq (L.find (elt:=A) x (elements m)) (Some a)
+++++
apply L.find_1.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
apply L.find_1.

*****
H : eq (find x m) (Some a)
a : A
x : L\.key
m : t A
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
apply elements_3.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
apply L.find_1.

*****
H : eq (find x m) (Some a)
a : A
x : L\.key
m : t A
A : Type
*****
L.PX.MapsTo x a (elements m)
+++++
red.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
apply L.find_1.
red.

*****
H : eq (find x m) (Some a)
a : A
x : L\.key
m : t A
A : Type
*****
InA (L.PX.eqke (elt:=A)) (pair x a) (elements m)
+++++
apply elements_1.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
apply L.find_1.
red.
apply elements_1.

*****
H : eq (find x m) (Some a)
a : A
x : L\.key
m : t A
A : Type
*****
MapsTo x a m
+++++
apply find_2.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
apply L.find_1.
red.
apply elements_1.
apply find_2.

*****
H : eq (find x m) (Some a)
a : A
x : L\.key
m : t A
A : Type
*****
eq (find x m) (Some a)
+++++
auto.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).

*****
x : L\.key
m : t A
A : Type
*****
forall _ : eq (find x m) None, eq (L.find (elt:=A) x (elements m)) None
+++++
intros.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.

*****
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
eq (L.find (elt:=A) x (elements m)) None
+++++
case_eq (L.find x (elements m)).
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).

*****
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
forall (a : A) (_ : eq (L.find (elt:=A) x (elements m)) (Some a)), eq (Some a) None
+++++
auto.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).
auto.

*****
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
forall (a : A) (_ : eq (L.find (elt:=A) x (elements m)) (Some a)), eq (Some a) None
+++++
intros.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).
auto.
intros.

*****
H0 : eq (L.find (elt:=A) x (elements m)) (Some a)
a : A
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
eq (Some a) None
+++++
rewrite <- H.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).
auto.
intros.
rewrite <- H.

*****
H0 : eq (L.find (elt:=A) x (elements m)) (Some a)
a : A
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
eq (Some a) (find x m)
+++++
symmetry.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).
auto.
intros.
rewrite <- H.
symmetry.

*****
H0 : eq (L.find (elt:=A) x (elements m)) (Some a)
a : A
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
eq (find x m) (Some a)
+++++
apply find_1.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.

*****
H0 : eq (L.find (elt:=A) x (elements m)) (Some a)
a : A
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
MapsTo x a m
+++++
auto.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.
auto.

*****
H0 : eq (L.find (elt:=A) x (elements m)) (Some a)
a : A
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
MapsTo x a m
+++++
apply elements_2.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.
auto.
apply elements_2.

*****
H0 : eq (L.find (elt:=A) x (elements m)) (Some a)
a : A
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
InA (eq_key_elt (A:=A)) (pair x a) (elements m)
+++++
apply L.find_2.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).
auto.
intros.
rewrite <- H.
symmetry.
apply find_1.
auto.
apply elements_2.
apply L.find_2.

*****
H0 : eq (L.find (elt:=A) x (elements m)) (Some a)
a : A
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
eq (L.find (elt:=A) x (elements m)) (Some a)
+++++
auto.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).
intros.
case_eq (L.find x (elements m)).

*****
H : eq (find x m) None
x : L\.key
m : t A
A : Type
*****
forall _ : eq (L.find (elt:=A) x (elements m)) None, eq None None
+++++
auto.
-----
Lemma find_elements : forall (A:Type)(m: t A) x, L.find x (elements m) = find x m.
Proof.
intros.
case_eq (find x m).

*****

*****

+++++
Qed.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.

*****

*****
forall (A : Type) (s : t A) (x : N), iff (L.PX.In x (elements s)) (In x s)
+++++
Proof.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.

*****

*****
forall (A : Type) (s : t A) (x : N), iff (L.PX.In x (elements s)) (In x s)
+++++
intros.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.

*****
x : N
s : t A
A : Type
*****
iff (L.PX.In x (elements s)) (In x s)
+++++
unfold L.PX.In.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.

*****
x : N
s : t A
A : Type
*****
iff (ex (fun e : A => L.PX.MapsTo x e (elements s))) (In x s)
+++++
unfold In.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.

*****
x : N
s : t A
A : Type
*****
iff (ex (fun e : A => L.PX.MapsTo x e (elements s))) (ex (fun e : A => MapsTo x e s))
+++++
firstorder.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.

*****
H : L.PX.MapsTo x x0 (elements s)
x0 : A
x : N
s : t A
A : Type
*****
ex (fun e : A => MapsTo x e s)
+++++
exists x0.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.

*****
H : L.PX.MapsTo x x0 (elements s)
x0 : A
x : N
s : t A
A : Type
*****
MapsTo x x0 s
+++++
red.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.
red.

*****
H : L.PX.MapsTo x x0 (elements s)
x0 : A
x : N
s : t A
A : Type
*****
eq (find x s) (Some x0)
+++++
rewrite <- find_elements.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.
red.
rewrite <- find_elements.

*****
H : L.PX.MapsTo x x0 (elements s)
x0 : A
x : N
s : t A
A : Type
*****
eq (L.find (elt:=A) x (elements s)) (Some x0)
+++++
auto.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.
red.
rewrite <- find_elements.
auto.

*****
H : L.PX.MapsTo x x0 (elements s)
x0 : A
x : N
s : t A
A : Type
*****
eq (L.find (elt:=A) x (elements s)) (Some x0)
+++++
apply L.find_1.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.
red.
rewrite <- find_elements.
auto.
apply L.find_1.

*****
H : L.PX.MapsTo x x0 (elements s)
x0 : A
x : N
s : t A
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements s)
+++++
auto.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.
red.
rewrite <- find_elements.
auto.
apply L.find_1.
auto.

*****
H : L.PX.MapsTo x x0 (elements s)
x0 : A
x : N
s : t A
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements s)
+++++
apply elements_3.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.
red.
rewrite <- find_elements.
auto.
apply L.find_1.

*****
H : L.PX.MapsTo x x0 (elements s)
x0 : A
x : N
s : t A
A : Type
*****
L.PX.MapsTo x x0 (elements s)
+++++
auto.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.

*****
H : MapsTo x x0 s
x0 : A
x : N
s : t A
A : Type
*****
ex (fun e : A => L.PX.MapsTo x e (elements s))
+++++
exists x0.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.

*****
H : MapsTo x x0 s
x0 : A
x : N
s : t A
A : Type
*****
L.PX.MapsTo x x0 (elements s)
+++++
apply L.find_2.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.
apply L.find_2.

*****
H : MapsTo x x0 s
x0 : A
x : N
s : t A
A : Type
*****
eq (L.find (elt:=A) x (elements s)) (Some x0)
+++++
rewrite find_elements.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.
exists x0.
apply L.find_2.
rewrite find_elements.

*****
H : MapsTo x x0 s
x0 : A
x : N
s : t A
A : Type
*****
eq (find x s) (Some x0)
+++++
auto.
-----
Lemma elements_in : forall (A:Type)(s:t A) x, L.PX.In x (elements s) <-> In x s.
Proof.
intros.
unfold L.PX.In.
unfold In.
firstorder.

*****

*****

+++++
Qed.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key)\n    (f:option A->option B ->option C), \n    In x m \/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').

*****

*****
forall (A B C : Type) (m : t A) (m' : t B) (x : key) (f : forall (_ : option A) (_ : option B), option C) (_ : or (In x m) (In x m')), eq (find x (map2 f m m')) (f (find x m) (find x m'))
+++++
Proof.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.

*****

*****
forall (A B C : Type) (m : t A) (m' : t B) (x : key) (f : forall (_ : option A) (_ : option B), option C) (_ : or (In x m) (In x m')), eq (find x (map2 f m m')) (f (find x m) (find x m'))
+++++
unfold map2.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.

*****

*****
forall (A B C : Type) (m : t A) (m' : t B) (x : key) (f : forall (_ : option A) (_ : option B), option C) (_ : or (In x m) (In x m')), eq (find x (anti_elements (L.map2 f (elements m) (elements m')))) (f (find x m) (find x m'))
+++++
intros.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
eq (find x (anti_elements (L.map2 f (elements m) (elements m')))) (f (find x m) (find x m'))
+++++
rewrite find_anti_elements.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
eq (L.find (elt:=C) x (L.map2 f (elements m) (elements m'))) (f (find x m) (find x m'))
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
eq (L.find (elt:=C) x (L.map2 f (elements m) (elements m'))) (f (find x m) (find x m'))
+++++
rewrite <- find_elements.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
eq (L.find (elt:=C) x (L.map2 f (elements m) (elements m'))) (f (L.find (elt:=A) x (elements m)) (find x m'))
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
eq (L.find (elt:=C) x (L.map2 f (elements m) (elements m'))) (f (L.find (elt:=A) x (elements m)) (find x m'))
+++++
rewrite <- find_elements.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.
rewrite <- find_elements.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
eq (L.find (elt:=C) x (L.map2 f (elements m) (elements m'))) (f (L.find (elt:=A) x (elements m)) (L.find (elt:=B) x (elements m')))
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.
rewrite <- find_elements.
auto.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
eq (L.find (elt:=C) x (L.map2 f (elements m) (elements m'))) (f (L.find (elt:=A) x (elements m)) (L.find (elt:=B) x (elements m')))
+++++
apply L.map2_1.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.
rewrite <- find_elements.
auto.
apply L.map2_1.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.
rewrite <- find_elements.
auto.
apply L.map2_1.
auto.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
apply elements_3.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.
rewrite <- find_elements.
auto.
apply L.map2_1.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=B)) (elements m')
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.
rewrite <- find_elements.
auto.
apply L.map2_1.
auto.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=B)) (elements m')
+++++
apply elements_3.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.
rewrite <- find_elements.
auto.
apply L.map2_1.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
or (L.PX.In x (elements m)) (L.PX.In x (elements m'))
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.
rewrite <- find_elements.
auto.
apply L.map2_1.
auto.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
or (L.PX.In x (elements m)) (L.PX.In x (elements m'))
+++++
do 2 rewrite elements_in.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
rewrite <- find_elements.
auto.
rewrite <- find_elements.
auto.
apply L.map2_1.
auto.
do 2 rewrite elements_in.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
or (In x m) (In x m')
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (lt_key (A:=C)) (L.map2 f (elements m) (elements m'))
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (lt_key (A:=C)) (L.map2 f (elements m) (elements m'))
+++++
apply L.map2_sorted.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
apply L.map2_sorted.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
apply L.map2_sorted.
auto.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
apply elements_3.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
apply L.map2_sorted.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=B)) (elements m')
+++++
auto.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.
auto.
apply L.map2_sorted.
auto.

*****
H : or (In x m) (In x m')
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=B)) (elements m')
+++++
apply elements_3.
-----
Lemma map2_1 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x m \\/ In x m' -> find x (map2 f m m') = f (find x m) (find x m').
Proof.
unfold map2.
intros.
rewrite find_anti_elements.

*****

*****

+++++
Qed.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key)\n      (f:option A->option B ->option C), \n    In x (map2 f m m') -> In x m \/ In x m'.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.

*****

*****
forall (A B C : Type) (m : t A) (m' : t B) (x : key) (f : forall (_ : option A) (_ : option B), option C) (_ : In x (map2 f m m')), or (In x m) (In x m')
+++++
Proof.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.

*****

*****
forall (A B C : Type) (m : t A) (m' : t B) (x : key) (f : forall (_ : option A) (_ : option B), option C) (_ : In x (map2 f m m')), or (In x m) (In x m')
+++++
unfold map2.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.

*****

*****
forall (A B C : Type) (m : t A) (m' : t B) (x : key) (f : forall (_ : option A) (_ : option B), option C) (_ : In x (anti_elements (L.map2 f (elements m) (elements m')))), or (In x m) (In x m')
+++++
intros.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.

*****
H : In x (anti_elements (L.map2 f (elements m) (elements m')))
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
or (In x m) (In x m')
+++++
do 2 rewrite <- elements_in.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.

*****
H : In x (anti_elements (L.map2 f (elements m) (elements m')))
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
or (L.PX.In x (elements m)) (L.PX.In x (elements m'))
+++++
apply L.map2_2 with (f:=f).
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).

*****
H : In x (anti_elements (L.map2 f (elements m) (elements m')))
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
auto.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.

*****
H : In x (anti_elements (L.map2 f (elements m) (elements m')))
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
apply elements_3.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).

*****
H : In x (anti_elements (L.map2 f (elements m) (elements m')))
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=B)) (elements m')
+++++
auto.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.

*****
H : In x (anti_elements (L.map2 f (elements m) (elements m')))
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=B)) (elements m')
+++++
apply elements_3.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).

*****
H : In x (anti_elements (L.map2 f (elements m) (elements m')))
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
L.PX.In x (L.map2 f (elements m) (elements m'))
+++++
auto.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.

*****
H : In x (anti_elements (L.map2 f (elements m) (elements m')))
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
L.PX.In x (L.map2 f (elements m) (elements m'))
+++++
destruct H.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
L.PX.In x (L.map2 f (elements m) (elements m'))
+++++
exists x0.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
L.PX.MapsTo x x0 (L.map2 f (elements m) (elements m'))
+++++
rewrite <- anti_elements_mapsto.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.
rewrite <- anti_elements_mapsto.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
+++++
auto.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.
rewrite <- anti_elements_mapsto.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
NoDupA (eq_key (A:=C)) (L.map2 f (elements m) (elements m'))
+++++
auto.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.
rewrite <- anti_elements_mapsto.
auto.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
NoDupA (eq_key (A:=C)) (L.map2 f (elements m) (elements m'))
+++++
apply L.PX.Sort_NoDupA.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.
rewrite <- anti_elements_mapsto.
auto.
apply L.PX.Sort_NoDupA.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=C)) (L.map2 f (elements m) (elements m'))
+++++
auto.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.
rewrite <- anti_elements_mapsto.
auto.
apply L.PX.Sort_NoDupA.
auto.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=C)) (L.map2 f (elements m) (elements m'))
+++++
apply L.map2_sorted.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.
rewrite <- anti_elements_mapsto.
auto.
apply L.PX.Sort_NoDupA.
auto.
apply L.map2_sorted.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
auto.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.
rewrite <- anti_elements_mapsto.
auto.
apply L.PX.Sort_NoDupA.
auto.
apply L.map2_sorted.
auto.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
apply elements_3.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.
rewrite <- anti_elements_mapsto.
auto.
apply L.PX.Sort_NoDupA.
auto.
apply L.map2_sorted.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=B)) (elements m')
+++++
auto.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).
auto.
destruct H.
exists x0.
rewrite <- anti_elements_mapsto.
auto.
apply L.PX.Sort_NoDupA.
auto.
apply L.map2_sorted.
auto.

*****
H : MapsTo x x0 (anti_elements (L.map2 f (elements m) (elements m')))
x0 : C
f : forall (_ : option A) (_ : option B), option C
x : key
m' : t B
m : t A
C : Type
B : Type
A : Type
*****
Sorted (L.PX.ltk (elt:=B)) (elements m')
+++++
apply elements_3.
-----
Lemma map2_2 : forall (A B C:Type)(m: t A)(m': t B)(x:key) (f:option A->option B ->option C), In x (map2 f m m') -> In x m \\/ In x m'.
Proof.
unfold map2.
intros.
do 2 rewrite <- elements_in.
apply L.map2_2 with (f:=f).

*****

*****

+++++
Qed.
-----
Definition equal (A:Type)(cmp:A -> A -> bool)(m m' : t A) : bool := \n    L.equal cmp (elements m) (elements m').
-----
Lemma equal_1 : \n    forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), \n    Equivb cmp m m' -> equal cmp m m' = true.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : Equivb cmp m m'), eq (equal cmp m m') true
+++++
Proof.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : Equivb cmp m m'), eq (equal cmp m m') true
+++++
unfold equal.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : Equivb cmp m m'), eq (L.equal cmp (elements m) (elements m')) true
+++++
unfold Equivb.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : Equiv (Cmp cmp) m m'), eq (L.equal cmp (elements m) (elements m')) true
+++++
unfold Equiv.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : and (forall k : key, iff (In k m) (In k m')) (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'), Cmp cmp e e')), eq (L.equal cmp (elements m) (elements m')) true
+++++
unfold Cmp.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : and (forall k : key, iff (In k m) (In k m')) (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'), eq (cmp e e') true)), eq (L.equal cmp (elements m) (elements m')) true
+++++
intros.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.

*****
H : and (forall k : key, iff (In k m) (In k m'))\n (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\n eq (cmp e e') true)
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (L.equal cmp (elements m) (elements m')) true
+++++
apply L.equal_1.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.

*****
H : and (forall k : key, iff (In k m) (In k m'))\n (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\n eq (cmp e e') true)
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
apply elements_3.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.

*****
H : and (forall k : key, iff (In k m) (In k m'))\n (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\n eq (cmp e e') true)
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m')
+++++
apply elements_3.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.

*****
H : and (forall k : key, iff (In k m) (In k m'))\n (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\n eq (cmp e e') true)
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
L.Equivb cmp (elements m) (elements m')
+++++
unfold L.Equivb.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.

*****
H : and (forall k : key, iff (In k m) (In k m'))\n (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\n eq (cmp e e') true)
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
and (forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))) (forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m)) (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true)
+++++
destruct H.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.

*****
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
and (forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))) (forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m)) (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true)
+++++
split.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.

*****
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
+++++
intros.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.

*****
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
+++++
do 2 rewrite elements_in.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
do 2 rewrite elements_in.

*****
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
iff (In k m) (In k m')
+++++
auto.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.

*****
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m)) (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
+++++
intros.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (cmp e e') true
+++++
apply (H0 k).
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
MapsTo k e m
+++++
red.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (find k m) (Some e)
+++++
rewrite <- find_elements.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.
rewrite <- find_elements.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (L.find (elt:=A) k (elements m)) (Some e)
+++++
apply L.find_1.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.
rewrite <- find_elements.
apply L.find_1.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
auto.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.
rewrite <- find_elements.
apply L.find_1.
auto.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m)
+++++
apply elements_3.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.
rewrite <- find_elements.
apply L.find_1.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
L.PX.MapsTo k e (elements m)
+++++
auto.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
MapsTo k e' m'
+++++
red.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (find k m') (Some e')
+++++
rewrite <- find_elements.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.
rewrite <- find_elements.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (L.find (elt:=A) k (elements m')) (Some e')
+++++
apply L.find_1.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.
rewrite <- find_elements.
apply L.find_1.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m')
+++++
auto.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.
rewrite <- find_elements.
apply L.find_1.
auto.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
Sorted (L.PX.ltk (elt:=A)) (elements m')
+++++
apply elements_3.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.
unfold L.Equivb.
destruct H.
split.
intros.
apply (H0 k).
red.
rewrite <- find_elements.
apply L.find_1.

*****
H2 : L.PX.MapsTo k e' (elements m')
H1 : L.PX.MapsTo k e (elements m)
e,e' : A
k : N
H0 : forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'),\neq (cmp e e') true
H : forall k : key, iff (In k m) (In k m')
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
L.PX.MapsTo k e' (elements m')
+++++
auto.
-----
Lemma equal_1 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), Equivb cmp m m' -> equal cmp m m' = true.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
apply L.equal_1.

*****

*****

+++++
Qed.
-----
Lemma equal_2 : \n    forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), \n    equal cmp m m' = true -> Equivb cmp m m'.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : eq (equal cmp m m') true), Equivb cmp m m'
+++++
Proof.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : eq (equal cmp m m') true), Equivb cmp m m'
+++++
unfold equal.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : eq (L.equal cmp (elements m) (elements m')) true), Equivb cmp m m'
+++++
unfold Equivb.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : eq (L.equal cmp (elements m) (elements m')) true), Equiv (Cmp cmp) m m'
+++++
unfold Equiv.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : eq (L.equal cmp (elements m) (elements m')) true), and (forall k : key, iff (In k m) (In k m')) (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'), Cmp cmp e e')
+++++
unfold Cmp.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.

*****

*****
forall (A : Type) (m m' : t A) (cmp : forall (_ : A) (_ : A), bool) (_ : eq (L.equal cmp (elements m) (elements m')) true), and (forall k : key, iff (In k m) (In k m')) (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'), eq (cmp e e') true)
+++++
intros.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.

*****
H : eq (L.equal cmp (elements m) (elements m')) true
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
and (forall k : key, iff (In k m) (In k m')) (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'), eq (cmp e e') true)
+++++
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).

*****
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
H : eq (L.equal cmp (elements m) (elements m')) true
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
and (forall k : key, iff (In k m) (In k m')) (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'), eq (cmp e e') true)
+++++
clear H.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.

*****
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
and (forall k : key, iff (In k m) (In k m')) (forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'), eq (cmp e e') true)
+++++
split.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.

*****
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
forall k : key, iff (In k m) (In k m')
+++++
intros.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.
intros.

*****
k : key
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
iff (In k m) (In k m')
+++++
do 2 rewrite <- elements_in.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.
intros.
do 2 rewrite <- elements_in.

*****
k : key
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
+++++
auto.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.

*****
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
forall (k : key) (e e' : A) (_ : MapsTo k e m) (_ : MapsTo k e' m'), eq (cmp e e') true
+++++
intros.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.
intros.

*****
H2 : MapsTo k e' m'
H : MapsTo k e m
e,e' : A
k : key
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (cmp e e') true
+++++
apply (H1 k).
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.
intros.
apply (H1 k).

*****
H2 : MapsTo k e' m'
H : MapsTo k e m
e,e' : A
k : key
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
L.PX.MapsTo k e (elements m)
+++++
apply L.find_2.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.
intros.
apply (H1 k).
apply L.find_2.

*****
H2 : MapsTo k e' m'
H : MapsTo k e m
e,e' : A
k : key
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (L.find (elt:=A) k (elements m)) (Some e)
+++++
rewrite find_elements.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.
intros.
apply (H1 k).
apply L.find_2.
rewrite find_elements.

*****
H2 : MapsTo k e' m'
H : MapsTo k e m
e,e' : A
k : key
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (find k m) (Some e)
+++++
auto.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.
intros.
apply (H1 k).

*****
H2 : MapsTo k e' m'
H : MapsTo k e m
e,e' : A
k : key
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
L.PX.MapsTo k e' (elements m')
+++++
apply L.find_2.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.
intros.
apply (H1 k).
apply L.find_2.

*****
H2 : MapsTo k e' m'
H : MapsTo k e m
e,e' : A
k : key
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (L.find (elt:=A) k (elements m')) (Some e')
+++++
rewrite find_elements.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.
intros.
apply (H1 k).
apply L.find_2.
rewrite find_elements.

*****
H2 : MapsTo k e' m'
H : MapsTo k e m
e,e' : A
k : key
H1 : forall (k : N) (e e' : A) (_ : L.PX.MapsTo k e (elements m))\n (_ : L.PX.MapsTo k e' (elements m')), eq (cmp e e') true
H0 : forall k : N, iff (L.PX.In k (elements m)) (L.PX.In k (elements m'))
cmp : forall (_ : A) (_ : A), bool
m,m' : t A
A : Type
*****
eq (find k m') (Some e')
+++++
auto.
-----
Lemma equal_2 : forall (A:Type)(m: t A)(m': t A)(cmp: A -> A -> bool), equal cmp m m' = true -> Equivb cmp m m'.
Proof.
unfold equal.
unfold Equivb.
unfold Equiv.
unfold Cmp.
intros.
destruct (L.equal_2 (elements_3 m) (elements_3 m') H).
clear H.
split.

*****

*****

+++++
Qed.
-----
End MapIntMap.
-----
