Require Import ExtLib.Structures.Maps.
-----
Require Import ExtLib.Structures.Functor.
-----
Require Import ExtLib.Data.Option.
-----
Require Import ExtLib.Data.Positive.
-----
Require Import ExtLib.Tactics.Cases.
-----
Set Implicit Arguments.
-----
Set Strict Implicit.
-----
Section pmap.
-----
Variable T : Type.
-----
Inductive pmap : Type :=\n  | Empty\n  | Branch : option T -> pmap -> pmap -> pmap.
-----
Definition pmap_here (m : pmap) : option T :=\n    match m with\n      | Empty => None\n      | Branch d _ _ => d\n    end.
-----
Definition pmap_left (m : pmap) : pmap :=\n    match m with\n      | Empty => Empty\n      | Branch _ l _ => l\n    end.
-----
Definition pmap_right (m : pmap) : pmap :=\n    match m with\n      | Empty => Empty\n      | Branch _ _ r => r\n    end.
-----
Fixpoint pmap_lookup (p : positive) (m : pmap) : option T :=\n    match m with\n      | Empty => None\n      | Branch d l r =>\n        match p with\n          | xH => d\n          | xO p => pmap_lookup p l\n          | xI p => pmap_lookup p r\n        end\n    end.
-----
Fixpoint pmap_insert (p : positive) (v : T) (m : pmap) : pmap :=\n    match p with\n      | xH => Branch (Some v) (pmap_left m) (pmap_right m)\n      | xO p =>\n        Branch (pmap_here m) (pmap_insert p v (pmap_left m)) (pmap_right m)\n      | xI p =>\n        Branch (pmap_here m) (pmap_left m) (pmap_insert p v (pmap_right m))\n    end.
-----
Definition branch (o : option T) (l r : pmap) : pmap :=\n    match o , l , r with\n      | None , Empty , Empty => Empty\n      | _ , _ , _ => Branch o l r\n    end.
-----
Fixpoint pmap_remove (p : positive) (m : pmap) : pmap :=\n    match m with\n      | Empty => Empty\n      | Branch d l r =>\n        match p with\n          | xH => branch None l r\n          | xO p => branch d (pmap_remove p l) r\n          | xI p => branch d l (pmap_remove p r)\n        end\n    end.
-----
Definition pmap_empty : pmap := Empty.
-----
Fixpoint pmap_union (f m : pmap) : pmap :=\n    match f with\n      | Empty => m\n      | Branch d l r =>\n        Branch (match d with\n                  | Some x => Some x\n                  | None => pmap_here m\n                end) (pmap_union l (pmap_left m)) (pmap_union r (pmap_right m))\n    end.
-----
Global Instance Map_pmap : Map positive T pmap :=\n  { empty := pmap_empty\n  ; add := pmap_insert\n  ; remove := pmap_remove\n  ; lookup := pmap_lookup\n  ; union := pmap_union\n  }.
-----
Lemma tilde_1_inj_neg : forall k k',\n    (k~1)%positive <> (k'~1)%positive -> k <> k'.
-----
Lemma tilde_1_inj_neg : forall k k', (k~1)%positive <> (k'~1)%positive -> k <> k'.

*****
T : Type
*****
forall (k k' : positive) (_ : not (eq (xI k) (xI k'))), not (eq k k')
+++++
Proof.
-----
Lemma tilde_1_inj_neg : forall k k', (k~1)%positive <> (k'~1)%positive -> k <> k'.
Proof.

*****
T : Type
*****
forall (k k' : positive) (_ : not (eq (xI k) (xI k'))), not (eq k k')
+++++
induction k; destruct k'; intuition; try match goal with | H : _ = _ |- _ => inversion H; clear H; subst end; intuition eauto.
-----
Lemma tilde_1_inj_neg : forall k k', (k~1)%positive <> (k'~1)%positive -> k <> k'.
Proof.
induction k; destruct k'; intuition; try match goal with | H : _ = _ |- _ => inversion H; clear H; subst end; intuition eauto.

*****

*****

+++++
Qed.
-----
Lemma tilde_0_inj_neg : forall k k',\n    (k~0)%positive <> (k'~0)%positive -> k <> k'.
-----
Lemma tilde_0_inj_neg : forall k k', (k~0)%positive <> (k'~0)%positive -> k <> k'.

*****
T : Type
*****
forall (k k' : positive) (_ : not (eq (xO k) (xO k'))), not (eq k k')
+++++
Proof.
-----
Lemma tilde_0_inj_neg : forall k k', (k~0)%positive <> (k'~0)%positive -> k <> k'.
Proof.

*****
T : Type
*****
forall (k k' : positive) (_ : not (eq (xO k) (xO k'))), not (eq k k')
+++++
induction k; destruct k'; intuition; try match goal with | H : _ = _ |- _ => inversion H; clear H; subst end; intuition eauto.
-----
Lemma tilde_0_inj_neg : forall k k', (k~0)%positive <> (k'~0)%positive -> k <> k'.
Proof.
induction k; destruct k'; intuition; try match goal with | H : _ = _ |- _ => inversion H; clear H; subst end; intuition eauto.

*****

*****

+++++
Qed.
-----
Lemma pmap_lookup_insert_empty : forall k k' v,\n    k <> k' ->\n    pmap_lookup k' (pmap_insert k v Empty) = None.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.

*****
T : Type
*****
forall (k k' : positive) (v : T) (_ : not (eq k k')), eq (pmap_lookup k' (pmap_insert k v Empty)) None
+++++
Proof.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.

*****
T : Type
*****
forall (k k' : positive) (v : T) (_ : not (eq k k')), eq (pmap_lookup k' (pmap_insert k v Empty)) None
+++++
induction k.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.

*****
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (k' : positive) (v : T) (_ : not (eq (xI k) k')), eq (pmap_lookup k' (pmap_insert (xI k) v Empty)) None
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.

*****
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (v : T) (_ : not (eq (xI k) (xI k'))), eq (pmap_lookup (xI k') (pmap_insert (xI k) v Empty)) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.

*****
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (v : T) (_ : not (eq (xI k) (xI k'))), eq (pmap_lookup k' (pmap_insert k v Empty)) None
+++++
intros.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.

*****
H : not (eq (xI k) (xI k'))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup k' (pmap_insert k v Empty)) None
+++++
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.

*****
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (v : T) (_ : not (eq (xI k) (xO k'))), eq (pmap_lookup (xO k') (pmap_insert (xI k) v Empty)) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.

*****
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (_ : T) (_ : not (eq (xI k) (xO k'))), eq (pmap_lookup k' Empty) None
+++++
intros.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.

*****
H : not (eq (xI k) (xO k'))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup k' Empty) None
+++++
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.

*****
H : not (eq (xI k) (xO k'))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup k' Empty) None
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq (xI k) (xO (xI k')))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup (xI k') Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq (xI k) (xO (xI k')))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq (xI k) (xO (xO k')))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup (xO k') Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq (xI k) (xO (xO k')))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq (xI k) (xO xH))
v : T
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup xH Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq (xI k) (xO xH))
v : T
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.

*****
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (v : T) (_ : not (eq (xI k) xH)), eq (pmap_lookup xH (pmap_insert (xI k) v Empty)) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.

*****
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (_ : T) (_ : not (eq (xI k) xH)), eq None None
+++++
intros.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.

*****
H : not (eq (xI k) xH)
v : T
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq None None
+++++
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.

*****
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (k' : positive) (v : T) (_ : not (eq (xO k) k')), eq (pmap_lookup k' (pmap_insert (xO k) v Empty)) None
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.

*****
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (v : T) (_ : not (eq (xO k) (xI k'))), eq (pmap_lookup (xI k') (pmap_insert (xO k) v Empty)) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.

*****
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (_ : T) (_ : not (eq (xO k) (xI k'))), eq (pmap_lookup k' Empty) None
+++++
intros.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.

*****
H : not (eq (xO k) (xI k'))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup k' Empty) None
+++++
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.

*****
H : not (eq (xO k) (xI k'))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup k' Empty) None
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq (xO k) (xI (xI k')))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup (xI k') Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq (xO k) (xI (xI k')))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq (xO k) (xI (xO k')))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup (xO k') Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq (xO k) (xI (xO k')))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq (xO k) (xI xH))
v : T
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup xH Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq (xO k) (xI xH))
v : T
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.

*****
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (v : T) (_ : not (eq (xO k) (xO k'))), eq (pmap_lookup (xO k') (pmap_insert (xO k) v Empty)) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.

*****
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (v : T) (_ : not (eq (xO k) (xO k'))), eq (pmap_lookup k' (pmap_insert k v Empty)) None
+++++
intros.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.

*****
H : not (eq (xO k) (xO k'))
v : T
k' : positive
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq (pmap_lookup k' (pmap_insert k v Empty)) None
+++++
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.

*****
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (v : T) (_ : not (eq (xO k) xH)), eq (pmap_lookup xH (pmap_insert (xO k) v Empty)) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.

*****
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
forall (_ : T) (_ : not (eq (xO k) xH)), eq None None
+++++
intros.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.

*****
H : not (eq (xO k) xH)
v : T
IHk : forall (k' : positive) (v : T) (_ : not (eq k k')),\neq (pmap_lookup k' (pmap_insert k v Empty)) None
k : positive
T : Type
*****
eq None None
+++++
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.

*****
T : Type
*****
forall (k' : positive) (v : T) (_ : not (eq xH k')), eq (pmap_lookup k' (pmap_insert xH v Empty)) None
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.

*****
k' : positive
T : Type
*****
forall (v : T) (_ : not (eq xH (xI k'))), eq (pmap_lookup (xI k') (pmap_insert xH v Empty)) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.

*****
k' : positive
T : Type
*****
forall (_ : T) (_ : not (eq xH (xI k'))), eq (pmap_lookup k' Empty) None
+++++
intros.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.

*****
H : not (eq xH (xI k'))
v : T
k' : positive
T : Type
*****
eq (pmap_lookup k' Empty) None
+++++
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.

*****
H : not (eq xH (xI k'))
v : T
k' : positive
T : Type
*****
eq (pmap_lookup k' Empty) None
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq xH (xI (xI k')))
v : T
k' : positive
T : Type
*****
eq (pmap_lookup (xI k') Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq xH (xI (xI k')))
v : T
k' : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq xH (xI (xO k')))
v : T
k' : positive
T : Type
*****
eq (pmap_lookup (xO k') Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq xH (xI (xO k')))
v : T
k' : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq xH (xI xH))
v : T
T : Type
*****
eq (pmap_lookup xH Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq xH (xI xH))
v : T
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.

*****
k' : positive
T : Type
*****
forall (v : T) (_ : not (eq xH (xO k'))), eq (pmap_lookup (xO k') (pmap_insert xH v Empty)) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.

*****
k' : positive
T : Type
*****
forall (_ : T) (_ : not (eq xH (xO k'))), eq (pmap_lookup k' Empty) None
+++++
intros.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.

*****
H : not (eq xH (xO k'))
v : T
k' : positive
T : Type
*****
eq (pmap_lookup k' Empty) None
+++++
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.

*****
H : not (eq xH (xO k'))
v : T
k' : positive
T : Type
*****
eq (pmap_lookup k' Empty) None
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq xH (xO (xI k')))
v : T
k' : positive
T : Type
*****
eq (pmap_lookup (xI k') Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq xH (xO (xI k')))
v : T
k' : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq xH (xO (xO k')))
v : T
k' : positive
T : Type
*****
eq (pmap_lookup (xO k') Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq xH (xO (xO k')))
v : T
k' : positive
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.

*****
H : not (eq xH (xO xH))
v : T
T : Type
*****
eq (pmap_lookup xH Empty) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
destruct k'.
simpl.

*****
H : not (eq xH (xO xH))
v : T
T : Type
*****
eq None None
+++++
auto.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.

*****
T : Type
*****
forall (v : T) (_ : not (eq xH xH)), eq (pmap_lookup xH (pmap_insert xH v Empty)) None
+++++
simpl.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.

*****
T : Type
*****
forall (v : T) (_ : not (eq xH xH)), eq (Some v) None
+++++
intros.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.

*****
H : not (eq xH xH)
v : T
T : Type
*****
eq (Some v) None
+++++
eauto using tilde_0_inj_neg, tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.
destruct k'.
simpl.
intros.
eauto using tilde_0_inj_neg, tilde_1_inj_neg.

*****
H : not (eq xH xH)
v : T
T : Type
*****
eq (Some v) None
+++++
congruence.
-----
Lemma pmap_lookup_insert_empty : forall k k' v, k <> k' -> pmap_lookup k' (pmap_insert k v Empty) = None.
Proof.
induction k.

*****

*****

+++++
Qed.
-----
Lemma lookup_empty : forall k, pmap_lookup k Empty = None.
-----
Lemma lookup_empty : forall k, pmap_lookup k Empty = None.

*****
T : Type
*****
forall k : positive, eq (pmap_lookup k Empty) None
+++++
Proof.
-----
Lemma lookup_empty : forall k, pmap_lookup k Empty = None.
Proof.

*****
T : Type
*****
forall k : positive, eq (pmap_lookup k Empty) None
+++++
destruct k.
-----
Lemma lookup_empty : forall k, pmap_lookup k Empty = None.
Proof.
destruct k.

*****
k : positive
T : Type
*****
eq (pmap_lookup (xI k) Empty) None
+++++
reflexivity.
-----
Lemma lookup_empty : forall k, pmap_lookup k Empty = None.
Proof.
destruct k.

*****
k : positive
T : Type
*****
eq (pmap_lookup (xO k) Empty) None
+++++
reflexivity.
-----
Lemma lookup_empty : forall k, pmap_lookup k Empty = None.
Proof.
destruct k.

*****
T : Type
*****
eq (pmap_lookup xH Empty) None
+++++
reflexivity.
-----
Lemma lookup_empty : forall k, pmap_lookup k Empty = None.
Proof.
destruct k.

*****

*****

+++++
Qed.
-----
Hint Rewrite lookup_empty pmap_lookup_insert_empty\n       using (eauto using tilde_1_inj_neg, tilde_1_inj_neg) : pmap_rw.
-----
Lemma pmap_lookup_insert_eq\n  : forall (m : pmap) (k : positive) (v : T),\n      pmap_lookup k (pmap_insert k v m) = Some v.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T), eq (pmap_lookup k (pmap_insert k v m)) (Some v)
+++++
Proof.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T), eq (pmap_lookup k (pmap_insert k v m)) (Some v)
+++++
intros m k.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.

*****
k : positive
m : pmap
T : Type
*****
forall v : T, eq (pmap_lookup k (pmap_insert k v m)) (Some v)
+++++
revert m.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.

*****
k : positive
T : Type
*****
forall (m : pmap) (v : T), eq (pmap_lookup k (pmap_insert k v m)) (Some v)
+++++
induction k.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.

*****
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
forall (m : pmap) (v : T), eq (pmap_lookup (xI k) (pmap_insert (xI k) v m)) (Some v)
+++++
simpl.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.

*****
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
forall (m : pmap) (v : T), eq (pmap_lookup k (pmap_insert k v (pmap_right m))) (Some v)
+++++
intros.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.

*****
v : T
m : pmap
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
eq (pmap_lookup k (pmap_insert k v (pmap_right m))) (Some v)
+++++
forward.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.

*****
v : T
m : pmap
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
eq (pmap_lookup k (pmap_insert k v (pmap_right m))) (Some v)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.

*****
v : T
m : pmap
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
eq (Some v) (Some v)
+++++
eauto.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.

*****
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
forall (m : pmap) (v : T), eq (pmap_lookup (xO k) (pmap_insert (xO k) v m)) (Some v)
+++++
simpl.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.

*****
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
forall (m : pmap) (v : T), eq (pmap_lookup k (pmap_insert k v (pmap_left m))) (Some v)
+++++
intros.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.

*****
v : T
m : pmap
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
eq (pmap_lookup k (pmap_insert k v (pmap_left m))) (Some v)
+++++
forward.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.

*****
v : T
m : pmap
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
eq (pmap_lookup k (pmap_insert k v (pmap_left m))) (Some v)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.

*****
v : T
m : pmap
IHk : forall (m : pmap) (v : T),\neq (pmap_lookup k (pmap_insert k v m)) (Some v)
k : positive
T : Type
*****
eq (Some v) (Some v)
+++++
eauto.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.

*****
T : Type
*****
forall (m : pmap) (v : T), eq (pmap_lookup xH (pmap_insert xH v m)) (Some v)
+++++
simpl.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.

*****
T : Type
*****
forall (_ : pmap) (v : T), eq (Some v) (Some v)
+++++
intros.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.

*****
v : T
m : pmap
T : Type
*****
eq (Some v) (Some v)
+++++
forward.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.

*****
v : T
m : pmap
T : Type
*****
eq (Some v) (Some v)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.

*****
v : T
m : pmap
T : Type
*****
eq (Some v) (Some v)
+++++
eauto.
-----
Lemma pmap_lookup_insert_eq : forall (m : pmap) (k : positive) (v : T), pmap_lookup k (pmap_insert k v m) = Some v.
Proof.
intros m k.
revert m.
induction k.

*****

*****

+++++
Qed.
-----
Lemma pmap_lookup_insert_Some_neq\n  : forall (m : pmap) (k : positive) (v : T) (k' : positive),\n      k <> k' ->\n      forall v' : T,\n        pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
+++++
Proof.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
+++++
intros m k.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.

*****
k : positive
m : pmap
T : Type
*****
forall (v : T) (k' : positive) (_ : not (eq k k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
+++++
revert m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.

*****
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
+++++
induction k.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.

*****
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq (xI k) k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (pmap_insert (xI k) v m)) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.

*****
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq (xI k) k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) (Some v'))
+++++
intros.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.

*****
v' : T
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) (Some v'))
+++++
forward.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.

*****
v' : T
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) (Some v'))
+++++
eauto.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.

*****
v' : T
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) (Some v'))
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup (xI k') m) (Some v')) (eq (pmap_lookup (xI k') (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch _ _ r => pmap_lookup k' r end (Some v')) (eq (pmap_lookup k' (pmap_insert k v (pmap_right m))) (Some v'))
+++++
destruct m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' (pmap_insert k v (pmap_right Empty))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' (pmap_insert k v Empty)) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' (pmap_insert k v (pmap_right (Branch o m1 m2)))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m2)) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m2)) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m2)) (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m2)) (Some v'))
+++++
erewrite IHk.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
erewrite IHk.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' (pmap_insert k ?Goal4 m2)) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m2)) (Some v'))
+++++
eauto using tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
erewrite IHk.
eauto using tilde_1_inj_neg.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' (pmap_insert k ?Goal4 m2)) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m2)) (Some v'))
+++++
reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
erewrite IHk.

*****
v' : T
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
not (eq k k')
+++++
eauto using tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup (xO k') m) (Some v')) (eq (pmap_lookup (xO k') (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch _ l _ => pmap_lookup k' l end (Some v')) (eq (pmap_lookup k' (pmap_left m)) (Some v'))
+++++
destruct m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' (pmap_left Empty)) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' Empty) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' (pmap_left (Branch o m1 m2))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' m1) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' m1) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' m1) (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
v' : T
H : not (eq (xI k) xH)
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup xH m) (Some v')) (eq (pmap_lookup xH (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
v' : T
H : not (eq (xI k) xH)
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch d _ _ => d end (Some v')) (eq (pmap_here m) (Some v'))
+++++
destruct m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xI k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_here Empty) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xI k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xI k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xI k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xI k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq o (Some v')) (eq (pmap_here (Branch o m1 m2)) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xI k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq o (Some v')) (eq o (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xI k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq o (Some v')) (eq o (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xI k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq o (Some v')) (eq o (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.

*****
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq (xO k) k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (pmap_insert (xO k) v m)) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.

*****
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq (xO k) k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) (Some v'))
+++++
intros.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.

*****
v' : T
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) (Some v'))
+++++
forward.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.

*****
v' : T
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) (Some v'))
+++++
eauto.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.

*****
v' : T
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) (Some v'))
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup (xI k') m) (Some v')) (eq (pmap_lookup (xI k') (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch _ _ r => pmap_lookup k' r end (Some v')) (eq (pmap_lookup k' (pmap_right m)) (Some v'))
+++++
destruct m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' (pmap_right Empty)) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' Empty) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' (pmap_right (Branch o m1 m2))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' m2) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' m2) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' m2) (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup (xO k') m) (Some v')) (eq (pmap_lookup (xO k') (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch _ l _ => pmap_lookup k' l end (Some v')) (eq (pmap_lookup k' (pmap_insert k v (pmap_left m))) (Some v'))
+++++
destruct m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' (pmap_insert k v (pmap_left Empty))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' (pmap_insert k v Empty)) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
not (eq k k')
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
not (eq k k')
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
not (eq k k')
+++++
try congruence.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' (pmap_insert k v (pmap_left (Branch o m1 m2)))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m1)) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m1)) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m1)) (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m1)) (Some v'))
+++++
try congruence.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
try congruence.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m1)) (Some v'))
+++++
erewrite IHk.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
try congruence.
erewrite IHk.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup k' (pmap_insert k ?Goal2 m1)) (Some v')) (eq (pmap_lookup k' (pmap_insert k v m1)) (Some v'))
+++++
reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
try congruence.
erewrite IHk.

*****
v' : T
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
not (eq k k')
+++++
eauto using tilde_0_inj_neg.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
v' : T
H : not (eq (xO k) xH)
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq (pmap_lookup xH m) (Some v')) (eq (pmap_lookup xH (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
v' : T
H : not (eq (xO k) xH)
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch d _ _ => d end (Some v')) (eq (pmap_here m) (Some v'))
+++++
destruct m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xO k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq (pmap_here Empty) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xO k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xO k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xO k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq (xO k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq o (Some v')) (eq (pmap_here (Branch o m1 m2)) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq (xO k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq o (Some v')) (eq o (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq (xO k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq o (Some v')) (eq o (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq (xO k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T),\niff (eq (pmap_lookup k' m) (Some v'))\n (eq (pmap_lookup k' (pmap_insert k v m)) (Some v'))
k : positive
T : Type
*****
iff (eq o (Some v')) (eq o (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.

*****
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq xH k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (pmap_insert xH v m)) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.

*****
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq xH k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) (Some v'))
+++++
intros.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.

*****
v' : T
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) (Some v'))
+++++
forward.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.

*****
v' : T
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) (Some v'))
+++++
eauto.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.

*****
v' : T
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) (Some v'))
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup (xI k') m) (Some v')) (eq (pmap_lookup (xI k') (Branch (Some v) (pmap_left m) (pmap_right m))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq match m with | Empty => None | Branch _ _ r => pmap_lookup k' r end (Some v')) (eq (pmap_lookup k' (pmap_right m)) (Some v'))
+++++
destruct m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' (pmap_right Empty)) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' Empty) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' (pmap_right (Branch o m1 m2))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' m2) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' m2) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq xH (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m2) (Some v')) (eq (pmap_lookup k' m2) (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup (xO k') m) (Some v')) (eq (pmap_lookup (xO k') (Branch (Some v) (pmap_left m) (pmap_right m))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq match m with | Empty => None | Branch _ l _ => pmap_lookup k' l end (Some v')) (eq (pmap_lookup k' (pmap_left m)) (Some v'))
+++++
destruct m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' (pmap_left Empty)) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
T : Type
*****
iff (eq None (Some v')) (eq (pmap_lookup k' Empty) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
T : Type
*****
iff (eq None (Some v')) (eq None (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' (pmap_left (Branch o m1 m2))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' m1) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' m1) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq xH (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m1) (Some v')) (eq (pmap_lookup k' m1) (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
v' : T
H : not (eq xH xH)
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup xH m) (Some v')) (eq (pmap_lookup xH (Branch (Some v) (pmap_left m) (pmap_right m))) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
v' : T
H : not (eq xH xH)
v : T
m : pmap
T : Type
*****
iff (eq match m with | Empty => None | Branch d _ _ => d end (Some v')) (eq (Some v) (Some v'))
+++++
destruct m.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None (Some v')) (eq (Some v) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None (Some v')) (eq (Some v) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None (Some v')) (eq (Some v) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None (Some v')) (eq (Some v) (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
v' : T
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None (Some v')) (eq (Some v) (Some v'))
+++++
try congruence.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
v' : T
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o (Some v')) (eq (Some v) (Some v'))
+++++
simpl.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
v' : T
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o (Some v')) (eq (Some v) (Some v'))
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
v' : T
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o (Some v')) (eq (Some v) (Some v'))
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
v' : T
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o (Some v')) (eq (Some v) (Some v'))
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
v' : T
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o (Some v')) (eq (Some v) (Some v'))
+++++
try congruence.
-----
Lemma pmap_lookup_insert_Some_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' m = Some v' <-> pmap_lookup k' (pmap_insert k v m) = Some v'.
Proof.
intros m k.
revert m.
induction k.

*****

*****

+++++
Qed.
-----
Lemma pmap_lookup_insert_None_neq\n  : forall (m : pmap) (k : positive) (v : T) (k' : positive),\n      k <> k' ->\n        pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T) (k' : positive) (_ : not (eq k k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (pmap_insert k v m)) None)
+++++
Proof.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T) (k' : positive) (_ : not (eq k k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (pmap_insert k v m)) None)
+++++
intros m k.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.

*****
k : positive
m : pmap
T : Type
*****
forall (v : T) (k' : positive) (_ : not (eq k k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (pmap_insert k v m)) None)
+++++
revert m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.

*****
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (pmap_insert k v m)) None)
+++++
induction k.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.

*****
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq (xI k) k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (pmap_insert (xI k) v m)) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.

*****
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq (xI k) k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) None)
+++++
intros.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.

*****
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) None)
+++++
forward.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.

*****
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.

*****
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.

*****
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) None)
+++++
eauto.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.

*****
H : not (eq (xI k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) None)
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup (xI k') m) None) (eq (pmap_lookup (xI k') (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch _ _ r => pmap_lookup k' r end None) (eq (pmap_lookup k' (pmap_insert k v (pmap_right m))) None)
+++++
destruct m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' (pmap_insert k v (pmap_right Empty))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' (pmap_insert k v Empty)) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' (pmap_insert k v (pmap_right (Branch o m1 m2)))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' (pmap_insert k v m2)) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' (pmap_insert k v m2)) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' (pmap_insert k v m2)) None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' (pmap_insert k v m2)) None)
+++++
erewrite IHk.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
erewrite IHk.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' (pmap_insert k ?Goal4 m2)) None) (eq (pmap_lookup k' (pmap_insert k v m2)) None)
+++++
eauto using tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
erewrite IHk.
eauto using tilde_1_inj_neg.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' (pmap_insert k ?Goal4 m2)) None) (eq (pmap_lookup k' (pmap_insert k v m2)) None)
+++++
reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
erewrite IHk.

*****
H : not (eq (xI k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
not (eq k k')
+++++
eauto using tilde_1_inj_neg.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup (xO k') m) None) (eq (pmap_lookup (xO k') (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch _ l _ => pmap_lookup k' l end None) (eq (pmap_lookup k' (pmap_left m)) None)
+++++
destruct m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' (pmap_left Empty)) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' Empty) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' (pmap_left (Branch o m1 m2))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' m1) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' m1) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xI k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' m1) None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
H : not (eq (xI k) xH)
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup xH m) None) (eq (pmap_lookup xH (Branch (pmap_here m) (pmap_left m) (pmap_insert k v (pmap_right m)))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
H : not (eq (xI k) xH)
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch d _ _ => d end None) (eq (pmap_here m) None)
+++++
destruct m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xI k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_here Empty) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xI k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xI k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xI k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xI k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq o None) (eq (pmap_here (Branch o m1 m2)) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xI k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq o None) (eq o None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xI k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq o None) (eq o None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xI k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq o None) (eq o None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.

*****
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq (xO k) k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (pmap_insert (xO k) v m)) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.

*****
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq (xO k) k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) None)
+++++
intros.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.

*****
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) None)
+++++
forward.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.

*****
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.

*****
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.

*****
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) None)
+++++
eauto.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.

*****
H : not (eq (xO k) k')
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) None)
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup (xI k') m) None) (eq (pmap_lookup (xI k') (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch _ _ r => pmap_lookup k' r end None) (eq (pmap_lookup k' (pmap_right m)) None)
+++++
destruct m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' (pmap_right Empty)) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' Empty) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' (pmap_right (Branch o m1 m2))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' m2) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' m2) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xO k) (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' m2) None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup (xO k') m) None) (eq (pmap_lookup (xO k') (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch _ l _ => pmap_lookup k' l end None) (eq (pmap_lookup k' (pmap_insert k v (pmap_left m))) None)
+++++
destruct m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' (pmap_insert k v (pmap_left Empty))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' (pmap_insert k v Empty)) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
not (eq k k')
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
not (eq k k')
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
not (eq k k')
+++++
try congruence.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' (pmap_insert k v (pmap_left (Branch o m1 m2)))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' (pmap_insert k v m1)) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' (pmap_insert k v m1)) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' (pmap_insert k v m1)) None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' (pmap_insert k v m1)) None)
+++++
try congruence.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
try congruence.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' (pmap_insert k v m1)) None)
+++++
erewrite IHk.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
try congruence.
erewrite IHk.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup k' (pmap_insert k ?Goal2 m1)) None) (eq (pmap_lookup k' (pmap_insert k v m1)) None)
+++++
reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.
try congruence.
erewrite IHk.

*****
H : not (eq (xO k) (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
not (eq k k')
+++++
eauto using tilde_0_inj_neg.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
H : not (eq (xO k) xH)
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq (pmap_lookup xH m) None) (eq (pmap_lookup xH (Branch (pmap_here m) (pmap_insert k v (pmap_left m)) (pmap_right m))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
H : not (eq (xO k) xH)
v : T
m : pmap
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq match m with | Empty => None | Branch d _ _ => d end None) (eq (pmap_here m) None)
+++++
destruct m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xO k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq (pmap_here Empty) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xO k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xO k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xO k) xH)
v : T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq None None) (eq None None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq (xO k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq o None) (eq (pmap_here (Branch o m1 m2)) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq (xO k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq o None) (eq o None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq (xO k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq o None) (eq o None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq (xO k) xH)
v : T
m1,m2 : pmap
o : option T
IHk : forall (m : pmap) (v : T) (k' : positive) (_ : not (eq k k')),\niff (eq (pmap_lookup k' m) None)\n (eq (pmap_lookup k' (pmap_insert k v m)) None)
k : positive
T : Type
*****
iff (eq o None) (eq o None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.

*****
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq xH k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (pmap_insert xH v m)) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.

*****
T : Type
*****
forall (m : pmap) (v : T) (k' : positive) (_ : not (eq xH k')), iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) None)
+++++
intros.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.

*****
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) None)
+++++
forward.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.

*****
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.

*****
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.

*****
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) None)
+++++
eauto.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.

*****
H : not (eq xH k')
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup k' m) None) (eq (pmap_lookup k' (Branch (Some v) (pmap_left m) (pmap_right m))) None)
+++++
destruct k'.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup (xI k') m) None) (eq (pmap_lookup (xI k') (Branch (Some v) (pmap_left m) (pmap_right m))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq match m with | Empty => None | Branch _ _ r => pmap_lookup k' r end None) (eq (pmap_lookup k' (pmap_right m)) None)
+++++
destruct m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' (pmap_right Empty)) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' Empty) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
T : Type
*****
iff (eq None None) (eq None None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
T : Type
*****
iff (eq None None) (eq None None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' (pmap_right (Branch o m1 m2))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' m2) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' m2) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq xH (xI k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m2) None) (eq (pmap_lookup k' m2) None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup (xO k') m) None) (eq (pmap_lookup (xO k') (Branch (Some v) (pmap_left m) (pmap_right m))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
m : pmap
T : Type
*****
iff (eq match m with | Empty => None | Branch _ l _ => pmap_lookup k' l end None) (eq (pmap_lookup k' (pmap_left m)) None)
+++++
destruct m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' (pmap_left Empty)) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
T : Type
*****
iff (eq None None) (eq (pmap_lookup k' Empty) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
T : Type
*****
iff (eq None None) (eq None None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
T : Type
*****
iff (eq None None) (eq None None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' (pmap_left (Branch o m1 m2))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' m1) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' m1) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq xH (xO k'))
k' : positive
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq (pmap_lookup k' m1) None) (eq (pmap_lookup k' m1) None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.

*****
H : not (eq xH xH)
v : T
m : pmap
T : Type
*****
iff (eq (pmap_lookup xH m) None) (eq (pmap_lookup xH (Branch (Some v) (pmap_left m) (pmap_right m))) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.

*****
H : not (eq xH xH)
v : T
m : pmap
T : Type
*****
iff (eq match m with | Empty => None | Branch d _ _ => d end None) (eq (Some v) None)
+++++
destruct m.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None None) (eq (Some v) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None None) (eq (Some v) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None None) (eq (Some v) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None None) (eq (Some v) None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
H : not (eq xH xH)
v : T
T : Type
*****
iff (eq None None) (eq (Some v) None)
+++++
try congruence.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.

*****
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o None) (eq (Some v) None)
+++++
simpl.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.

*****
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o None) (eq (Some v) None)
+++++
autorewrite with pmap_rw.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.

*****
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o None) (eq (Some v) None)
+++++
Cases.rewrite_all_goal.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.

*****
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o None) (eq (Some v) None)
+++++
try reflexivity.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.
simpl.
intros.
forward.
Cases.rewrite_all_goal.
autorewrite with pmap_rw.
eauto.
destruct k'.
simpl.
destruct m.
simpl.
autorewrite with pmap_rw.
Cases.rewrite_all_goal.
try reflexivity.

*****
H : not (eq xH xH)
v : T
m1,m2 : pmap
o : option T
T : Type
*****
iff (eq o None) (eq (Some v) None)
+++++
try congruence.
-----
Lemma pmap_lookup_insert_None_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> pmap_lookup k' m = None <-> pmap_lookup k' (pmap_insert k v m) = None.
Proof.
intros m k.
revert m.
induction k.

*****

*****

+++++
Qed.
-----
Lemma pmap_lookup_insert_neq\n  : forall (m : pmap) (k : positive) (v : T) (k' : positive),\n      k <> k' ->\n      forall v' : T,\n        pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T) (k' : positive) (_ : not (eq k k')) (_ : T), eq (pmap_lookup k' (pmap_insert k v m)) (pmap_lookup k' m)
+++++
Proof.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T) (k' : positive) (_ : not (eq k k')) (_ : T), eq (pmap_lookup k' (pmap_insert k v m)) (pmap_lookup k' m)
+++++
intros.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.
intros.

*****
v' : T
H : not (eq k k')
k' : positive
v : T
k : positive
m : pmap
T : Type
*****
eq (pmap_lookup k' (pmap_insert k v m)) (pmap_lookup k' m)
+++++
remember (pmap_lookup k' m).
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.
intros.
remember (pmap_lookup k' m).

*****
Heqo : eq o (pmap_lookup k' m)
o : option T
v' : T
H : not (eq k k')
k' : positive
v : T
k : positive
m : pmap
T : Type
*****
eq (pmap_lookup k' (pmap_insert k v m)) o
+++++
destruct o.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.
intros.
remember (pmap_lookup k' m).
destruct o.

*****
Heqo : eq (Some t) (pmap_lookup k' m)
v',t : T
H : not (eq k k')
k' : positive
v : T
k : positive
m : pmap
T : Type
*****
eq (pmap_lookup k' (pmap_insert k v m)) (Some t)
+++++
apply pmap_lookup_insert_Some_neq.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.
intros.
remember (pmap_lookup k' m).
destruct o.
apply pmap_lookup_insert_Some_neq.

*****
Heqo : eq (Some t) (pmap_lookup k' m)
v',t : T
H : not (eq k k')
k' : positive
v : T
k : positive
m : pmap
T : Type
*****
not (eq k k')
+++++
intuition.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.
intros.
remember (pmap_lookup k' m).
destruct o.
apply pmap_lookup_insert_Some_neq.

*****
Heqo : eq (Some t) (pmap_lookup k' m)
v',t : T
H : not (eq k k')
k' : positive
v : T
k : positive
m : pmap
T : Type
*****
eq (pmap_lookup k' m) (Some t)
+++++
intuition.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.
intros.
remember (pmap_lookup k' m).
destruct o.

*****
Heqo : eq None (pmap_lookup k' m)
v' : T
H : not (eq k k')
k' : positive
v : T
k : positive
m : pmap
T : Type
*****
eq (pmap_lookup k' (pmap_insert k v m)) None
+++++
apply pmap_lookup_insert_None_neq.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.
intros.
remember (pmap_lookup k' m).
destruct o.
apply pmap_lookup_insert_None_neq.

*****
Heqo : eq None (pmap_lookup k' m)
v' : T
H : not (eq k k')
k' : positive
v : T
k : positive
m : pmap
T : Type
*****
not (eq k k')
+++++
intuition.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.
intros.
remember (pmap_lookup k' m).
destruct o.
apply pmap_lookup_insert_None_neq.

*****
Heqo : eq None (pmap_lookup k' m)
v' : T
H : not (eq k k')
k' : positive
v : T
k : positive
m : pmap
T : Type
*****
eq (pmap_lookup k' m) None
+++++
intuition.
-----
Lemma pmap_lookup_insert_neq : forall (m : pmap) (k : positive) (v : T) (k' : positive), k <> k' -> forall v' : T, pmap_lookup k' (pmap_insert k v m) = pmap_lookup k' m.
Proof.
intros.
remember (pmap_lookup k' m).
destruct o.

*****

*****

+++++
Qed.
-----
Global Instance MapOk_pmap : MapOk (@eq _) Map_pmap.
-----
Global Instance MapOk_pmap : MapOk (@eq _) Map_pmap.

*****
T : Type
*****
MapOk eq Map_pmap
+++++
Proof.
-----
Global Instance MapOk_pmap : MapOk (@eq _) Map_pmap.
Proof.

*****
T : Type
*****
MapOk eq Map_pmap
+++++
refine {| mapsto := fun k v m => pmap_lookup k m = Some v |}.
-----
Global Instance MapOk_pmap : MapOk (@eq _) Map_pmap.
Proof.
refine {| mapsto := fun k v m => pmap_lookup k m = Some v |}.

*****
T : Type
*****
forall (k : positive) (v : T), not (eq (pmap_lookup k empty) (Some v))
+++++
abstract (induction k; simpl; congruence).
-----
Global Instance MapOk_pmap : MapOk (@eq _) Map_pmap.
Proof.
refine {| mapsto := fun k v m => pmap_lookup k m = Some v |}.

*****
T : Type
*****
forall (k : positive) (v : T) (m : pmap), iff (eq (lookup k m) (Some v)) (eq (pmap_lookup k m) (Some v))
+++++
abstract (induction k; simpl; intros; forward).
-----
Global Instance MapOk_pmap : MapOk (@eq _) Map_pmap.
Proof.
refine {| mapsto := fun k v m => pmap_lookup k m = Some v |}.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T), eq (pmap_lookup k (add k v m)) (Some v)
+++++
eauto using pmap_lookup_insert_eq.
-----
Global Instance MapOk_pmap : MapOk (@eq _) Map_pmap.
Proof.
refine {| mapsto := fun k v m => pmap_lookup k m = Some v |}.

*****
T : Type
*****
forall (m : pmap) (k : positive) (v : T) (k' : positive) (_ : not (eq k k')) (v' : T), iff (eq (pmap_lookup k' m) (Some v')) (eq (pmap_lookup k' (add k v m)) (Some v'))
+++++
eauto using pmap_lookup_insert_Some_neq.
-----
Global Instance MapOk_pmap : MapOk (@eq _) Map_pmap.
Proof.
refine {| mapsto := fun k v m => pmap_lookup k m = Some v |}.

*****

*****

+++++
Defined.
-----
Definition from_list : list T -> pmap :=\n    (fix from_list acc i ls {struct ls} :=\n       match ls with\n         | nil => acc\n         | List.cons l ls =>\n           from_list (pmap_insert i l acc) (Pos.succ i) ls\n       end) Empty 1%positive.
-----
End pmap.
-----
Arguments Empty {_}.
-----
Arguments Branch {_} _ _ _.
-----
Section fmap.
-----
Variables T U : Type.
-----
Variable f : T -> U.
-----
Fixpoint fmap_pmap (m : pmap T) : pmap U :=\n    match m with\n      | Empty => Empty\n      | Branch h l r => Branch (fmap f h) (fmap_pmap l) (fmap_pmap r)\n    end.
-----
Theorem fmap_lookup : forall a b m,\n    mapsto a b m ->\n    mapsto a (f b) (fmap_pmap m).
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).

*****
f : forall _ : T, U
T,U : Type
*****
forall (a : positive) (b : T) (m : pmap T) (_ : mapsto a b m), mapsto a (f b) (fmap_pmap m)
+++++
Proof.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.

*****
f : forall _ : T, U
T,U : Type
*****
forall (a : positive) (b : T) (m : pmap T) (_ : mapsto a b m), mapsto a (f b) (fmap_pmap m)
+++++
induction a.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.

*****
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall (b : T) (m : pmap T) (_ : mapsto (xI a) b m), mapsto (xI a) (f b) (fmap_pmap m)
+++++
destruct m.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.

*****
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto (xI a) b Empty, mapsto (xI a) (f b) (fmap_pmap Empty)
+++++
simpl.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.

*****
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : eq None (Some b), eq None (Some (f b))
+++++
intros.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq None (Some b)
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
eq None (Some (f b))
+++++
try congruence.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.

*****
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto (xI a) b (Branch o m1 m2), mapsto (xI a) (f b) (fmap_pmap (Branch o m1 m2))
+++++
simpl.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.

*****
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : eq (pmap_lookup a m2) (Some b), eq (pmap_lookup a (fmap_pmap m2)) (Some (f b))
+++++
intros.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq (pmap_lookup a m2) (Some b)
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
eq (pmap_lookup a (fmap_pmap m2)) (Some (f b))
+++++
try congruence.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.

*****
H : eq (pmap_lookup a m2) (Some b)
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
eq (pmap_lookup a (fmap_pmap m2)) (Some (f b))
+++++
eapply IHa.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
eapply IHa.

*****
H : eq (pmap_lookup a m2) (Some b)
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
mapsto a b m2
+++++
eapply H.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.

*****
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall (b : T) (m : pmap T) (_ : mapsto (xO a) b m), mapsto (xO a) (f b) (fmap_pmap m)
+++++
destruct m.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.

*****
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto (xO a) b Empty, mapsto (xO a) (f b) (fmap_pmap Empty)
+++++
simpl.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.

*****
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : eq None (Some b), eq None (Some (f b))
+++++
intros.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq None (Some b)
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
eq None (Some (f b))
+++++
try congruence.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.

*****
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto (xO a) b (Branch o m1 m2), mapsto (xO a) (f b) (fmap_pmap (Branch o m1 m2))
+++++
simpl.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.

*****
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : eq (pmap_lookup a m1) (Some b), eq (pmap_lookup a (fmap_pmap m1)) (Some (f b))
+++++
intros.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq (pmap_lookup a m1) (Some b)
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
eq (pmap_lookup a (fmap_pmap m1)) (Some (f b))
+++++
try congruence.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.

*****
H : eq (pmap_lookup a m1) (Some b)
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
eq (pmap_lookup a (fmap_pmap m1)) (Some (f b))
+++++
eapply IHa.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
eapply IHa.

*****
H : eq (pmap_lookup a m1) (Some b)
m1,m2 : pmap T
o : option T
b : T
IHa : forall (b : T) (m : pmap T) (_ : mapsto a b m),\nmapsto a (f b) (fmap_pmap m)
a : positive
f : forall _ : T, U
T,U : Type
*****
mapsto a b m1
+++++
eapply H.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.

*****
f : forall _ : T, U
T,U : Type
*****
forall (b : T) (m : pmap T) (_ : mapsto xH b m), mapsto xH (f b) (fmap_pmap m)
+++++
destruct m.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.

*****
b : T
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto xH b Empty, mapsto xH (f b) (fmap_pmap Empty)
+++++
simpl.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.

*****
b : T
f : forall _ : T, U
T,U : Type
*****
forall _ : eq None (Some b), eq None (Some (f b))
+++++
intros.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq None (Some b)
b : T
f : forall _ : T, U
T,U : Type
*****
eq None (Some (f b))
+++++
try congruence.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.

*****
m1,m2 : pmap T
o : option T
b : T
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto xH b (Branch o m1 m2), mapsto xH (f b) (fmap_pmap (Branch o m1 m2))
+++++
simpl.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.

*****
m1,m2 : pmap T
o : option T
b : T
f : forall _ : T, U
T,U : Type
*****
forall _ : eq o (Some b), eq match o with | Some x => Some (f x) | None => None end (Some (f b))
+++++
intros.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq o (Some b)
m1,m2 : pmap T
o : option T
b : T
f : forall _ : T, U
T,U : Type
*****
eq match o with | Some x => Some (f x) | None => None end (Some (f b))
+++++
try congruence.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.

*****
H : eq o (Some b)
m1,m2 : pmap T
o : option T
b : T
f : forall _ : T, U
T,U : Type
*****
eq match o with | Some x => Some (f x) | None => None end (Some (f b))
+++++
subst.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
subst.

*****
m1,m2 : pmap T
b : T
f : forall _ : T, U
T,U : Type
*****
eq (Some (f b)) (Some (f b))
+++++
auto.
-----
Theorem fmap_lookup : forall a b m, mapsto a b m -> mapsto a (f b) (fmap_pmap m).
Proof.
induction a.

*****

*****

+++++
Qed.
-----
Theorem fmap_lookup_bk : forall a b m,\n    mapsto a b (fmap_pmap m) ->\n    exists b', mapsto a b' m /\ f b' = b.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.

*****
f : forall _ : T, U
T,U : Type
*****
forall (a : positive) (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)), ex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
+++++
Proof.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.

*****
f : forall _ : T, U
T,U : Type
*****
forall (a : positive) (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)), ex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
+++++
induction a.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.

*****
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall (b : U) (m : pmap T) (_ : mapsto (xI a) b (fmap_pmap m)), ex (fun b' : T => and (mapsto (xI a) b' m) (eq (f b') b))
+++++
destruct m.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.

*****
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto (xI a) b (fmap_pmap Empty), ex (fun b' : T => and (mapsto (xI a) b' Empty) (eq (f b') b))
+++++
simpl.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.

*****
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : eq None (Some b), ex (fun b' : T => and (eq None (Some b')) (eq (f b') b))
+++++
intros.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq None (Some b)
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq None (Some b')) (eq (f b') b))
+++++
try congruence.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.

*****
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto (xI a) b (fmap_pmap (Branch o m1 m2)), ex (fun b' : T => and (mapsto (xI a) b' (Branch o m1 m2)) (eq (f b') b))
+++++
simpl.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.

*****
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : eq (pmap_lookup a (fmap_pmap m2)) (Some b), ex (fun b' : T => and (eq (pmap_lookup a m2) (Some b')) (eq (f b') b))
+++++
intros.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq (pmap_lookup a (fmap_pmap m2)) (Some b)
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq (pmap_lookup a m2) (Some b')) (eq (f b') b))
+++++
try congruence.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.

*****
H : eq (pmap_lookup a (fmap_pmap m2)) (Some b)
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq (pmap_lookup a m2) (Some b')) (eq (f b') b))
+++++
eapply IHa.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
eapply IHa.

*****
H : eq (pmap_lookup a (fmap_pmap m2)) (Some b)
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
mapsto a b (fmap_pmap m2)
+++++
eapply H.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.

*****
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall (b : U) (m : pmap T) (_ : mapsto (xO a) b (fmap_pmap m)), ex (fun b' : T => and (mapsto (xO a) b' m) (eq (f b') b))
+++++
destruct m.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.

*****
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto (xO a) b (fmap_pmap Empty), ex (fun b' : T => and (mapsto (xO a) b' Empty) (eq (f b') b))
+++++
simpl.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.

*****
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : eq None (Some b), ex (fun b' : T => and (eq None (Some b')) (eq (f b') b))
+++++
intros.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq None (Some b)
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq None (Some b')) (eq (f b') b))
+++++
try congruence.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.

*****
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto (xO a) b (fmap_pmap (Branch o m1 m2)), ex (fun b' : T => and (mapsto (xO a) b' (Branch o m1 m2)) (eq (f b') b))
+++++
simpl.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.

*****
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
forall _ : eq (pmap_lookup a (fmap_pmap m1)) (Some b), ex (fun b' : T => and (eq (pmap_lookup a m1) (Some b')) (eq (f b') b))
+++++
intros.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq (pmap_lookup a (fmap_pmap m1)) (Some b)
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq (pmap_lookup a m1) (Some b')) (eq (f b') b))
+++++
try congruence.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.

*****
H : eq (pmap_lookup a (fmap_pmap m1)) (Some b)
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq (pmap_lookup a m1) (Some b')) (eq (f b') b))
+++++
eapply IHa.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
eapply IHa.

*****
H : eq (pmap_lookup a (fmap_pmap m1)) (Some b)
m1,m2 : pmap T
o : option T
b : U
IHa : forall (b : U) (m : pmap T) (_ : mapsto a b (fmap_pmap m)),\nex (fun b' : T => and (mapsto a b' m) (eq (f b') b))
a : positive
f : forall _ : T, U
T,U : Type
*****
mapsto a b (fmap_pmap m1)
+++++
eapply H.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.

*****
f : forall _ : T, U
T,U : Type
*****
forall (b : U) (m : pmap T) (_ : mapsto xH b (fmap_pmap m)), ex (fun b' : T => and (mapsto xH b' m) (eq (f b') b))
+++++
destruct m.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.

*****
b : U
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto xH b (fmap_pmap Empty), ex (fun b' : T => and (mapsto xH b' Empty) (eq (f b') b))
+++++
simpl.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.

*****
b : U
f : forall _ : T, U
T,U : Type
*****
forall _ : eq None (Some b), ex (fun b' : T => and (eq None (Some b')) (eq (f b') b))
+++++
intros.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq None (Some b)
b : U
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq None (Some b')) (eq (f b') b))
+++++
try congruence.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.

*****
m1,m2 : pmap T
o : option T
b : U
f : forall _ : T, U
T,U : Type
*****
forall _ : mapsto xH b (fmap_pmap (Branch o m1 m2)), ex (fun b' : T => and (mapsto xH b' (Branch o m1 m2)) (eq (f b') b))
+++++
simpl.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.

*****
m1,m2 : pmap T
o : option T
b : U
f : forall _ : T, U
T,U : Type
*****
forall _ : eq match o with | Some x => Some (f x) | None => None end (Some b), ex (fun b' : T => and (eq o (Some b')) (eq (f b') b))
+++++
intros.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.

*****
H : eq match o with\n | Some x => Some (f x)\n | None => None\n end (Some b)
m1,m2 : pmap T
o : option T
b : U
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq o (Some b')) (eq (f b') b))
+++++
try congruence.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.

*****
H : eq match o with\n | Some x => Some (f x)\n | None => None\n end (Some b)
m1,m2 : pmap T
o : option T
b : U
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq o (Some b')) (eq (f b') b))
+++++
destruct o.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
destruct o.

*****
H : eq (Some (f t)) (Some b)
m1,m2 : pmap T
t : T
b : U
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq (Some t) (Some b')) (eq (f b') b))
+++++
try congruence.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
destruct o.
try congruence.

*****
H : eq (Some (f t)) (Some b)
m1,m2 : pmap T
t : T
b : U
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq (Some t) (Some b')) (eq (f b') b))
+++++
eexists.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
destruct o.
try congruence.
eexists.

*****
H : eq (Some (f t)) (Some b)
m1,m2 : pmap T
t : T
b : U
f : forall _ : T, U
T,U : Type
*****
and (eq (Some t) (Some ?b')) (eq (f ?b') b)
+++++
split.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
destruct o.
try congruence.
eexists.
split.

*****
H : eq (Some (f t)) (Some b)
m1,m2 : pmap T
t : T
b : U
f : forall _ : T, U
T,U : Type
*****
eq (Some t) (Some ?b')
+++++
eauto.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
destruct o.
try congruence.
eexists.
split.

*****
H : eq (Some (f t)) (Some b)
m1,m2 : pmap T
t : T
b : U
f : forall _ : T, U
T,U : Type
*****
eq (f t) b
+++++
eauto.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
destruct o.
try congruence.
eexists.
split.
eauto.

*****
H : eq (Some (f t)) (Some b)
m1,m2 : pmap T
t : T
b : U
f : forall _ : T, U
T,U : Type
*****
eq (f t) b
+++++
inversion H.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
destruct o.
try congruence.
eexists.
split.
eauto.
inversion H.

*****
H1 : eq (f t) b
H : eq (Some (f t)) (Some b)
m1,m2 : pmap T
t : T
b : U
f : forall _ : T, U
T,U : Type
*****
eq (f t) (f t)
+++++
auto.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.
destruct m.
simpl.
intros.
try congruence.
destruct o.

*****
H : eq None (Some b)
m1,m2 : pmap T
b : U
f : forall _ : T, U
T,U : Type
*****
ex (fun b' : T => and (eq None (Some b')) (eq (f b') b))
+++++
try congruence.
-----
Theorem fmap_lookup_bk : forall a b m, mapsto a b (fmap_pmap m) -> exists b', mapsto a b' m /\\ f b' = b.
Proof.
induction a.

*****

*****

+++++
Qed.
-----
End fmap.
-----
Require Import ExtLib.Core.Type.
-----
Section type.
-----
Variable T : Type.
-----
Variable tT : type T.
-----
Instance type_pmap : type (pmap T) :=\n    type_from_equal\n      (fun l r =>\n            (forall k v,\n               mapsto k v l -> exists v', mapsto k v' r /\ equal v v')\n         /\ (forall k v,\n               mapsto k v r -> exists v', mapsto k v' l /\ equal v v')).
-----
End type.
-----
Global Instance Functor_pmap : Functor pmap :=\n{ fmap := fmap_pmap }.
-----
