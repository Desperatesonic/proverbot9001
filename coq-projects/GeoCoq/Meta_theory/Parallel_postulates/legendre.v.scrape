Require Import GeoCoq.Axioms.continuity_axioms.
-----
Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.SPP_ID.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.TCP_tarski.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.alternate_interior_angles_proclus.
-----
Require Export GeoCoq.Meta_theory.Continuity.angle_archimedes.
-----
Require Export GeoCoq.Meta_theory.Continuity.archimedes.
-----
Require Export GeoCoq.Meta_theory.Continuity.aristotle.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.euclid_5_original_euclid.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.existential_triangle_rah.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.par_perp_perp_TCP.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.playfair_alternate_interior_angles.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.playfair_bis_playfair.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.playfair_universal_posidonius_postulate.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.proclus_SPP.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.rah_triangle.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.tarski_euclid.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.triangle_playfair_bis.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.triangle_existential_triangle.
-----
Require Export GeoCoq.Meta_theory.Parallel_postulates.universal_posidonius_postulate_par_perp_perp.
-----
Require Export GeoCoq.Tarski_dev.Annexes.defect.
-----
Section Legendre.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Theorem stronger_legendre_s_first_theorem :\n  aristotle_s_axiom ->\n  forall A B C D E F,\n    SumA C A B A B C D E F ->\n    SAMS D E F B C A.
-----
Theorem stronger_legendre_s_first_theorem : aristotle_s_axiom -> forall A B C D E F, SumA C A B A B C D E F -> SAMS D E F B C A.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (A B C D E F : Tpoint) (_ : SumA C A B A B C D E F), SAMS D E F B C A
+++++
Proof.
-----
Theorem stronger_legendre_s_first_theorem : aristotle_s_axiom -> forall A B C D E F, SumA C A B A B C D E F -> SAMS D E F B C A.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (A B C D E F : Tpoint) (_ : SumA C A B A B C D E F), SAMS D E F B C A
+++++
intros ari A B C D E F.
-----
Theorem stronger_legendre_s_first_theorem : aristotle_s_axiom -> forall A B C D E F, SumA C A B A B C D E F -> SAMS D E F B C A.
Proof.
intros ari A B C D E F.

*****
A,B,C,D,E,F : Tpoint
ari : aristotle_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : SumA C A B A B C D E F, SAMS D E F B C A
+++++
apply (t22_20 (aristotle__obtuse_case_elimination ari)).
-----
Theorem stronger_legendre_s_first_theorem : aristotle_s_axiom -> forall A B C D E F, SumA C A B A B C D E F -> SAMS D E F B C A.
Proof.
intros ari A B C D E F.
apply (t22_20 (aristotle__obtuse_case_elimination ari)).

*****

*****

+++++
Qed.
-----
Theorem legendre_s_first_theorem :\n  archimedes_axiom ->\n  forall A B C D E F,\n    SumA C A B A B C D E F ->\n    SAMS D E F B C A.
-----
Theorem legendre_s_first_theorem : archimedes_axiom -> forall A B C D E F, SumA C A B A B C D E F -> SAMS D E F B C A.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D E F : Tpoint) (_ : SumA C A B A B C D E F), SAMS D E F B C A
+++++
Proof.
-----
Theorem legendre_s_first_theorem : archimedes_axiom -> forall A B C D E F, SumA C A B A B C D E F -> SAMS D E F B C A.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (A B C D E F : Tpoint) (_ : SumA C A B A B C D E F), SAMS D E F B C A
+++++
intros archi A B C D E F.
-----
Theorem legendre_s_first_theorem : archimedes_axiom -> forall A B C D E F, SumA C A B A B C D E F -> SAMS D E F B C A.
Proof.
intros archi A B C D E F.

*****
A,B,C,D,E,F : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : SumA C A B A B C D E F, SAMS D E F B C A
+++++
apply (t22_20 (archi__obtuse_case_elimination archi)).
-----
Theorem legendre_s_first_theorem : archimedes_axiom -> forall A B C D E F, SumA C A B A B C D E F -> SAMS D E F B C A.
Proof.
intros archi A B C D E F.
apply (t22_20 (archi__obtuse_case_elimination archi)).

*****

*****

+++++
Qed.
-----
Theorem legendre_s_second_theorem :\n  postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights ->\n  triangle_postulate.
-----
Theorem legendre_s_second_theorem : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights -> triangle_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights, triangle_postulate
+++++
Proof.
-----
Theorem legendre_s_second_theorem : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights -> triangle_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights, triangle_postulate
+++++
assert (H:=existential_triangle__rah).
-----
Theorem legendre_s_second_theorem : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights -> triangle_postulate.
Proof.
assert (H:=existential_triangle__rah).

*****
H : forall\n _ : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights,\npostulate_of_right_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights, triangle_postulate
+++++
assert (I:=rah__triangle).
-----
Theorem legendre_s_second_theorem : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights -> triangle_postulate.
Proof.
assert (H:=existential_triangle__rah).
assert (I:=rah__triangle).

*****
I : forall _ : postulate_of_right_saccheri_quadrilaterals,\ntriangle_postulate
H : forall\n _ : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights,\npostulate_of_right_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights, triangle_postulate
+++++
tauto.
-----
Theorem legendre_s_second_theorem : postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights -> triangle_postulate.
Proof.
assert (H:=existential_triangle__rah).
assert (I:=rah__triangle).
tauto.

*****

*****

+++++
Qed.
-----
Lemma legendre_s_third_theorem_aux :\n  aristotle_s_axiom ->\n  triangle_postulate ->\n  euclid_s_parallel_postulate.
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
Proof.
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (I:=aristotle__greenberg).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).

*****
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).

*****
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom), decidability_of_intersection
+++++
intro HP.
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
intro HP.

*****
HP : playfair_s_postulate
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : greenberg_s_axiom, decidability_of_intersection
+++++
assert (J:=playfair__alternate_interior HP).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
intro HP.
assert (J:=playfair__alternate_interior HP).

*****
J : alternate_interior_angles_postulate
HP : playfair_s_postulate
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : greenberg_s_axiom, decidability_of_intersection
+++++
assert(K:=alternate_interior__proclus).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
intro HP.
assert (J:=playfair__alternate_interior HP).
assert(K:=alternate_interior__proclus).

*****
K : forall (_ : greenberg_s_axiom)\n (_ : alternate_interior_angles_postulate), proclus_postulate
J : alternate_interior_angles_postulate
HP : playfair_s_postulate
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : greenberg_s_axiom, decidability_of_intersection
+++++
assert(L:proclus_postulate->decidability_of_intersection).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
intro HP.
assert (J:=playfair__alternate_interior HP).
assert(K:=alternate_interior__proclus).
assert(L:proclus_postulate->decidability_of_intersection).

*****
K : forall (_ : greenberg_s_axiom)\n (_ : alternate_interior_angles_postulate), proclus_postulate
J : alternate_interior_angles_postulate
HP : playfair_s_postulate
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : proclus_postulate, decidability_of_intersection
+++++
idtac.
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
intro HP.
assert (J:=playfair__alternate_interior HP).
assert(K:=alternate_interior__proclus).
assert(L:proclus_postulate->decidability_of_intersection).
idtac.

*****
K : forall (_ : greenberg_s_axiom)\n (_ : alternate_interior_angles_postulate), proclus_postulate
J : alternate_interior_angles_postulate
HP : playfair_s_postulate
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : proclus_postulate, decidability_of_intersection
+++++
assert(M:=proclus_s_postulate_implies_strong_parallel_postulate).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
intro HP.
assert (J:=playfair__alternate_interior HP).
assert(K:=alternate_interior__proclus).
assert(L:proclus_postulate->decidability_of_intersection).
idtac.
assert(M:=proclus_s_postulate_implies_strong_parallel_postulate).

*****
M : forall _ : proclus_postulate, strong_parallel_postulate
K : forall (_ : greenberg_s_axiom)\n (_ : alternate_interior_angles_postulate), proclus_postulate
J : alternate_interior_angles_postulate
HP : playfair_s_postulate
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : proclus_postulate, decidability_of_intersection
+++++
assert(N:=strong_parallel_postulate_implies_inter_dec).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
intro HP.
assert (J:=playfair__alternate_interior HP).
assert(K:=alternate_interior__proclus).
assert(L:proclus_postulate->decidability_of_intersection).
idtac.
assert(M:=proclus_s_postulate_implies_strong_parallel_postulate).
assert(N:=strong_parallel_postulate_implies_inter_dec).

*****
N : forall _ : strong_parallel_postulate, decidability_of_intersection
M : forall _ : proclus_postulate, strong_parallel_postulate
K : forall (_ : greenberg_s_axiom)\n (_ : alternate_interior_angles_postulate), proclus_postulate
J : alternate_interior_angles_postulate
HP : playfair_s_postulate
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : proclus_postulate, decidability_of_intersection
+++++
tauto.
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
intro HP.
assert (J:=playfair__alternate_interior HP).
assert(K:=alternate_interior__proclus).
assert(L:proclus_postulate->decidability_of_intersection).

*****
L : forall _ : proclus_postulate, decidability_of_intersection
K : forall (_ : greenberg_s_axiom)\n (_ : alternate_interior_angles_postulate), proclus_postulate
J : alternate_interior_angles_postulate
HP : playfair_s_postulate
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : greenberg_s_axiom, decidability_of_intersection
+++++
tauto.
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).

*****
J : forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom),\ndecidability_of_intersection
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (K:=triangle__playfair_bis).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
assert (K:=triangle__playfair_bis).

*****
K : forall (_ : greenberg_s_axiom) (_ : triangle_postulate),\nalternative_playfair_s_postulate
J : forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom),\ndecidability_of_intersection
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (L:=playfair_bis__playfair).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
assert (K:=triangle__playfair_bis).
assert (L:=playfair_bis__playfair).

*****
L : forall _ : alternative_playfair_s_postulate, playfair_s_postulate
K : forall (_ : greenberg_s_axiom) (_ : triangle_postulate),\nalternative_playfair_s_postulate
J : forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom),\ndecidability_of_intersection
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (M:=playfair__universal_posidonius_postulate).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
assert (K:=triangle__playfair_bis).
assert (L:=playfair_bis__playfair).
assert (M:=playfair__universal_posidonius_postulate).

*****
M : forall _ : playfair_s_postulate, universal_posidonius_postulate
L : forall _ : alternative_playfair_s_postulate, playfair_s_postulate
K : forall (_ : greenberg_s_axiom) (_ : triangle_postulate),\nalternative_playfair_s_postulate
J : forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom),\ndecidability_of_intersection
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (N:=universal_posidonius_postulate__perpendicular_transversal_postulate).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
assert (K:=triangle__playfair_bis).
assert (L:=playfair_bis__playfair).
assert (M:=playfair__universal_posidonius_postulate).
assert (N:=universal_posidonius_postulate__perpendicular_transversal_postulate).

*****
N : forall _ : universal_posidonius_postulate,\nperpendicular_transversal_postulate
M : forall _ : playfair_s_postulate, universal_posidonius_postulate
L : forall _ : alternative_playfair_s_postulate, playfair_s_postulate
K : forall (_ : greenberg_s_axiom) (_ : triangle_postulate),\nalternative_playfair_s_postulate
J : forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom),\ndecidability_of_intersection
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (O:=inter_dec_plus_par_perp_perp_imply_triangle_circumscription).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
assert (K:=triangle__playfair_bis).
assert (L:=playfair_bis__playfair).
assert (M:=playfair__universal_posidonius_postulate).
assert (N:=universal_posidonius_postulate__perpendicular_transversal_postulate).
assert (O:=inter_dec_plus_par_perp_perp_imply_triangle_circumscription).

*****
O : forall (_ : decidability_of_intersection)\n (_ : perpendicular_transversal_postulate),\ntriangle_circumscription_principle
N : forall _ : universal_posidonius_postulate,\nperpendicular_transversal_postulate
M : forall _ : playfair_s_postulate, universal_posidonius_postulate
L : forall _ : alternative_playfair_s_postulate, playfair_s_postulate
K : forall (_ : greenberg_s_axiom) (_ : triangle_postulate),\nalternative_playfair_s_postulate
J : forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom),\ndecidability_of_intersection
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (P:=triangle_circumscription_implies_tarski_s_euclid).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
assert (K:=triangle__playfair_bis).
assert (L:=playfair_bis__playfair).
assert (M:=playfair__universal_posidonius_postulate).
assert (N:=universal_posidonius_postulate__perpendicular_transversal_postulate).
assert (O:=inter_dec_plus_par_perp_perp_imply_triangle_circumscription).
assert (P:=triangle_circumscription_implies_tarski_s_euclid).

*****
P : forall _ : triangle_circumscription_principle,\ntarski_s_parallel_postulate
O : forall (_ : decidability_of_intersection)\n (_ : perpendicular_transversal_postulate),\ntriangle_circumscription_principle
N : forall _ : universal_posidonius_postulate,\nperpendicular_transversal_postulate
M : forall _ : playfair_s_postulate, universal_posidonius_postulate
L : forall _ : alternative_playfair_s_postulate, playfair_s_postulate
K : forall (_ : greenberg_s_axiom) (_ : triangle_postulate),\nalternative_playfair_s_postulate
J : forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom),\ndecidability_of_intersection
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (Q:=tarski_s_euclid_implies_euclid_5).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
assert (K:=triangle__playfair_bis).
assert (L:=playfair_bis__playfair).
assert (M:=playfair__universal_posidonius_postulate).
assert (N:=universal_posidonius_postulate__perpendicular_transversal_postulate).
assert (O:=inter_dec_plus_par_perp_perp_imply_triangle_circumscription).
assert (P:=triangle_circumscription_implies_tarski_s_euclid).
assert (Q:=tarski_s_euclid_implies_euclid_5).

*****
Q : forall _ : tarski_s_parallel_postulate, euclid_5
P : forall _ : triangle_circumscription_principle,\ntarski_s_parallel_postulate
O : forall (_ : decidability_of_intersection)\n (_ : perpendicular_transversal_postulate),\ntriangle_circumscription_principle
N : forall _ : universal_posidonius_postulate,\nperpendicular_transversal_postulate
M : forall _ : playfair_s_postulate, universal_posidonius_postulate
L : forall _ : alternative_playfair_s_postulate, playfair_s_postulate
K : forall (_ : greenberg_s_axiom) (_ : triangle_postulate),\nalternative_playfair_s_postulate
J : forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom),\ndecidability_of_intersection
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (R:=euclid_5__original_euclid).
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).
assert (K:=triangle__playfair_bis).
assert (L:=playfair_bis__playfair).
assert (M:=playfair__universal_posidonius_postulate).
assert (N:=universal_posidonius_postulate__perpendicular_transversal_postulate).
assert (O:=inter_dec_plus_par_perp_perp_imply_triangle_circumscription).
assert (P:=triangle_circumscription_implies_tarski_s_euclid).
assert (Q:=tarski_s_euclid_implies_euclid_5).
assert (R:=euclid_5__original_euclid).

*****
R : forall _ : euclid_5, euclid_s_parallel_postulate
Q : forall _ : tarski_s_parallel_postulate, euclid_5
P : forall _ : triangle_circumscription_principle,\ntarski_s_parallel_postulate
O : forall (_ : decidability_of_intersection)\n (_ : perpendicular_transversal_postulate),\ntriangle_circumscription_principle
N : forall _ : universal_posidonius_postulate,\nperpendicular_transversal_postulate
M : forall _ : playfair_s_postulate, universal_posidonius_postulate
L : forall _ : alternative_playfair_s_postulate, playfair_s_postulate
K : forall (_ : greenberg_s_axiom) (_ : triangle_postulate),\nalternative_playfair_s_postulate
J : forall (_ : playfair_s_postulate) (_ : greenberg_s_axiom),\ndecidability_of_intersection
I : forall _ : aristotle_s_axiom, greenberg_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : aristotle_s_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
tauto.
-----
Lemma legendre_s_third_theorem_aux : aristotle_s_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (I:=aristotle__greenberg).
assert (J:playfair_s_postulate->greenberg_s_axiom->decidability_of_intersection).

*****

*****

+++++
Qed.
-----
Theorem legendre_s_third_theorem :\n  archimedes_axiom ->\n  triangle_postulate ->\n  euclid_s_parallel_postulate.
-----
Theorem legendre_s_third_theorem : archimedes_axiom -> triangle_postulate -> euclid_s_parallel_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
Proof.
-----
Theorem legendre_s_third_theorem : archimedes_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (H:=t22_24).
-----
Theorem legendre_s_third_theorem : archimedes_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (H:=t22_24).

*****
H : forall _ : archimedes_axiom, aristotle_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
assert (I:=legendre_s_third_theorem_aux).
-----
Theorem legendre_s_third_theorem : archimedes_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (H:=t22_24).
assert (I:=legendre_s_third_theorem_aux).

*****
I : forall (_ : aristotle_s_axiom) (_ : triangle_postulate),\neuclid_s_parallel_postulate
H : forall _ : archimedes_axiom, aristotle_s_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : triangle_postulate), euclid_s_parallel_postulate
+++++
tauto.
-----
Theorem legendre_s_third_theorem : archimedes_axiom -> triangle_postulate -> euclid_s_parallel_postulate.
Proof.
assert (H:=t22_24).
assert (I:=legendre_s_third_theorem_aux).
tauto.

*****

*****

+++++
Qed.
-----
Lemma legendre_aux :\n  ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->\n  forall A B C D B1 C1 P Q R S T U V W X,\n    ~ Col A B C -> CongA A C B C B D ->\n    Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 ->\n    Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X ->\n    SAMS P Q R P Q R /\ LeA V W X S T U.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not hypothesis_of_obtuse_saccheri_quadrilaterals) (A B C D B1 C1 P Q R S T U V W X : Tpoint) (_ : not (Col A B C)) (_ : CongA A C B C B D) (_ : Cong A C B D) (_ : TS B C A D) (_ : Out A B B1) (_ : Out A C C1) (_ : Bet B1 D C1) (_ : Defect A B C P Q R) (_ : Defect A B1 C1 S T U) (_ : SumA P Q R P Q R V W X), and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
Proof.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not hypothesis_of_obtuse_saccheri_quadrilaterals) (A B C D B1 C1 P Q R S T U V W X : Tpoint) (_ : not (Col A B C)) (_ : CongA A C B C B D) (_ : Cong A C B D) (_ : TS B C A D) (_ : Out A B B1) (_ : Out A C C1) (_ : Bet B1 D C1) (_ : Defect A B C P Q R) (_ : Defect A B1 C1 S T U) (_ : SumA P Q R P Q R V W X), and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.

*****
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.

*****
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
assert_diffs; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.

*****
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HPar : Par_strict A C B D).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).

*****
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict A C B D
+++++
apply par_not_col_strict with B; Col.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
apply par_not_col_strict with B; Col.

*****
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A C B D
+++++
apply par_left_comm, l12_21_b; Side; CongA.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).

*****
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HPar' : Par_strict A B C D).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).

*****
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict A B C D
+++++
apply par_not_col_strict with C; Col.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
apply par_not_col_strict with C; Col.

*****
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B C D
+++++
apply par_left_comm, l12_21_b; Side; CongA.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).

*****
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').

*****
HPar',HNCol2,HNCol3,HNCol4 : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.

*****
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HB : ~ Col B1 B D /\ TS B D B1 C1 /\ Bet A B B1).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).

*****
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col B1 B D)) (and (TS B D B1 C1) (Bet A B B1))
+++++
assert_diffs.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
assert_diffs.

*****
H14 : not (eq W X)
H12 : not (eq V W)
H10 : not (eq Q R)
H0 : not (eq P Q)
H8 : not (eq B1 A)
H3 : not (eq C1 A)
H6 : not (eq B C)
H7 : not (eq C A)
H5 : not (eq C D)
H4 : not (eq A D)
H1 : not (eq B D)
H2 : not (eq A B)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col B1 B D)) (and (TS B D B1 C1) (Bet A B B1))
+++++
apply par_strict_symmetry, (par_strict_col_par_strict B D A C C1) in HPar; Col.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict B D A C C1) in HPar; Col.

*****
H14 : not (eq W X)
H12 : not (eq V W)
H10 : not (eq Q R)
H0 : not (eq P Q)
H8 : not (eq B1 A)
H3 : not (eq C1 A)
H6 : not (eq B C)
H7 : not (eq C A)
H5 : not (eq C D)
H4 : not (eq A D)
H1 : not (eq B D)
H2 : not (eq A B)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict B D A C1
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col B1 B D)) (and (TS B D B1 C1) (Bet A B B1))
+++++
assert (HNCol' := par_strict_not_col_4 B D A C1 HPar).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict B D A C C1) in HPar; Col.
assert (HNCol' := par_strict_not_col_4 B D A C1 HPar).

*****
HNCol' : not (Col B D C1)
H14 : not (eq W X)
H12 : not (eq V W)
H10 : not (eq Q R)
H0 : not (eq P Q)
H8 : not (eq B1 A)
H3 : not (eq C1 A)
H6 : not (eq B C)
H7 : not (eq C A)
H5 : not (eq C D)
H4 : not (eq A D)
H1 : not (eq B D)
H2 : not (eq A B)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict B D A C1
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col B1 B D)) (and (TS B D B1 C1) (Bet A B B1))
+++++
assert (B <> B1) by (intro; subst B1; apply HNCol'; Col).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict B D A C C1) in HPar; Col.
assert (HNCol' := par_strict_not_col_4 B D A C1 HPar).
assert (B <> B1) by (intro; subst B1; apply HNCol'; Col).

*****
H : not (eq B B1)
HNCol' : not (Col B D C1)
H14 : not (eq W X)
H12 : not (eq V W)
H10 : not (eq Q R)
H0 : not (eq P Q)
H8 : not (eq B1 A)
H3 : not (eq C1 A)
H6 : not (eq B C)
H7 : not (eq C A)
H5 : not (eq C D)
H4 : not (eq A D)
H1 : not (eq B D)
H2 : not (eq A B)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict B D A C1
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col B1 B D)) (and (TS B D B1 C1) (Bet A B B1))
+++++
assert (~ Col B1 B D) by (intro; apply HNCol4; ColR).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict B D A C C1) in HPar; Col.
assert (HNCol' := par_strict_not_col_4 B D A C1 HPar).
assert (B <> B1) by (intro; subst B1; apply HNCol'; Col).
assert (~ Col B1 B D) by (intro; apply HNCol4; ColR).

*****
H9 : not (Col B1 B D)
H : not (eq B B1)
HNCol' : not (Col B D C1)
H14 : not (eq W X)
H12 : not (eq V W)
H10 : not (eq Q R)
H0 : not (eq P Q)
H8 : not (eq B1 A)
H3 : not (eq C1 A)
H6 : not (eq B C)
H7 : not (eq C A)
H5 : not (eq C D)
H4 : not (eq A D)
H1 : not (eq B D)
H2 : not (eq A B)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict B D A C1
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col B1 B D)) (and (TS B D B1 C1) (Bet A B B1))
+++++
assert (TS B D B1 C1) by (repeat split; Col; exists D; Col).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict B D A C C1) in HPar; Col.
assert (HNCol' := par_strict_not_col_4 B D A C1 HPar).
assert (B <> B1) by (intro; subst B1; apply HNCol'; Col).
assert (~ Col B1 B D) by (intro; apply HNCol4; ColR).
assert (TS B D B1 C1) by (repeat split; Col; exists D; Col).

*****
H11 : TS B D B1 C1
H9 : not (Col B1 B D)
H : not (eq B B1)
HNCol' : not (Col B D C1)
H14 : not (eq W X)
H12 : not (eq V W)
H10 : not (eq Q R)
H0 : not (eq P Q)
H8 : not (eq B1 A)
H3 : not (eq C1 A)
H6 : not (eq B C)
H7 : not (eq C A)
H5 : not (eq C D)
H4 : not (eq A D)
H1 : not (eq B D)
H2 : not (eq A B)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict B D A C1
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col B1 B D)) (and (TS B D B1 C1) (Bet A B B1))
+++++
repeat (split; auto).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict B D A C C1) in HPar; Col.
assert (HNCol' := par_strict_not_col_4 B D A C1 HPar).
assert (B <> B1) by (intro; subst B1; apply HNCol'; Col).
assert (~ Col B1 B D) by (intro; apply HNCol4; ColR).
assert (TS B D B1 C1) by (repeat split; Col; exists D; Col).
repeat (split; auto).

*****
H11 : TS B D B1 C1
H9 : not (Col B1 B D)
H : not (eq B B1)
HNCol' : not (Col B D C1)
H14 : not (eq W X)
H12 : not (eq V W)
H10 : not (eq Q R)
H0 : not (eq P Q)
H8 : not (eq B1 A)
H3 : not (eq C1 A)
H6 : not (eq B C)
H7 : not (eq C A)
H5 : not (eq C D)
H4 : not (eq A D)
H1 : not (eq B D)
H2 : not (eq A B)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict B D A C1
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B B1
+++++
apply col_two_sides_bet with D; Col.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict B D A C C1) in HPar; Col.
assert (HNCol' := par_strict_not_col_4 B D A C1 HPar).
assert (B <> B1) by (intro; subst B1; apply HNCol'; Col).
assert (~ Col B1 B D) by (intro; apply HNCol4; ColR).
assert (TS B D B1 C1) by (repeat split; Col; exists D; Col).
repeat (split; auto).
apply col_two_sides_bet with D; Col.

*****
H11 : TS B D B1 C1
H9 : not (Col B1 B D)
H : not (eq B B1)
HNCol' : not (Col B D C1)
H14 : not (eq W X)
H12 : not (eq V W)
H10 : not (eq Q R)
H0 : not (eq P Q)
H8 : not (eq B1 A)
H3 : not (eq C1 A)
H6 : not (eq B C)
H7 : not (eq C A)
H5 : not (eq C D)
H4 : not (eq A D)
H1 : not (eq B D)
H2 : not (eq A B)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict B D A C1
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B D A B1
+++++
apply l9_8_2 with C1; Side.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).

*****
HB : and (not (Col B1 B D)) (and (TS B D B1 C1) (Bet A B B1))
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct HB as [HNCol5 [HTS1 HBetB]].
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].

*****
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HC : ~ Col C D B1 /\ C <> C1 /\ Bet A C C1).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).

*****
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col C D B1)) (and (not (eq C C1)) (Bet A C C1))
+++++
assert_diffs.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
assert_diffs.

*****
H19 : not (eq W X)
H17 : not (eq V W)
H14 : not (eq Q R)
H10 : not (eq P Q)
H15 : not (eq D C1)
H12 : not (eq B C1)
H11 : not (eq C1 A)
H0 : not (eq B1 C1)
H : not (eq A B1)
H8 : not (eq B C)
H9 : not (eq C A)
H6 : not (eq C D)
H7 : not (eq A D)
H5 : not (eq A B)
H4 : not (eq B1 D)
H1 : not (eq B D)
H2 : not (eq B1 B)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col C D B1)) (and (not (eq C C1)) (Bet A C C1))
+++++
apply par_strict_symmetry, (par_strict_col_par_strict C D A B B1) in HPar'; Col.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict C D A B B1) in HPar'; Col.

*****
H19 : not (eq W X)
H17 : not (eq V W)
H14 : not (eq Q R)
H10 : not (eq P Q)
H15 : not (eq D C1)
H12 : not (eq B C1)
H11 : not (eq C1 A)
H0 : not (eq B1 C1)
H : not (eq A B1)
H8 : not (eq B C)
H9 : not (eq C A)
H6 : not (eq C D)
H7 : not (eq A D)
H5 : not (eq A B)
H4 : not (eq B1 D)
H1 : not (eq B D)
H2 : not (eq B1 B)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict C D A B1
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col C D B1)) (and (not (eq C C1)) (Bet A C C1))
+++++
assert (HNCol' := par_strict_not_col_4 C D A B1 HPar').
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict C D A B B1) in HPar'; Col.
assert (HNCol' := par_strict_not_col_4 C D A B1 HPar').

*****
HNCol' : not (Col C D B1)
H19 : not (eq W X)
H17 : not (eq V W)
H14 : not (eq Q R)
H10 : not (eq P Q)
H15 : not (eq D C1)
H12 : not (eq B C1)
H11 : not (eq C1 A)
H0 : not (eq B1 C1)
H : not (eq A B1)
H8 : not (eq B C)
H9 : not (eq C A)
H6 : not (eq C D)
H7 : not (eq A D)
H5 : not (eq A B)
H4 : not (eq B1 D)
H1 : not (eq B D)
H2 : not (eq B1 B)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict C D A B1
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col C D B1)) (and (not (eq C C1)) (Bet A C C1))
+++++
assert (C <> C1) by (intro; subst C1; apply HNCol'; Col).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict C D A B B1) in HPar'; Col.
assert (HNCol' := par_strict_not_col_4 C D A B1 HPar').
assert (C <> C1) by (intro; subst C1; apply HNCol'; Col).

*****
H3 : not (eq C C1)
HNCol' : not (Col C D B1)
H19 : not (eq W X)
H17 : not (eq V W)
H14 : not (eq Q R)
H10 : not (eq P Q)
H15 : not (eq D C1)
H12 : not (eq B C1)
H11 : not (eq C1 A)
H0 : not (eq B1 C1)
H : not (eq A B1)
H8 : not (eq B C)
H9 : not (eq C A)
H6 : not (eq C D)
H7 : not (eq A D)
H5 : not (eq A B)
H4 : not (eq B1 D)
H1 : not (eq B D)
H2 : not (eq B1 B)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict C D A B1
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (Col C D B1)) (and (not (eq C C1)) (Bet A C C1))
+++++
repeat split; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict C D A B B1) in HPar'; Col.
assert (HNCol' := par_strict_not_col_4 C D A B1 HPar').
assert (C <> C1) by (intro; subst C1; apply HNCol'; Col).
repeat split; auto.

*****
H3 : not (eq C C1)
HNCol' : not (Col C D B1)
H19 : not (eq W X)
H17 : not (eq V W)
H14 : not (eq Q R)
H10 : not (eq P Q)
H15 : not (eq D C1)
H12 : not (eq B C1)
H11 : not (eq C1 A)
H0 : not (eq B1 C1)
H : not (eq A B1)
H8 : not (eq B C)
H9 : not (eq C A)
H6 : not (eq C D)
H7 : not (eq A D)
H5 : not (eq A B)
H4 : not (eq B1 D)
H1 : not (eq B D)
H2 : not (eq B1 B)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict C D A B1
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C C1
+++++
apply col_two_sides_bet with D; Col.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict C D A B B1) in HPar'; Col.
assert (HNCol' := par_strict_not_col_4 C D A B1 HPar').
assert (C <> C1) by (intro; subst C1; apply HNCol'; Col).
repeat split; auto.
apply col_two_sides_bet with D; Col.

*****
H3 : not (eq C C1)
HNCol' : not (Col C D B1)
H19 : not (eq W X)
H17 : not (eq V W)
H14 : not (eq Q R)
H10 : not (eq P Q)
H15 : not (eq D C1)
H12 : not (eq B C1)
H11 : not (eq C1 A)
H0 : not (eq B1 C1)
H : not (eq A B1)
H8 : not (eq B C)
H9 : not (eq C A)
H6 : not (eq C D)
H7 : not (eq A D)
H5 : not (eq A B)
H4 : not (eq B1 D)
H1 : not (eq B D)
H2 : not (eq B1 B)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict C D A B1
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS C D A C1
+++++
apply l9_8_2 with B1; Side.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict C D A B B1) in HPar'; Col.
assert (HNCol' := par_strict_not_col_4 C D A B1 HPar').
assert (C <> C1) by (intro; subst C1; apply HNCol'; Col).
repeat split; auto.
apply col_two_sides_bet with D; Col.
apply l9_8_2 with B1; Side.

*****
H3 : not (eq C C1)
HNCol' : not (Col C D B1)
H19 : not (eq W X)
H17 : not (eq V W)
H14 : not (eq Q R)
H10 : not (eq P Q)
H15 : not (eq D C1)
H12 : not (eq B C1)
H11 : not (eq C1 A)
H0 : not (eq B1 C1)
H : not (eq A B1)
H8 : not (eq B C)
H9 : not (eq C A)
H6 : not (eq C D)
H7 : not (eq A D)
H5 : not (eq A B)
H4 : not (eq B1 D)
H1 : not (eq B D)
H2 : not (eq B1 B)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict C D A B1
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS C D B1 C1
+++++
repeat split; Col.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict C D A B B1) in HPar'; Col.
assert (HNCol' := par_strict_not_col_4 C D A B1 HPar').
assert (C <> C1) by (intro; subst C1; apply HNCol'; Col).
repeat split; auto.
apply col_two_sides_bet with D; Col.
apply l9_8_2 with B1; Side.
repeat split; Col.

*****
H3 : not (eq C C1)
HNCol' : not (Col C D B1)
H19 : not (eq W X)
H17 : not (eq V W)
H14 : not (eq Q R)
H10 : not (eq P Q)
H15 : not (eq D C1)
H12 : not (eq B C1)
H11 : not (eq C1 A)
H0 : not (eq B1 C1)
H : not (eq A B1)
H8 : not (eq B C)
H9 : not (eq C A)
H6 : not (eq C D)
H7 : not (eq A D)
H5 : not (eq A B)
H4 : not (eq B1 D)
H1 : not (eq B D)
H2 : not (eq B1 B)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict C D A B1
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col C1 C D)
+++++
intro; apply HNCol3; ColR.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
assert_diffs.
apply par_strict_symmetry, (par_strict_col_par_strict C D A B B1) in HPar'; Col.
assert (HNCol' := par_strict_not_col_4 C D A B1 HPar').
assert (C <> C1) by (intro; subst C1; apply HNCol'; Col).
repeat split; auto.
apply col_two_sides_bet with D; Col.
apply l9_8_2 with B1; Side.
repeat split; Col.
intro; apply HNCol3; ColR.

*****
H3 : not (eq C C1)
HNCol' : not (Col C D B1)
H19 : not (eq W X)
H17 : not (eq V W)
H14 : not (eq Q R)
H10 : not (eq P Q)
H15 : not (eq D C1)
H12 : not (eq B C1)
H11 : not (eq C1 A)
H0 : not (eq B1 C1)
H : not (eq A B1)
H8 : not (eq B C)
H9 : not (eq C A)
H6 : not (eq C D)
H7 : not (eq A D)
H5 : not (eq A B)
H4 : not (eq B1 D)
H1 : not (eq B D)
H2 : not (eq B1 B)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict C D A B1
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T C D) (Bet B1 T C1))
+++++
exists D; Col.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).

*****
HC : and (not (Col C D B1)) (and (not (eq C C1)) (Bet A C C1))
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct HC as [HNCol6 [HCC1 HBetC]].
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].

*****
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert_diffs.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.

*****
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
H : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].

*****
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
H : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B D C B1
+++++
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.

*****
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
H : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS C B1 B D
+++++
apply l9_31.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
apply l9_31.

*****
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
H : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS C B B1 D
+++++
apply l9_17 with C1; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
apply l9_31.
apply l9_17 with C1; trivial.

*****
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
H : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS C B B1 C1
+++++
exists A; assert_diffs; repeat split; Col; try (intro; apply HNCol; ColR); [exists B|exists C]; split; Col; Between.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
apply l9_31.
apply l9_17 with C1; trivial.
exists A; assert_diffs; repeat split; Col; try (intro; apply HNCol; ColR); [exists B|exists C]; split; Col; Between.

*****
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
H : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS C D B1 B
+++++
apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.

*****
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
H : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
rename H into HAB1.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.

*****
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.

*****
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.

*****
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.

*****
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.

*****
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.

*****
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.

*****
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (Hd := defect_distincts A B1 C G H I HDef2).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).

*****
Hd : and (not (eq A B1))\n (and (not (eq B1 C))\n (and (not (eq A C)) (and (not (eq G H)) (not (eq H I)))))
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).

*****
Hd2 : and (not (eq C B))\n (and (not (eq B B1))\n (and (not (eq C B1)) (and (not (eq M N)) (not (eq N O)))))
Hd : and (not (eq A B1))\n (and (not (eq B1 C))\n (and (not (eq A C)) (and (not (eq G H)) (not (eq H I)))))
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).

*****
Hd3 : and (not (eq B1 C))\n (and (not (eq C D))\n (and (not (eq B1 D)) (and (not (eq A' B')) (not (eq B' C')))))
Hd2 : and (not (eq C B))\n (and (not (eq B B1))\n (and (not (eq C B1)) (and (not (eq M N)) (not (eq N O)))))
Hd : and (not (eq A B1))\n (and (not (eq B1 C))\n (and (not (eq A C)) (and (not (eq G H)) (not (eq H I)))))
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
spliter; clean.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.

*****
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.

*****
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.

*****
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.

*****
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.

*****
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.

*****
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Defect A C B P Q R
+++++
apply defect_perm_132, HDef.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.

*****
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Defect A C B1 G H I
+++++
apply defect_perm_132, HDef2.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.

*****
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HIsi1 : SAMS G H I A' B' C').
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').

*****
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS G H I A' B' C'
+++++
apply sams_lea2__sams with G H I J K L; Lea.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.

*****
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A' B' C' J K L
+++++
apply sams_suma__lea123789 with D' E' F'; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.

*****
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HIsi2 : SAMS M N O A' B' C').
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').

*****
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS M N O A' B' C'
+++++
apply sams_lea2__sams with G H I A' B' C'; Lea.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.

*****
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA M N O G H I
+++++
apply sams_suma__lea456789 with P Q R; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.

*****
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).

*****
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA G' H' I' D' E' F' S T U
+++++
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.

*****
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HIsi6 : SAMS G' H' I' D' E' F').
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').

*****
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS G' H' I' D' E' F'
+++++
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.

*****
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').

*****
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P Q R J' K' L' G' H' I'
+++++
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.

*****
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HIsi7 : SAMS P Q R J' K' L').
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').

*****
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R J' K' L'
+++++
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.

*****
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.

*****
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Defect C B D P Q R
+++++
apply defect_perm_231, (conga3_defect__defect A B C); CongA.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
apply defect_perm_231, (conga3_defect__defect A B C); CongA.

*****
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Defect C D B1 A' B' C'
+++++
apply defect_perm_231, HDef5.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
apply defect_perm_231, (conga3_defect__defect A B C); CongA.
apply defect_perm_231, HDef5.

*****
HSuma8 : SumA P Q R M' N' O' J' K' L'
HIsi8 : SAMS P Q R M' N' O'
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
assert (HLea : LeA P Q R J' K' L') by (apply sams_suma__lea123789 with M' N' O'; trivial).
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
apply defect_perm_231, (conga3_defect__defect A B C); CongA.
apply defect_perm_231, HDef5.
assert (HLea : LeA P Q R J' K' L') by (apply sams_suma__lea123789 with M' N' O'; trivial).

*****
HLea : LeA P Q R J' K' L'
HSuma8 : SumA P Q R M' N' O' J' K' L'
HIsi8 : SAMS P Q R M' N' O'
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (SAMS P Q R P Q R) (LeA V W X S T U)
+++++
split.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
apply defect_perm_231, (conga3_defect__defect A B C); CongA.
apply defect_perm_231, HDef5.
assert (HLea : LeA P Q R J' K' L') by (apply sams_suma__lea123789 with M' N' O'; trivial).
split.

*****
HLea : LeA P Q R J' K' L'
HSuma8 : SumA P Q R M' N' O' J' K' L'
HIsi8 : SAMS P Q R M' N' O'
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R P Q R
+++++
suma.assert_diffs.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
apply defect_perm_231, (conga3_defect__defect A B C); CongA.
apply defect_perm_231, HDef5.
assert (HLea : LeA P Q R J' K' L') by (apply sams_suma__lea123789 with M' N' O'; trivial).
split.
suma.assert_diffs.

*****
H40 : not (eq K L)
H38 : not (eq J K)
H36 : not (eq T U)
H33 : not (eq S T)
H29 : not (eq E' F')
H22 : not (eq D' E')
H34 : not (eq H' I')
H32 : not (eq G' H')
H28 : not (eq K' L')
H24 : not (eq J' K')
H23 : not (eq N' O')
H17 : not (eq M' N')
HLea : LeA P Q R J' K' L'
HSuma8 : SumA P Q R M' N' O' J' K' L'
HIsi8 : SAMS P Q R M' N' O'
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q R P Q R
+++++
apply sams_lea2__sams with P Q R J' K' L'; Lea.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
apply defect_perm_231, (conga3_defect__defect A B C); CongA.
apply defect_perm_231, HDef5.
assert (HLea : LeA P Q R J' K' L') by (apply sams_suma__lea123789 with M' N' O'; trivial).
split.
suma.assert_diffs.
apply sams_lea2__sams with P Q R J' K' L'; Lea.

*****
HLea : LeA P Q R J' K' L'
HSuma8 : SumA P Q R M' N' O' J' K' L'
HIsi8 : SAMS P Q R M' N' O'
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA V W X S T U
+++++
apply lea_trans with G' H' I'.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
apply defect_perm_231, (conga3_defect__defect A B C); CongA.
apply defect_perm_231, HDef5.
assert (HLea : LeA P Q R J' K' L') by (apply sams_suma__lea123789 with M' N' O'; trivial).
split.
suma.assert_diffs.
apply sams_lea2__sams with P Q R J' K' L'; Lea.
apply lea_trans with G' H' I'.

*****
HLea : LeA P Q R J' K' L'
HSuma8 : SumA P Q R M' N' O' J' K' L'
HIsi8 : SAMS P Q R M' N' O'
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA V W X G' H' I'
+++++
apply sams_lea456_suma2__lea with P Q R P Q R J' K' L'; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
apply defect_perm_231, (conga3_defect__defect A B C); CongA.
apply defect_perm_231, HDef5.
assert (HLea : LeA P Q R J' K' L') by (apply sams_suma__lea123789 with M' N' O'; trivial).
split.
suma.assert_diffs.
apply sams_lea2__sams with P Q R J' K' L'; Lea.
apply lea_trans with G' H' I'.
apply sams_lea456_suma2__lea with P Q R P Q R J' K' L'; trivial.

*****
HLea : LeA P Q R J' K' L'
HSuma8 : SumA P Q R M' N' O' J' K' L'
HIsi8 : SAMS P Q R M' N' O'
HIsi7 : SAMS P Q R J' K' L'
HSuma7 : SumA P Q R J' K' L' G' H' I'
HIsi6 : SAMS G' H' I' D' E' F'
HSuma6 : SumA G' H' I' D' E' F' S T U
HIsi2 : SAMS M N O A' B' C'
HIsi1 : SAMS G H I A' B' C'
HSuma5 : SumA P Q R M N O G H I
HIsi5 : SAMS P Q R M N O
HSuma4 : SumA A' B' C' D' E' F' J K L
HIsi4 : SAMS A' B' C' D' E' F'
HSuma3 : SumA G H I J K L S T U
HIsi3 : SAMS G H I J K L
HSuma2 : SumA M N O A' B' C' J' K' L'
J',K',L' : Tpoint
HSuma1 : SumA G H I A' B' C' G' H' I'
G',H',I' : Tpoint
H21 : not (eq B' C')
H19 : not (eq A' B')
H26 : not (eq N O)
H25 : not (eq M N)
H31 : not (eq H I)
H30 : not (eq G H)
HDef7 : Defect B1 B D M' N' O'
M',N',O' : Tpoint
HDef6 : Defect C D C1 D' E' F'
D',E',F' : Tpoint
HDef5 : Defect B1 C D A' B' C'
A',B',C' : Tpoint
HDef4 : Defect C B B1 M N O
M,N,O : Tpoint
HDef3 : Defect B1 C C1 J K L
J,K,L : Tpoint
HDef2 : Defect A B1 C G H I
G,H,I : Tpoint
HZ2 : Bet C Z B1
HZ1 : Bet B Z D
Z : Tpoint
H20 : not (eq W X)
H18 : not (eq V W)
H15 : not (eq Q R)
H12 : not (eq P Q)
H16 : not (eq D C1)
H13 : not (eq B C1)
H6 : not (eq B1 C1)
H0 : not (eq A C1)
HAB1 : not (eq A B1)
H8 : not (eq B C)
H11 : not (eq C A)
H9 : not (eq A D)
H7 : not (eq A B)
H3 : not (eq B D)
H5 : not (eq B1 B)
H4 : not (eq C B1)
H1 : not (eq D B1)
H2 : not (eq C D)
HBetC : Bet A C C1
HCC1 : not (eq C C1)
HNCol6 : not (Col C D B1)
HBetB : Bet A B B1
HTS1 : TS B D B1 C1
HNCol5 : not (Col B1 B D)
HNCol4 : not (Col A B D)
HNCol3 : not (Col C D A)
HNCol2 : not (Col B C D)
HPar' : Par_strict A B C D
HPar : Par_strict A C B D
HConga2 : CongA C B A B C D
HConga1 : CongA C A B B D C
HCong1 : Cong A B D C
HSuma : SumA P Q R P Q R V W X
HDef1 : Defect A B1 C1 S T U
HDef : Defect A B C P Q R
HBet : Bet B1 D C1
HOutC : Out A C C1
HOutB : Out A B B1
HTS : TS B C A D
HCong : Cong A C B D
HConga : CongA A C B C B D
HNCol : not (Col A B C)
A,B,C,D,B1,C1,P,Q,R,S,T,U,V,W,X : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA G' H' I' S T U
+++++
apply sams_suma__lea123789 with D' E' F'; trivial.
-----
Lemma legendre_aux : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C D B1 C1 P Q R S T U V W X, ~ Col A B C -> CongA A C B C B D -> Cong A C B D -> TS B C A D -> Out A B B1 -> Out A C C1 -> Bet B1 D C1 -> Defect A B C P Q R -> Defect A B1 C1 S T U -> SumA P Q R P Q R V W X -> SAMS P Q R P Q R /\\ LeA V W X S T U.
Proof.
intros noah A B C D B1 C1 P Q R S T U V W X HNCol HConga HCong HTS HOutB HOutC HBet HDef HDef1 HSuma.
destruct (l11_49 A C B D B C) as [HCong1 [HConga1 HConga2]]; CongA; Cong.
assert_diffs; auto.
assert (HPar : Par_strict A C B D).
assert (HPar' : Par_strict A B C D).
assert (HNCol2:= HPar'); assert (HNCol3 := HPar'); assert (HNCol4 := HPar').
apply par_strict_not_col_2 in HNCol2; apply par_strict_not_col_3 in HNCol3; apply par_strict_not_col_4 in HNCol4.
assert (HB : ~ Col B1 B D /\\ TS B D B1 C1 /\\ Bet A B B1).
destruct HB as [HNCol5 [HTS1 HBetB]].
assert (HC : ~ Col C D B1 /\\ C <> C1 /\\ Bet A C C1).
destruct HC as [HNCol6 [HCC1 HBetC]].
assert_diffs.
destruct (ts2__ex_bet2 B C D B1) as [Z [HZ1 HZ2]].
apply l9_8_2 with C1; Side; apply one_side_symmetry, l12_6, par_strict_col_par_strict with A; Col; Par.
rename H into HAB1.
destruct (ex_defect A B1 C) as [G [H [I HDef2]]]; auto.
destruct (ex_defect B1 C C1) as [J [K [L HDef3]]]; auto.
destruct (ex_defect C B B1) as [M [N [O HDef4]]]; auto.
destruct (ex_defect B1 C D) as [A' [B' [C' HDef5]]]; auto.
destruct (ex_defect C D C1) as [D' [E' [F' HDef6]]]; auto.
destruct (ex_defect B1 B D) as [M' [N' [O' HDef7]]]; auto.
assert (Hd := defect_distincts A B1 C G H I HDef2).
assert (Hd2 := defect_distincts C B B1 M N O HDef4).
assert (Hd3 := defect_distincts B1 C D A' B' C' HDef5).
spliter; clean.
destruct (ex_suma G H I A' B' C') as [G' [H' [I' HSuma1]]]; auto.
destruct (ex_suma M N O A' B' C') as [J' [K' [L' HSuma2]]]; auto.
destruct (t22_16_1bis noah A B1 C1 C G H I J K L S T U) as [HIsi3 HSuma3]; trivial.
destruct (t22_16_1bis noah B1 C C1 D A' B' C' D' E' F' J K L) as [HIsi4 HSuma4]; trivial.
destruct (t22_16_1bis noah A C B1 B P Q R M N O G H I) as [HIsi5 HSuma5]; trivial.
apply defect_perm_132, HDef.
apply defect_perm_132, HDef2.
assert (HIsi1 : SAMS G H I A' B' C').
apply sams_lea2__sams with G H I J K L; Lea.
apply sams_suma__lea123789 with D' E' F'; trivial.
assert (HIsi2 : SAMS M N O A' B' C').
apply sams_lea2__sams with G H I A' B' C'; Lea.
apply sams_suma__lea456789 with P Q R; trivial.
assert (HSuma6 : SumA G' H' I' D' E' F' S T U).
apply suma_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HIsi6 : SAMS G' H' I' D' E' F').
apply sams_assoc_2 with G H I A' B' C' J K L; trivial.
assert (HSuma7 : SumA P Q R J' K' L' G' H' I').
apply suma_assoc_1 with M N O A' B' C' G H I; trivial.
assert (HIsi7 : SAMS P Q R J' K' L').
apply sams_assoc_1 with M N O A' B' C' G H I; trivial.
destruct (t22_16_2 noah C B B1 D M' N' O' A' B' C' P Q R M N O Z J' K' L') as [HIsi8 HSuma8]; trivial.
apply defect_perm_231, (conga3_defect__defect A B C); CongA.
apply defect_perm_231, HDef5.
assert (HLea : LeA P Q R J' K' L') by (apply sams_suma__lea123789 with M' N' O'; trivial).
split.
suma.assert_diffs.
apply sams_lea2__sams with P Q R J' K' L'; Lea.
apply lea_trans with G' H' I'.
apply sams_lea456_suma2__lea with P Q R P Q R J' K' L'; trivial.
apply sams_suma__lea123789 with D' E' F'; trivial.

*****

*****

+++++
Qed.
-----
Lemma legendre_aux1 : forall A B C B' C',\n  ~ Col A B C -> Out A B B' -> Out A C C' ->\n  exists D', InAngle D' B A C /\ CongA A C' B' C' B' D' /\\n             Cong A C' B' D' /\ TS B' C' A D'.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C B' C' : Tpoint) (_ : not (Col A B C)) (_ : Out A B B') (_ : Out A C C'), ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
Proof.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C B' C' : Tpoint) (_ : not (Col A B C)) (_ : Out A B B') (_ : Out A C C'), ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
intros A B C B' C' HNCol HOutB HOutC.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.

*****
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
assert_diffs.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.

*****
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
assert (HNCol' : ~ Col A B' C').
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').

*****
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B' C')
+++++
intro.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
intro.

*****
H : Col A B' C'
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
intro.
assert_diffs.

*****
H : Col A B' C'
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
intro.
assert_diffs.
apply HNCol.

*****
H : Col A B' C'
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').

*****
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
idtac.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.

*****
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
destruct (midpoint_existence B' C') as [M HM].
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].

*****
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
destruct (symmetric_point_construction A M) as [D' HD].
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].

*****
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
assert (HNCol1 : ~ Col A M B').
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').

*****
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A M B')
+++++
intro.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
intro.

*****
H : Col A M B'
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
intro.
assert_diffs.

*****
H8 : not (eq M C')
H6 : not (eq M B')
H7 : not (eq B' C')
H : Col A M B'
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol'.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
intro.
assert_diffs.
apply HNCol'.

*****
H8 : not (eq M C')
H6 : not (eq M B')
H7 : not (eq B' C')
H : Col A M B'
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B' C'
+++++
ColR.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').

*****
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
idtac.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.

*****
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
assert (HNCol2 : ~ Col D' B' C').
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').

*****
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col D' B' C')
+++++
intro.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
intro.

*****
H : Col D' B' C'
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
intro.
assert_diffs.

*****
H11 : not (eq M D')
H6 : not (eq A D')
H10 : not (eq M C')
H9 : not (eq B' C')
H7 : not (eq M B')
H8 : not (eq A M)
H : Col D' B' C'
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol'.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
intro.
assert_diffs.
apply HNCol'.

*****
H11 : not (eq M D')
H6 : not (eq A D')
H10 : not (eq M C')
H9 : not (eq B' C')
H7 : not (eq M B')
H8 : not (eq A M)
H : Col D' B' C'
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B' C'
+++++
ColR.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').

*****
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
idtac.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.

*****
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D' : Tpoint => and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))))
+++++
exists D'.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.

*****
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D')))
+++++
assert_diffs.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
HM : Midpoint M B' C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D')))
+++++
destruct HM.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
HD : Midpoint M A D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D')))
+++++
destruct HD.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (InAngle D' B A C) (and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D')))
+++++
split.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle D' B A C
+++++
apply l11_25 with D' B' C'.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle D' B' A C'
+++++
try (apply out_trivial).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle D' B' A C'
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle D' B' A C'
+++++
repeat split.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B' A)
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C' A)
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D' A)
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Bet B' X C') (or (eq X A) (Out A X D')))
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.
auto.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Bet B' X C') (or (eq X A) (Out A X D')))
+++++
exists M.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.
auto.
exists M.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet B' M C') (or (eq M A) (Out A M D'))
+++++
split.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.
auto.
exists M.
split.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B' M C'
+++++
trivial.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.
auto.
exists M.
split.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (eq M A) (Out A M D')
+++++
trivial.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.
auto.
exists M.
split.
trivial.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (eq M A) (Out A M D')
+++++
right.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.
auto.
exists M.
split.
trivial.
right.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A M D'
+++++
apply bet_out.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.
auto.
exists M.
split.
trivial.
right.
apply bet_out.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M A)
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).
auto.
repeat split.
auto.
exists M.
split.
trivial.
right.
apply bet_out.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M D'
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B B'
+++++
try (apply out_trivial).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B B'
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C C'
+++++
try (apply out_trivial).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C C'
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A D' D'
+++++
try (apply out_trivial).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
apply l11_25 with D' B' C'.
try (apply out_trivial).

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D' A)
+++++
auto.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))
+++++
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A M C' D' M B'
+++++
Cong.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A M C' D' M B'
+++++
apply l11_14.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
apply l11_14.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M D'
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
apply l11_14.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A M)
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
apply l11_14.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D' M)
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
apply l11_14.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C' M B'
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
apply l11_14.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M C')
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
apply l11_14.

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M B')
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M A M D'
+++++
Cong.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].

*****
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong M C' M B'
+++++
Cong.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].

*****
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C')
+++++
Cong.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))
+++++
Cong.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (CongA A C' B' C' B' D') (and (Cong A C' B' D') (TS B' C' A D'))
+++++
split.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A C' B' C' B' D'
+++++
apply (out_conga A C' M M B' D').
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A C' M M B' D'
+++++
try (apply out_trivial).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A C' M M B' D'
+++++
try (apply bet_out).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).
try (apply bet_out).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A C' M M B' D'
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).
try (apply bet_out).
Between.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A C' M M B' D'
+++++
CongA.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C' A A
+++++
try (apply out_trivial).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C')
+++++
try (apply bet_out).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).
try (apply bet_out).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C')
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C' M B'
+++++
try (apply out_trivial).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C' M B'
+++++
try (apply bet_out).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).
try (apply bet_out).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M C')
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).
try (apply bet_out).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C' M B'
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B' M C'
+++++
try (apply out_trivial).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B' M C'
+++++
try (apply bet_out).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).
try (apply bet_out).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M B')
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).
try (apply bet_out).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B' M C'
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B' D' D'
+++++
try (apply out_trivial).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D' B')
+++++
try (apply bet_out).
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
apply (out_conga A C' M M B' D').
try (apply out_trivial).
try (apply bet_out).

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq D' B')
+++++
Between.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Cong A C' B' D') (TS B' C' A D')
+++++
split.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C' B' D'
+++++
Cong.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B' C' A D'
+++++
Cong.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.
Cong.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B' C' A D'
+++++
repeat split.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.
Cong.
repeat split.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B' C')
+++++
Col.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.
Cong.
repeat split.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col D' B' C')
+++++
Col.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.
Cong.
repeat split.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T B' C') (Bet A T D'))
+++++
Col.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.
Cong.
repeat split.
Col.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (Col T B' C') (Bet A T D'))
+++++
exists M.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.
Cong.
repeat split.
Col.
exists M.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col M B' C') (Bet A M D')
+++++
split.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.
Cong.
repeat split.
Col.
exists M.
split.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col M B' C'
+++++
Col.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (midpoint_existence B' C') as [M HM].
destruct (symmetric_point_construction A M) as [D' HD].
assert (HNCol1 : ~ Col A M B').
idtac.
assert (HNCol2 : ~ Col D' B' C').
idtac.
exists D'.
assert_diffs.
destruct HM.
destruct HD.
split.
destruct (l11_49 A M C' D' M B') as [HCong1 [HConga1 HConga2]].
Cong.
split.
split.
Cong.
repeat split.
Col.
exists M.
split.

*****
HConga2 : CongA M C' A M B' D'
HConga1 : CongA M A C' M D' B'
HCong1 : Cong A C' D' B'
H12 : not (eq M D')
H0 : not (eq A D')
H11 : not (eq M C')
H8 : not (eq M B')
H10 : not (eq A M)
H9 : not (eq D' C')
H6 : not (eq B' C')
H7 : not (eq D' B')
HNCol2 : not (Col D' B' C')
HNCol1 : not (Col A M B')
H15 : Cong A M M D'
H14 : Bet A M D'
D' : Tpoint
H13 : Cong B' M M C'
H : Bet B' M C'
M : Tpoint
HNCol' : not (Col A B' C')
H5 : not (eq B' A)
H3 : not (eq C' A)
H4 : not (eq A C)
H1 : not (eq B C)
H2 : not (eq A B)
HOutC : Out A C C'
HOutB : Out A B B'
HNCol : not (Col A B C)
A,B,C,B',C' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A M D'
+++++
Col.
-----
Lemma legendre_aux1 : forall A B C B' C', ~ Col A B C -> Out A B B' -> Out A C C' -> exists D', InAngle D' B A C /\\ CongA A C' B' C' B' D' /\\ Cong A C' B' D' /\\ TS B' C' A D'.
Proof.
intros A B C B' C' HNCol HOutB HOutC.
assert_diffs.
assert (HNCol' : ~ Col A B' C').

*****

*****

+++++
Qed.
-----
Lemma legendre_aux2 :\n  ~ hypothesis_of_obtuse_saccheri_quadrilaterals ->\n  forall A B C,\n    ~ Col A B C ->  Acute B A C ->\n    (forall T,\n       InAngle T B A C ->\n       exists X Y : Tpoint, Out A B X /\ Out A C Y /\ Bet X T Y) ->\n    forall P Q R S T U,\n      Defect A B C P Q R -> GradAExp P Q R S T U ->\n      exists B' C' P' Q' R',\n        (Out A B B' /\ Out A C C' /\\n         Defect A B' C' P' Q' R' /\ LeA S T U P' Q' R').
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not hypothesis_of_obtuse_saccheri_quadrilaterals) (A B C : Tpoint) (_ : not (Col A B C)) (_ : Acute B A C) (_ : forall (T : Tpoint) (_ : InAngle T B A C), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))) (P Q R S T U : Tpoint) (_ : Defect A B C P Q R) (_ : GradAExp P Q R S T U), ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA S T U P' Q' R'))))))))
+++++
Proof.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : not hypothesis_of_obtuse_saccheri_quadrilaterals) (A B C : Tpoint) (_ : not (Col A B C)) (_ : Acute B A C) (_ : forall (T : Tpoint) (_ : InAngle T B A C), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))) (P Q R S T U : Tpoint) (_ : Defect A B C P Q R) (_ : GradAExp P Q R S T U), ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA S T U P' Q' R'))))))))
+++++
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.

*****
HDef : Defect A B C P Q R
P,Q,R,S,T,U : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : GradAExp P Q R S T U, ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA S T U P' Q' R'))))))))
+++++
induction 1.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.

*****
H : CongA A0 B0 C0 D E F
D,E,F : Tpoint
HDef : Defect A B C A0 B0 C0
A0,B0,C0 : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA D E F P' Q' R'))))))))
+++++
rename A0 into P.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.

*****
H : CongA P B0 C0 D E F
D,E,F : Tpoint
HDef : Defect A B C P B0 C0
P,B0,C0 : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA D E F P' Q' R'))))))))
+++++
rename B0 into Q.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.

*****
H : CongA P Q C0 D E F
D,E,F : Tpoint
HDef : Defect A B C P Q C0
P,Q,C0 : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA D E F P' Q' R'))))))))
+++++
rename C0 into R.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.

*****
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA D E F P' Q' R'))))))))
+++++
exists B.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.

*****
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B) (and (Out A C C') (and (Defect A B C' P' Q' R') (LeA D E F P' Q' R')))))))
+++++
exists C.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.

*****
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B) (and (Out A C C) (and (Defect A B C P' Q' R') (LeA D E F P' Q' R'))))))
+++++
exists P.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.

*****
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B) (and (Out A C C) (and (Defect A B C P Q' R') (LeA D E F P Q' R')))))
+++++
exists Q.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.

*****
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R' : Tpoint => and (Out A B B) (and (Out A C C) (and (Defect A B C P Q R') (LeA D E F P Q R'))))
+++++
exists R.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.

*****
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A B B) (and (Out A C C) (and (Defect A B C P Q R) (LeA D E F P Q R)))
+++++
assert_diffs.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A B B) (and (Out A C C) (and (Defect A B C P Q R) (LeA D E F P Q R)))
+++++
repeat split.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B A)
+++++
try apply out_trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.
try apply out_trivial.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B A)
+++++
Lea.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B A)
+++++
try apply out_trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.
try apply out_trivial.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B A)
+++++
Lea.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A B B) (Bet A B B)
+++++
try apply out_trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.
try apply out_trivial.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B A)
+++++
Lea.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C A)
+++++
try apply out_trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.
try apply out_trivial.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C A)
+++++
Lea.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C A)
+++++
try apply out_trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.
try apply out_trivial.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C A)
+++++
Lea.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Bet A C C) (Bet A C C)
+++++
try apply out_trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.
try apply out_trivial.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C A)
+++++
Lea.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Defect A B C P Q R
+++++
try apply out_trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.
try apply out_trivial.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Defect A B C P Q R
+++++
Lea.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
try apply out_trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
exists B.
exists C.
exists P.
exists Q.
exists R.
assert_diffs.
repeat split.
try apply out_trivial.

*****
H6 : not (eq F E)
H4 : not (eq D E)
H1 : not (eq R Q)
H0 : not (eq P Q)
H5 : not (eq A C)
H2 : not (eq B C)
H3 : not (eq A B)
H : CongA P Q R D E F
D,E,F : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA D E F P Q R
+++++
Lea.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.

*****
IHGradAExp : forall _ : Defect A B C A0 B0 C0,\nex\n (fun B' : Tpoint =>\n ex\n (fun C' : Tpoint =>\n ex\n (fun P' : Tpoint =>\n ex\n (fun Q' : Tpoint =>\n ex\n (fun R' : Tpoint =>\n and (Out A B B')\n (and (Out A C C')\n (and (Defect A B' C' P' Q' R') (LeA D E F P' Q' R'))))))))
H2 : SumA D E F D E F G H I
H1 : SAMS D E F D E F
H0 : GradAExp A0 B0 C0 D E F
D,E,F,G,H,I : Tpoint
HDef : Defect A B C A0 B0 C0
A0,B0,C0 : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
rename A0 into P.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.

*****
IHGradAExp : forall _ : Defect A B C P B0 C0,\nex\n (fun B' : Tpoint =>\n ex\n (fun C' : Tpoint =>\n ex\n (fun P' : Tpoint =>\n ex\n (fun Q' : Tpoint =>\n ex\n (fun R' : Tpoint =>\n and (Out A B B')\n (and (Out A C C')\n (and (Defect A B' C' P' Q' R') (LeA D E F P' Q' R'))))))))
H2 : SumA D E F D E F G H I
H1 : SAMS D E F D E F
H0 : GradAExp P B0 C0 D E F
D,E,F,G,H,I : Tpoint
HDef : Defect A B C P B0 C0
P,B0,C0 : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
rename B0 into Q.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.

*****
IHGradAExp : forall _ : Defect A B C P Q C0,\nex\n (fun B' : Tpoint =>\n ex\n (fun C' : Tpoint =>\n ex\n (fun P' : Tpoint =>\n ex\n (fun Q' : Tpoint =>\n ex\n (fun R' : Tpoint =>\n and (Out A B B')\n (and (Out A C C')\n (and (Defect A B' C' P' Q' R') (LeA D E F P' Q' R'))))))))
H2 : SumA D E F D E F G H I
H1 : SAMS D E F D E F
H0 : GradAExp P Q C0 D E F
D,E,F,G,H,I : Tpoint
HDef : Defect A B C P Q C0
P,Q,C0 : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
rename C0 into R.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.

*****
IHGradAExp : forall _ : Defect A B C P Q R,\nex\n (fun B' : Tpoint =>\n ex\n (fun C' : Tpoint =>\n ex\n (fun P' : Tpoint =>\n ex\n (fun Q' : Tpoint =>\n ex\n (fun R' : Tpoint =>\n and (Out A B B')\n (and (Out A C C')\n (and (Defect A B' C' P' Q' R') (LeA D E F P' Q' R'))))))))
H2 : SumA D E F D E F G H I
H1 : SAMS D E F D E F
H0 : GradAExp P Q R D E F
D,E,F,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
rename D into S.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.

*****
IHGradAExp : forall _ : Defect A B C P Q R,\nex\n (fun B' : Tpoint =>\n ex\n (fun C' : Tpoint =>\n ex\n (fun P' : Tpoint =>\n ex\n (fun Q' : Tpoint =>\n ex\n (fun R' : Tpoint =>\n and (Out A B B')\n (and (Out A C C')\n (and (Defect A B' C' P' Q' R') (LeA S E F P' Q' R'))))))))
H2 : SumA S E F S E F G H I
H1 : SAMS S E F S E F
H0 : GradAExp P Q R S E F
S,E,F,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
rename E into T.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.

*****
IHGradAExp : forall _ : Defect A B C P Q R,\nex\n (fun B' : Tpoint =>\n ex\n (fun C' : Tpoint =>\n ex\n (fun P' : Tpoint =>\n ex\n (fun Q' : Tpoint =>\n ex\n (fun R' : Tpoint =>\n and (Out A B B')\n (and (Out A C C')\n (and (Defect A B' C' P' Q' R') (LeA S T F P' Q' R'))))))))
H2 : SumA S T F S T F G H I
H1 : SAMS S T F S T F
H0 : GradAExp P Q R S T F
S,T,F,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
rename F into U.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.

*****
IHGradAExp : forall _ : Defect A B C P Q R,\nex\n (fun B' : Tpoint =>\n ex\n (fun C' : Tpoint =>\n ex\n (fun P' : Tpoint =>\n ex\n (fun Q' : Tpoint =>\n ex\n (fun R' : Tpoint =>\n and (Out A B B')\n (and (Out A C C')\n (and (Defect A B' C' P' Q' R') (LeA S T U P' Q' R'))))))))
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].

*****
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Defect A B C P Q R
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].

*****
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.

*****
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].

*****
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B C)
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].

*****
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B B'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].

*****
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C C'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].

*****
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.

*****
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
assert (HNCol' : ~ Col A B' C').
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').

*****
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B' C')
+++++
destruct HTS.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
destruct HTS.

*****
H4 : and (not (Col D' B' C'))\n (ex (fun T : Tpoint => and (Col T B' C') (Bet A T D')))
H3 : not (Col A B' C')
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B' C')
+++++
Col.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').

*****
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
idtac.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.

*****
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].

*****
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').

*****
Hd : and (not (eq A B'))\n (and (not (eq B' C'))\n (and (not (eq A C')) (and (not (eq P' Q')) (not (eq Q' R')))))
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
spliter.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.

*****
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
assert_diffs.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.

*****
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].

*****
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B'')
+++++
auto.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].

*****
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B'' C'')
+++++
auto.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.

*****
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B'' C'')
+++++
intro.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
intro.

*****
H9 : eq B'' C''
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
intro.
subst.

*****
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H14,H15 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet C'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B C''
C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
intro.
subst.
apply HNCol.

*****
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H14,H15 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet C'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B C''
C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A B C
+++++
ColR.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].

*****
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C'')
+++++
auto.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
auto.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B') (and (Out A C C') (and (Defect A B' C' P' Q' R') (LeA G H I P' Q' R'))))))))
+++++
exists B''.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C' : Tpoint => ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B'') (and (Out A C C') (and (Defect A B'' C' P' Q' R') (LeA G H I P' Q' R')))))))
+++++
exists C''.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P' : Tpoint => ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B'') (and (Out A C C'') (and (Defect A B'' C'' P' Q' R') (LeA G H I P' Q' R'))))))
+++++
exists P''.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q' : Tpoint => ex (fun R' : Tpoint => and (Out A B B'') (and (Out A C C'') (and (Defect A B'' C'' P'' Q' R') (LeA G H I P'' Q' R')))))
+++++
exists Q''.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R' : Tpoint => and (Out A B B'') (and (Out A C C'') (and (Defect A B'' C'' P'' Q'' R') (LeA G H I P'' Q'' R'))))
+++++
exists R''.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Out A B B'') (and (Out A C C'') (and (Defect A B'' C'' P'' Q'' R'') (LeA G H I P'' Q'' R'')))
+++++
repeat (split; trivial).
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA G H I P'' Q'' R''
+++++
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P' Q')
+++++
auto.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q' R')
+++++
auto.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P' Q')
+++++
auto.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].

*****
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q' R')
+++++
auto.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA G H I P'' Q'' R''
+++++
auto.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA G H I P'' Q'' R''
+++++
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A B' C')
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A C' B' C' B' D'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C' B' D'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS B' C' A D'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B' B''
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B' B''
+++++
apply l6_7 with B.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply l6_7 with B.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B' B
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply l6_7 with B.
trivial.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B' B
+++++
apply l6_6.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply l6_7 with B.
trivial.
apply l6_6.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B B'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply l6_7 with B.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B B''
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C' C''
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C' C''
+++++
apply l6_7 with C.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply l6_7 with C.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C' C
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply l6_7 with C.
trivial.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C' C
+++++
apply l6_6.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply l6_7 with C.
trivial.
apply l6_6.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C C'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply l6_7 with C.

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C C''
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B'' D' C''
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Defect A B' C' P' Q' R'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Defect A B'' C'' P'' Q'' R''
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P' Q' R' P' Q' R' V W X
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA G H I P'' Q'' R''
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA G H I P'' Q'' R''
+++++
apply lea_trans with V W X.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply lea_trans with V W X.

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA G H I V W X
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply lea_trans with V W X.
trivial.

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA G H I V W X
+++++
apply sams_lea2_suma2__lea with S T U S T U P' Q' R' P' Q' R'.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply lea_trans with V W X.
trivial.
apply sams_lea2_suma2__lea with S T U S T U P' Q' R' P' Q' R'.

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA S T U P' Q' R'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply lea_trans with V W X.
trivial.
apply sams_lea2_suma2__lea with S T U S T U P' Q' R' P' Q' R'.

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA S T U P' Q' R'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply lea_trans with V W X.
trivial.
apply sams_lea2_suma2__lea with S T U S T U P' Q' R' P' Q' R'.

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P' Q' R' P' Q' R'
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply lea_trans with V W X.
trivial.
apply sams_lea2_suma2__lea with S T U S T U P' Q' R' P' Q' R'.

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA S T U S T U G H I
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply lea_trans with V W X.
trivial.
apply sams_lea2_suma2__lea with S T U S T U P' Q' R' P' Q' R'.

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P' Q' R' P' Q' R' V W X
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.
rename A0 into P.
rename B0 into Q.
rename C0 into R.
rename D into S.
rename E into T.
rename F into U.
destruct IHGradAExp as [B' [C' [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]]]].
trivial.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]].
trivial.
assert (HNCol' : ~ Col A B' C').
idtac.
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert (Hd := defect_distincts A B' C' P' Q' R' HDef').
spliter.
assert_diffs.
destruct (ex_defect A B'' C'') as [P'' [Q'' [R'' HDef'']]].
auto.
exists B''.
exists C''.
exists P''.
exists Q''.
exists R''.
repeat (split; trivial).
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma1]]].
auto.
destruct (legendre_aux noah A B' C' D' B'' C'' P' Q' R' P'' Q'' R'' V W X) as [HIsi1 HLea1].
trivial.
apply lea_trans with V W X.

*****
HLea1 : LeA V W X P'' Q'' R''
HIsi1 : SAMS P' Q' R' P' Q' R'
HSuma1 : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' P'' Q'' R''
P'',Q'',R'' : Tpoint
H23 : not (eq H I)
H20 : not (eq G H)
H17 : not (eq T U)
H12 : not (eq S T)
H21 : not (eq A D')
H19 : not (eq C' D')
H15 : not (eq B'' A)
H14 : not (eq C'' A)
H8 : not (eq B' D')
H13 : not (eq A C)
H10 : not (eq B C)
H11 : not (eq A B)
H7 : not (eq Q' R')
H6 : not (eq P' Q')
H5 : not (eq A C')
H4 : not (eq B' C')
H3 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
H2 : SumA S T U S T U G H I
H1 : SAMS S T U S T U
H0 : GradAExp P Q R S T U
S,T,U,G,H,I : Tpoint
HDef : Defect A B C P Q R
P,Q,R : Tpoint
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
A,B,C : Tpoint
noah : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA V W X P'' Q'' R''
+++++
trivial.
-----
Lemma legendre_aux2 : ~ hypothesis_of_obtuse_saccheri_quadrilaterals -> forall A B C, ~ Col A B C -> Acute B A C -> (forall T, InAngle T B A C -> exists X Y : Tpoint, Out A B X /\\ Out A C Y /\\ Bet X T Y) -> forall P Q R S T U, Defect A B C P Q R -> GradAExp P Q R S T U -> exists B' C' P' Q' R', (Out A B B' /\\ Out A C C' /\\ Defect A B' C' P' Q' R' /\\ LeA S T U P' Q' R').
Proof.
intros noah A B C HNCol HAcute legendre P Q R S T U HDef.
induction 1.

*****

*****

+++++
Qed.
-----
Lemma legendre_s_fourth_theorem_aux :\n  archimedes_axiom ->\n  legendre_s_parallel_postulate ->\n  postulate_of_right_saccheri_quadrilaterals.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate), postulate_of_right_saccheri_quadrilaterals
+++++
Proof.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate), postulate_of_right_saccheri_quadrilaterals
+++++
intros archi legendre.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.

*****
legendre : legendre_s_parallel_postulate
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].

*****
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
assert_diffs.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.

*****
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.

*****
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
destruct (col_dec P Q R) as [HCol|HNCol1].
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].

*****
HCol : Col P Q R
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
-
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-

*****
HCol : Col P Q R
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
apply archi__obtuse_case_elimination in archi.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.

*****
HCol : Col P Q R
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
apply (defect_ncol_out__rah A B C P Q R); Col.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.

*****
HCol : Col P Q R
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Q P R
+++++
apply not_bet_out; Col.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.

*****
HCol : Col P Q R
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Bet P Q R)
+++++
intro HBet.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.

*****
HBet : Bet P Q R
HCol : Col P Q R
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.

*****
HBet : Bet P Q R
HCol : Col P Q R
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A C
+++++
apply defect_perm_213 in HDef.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.

*****
HBet : Bet P Q R
HCol : Col P Q R
HDef : Defect B A C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A C
+++++
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].

*****
HBet : Bet P Q R
HCol : Col P Q R
HSuppa : SuppA D E F P Q R
HSuma2 : SumA G H I C B A D E F
HSuma1 : SumA B A C A C B G H I
P,Q,R,D,E,F,G,H,I : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col B A C
+++++
apply out_col, l6_6, out_lea__out with D E F.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.

*****
HBet : Bet P Q R
HCol : Col P Q R
HSuppa : SuppA D E F P Q R
HSuma2 : SumA G H I C B A D E F
HSuma1 : SumA B A C A C B G H I
P,Q,R,D,E,F,G,H,I : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out E D F
+++++
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.

*****
HBet : Bet P Q R
HCol : Col P Q R
HSuppa : SuppA D E F P Q R
HSuma2 : SumA G H I C B A D E F
HSuma1 : SumA B A C A C B G H I
P,Q,R,D,E,F,G,H,I : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA C B A D E F
+++++
apply sams_suma__lea456789 with G H I; trivial.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.

*****
HBet : Bet P Q R
HCol : Col P Q R
HSuppa : SuppA D E F P Q R
HSuma2 : SumA G H I C B A D E F
HSuma1 : SumA B A C A C B G H I
P,Q,R,D,E,F,G,H,I : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS G H I C B A
+++++
apply (t22_20 archi); trivial.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.

*****

*****

+++++
-
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-

*****
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].

*****
HObtuse : Obtuse S T U
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : archimedes_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
apply archi__obtuse_case_elimination in archi.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.

*****
HObtuse : Obtuse S T U
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col B A C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
apply not_col_permutation_4 in HNCol.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.

*****
HObtuse : Obtuse S T U
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].

*****
HInter : ex\n (fun P' : Tpoint =>\n ex\n (fun Q' : Tpoint =>\n ex\n (fun R' : Tpoint =>\n and (Out A B B')\n (and (Out A C C')\n (and (Defect A B' C' P' Q' R') (LeA S T U P' Q' R'))))))
B',C' : Tpoint
HObtuse : Obtuse S T U
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].

*****
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C',P',Q',R' : Tpoint
HObtuse : Obtuse S T U
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.

*****
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
postulate_of_right_saccheri_quadrilaterals
+++++
exfalso.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.

*****
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HObtuse.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.
apply HObtuse.

*****
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P' Q' R' P' Q' R'
+++++
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]]; trivial.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.
apply HObtuse.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]]; trivial.

*****
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P' Q' R' P' Q' R'
+++++
assert (HNCol' : ~ Col A B' C') by (destruct HTS; Col).
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.
apply HObtuse.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]]; trivial.
assert (HNCol' : ~ Col A B' C') by (destruct HTS; Col).

*****
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P' Q' R' P' Q' R'
+++++
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.
apply HObtuse.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]]; trivial.
assert (HNCol' : ~ Col A B' C') by (destruct HTS; Col).
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].

*****
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P' Q' R' P' Q' R'
+++++
assert_diffs.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.
apply HObtuse.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]]; trivial.
assert (HNCol' : ~ Col A B' C') by (destruct HTS; Col).
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert_diffs.

*****
H17 : not (eq R' Q')
H13 : not (eq P' Q')
H14 : not (eq U T)
H9 : not (eq S T)
H18 : not (eq A D')
H16 : not (eq C' D')
H12 : not (eq B'' A)
H11 : not (eq C'' A)
H : not (eq B' D')
H10 : not (eq P R)
H6 : not (eq Q R)
H8 : not (eq P Q)
H7 : not (eq A C')
H3 : not (eq B' C')
H5 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P' Q' R' P' Q' R'
+++++
destruct (ex_defect A B'' C'') as [S' [T' [U' HDef'']]]; auto.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.
apply HObtuse.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]]; trivial.
assert (HNCol' : ~ Col A B' C') by (destruct HTS; Col).
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert_diffs.
destruct (ex_defect A B'' C'') as [S' [T' [U' HDef'']]]; auto.

*****
H17 : not (eq R' Q')
H13 : not (eq P' Q')
H14 : not (eq U T)
H9 : not (eq S T)
H18 : not (eq A D')
H16 : not (eq C' D')
H12 : not (eq B'' A)
H11 : not (eq C'' A)
H : not (eq B' D')
H10 : not (eq P R)
H6 : not (eq Q R)
H8 : not (eq P Q)
H7 : not (eq A C')
H3 : not (eq B' C')
H5 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B'' C'')
+++++
intro; subst; apply HNCol; ColR.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.
apply HObtuse.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]]; trivial.
assert (HNCol' : ~ Col A B' C') by (destruct HTS; Col).
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert_diffs.
destruct (ex_defect A B'' C'') as [S' [T' [U' HDef'']]]; auto.
intro; subst; apply HNCol; ColR.

*****
HDef'' : Defect A B'' C'' S' T' U'
S',T',U' : Tpoint
H17 : not (eq R' Q')
H13 : not (eq P' Q')
H14 : not (eq U T)
H9 : not (eq S T)
H18 : not (eq A D')
H16 : not (eq C' D')
H12 : not (eq B'' A)
H11 : not (eq C'' A)
H : not (eq B' D')
H10 : not (eq P R)
H6 : not (eq Q R)
H8 : not (eq P Q)
H7 : not (eq A C')
H3 : not (eq B' C')
H5 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P' Q' R' P' Q' R'
+++++
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma]]]; auto.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.
apply HObtuse.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]]; trivial.
assert (HNCol' : ~ Col A B' C') by (destruct HTS; Col).
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert_diffs.
destruct (ex_defect A B'' C'') as [S' [T' [U' HDef'']]]; auto.
intro; subst; apply HNCol; ColR.
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma]]]; auto.

*****
HSuma : SumA P' Q' R' P' Q' R' V W X
V,W,X : Tpoint
HDef'' : Defect A B'' C'' S' T' U'
S',T',U' : Tpoint
H17 : not (eq R' Q')
H13 : not (eq P' Q')
H14 : not (eq U T)
H9 : not (eq S T)
H18 : not (eq A D')
H16 : not (eq C' D')
H12 : not (eq B'' A)
H11 : not (eq C'' A)
H : not (eq B' D')
H10 : not (eq P R)
H6 : not (eq Q R)
H8 : not (eq P Q)
H7 : not (eq A C')
H3 : not (eq B' C')
H5 : not (eq A B')
HBet : Bet B'' D' C''
HOutC' : Out A C C''
HOutB' : Out A B B''
B'',C'' : Tpoint
HNCol' : not (Col A B' C')
HTS : TS B' C' A D'
HCong : Cong A C' B' D'
HConga : CongA A C' B' C' B' D'
HInangle : InAngle D' B A C
D' : Tpoint
HLea : LeA S T U P' Q' R'
HDef' : Defect A B' C' P' Q' R'
HOutC : Out A C C'
HOutB : Out A B B'
B',C' : Tpoint
HObtuse : not (SAMS P' Q' R' P' Q' R')
P',Q',R' : Tpoint
HGAE : GradAExp P Q R S T U
S,T,U : Tpoint
HNCol1 : not (Col P Q R)
HDef : Defect A B C P Q R
P,Q,R : Tpoint
H4 : not (eq B C)
H1 : not (eq A C)
H2 : not (eq B A)
legendre : forall (T : Tpoint) (_ : InAngle T B A C),\nex\n (fun X : Tpoint =>\n ex (fun Y : Tpoint => and (Out A B X) (and (Out A C Y) (Bet X T Y))))
HAcute : Acute B A C
HNCol : not (Col A B C)
B,A,C : Tpoint
archi : not hypothesis_of_obtuse_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P' Q' R' P' Q' R'
+++++
destruct (legendre_aux archi A B' C' D' B'' C'' P' Q' R' S' T' U' V W X); trivial; [apply l6_7 with B|apply l6_7 with C]; trivial; apply l6_6; trivial.
-----
Lemma legendre_s_fourth_theorem_aux : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_right_saccheri_quadrilaterals.
Proof.
intros archi legendre.
destruct legendre as [B [A [C [HNCol [HAcute legendre]]]]].
assert_diffs.
destruct (ex_defect A B C) as [P [Q [R HDef]]]; auto.
destruct (col_dec P Q R) as [HCol|HNCol1].
-
apply archi__obtuse_case_elimination in archi.
apply (defect_ncol_out__rah A B C P Q R); Col.
apply not_bet_out; Col.
intro HBet.
apply HNCol.
apply defect_perm_213 in HDef.
destruct HDef as [D [E [F [[G [H [I [HSuma1 HSuma2]]]] HSuppa]]]].
apply out_col, l6_6, out_lea__out with D E F.
apply (bet_suppa__out P Q R); [|apply suppa_sym]; assumption.
apply sams_suma__lea456789 with G H I; trivial.
apply (t22_20 archi); trivial.
-
destruct (archi__gradaexp_destruction archi P Q R HNCol1) as [S [T [U [HGAE HObtuse]]]].
apply archi__obtuse_case_elimination in archi.
apply not_col_permutation_4 in HNCol.
destruct (legendre_aux2 archi A B C HNCol HAcute legendre P Q R S T U HDef HGAE) as [B' [C' HInter]].
destruct HInter as [P' [Q' [R' [HOutB [HOutC [HDef' HLea]]]]]].
apply (obtuse_gea_obtuse P' Q' R'), obtuse__nsams in HObtuse; auto.
exfalso.
apply HObtuse.
destruct (legendre_aux1 A B C B' C') as [D' [HInangle [HConga [HCong HTS]]]]; trivial.
assert (HNCol' : ~ Col A B' C') by (destruct HTS; Col).
destruct (legendre D' HInangle) as [B'' [C'' [HOutB' [HOutC' HBet]]]].
assert_diffs.
destruct (ex_defect A B'' C'') as [S' [T' [U' HDef'']]]; auto.
intro; subst; apply HNCol; ColR.
destruct (ex_suma P' Q' R' P' Q' R') as [V [W [X HSuma]]]; auto.
destruct (legendre_aux archi A B' C' D' B'' C'' P' Q' R' S' T' U' V W X); trivial; [apply l6_7 with B|apply l6_7 with C]; trivial; apply l6_6; trivial.

*****

*****

+++++
Qed.
-----
Theorem legendre_s_fourth_theorem :\n  archimedes_axiom ->\n  legendre_s_parallel_postulate ->\n  postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights.
-----
Theorem legendre_s_fourth_theorem : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate), postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights
+++++
Proof.
-----
Theorem legendre_s_fourth_theorem : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate), postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights
+++++
assert (H:=legendre_s_fourth_theorem_aux).
-----
Theorem legendre_s_fourth_theorem : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights.
Proof.
assert (H:=legendre_s_fourth_theorem_aux).

*****
H : forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate),\npostulate_of_right_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate), postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights
+++++
assert (I:=rah__triangle).
-----
Theorem legendre_s_fourth_theorem : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights.
Proof.
assert (H:=legendre_s_fourth_theorem_aux).
assert (I:=rah__triangle).

*****
I : forall _ : postulate_of_right_saccheri_quadrilaterals,\ntriangle_postulate
H : forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate),\npostulate_of_right_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate), postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights
+++++
assert (J:=triangle__existential_triangle).
-----
Theorem legendre_s_fourth_theorem : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights.
Proof.
assert (H:=legendre_s_fourth_theorem_aux).
assert (I:=rah__triangle).
assert (J:=triangle__existential_triangle).

*****
J : forall _ : triangle_postulate,\npostulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights
I : forall _ : postulate_of_right_saccheri_quadrilaterals,\ntriangle_postulate
H : forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate),\npostulate_of_right_saccheri_quadrilaterals
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : archimedes_axiom) (_ : legendre_s_parallel_postulate), postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights
+++++
tauto.
-----
Theorem legendre_s_fourth_theorem : archimedes_axiom -> legendre_s_parallel_postulate -> postulate_of_existence_of_a_triangle_whose_angles_sum_to_two_rights.
Proof.
assert (H:=legendre_s_fourth_theorem_aux).
assert (I:=rah__triangle).
assert (J:=triangle__existential_triangle).
tauto.

*****

*****

+++++
Qed.
-----
End Legendre.
-----
