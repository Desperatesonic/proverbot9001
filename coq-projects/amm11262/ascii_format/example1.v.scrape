Require Import AMM11262.
-----
Import NatSet GeneralProperties.
-----
Section example_three_inhabitants.
-----
Definition town_1:= 1++ 2 ++ 3 ++ empty.
-----
Remark population_1 : cardinal town_1 = 2*1 +1.
-----
Remark population_1 : cardinal town_1 = 2*1 +1.

*****

*****
Logic.eq (cardinal town_1) (Nat.add (Nat.mul (S (S O)) (S O)) (S O))
+++++
Proof.
-----
Remark population_1 : cardinal town_1 = 2*1 +1.
Proof.

*****

*****
Logic.eq (cardinal town_1) (Nat.add (Nat.mul (S (S O)) (S O)) (S O))
+++++
reflexivity.
-----
Remark population_1 : cardinal town_1 = 2*1 +1.
Proof.
reflexivity.

*****

*****

+++++
Qed.
-----
Definition familiarity_1 (m n:elt):Prop := \n  match m,n with\n  | 1,2 => True\n  | 2,1 => True\n  | 2,3 => True\n  | 3,2 => True\n  | _,_ => False\n  end.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.

*****

*****
forall (m n : elt) (_ : familiarity_1 m n), familiarity_1 n m
+++++
Proof.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.

*****

*****
forall (m n : elt) (_ : familiarity_1 m n), familiarity_1 n m
+++++
intros [|[|[|[|m']]]] [|[|[|[|n']]]].
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 O O, familiarity_1 O O
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 O (S O), familiarity_1 (S O) O
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 O (S (S O)), familiarity_1 (S (S O)) O
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 O (S (S (S O))), familiarity_1 (S (S (S O))) O
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****
n' : nat
*****
forall _ : familiarity_1 O (S (S (S (S n')))), familiarity_1 (S (S (S (S n')))) O
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S O) O, familiarity_1 O (S O)
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S O) (S O), familiarity_1 (S O) (S O)
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S O) (S (S O)), familiarity_1 (S (S O)) (S O)
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S O) (S (S (S O))), familiarity_1 (S (S (S O))) (S O)
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****
n' : nat
*****
forall _ : familiarity_1 (S O) (S (S (S (S n')))), familiarity_1 (S (S (S (S n')))) (S O)
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S (S O)) O, familiarity_1 O (S (S O))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S (S O)) (S O), familiarity_1 (S O) (S (S O))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S (S O)) (S (S O)), familiarity_1 (S (S O)) (S (S O))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S (S O)) (S (S (S O))), familiarity_1 (S (S (S O))) (S (S O))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****
n' : nat
*****
forall _ : familiarity_1 (S (S O)) (S (S (S (S n')))), familiarity_1 (S (S (S (S n')))) (S (S O))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S (S (S O))) O, familiarity_1 O (S (S (S O)))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S (S (S O))) (S O), familiarity_1 (S O) (S (S (S O)))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S (S (S O))) (S (S O)), familiarity_1 (S (S O)) (S (S (S O)))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****
forall _ : familiarity_1 (S (S (S O))) (S (S (S O))), familiarity_1 (S (S (S O))) (S (S (S O)))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****
n' : nat
*****
forall _ : familiarity_1 (S (S (S O))) (S (S (S (S n')))), familiarity_1 (S (S (S (S n')))) (S (S (S O)))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****
m' : nat
*****
forall _ : familiarity_1 (S (S (S (S m')))) O, familiarity_1 O (S (S (S (S m'))))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****
m' : nat
*****
forall _ : familiarity_1 (S (S (S (S m')))) (S O), familiarity_1 (S O) (S (S (S (S m'))))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****
m' : nat
*****
forall _ : familiarity_1 (S (S (S (S m')))) (S (S O)), familiarity_1 (S (S O)) (S (S (S (S m'))))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****
m' : nat
*****
forall _ : familiarity_1 (S (S (S (S m')))) (S (S (S O))), familiarity_1 (S (S (S O))) (S (S (S (S m'))))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****
m',n' : nat
*****
forall _ : familiarity_1 (S (S (S (S m')))) (S (S (S (S n')))), familiarity_1 (S (S (S (S n')))) (S (S (S (S m'))))
+++++
trivial.
-----
Remark familiarity_1_sym:forall m n : elt, familiarity_1 m n -> familiarity_1 n m.
Proof.
intros [|[|[|[|m']]]] [|[|[|[|n']]]].

*****

*****

+++++
Qed.
-----
Remark familiarity_1_extensional:forall (m : elt) (n p : E.t), E.eq n p -> familiarity_1 m n -> familiarity_1 m p.
-----
Remark familiarity_1_extensional:forall (m : elt) (n p : E.t), E.eq n p -> familiarity_1 m n -> familiarity_1 m p.

*****

*****
forall (m : elt) (n p : E.t) (_ : E.eq n p) (_ : familiarity_1 m n), familiarity_1 m p
+++++
Proof.
-----
Remark familiarity_1_extensional:forall (m : elt) (n p : E.t), E.eq n p -> familiarity_1 m n -> familiarity_1 m p.
Proof.

*****

*****
forall (m : elt) (n p : E.t) (_ : E.eq n p) (_ : familiarity_1 m n), familiarity_1 m p
+++++
intros m n p H1 H2.
-----
Remark familiarity_1_extensional:forall (m : elt) (n p : E.t), E.eq n p -> familiarity_1 m n -> familiarity_1 m p.
Proof.
intros m n p H1 H2.

*****
H2 : familiarity_1 m n
H1 : E.eq n p
n,p : E\.t
m : elt
*****
familiarity_1 m p
+++++
compute in H1.
-----
Remark familiarity_1_extensional:forall (m : elt) (n p : E.t), E.eq n p -> familiarity_1 m n -> familiarity_1 m p.
Proof.
intros m n p H1 H2.
compute in H1.

*****
H2 : familiarity_1 m n
H1 : Logic.eq n p
n,p : E\.t
m : elt
*****
familiarity_1 m p
+++++
rewrite <- H1.
-----
Remark familiarity_1_extensional:forall (m : elt) (n p : E.t), E.eq n p -> familiarity_1 m n -> familiarity_1 m p.
Proof.
intros m n p H1 H2.
compute in H1.
rewrite <- H1.

*****
H2 : familiarity_1 m n
H1 : Logic.eq n p
n,p : E\.t
m : elt
*****
familiarity_1 m n
+++++
assumption.
-----
Remark familiarity_1_extensional:forall (m : elt) (n p : E.t), E.eq n p -> familiarity_1 m n -> familiarity_1 m p.
Proof.
intros m n p H1 H2.
compute in H1.
rewrite <- H1.
assumption.

*****

*****

+++++
Qed.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.

*****

*****
forall (B : t) (_ : Subset B town_1) (_ : Logic.eq (cardinal B) (S O)), sumor (sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))) (Equal B (add (S (S (S O))) empty))
+++++
Proof.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.

*****

*****
forall (B : t) (_ : Subset B town_1) (_ : Logic.eq (cardinal B) (S O)), sumor (sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))) (Equal B (add (S (S (S O))) empty))
+++++
intros B H_sub H_card.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.

*****
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sumor (sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))) (Equal B (add (S (S (S O))) empty))
+++++
destruct (In_dec 1 B) as [H1|H1].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].

*****
H1 : In (S O) B
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sumor (sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))) (Equal B (add (S (S (S O))) empty))
+++++
left.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
left.

*****
H1 : In (S O) B
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))
+++++
left.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
left.
left.

*****
H1 : In (S O) B
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal B (add (S O) empty)
+++++
rewrite <- (add_remove H1).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
left.
left.
rewrite <- (add_remove H1).

*****
H1 : In (S O) B
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal (add (S O) (remove (S O) B)) (add (S O) empty)
+++++
generalize (remove_cardinal_1 H1).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
left.
left.
rewrite <- (add_remove H1).
generalize (remove_cardinal_1 H1).

*****
H1 : In (S O) B
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : Logic.eq (S (cardinal (remove (S O) B))) (cardinal B), Equal (add (S O) (remove (S O) B)) (add (S O) empty)
+++++
rewrite H_card.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
left.
left.
rewrite <- (add_remove H1).
generalize (remove_cardinal_1 H1).
rewrite H_card.

*****
H1 : In (S O) B
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : Logic.eq (S (cardinal (remove (S O) B))) (S O), Equal (add (S O) (remove (S O) B)) (add (S O) empty)
+++++
intro H_eq.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
left.
left.
rewrite <- (add_remove H1).
generalize (remove_cardinal_1 H1).
rewrite H_card.
intro H_eq.

*****
H_eq : Logic.eq (S (cardinal (remove (S O) B))) (S O)
H1 : In (S O) B
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal (add (S O) (remove (S O) B)) (add (S O) empty)
+++++
rewrite (empty_is_empty_1 (cardinal_inv_1 (eq_add_S _ _ H_eq))).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
left.
left.
rewrite <- (add_remove H1).
generalize (remove_cardinal_1 H1).
rewrite H_card.
intro H_eq.
rewrite (empty_is_empty_1 (cardinal_inv_1 (eq_add_S _ _ H_eq))).

*****
H_eq : Logic.eq (S (cardinal (remove (S O) B))) (S O)
H1 : In (S O) B
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal (add (S O) empty) (add (S O) empty)
+++++
reflexivity.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].

*****
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sumor (sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))) (Equal B (add (S (S (S O))) empty))
+++++
destruct (In_dec 2 B) as [H2|H2].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].

*****
H2 : In (S (S O)) B
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sumor (sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))) (Equal B (add (S (S (S O))) empty))
+++++
left.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
left.

*****
H2 : In (S (S O)) B
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))
+++++
right.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
left.
right.

*****
H2 : In (S (S O)) B
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal B (add (S (S O)) empty)
+++++
rewrite <- (add_remove H2).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
left.
right.
rewrite <- (add_remove H2).

*****
H2 : In (S (S O)) B
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal (add (S (S O)) (remove (S (S O)) B)) (add (S (S O)) empty)
+++++
generalize (remove_cardinal_1 H2).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
left.
right.
rewrite <- (add_remove H2).
generalize (remove_cardinal_1 H2).

*****
H2 : In (S (S O)) B
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : Logic.eq (S (cardinal (remove (S (S O)) B))) (cardinal B), Equal (add (S (S O)) (remove (S (S O)) B)) (add (S (S O)) empty)
+++++
rewrite H_card.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
left.
right.
rewrite <- (add_remove H2).
generalize (remove_cardinal_1 H2).
rewrite H_card.

*****
H2 : In (S (S O)) B
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : Logic.eq (S (cardinal (remove (S (S O)) B))) (S O), Equal (add (S (S O)) (remove (S (S O)) B)) (add (S (S O)) empty)
+++++
intro H_eq.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
left.
right.
rewrite <- (add_remove H2).
generalize (remove_cardinal_1 H2).
rewrite H_card.
intro H_eq.

*****
H_eq : Logic.eq (S (cardinal (remove (S (S O)) B))) (S O)
H2 : In (S (S O)) B
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal (add (S (S O)) (remove (S (S O)) B)) (add (S (S O)) empty)
+++++
rewrite (empty_is_empty_1 (cardinal_inv_1 (eq_add_S _ _ H_eq))).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
left.
right.
rewrite <- (add_remove H2).
generalize (remove_cardinal_1 H2).
rewrite H_card.
intro H_eq.
rewrite (empty_is_empty_1 (cardinal_inv_1 (eq_add_S _ _ H_eq))).

*****
H_eq : Logic.eq (S (cardinal (remove (S (S O)) B))) (S O)
H2 : In (S (S O)) B
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal (add (S (S O)) empty) (add (S (S O)) empty)
+++++
reflexivity.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].

*****
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sumor (sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))) (Equal B (add (S (S (S O))) empty))
+++++
destruct (In_dec 3 B) as [H3|H3].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].

*****
H3 : In (S (S (S O))) B
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sumor (sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))) (Equal B (add (S (S (S O))) empty))
+++++
right.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
right.

*****
H3 : In (S (S (S O))) B
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal B (add (S (S (S O))) empty)
+++++
rewrite <- (add_remove H3).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
right.
rewrite <- (add_remove H3).

*****
H3 : In (S (S (S O))) B
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal (add (S (S (S O))) (remove (S (S (S O))) B)) (add (S (S (S O))) empty)
+++++
generalize (remove_cardinal_1 H3).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
right.
rewrite <- (add_remove H3).
generalize (remove_cardinal_1 H3).

*****
H3 : In (S (S (S O))) B
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : Logic.eq (S (cardinal (remove (S (S (S O))) B))) (cardinal B), Equal (add (S (S (S O))) (remove (S (S (S O))) B)) (add (S (S (S O))) empty)
+++++
rewrite H_card.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
right.
rewrite <- (add_remove H3).
generalize (remove_cardinal_1 H3).
rewrite H_card.

*****
H3 : In (S (S (S O))) B
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : Logic.eq (S (cardinal (remove (S (S (S O))) B))) (S O), Equal (add (S (S (S O))) (remove (S (S (S O))) B)) (add (S (S (S O))) empty)
+++++
intro H_eq.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
right.
rewrite <- (add_remove H3).
generalize (remove_cardinal_1 H3).
rewrite H_card.
intro H_eq.

*****
H_eq : Logic.eq (S (cardinal (remove (S (S (S O))) B))) (S O)
H3 : In (S (S (S O))) B
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal (add (S (S (S O))) (remove (S (S (S O))) B)) (add (S (S (S O))) empty)
+++++
rewrite (empty_is_empty_1 (cardinal_inv_1 (eq_add_S _ _ H_eq))).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
right.
rewrite <- (add_remove H3).
generalize (remove_cardinal_1 H3).
rewrite H_card.
intro H_eq.
rewrite (empty_is_empty_1 (cardinal_inv_1 (eq_add_S _ _ H_eq))).

*****
H_eq : Logic.eq (S (cardinal (remove (S (S (S O))) B))) (S O)
H3 : In (S (S (S O))) B
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Equal (add (S (S (S O))) empty) (add (S (S (S O))) empty)
+++++
reflexivity.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].

*****
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sumor (sumbool (Equal B (add (S O) empty)) (Equal B (add (S (S O)) empty))) (Equal B (add (S (S (S O))) empty))
+++++
apply False_rec.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.

*****
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
destruct (cardinal_inv_2 H_card) as [b Hb].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].

*****
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].

*****
Hb1 : Logic.eq b (S O)
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply H1.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
apply H1.

*****
Hb1 : Logic.eq b (S O)
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In (S O) B
+++++
rewrite <- Hb1.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
apply H1.
rewrite <- Hb1.

*****
Hb1 : Logic.eq b (S O)
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In b B
+++++
assumption.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].

*****
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].

*****
Hb2 : Logic.eq b (S (S O))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply H2.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
apply H2.

*****
Hb2 : Logic.eq b (S (S O))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In (S (S O)) B
+++++
rewrite <- Hb2.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
apply H2.
rewrite <- Hb2.

*****
Hb2 : Logic.eq b (S (S O))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In b B
+++++
assumption.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].

*****
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].

*****
Hb3 : Logic.eq b (S (S (S O)))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply H3.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
apply H3.

*****
Hb3 : Logic.eq b (S (S (S O)))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In (S (S (S O))) B
+++++
rewrite <- Hb3.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
apply H3.
rewrite <- Hb3.

*****
Hb3 : Logic.eq b (S (S (S O)))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In b B
+++++
assumption.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].

*****
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
assert (Hb_town:=H_sub _ Hb).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).

*****
Hb_town : In b town_1
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
unfold town_1 in Hb_town.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.

*****
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].

*****
Hb1_town : Logic.eq (S O) b
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply Hb1.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
apply Hb1.

*****
Hb1_town : Logic.eq (S O) b
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Logic.eq b (S O)
+++++
rewrite Hb1_town.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
apply Hb1.
rewrite Hb1_town.

*****
Hb1_town : Logic.eq (S O) b
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Logic.eq b b
+++++
reflexivity.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].

*****
Hb1_town : In b (add (S (S O)) (add (S (S (S O))) empty))
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
destruct (proj1 (FM.add_iff _ _ b) Hb1_town) as [Hb2_town|Hb2_town].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
destruct (proj1 (FM.add_iff _ _ b) Hb1_town) as [Hb2_town|Hb2_town].

*****
Hb2_town : Logic.eq (S (S O)) b
Hb1_town : In b (add (S (S O)) (add (S (S (S O))) empty))
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply Hb2.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
destruct (proj1 (FM.add_iff _ _ b) Hb1_town) as [Hb2_town|Hb2_town].
apply Hb2.

*****
Hb2_town : Logic.eq (S (S O)) b
Hb1_town : In b (add (S (S O)) (add (S (S (S O))) empty))
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Logic.eq b (S (S O))
+++++
rewrite Hb2_town.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
destruct (proj1 (FM.add_iff _ _ b) Hb1_town) as [Hb2_town|Hb2_town].
apply Hb2.
rewrite Hb2_town.

*****
Hb2_town : Logic.eq (S (S O)) b
Hb1_town : In b (add (S (S O)) (add (S (S (S O))) empty))
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Logic.eq b b
+++++
reflexivity.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
destruct (proj1 (FM.add_iff _ _ b) Hb1_town) as [Hb2_town|Hb2_town].

*****
Hb2_town : In b (add (S (S (S O))) empty)
Hb1_town : In b (add (S (S O)) (add (S (S (S O))) empty))
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
destruct (proj1 (FM.add_iff _ _ b) Hb2_town) as [Hb3_town|Hb3_town].
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
destruct (proj1 (FM.add_iff _ _ b) Hb1_town) as [Hb2_town|Hb2_town].
destruct (proj1 (FM.add_iff _ _ b) Hb2_town) as [Hb3_town|Hb3_town].

*****
Hb3_town : Logic.eq (S (S (S O))) b
Hb2_town : In b (add (S (S (S O))) empty)
Hb1_town : In b (add (S (S O)) (add (S (S (S O))) empty))
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply Hb3.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
destruct (proj1 (FM.add_iff _ _ b) Hb1_town) as [Hb2_town|Hb2_town].
destruct (proj1 (FM.add_iff _ _ b) Hb2_town) as [Hb3_town|Hb3_town].
apply Hb3.

*****
Hb3_town : Logic.eq (S (S (S O))) b
Hb2_town : In b (add (S (S (S O))) empty)
Hb1_town : In b (add (S (S O)) (add (S (S (S O))) empty))
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Logic.eq b (S (S (S O)))
+++++
rewrite Hb3_town.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
destruct (proj1 (FM.add_iff _ _ b) Hb1_town) as [Hb2_town|Hb2_town].
destruct (proj1 (FM.add_iff _ _ b) Hb2_town) as [Hb3_town|Hb3_town].
apply Hb3.
rewrite Hb3_town.

*****
Hb3_town : Logic.eq (S (S (S O))) b
Hb2_town : In b (add (S (S (S O))) empty)
Hb1_town : In b (add (S (S O)) (add (S (S (S O))) empty))
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Logic.eq b b
+++++
reflexivity.
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].
destruct (In_dec 2 B) as [H2|H2].
destruct (In_dec 3 B) as [H3|H3].
apply False_rec.
destruct (cardinal_inv_2 H_card) as [b Hb].
destruct (NatSet.E.eq_dec b 1) as [Hb1|Hb1].
destruct (NatSet.E.eq_dec b 2) as [Hb2|Hb2].
destruct (NatSet.E.eq_dec b 3) as [Hb3|Hb3].
assert (Hb_town:=H_sub _ Hb).
unfold town_1 in Hb_town.
destruct (proj1 (FM.add_iff _ _ b) Hb_town) as [Hb1_town|Hb1_town].
destruct (proj1 (FM.add_iff _ _ b) Hb1_town) as [Hb2_town|Hb2_town].
destruct (proj1 (FM.add_iff _ _ b) Hb2_town) as [Hb3_town|Hb3_town].

*****
Hb3_town : In b empty
Hb2_town : In b (add (S (S (S O))) empty)
Hb1_town : In b (add (S (S O)) (add (S (S (S O))) empty))
Hb_town : In b (add (S O) (add (S (S O)) (add (S (S (S O))) empty)))
Hb3 : not (Logic.eq b (S (S (S O))))
Hb2 : not (Logic.eq b (S (S O)))
Hb1 : not (Logic.eq b (S O))
Hb : In b B
b : elt
H3 : not (In (S (S (S O))) B)
H2 : not (In (S (S O)) B)
H1 : not (In (S O) B)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply (proj1 (FM.empty_iff b) Hb3_town).
-----
Remark subsets_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {B [=] 1++empty}+{B[=]2++empty}+{B[=]3++empty}.
Proof.
intros B H_sub H_card.
destruct (In_dec 1 B) as [H1|H1].

*****

*****

+++++
Qed.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> \n          {d : elt |In d (diff town_1 B) /\ (forall b : elt, In b B -> familiarity_1 d b)}.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.

*****

*****
forall (B : t) (_ : Subset B town_1) (_ : Logic.eq (cardinal B) (S O)), sig (fun d : elt => and (In d (diff town_1 B)) (forall (b : elt) (_ : In b B), familiarity_1 d b))
+++++
Proof.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.

*****

*****
forall (B : t) (_ : Subset B town_1) (_ : Logic.eq (cardinal B) (S O)), sig (fun d : elt => and (In d (diff town_1 B)) (forall (b : elt) (_ : In b B), familiarity_1 d b))
+++++
intros B H_sub H_card.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.

*****
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sig (fun d : elt => and (In d (diff town_1 B)) (forall (b : elt) (_ : In b B), familiarity_1 d b))
+++++
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].

*****
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sig (fun d : elt => and (In d (diff town_1 B)) (forall (b : elt) (_ : In b B), familiarity_1 d b))
+++++
exists 2.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.

*****
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
and (In (S (S O)) (diff town_1 B)) (forall (b : elt) (_ : In b B), familiarity_1 (S (S O)) b)
+++++
split.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.

*****
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In (S (S O)) (diff town_1 B)
+++++
rewrite HB1.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
rewrite HB1.

*****
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In (S (S O)) (diff town_1 (add (S O) empty))
+++++
apply mem_2.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
rewrite HB1.
apply mem_2.

*****
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Logic.eq (mem (S (S O)) (diff town_1 (add (S O) empty))) true
+++++
trivial.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.

*****
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall (b : elt) (_ : In b B), familiarity_1 (S (S O)) b
+++++
intro b.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.

*****
b : elt
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : In b B, familiarity_1 (S (S O)) b
+++++
rewrite HB1.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB1.

*****
b : elt
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : In b (add (S O) empty), familiarity_1 (S (S O)) b
+++++
intro Hb.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB1.
intro Hb.

*****
Hb : In b (add (S O) empty)
b : elt
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) b
+++++
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB1.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].

*****
H : Logic.eq (S O) b
Hb : In b (add (S O) empty)
b : elt
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) b
+++++
compute in H.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB1.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
compute in H.

*****
H : Logic.eq (S O) b
Hb : In b (add (S O) empty)
b : elt
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) b
+++++
rewrite <- H.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB1.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
compute in H.
rewrite <- H.

*****
H : Logic.eq (S O) b
Hb : In b (add (S O) empty)
b : elt
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) (S O)
+++++
simpl.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB1.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
compute in H.
rewrite <- H.
simpl.

*****
H : Logic.eq (S O) b
Hb : In b (add (S O) empty)
b : elt
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
True
+++++
trivial.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB1.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].

*****
H : In b empty
Hb : In b (add (S O) empty)
b : elt
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) b
+++++
apply False_ind.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB1.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
apply False_ind.

*****
H : In b empty
Hb : In b (add (S O) empty)
b : elt
HB1 : Equal B (add (S O) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply (proj1 (FM.empty_iff b) H).
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].

*****
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sig (fun d : elt => and (In d (diff town_1 B)) (forall (b : elt) (_ : In b B), familiarity_1 d b))
+++++
exists 1.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.

*****
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
and (In (S O) (diff town_1 B)) (forall (b : elt) (_ : In b B), familiarity_1 (S O) b)
+++++
split.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.

*****
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In (S O) (diff town_1 B)
+++++
rewrite HB2.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
rewrite HB2.

*****
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In (S O) (diff town_1 (add (S (S O)) empty))
+++++
apply mem_2.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
rewrite HB2.
apply mem_2.

*****
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Logic.eq (mem (S O) (diff town_1 (add (S (S O)) empty))) true
+++++
trivial.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.

*****
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall (b : elt) (_ : In b B), familiarity_1 (S O) b
+++++
intro b.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
intro b.

*****
b : elt
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : In b B, familiarity_1 (S O) b
+++++
rewrite HB2.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
intro b.
rewrite HB2.

*****
b : elt
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : In b (add (S (S O)) empty), familiarity_1 (S O) b
+++++
intro Hb.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
intro b.
rewrite HB2.
intro Hb.

*****
Hb : In b (add (S (S O)) empty)
b : elt
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S O) b
+++++
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
intro b.
rewrite HB2.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].

*****
H : Logic.eq (S (S O)) b
Hb : In b (add (S (S O)) empty)
b : elt
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S O) b
+++++
compute in H.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
intro b.
rewrite HB2.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
compute in H.

*****
H : Logic.eq (S (S O)) b
Hb : In b (add (S (S O)) empty)
b : elt
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S O) b
+++++
rewrite <- H.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
intro b.
rewrite HB2.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
compute in H.
rewrite <- H.

*****
H : Logic.eq (S (S O)) b
Hb : In b (add (S (S O)) empty)
b : elt
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S O) (S (S O))
+++++
simpl.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
intro b.
rewrite HB2.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
compute in H.
rewrite <- H.
simpl.

*****
H : Logic.eq (S (S O)) b
Hb : In b (add (S (S O)) empty)
b : elt
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
True
+++++
trivial.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
intro b.
rewrite HB2.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].

*****
H : In b empty
Hb : In b (add (S (S O)) empty)
b : elt
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S O) b
+++++
apply False_ind.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 1.
split.
intro b.
rewrite HB2.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
apply False_ind.

*****
H : In b empty
Hb : In b (add (S (S O)) empty)
b : elt
HB2 : Equal B (add (S (S O)) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply (proj1 (FM.empty_iff b) H).
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].

*****
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
sig (fun d : elt => and (In d (diff town_1 B)) (forall (b : elt) (_ : In b B), familiarity_1 d b))
+++++
exists 2.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.

*****
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
and (In (S (S O)) (diff town_1 B)) (forall (b : elt) (_ : In b B), familiarity_1 (S (S O)) b)
+++++
split.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.

*****
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In (S (S O)) (diff town_1 B)
+++++
rewrite HB3.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
rewrite HB3.

*****
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
In (S (S O)) (diff town_1 (add (S (S (S O))) empty))
+++++
apply mem_2.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
rewrite HB3.
apply mem_2.

*****
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
Logic.eq (mem (S (S O)) (diff town_1 (add (S (S (S O))) empty))) true
+++++
trivial.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.

*****
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall (b : elt) (_ : In b B), familiarity_1 (S (S O)) b
+++++
intro b.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.

*****
b : elt
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : In b B, familiarity_1 (S (S O)) b
+++++
rewrite HB3.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB3.

*****
b : elt
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
forall _ : In b (add (S (S (S O))) empty), familiarity_1 (S (S O)) b
+++++
intro Hb.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB3.
intro Hb.

*****
Hb : In b (add (S (S (S O))) empty)
b : elt
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) b
+++++
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB3.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].

*****
H : Logic.eq (S (S (S O))) b
Hb : In b (add (S (S (S O))) empty)
b : elt
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) b
+++++
compute in H.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB3.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
compute in H.

*****
H : Logic.eq (S (S (S O))) b
Hb : In b (add (S (S (S O))) empty)
b : elt
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) b
+++++
rewrite <- H.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB3.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
compute in H.
rewrite <- H.

*****
H : Logic.eq (S (S (S O))) b
Hb : In b (add (S (S (S O))) empty)
b : elt
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) (S (S (S O)))
+++++
simpl.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB3.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
compute in H.
rewrite <- H.
simpl.

*****
H : Logic.eq (S (S (S O))) b
Hb : In b (add (S (S (S O))) empty)
b : elt
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
True
+++++
trivial.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB3.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].

*****
H : In b empty
Hb : In b (add (S (S (S O))) empty)
b : elt
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
familiarity_1 (S (S O)) b
+++++
apply False_ind.
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].
exists 2.
split.
intro b.
rewrite HB3.
intro Hb.
destruct (proj1 (FM.add_iff _ _ b) Hb) as [H|H].
apply False_ind.

*****
H : In b empty
Hb : In b (add (S (S (S O))) empty)
b : elt
HB3 : Equal B (add (S (S (S O))) empty)
H_card : Logic.eq (cardinal B) (S O)
H_sub : Subset B town_1
B : True
*****
False
+++++
apply (proj1 (FM.empty_iff b) H).
-----
Remark acquintance_1: forall B : t, Subset B town_1 -> cardinal B = 1 -> {d : elt |In d (diff town_1 B) /\\ (forall b : elt, In b B -> familiarity_1 d b)}.
Proof.
intros B H_sub H_card.
destruct (subsets_1 B H_sub H_card) as [[HB1|HB2]|HB3].

*****

*****

+++++
Defined.
-----
Check (AMM11262 town_1 1 population_1 familiarity_1 familiarity_1_sym familiarity_1_extensional acquintance_1).
-----
Definition social_citizen_1:=AMM11262 town_1 1 population_1 familiarity_1 \n                                      familiarity_1_sym familiarity_1_extensional acquintance_1.
-----
End example_three_inhabitants.
-----
Extraction "social1" social_citizen_1.
-----
