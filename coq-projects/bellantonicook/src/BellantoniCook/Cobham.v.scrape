From Coq Require Import Bool.
-----
From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.MultiPoly.
-----
Inductive Cobham : Type :=\n| Zero : Cobham\n| Proj : nat -> nat -> Cobham\n| Succ : bool -> Cobham\n| Smash : Cobham\n| Rec  : Cobham -> Cobham -> Cobham -> Cobham -> Cobham\n| Comp : nat -> Cobham -> list Cobham -> Cobham.
-----
Definition Rec2 g h j := Rec g h h j.
-----
Lemma Cobham_ind2' :\n  forall P : Cobham -> Prop,\n  forall Q : list Cobham -> Prop,\n  Q nil ->\n  (forall e l, P e -> Q l -> Q (e :: l)) ->\n  P Zero ->\n  (forall n i, P (Proj n i)) ->\n  (forall b, P (Succ b)) ->\n  P Smash ->\n  (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) ->\n  (forall n h l, P h -> Q l -> P (Comp n h l)) ->\n  forall e, P e.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.

*****

*****
forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop) (_ : Q nil) (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i)) (_ : forall b : bool, P (Succ b)) (_ : P Smash) (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)) (_ : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), P e
+++++
Proof.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.

*****

*****
forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop) (_ : Q nil) (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i)) (_ : forall b : bool, P (Succ b)) (_ : P Smash) (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)) (_ : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), P e
+++++
fix Cobham_ind2' 11.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.

*****
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop) (_ : Q nil) (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i)) (_ : forall b : bool, P (Succ b)) (_ : P Smash) (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)) (_ : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), P e
+++++
intros.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.

*****
e : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P e
+++++
destruct e.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.

*****
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Zero
+++++
auto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.

*****
n,n0 : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P (Proj n n0)
+++++
auto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.

*****
b : bool
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P (Succ b)
+++++
auto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.

*****
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Smash
+++++
auto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P (Rec e1 e2 e3 e4)
+++++
auto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P (Rec e1 e2 e3 e4)
+++++
apply H5.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P e1
+++++
eapply Cobham_ind2'.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
?Q nil
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Zero
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall n i : nat, P (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall b : bool, P (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Smash
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l), P (Comp n h l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P e2
+++++
eapply Cobham_ind2'.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
?Q nil
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Zero
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall n i : nat, P (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall b : bool, P (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Smash
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l), P (Comp n h l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P e3
+++++
eapply Cobham_ind2'.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
?Q nil
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Zero
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall n i : nat, P (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall b : bool, P (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Smash
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l), P (Comp n h l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P e4
+++++
eapply Cobham_ind2'.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
?Q nil
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Zero
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall n i : nat, P (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall b : bool, P (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Smash
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H5.
eapply Cobham_ind2'.

*****
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l), P (Comp n h l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P (Comp n e l)
+++++
auto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P (Comp n e l)
+++++
apply H6.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P e
+++++
eapply Cobham_ind2'.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
eapply Cobham_ind2'.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
?Q nil
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
eapply Cobham_ind2'.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
eapply Cobham_ind2'.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Zero
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
eapply Cobham_ind2'.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall n i : nat, P (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
eapply Cobham_ind2'.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall b : bool, P (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
eapply Cobham_ind2'.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Smash
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
eapply Cobham_ind2'.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
eapply Cobham_ind2'.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l), P (Comp n h l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.

*****
l : list Cobham
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
Q l
+++++
revert l.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.

*****
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall l : list Cobham, Q l
+++++
fix Cobham_ind2'0 1.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.

*****
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall l : list Cobham, Q l
+++++
intro.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.

*****
l : list Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
Q l
+++++
destruct l.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.

*****
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
Q nil
+++++
apply H.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
Q (cons c l)
+++++
apply H0.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P c
+++++
eapply Cobham_ind2'.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.
eapply Cobham_ind2'.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
?Q nil
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.
eapply Cobham_ind2'.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.
eapply Cobham_ind2'.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Zero
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.
eapply Cobham_ind2'.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall n i : nat, P (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.
eapply Cobham_ind2'.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall b : bool, P (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.
eapply Cobham_ind2'.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
P Smash
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.
eapply Cobham_ind2'.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.
eapply Cobham_ind2'.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l), P (Comp n h l)
+++++
eauto.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.
auto.
apply H6.
revert l.
fix Cobham_ind2'0 1.
intro.
destruct l.
apply H0.

*****
l : list Cobham
c : Cobham
Cobham_ind2'0 : forall l : list Cobham, Q l
e : Cobham
n : nat
H6 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : Q l),\nP (Comp n h l)
H5 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H4 : P Smash
H3 : forall b : bool, P (Succ b)
H2 : forall n i : nat, P (Proj n i)
H1 : P Zero
H0 : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list Cobham, Prop
P : forall _ : Cobham, Prop
Cobham_ind2' : forall (P : forall _ : Cobham, Prop) (Q : forall _ : list Cobham, Prop)\n (_ : Q nil)\n (_ : forall (e : Cobham) (l : list Cobham) (_ : P e) (_ : Q l),\n Q (cons e l)) (_ : P Zero) (_ : forall n i : nat, P (Proj n i))\n (_ : forall b : bool, P (Succ b)) (_ : P Smash)\n (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) \n (_ : P h0) (_ : P h1), P (Rec j g h0 h1))\n (_ : forall (n : nat) (h : Cobham) (l : list Cobham) \n (_ : P h) (_ : Q l), P (Comp n h l)) (e : Cobham), \nP e
*****
Q l
+++++
apply Cobham_ind2'0.
-----
Lemma Cobham_ind2' : forall P : Cobham -> Prop, forall Q : list Cobham -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> Q l -> P (Comp n h l)) -> forall e, P e.
Proof.
fix Cobham_ind2' 11.
intros.
destruct e.

*****

*****

+++++
Qed.
-----
Lemma Cobham_ind2 :\n  forall P : Cobham -> Prop,\n  P Zero ->\n  (forall n i, P (Proj n i)) ->\n  (forall b, P (Succ b)) ->\n  P Smash ->\n  (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) ->\n  (forall n h l, P h -> (forall e, In e l -> P e) ->\n    P (Comp n h l)) ->\n  forall e, P e.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.

*****

*****
forall (P : forall _ : Cobham, Prop) (_ : P Zero) (_ : forall n i : nat, P (Proj n i)) (_ : forall b : bool, P (Succ b)) (_ : P Smash) (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)) (_ : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)) (e : Cobham), P e
+++++
Proof.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.

*****

*****
forall (P : forall _ : Cobham, Prop) (_ : P Zero) (_ : forall n i : nat, P (Proj n i)) (_ : forall b : bool, P (Succ b)) (_ : P Smash) (_ : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1), P (Rec j g h0 h1)) (_ : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h) (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)) (e : Cobham), P e
+++++
intros.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.

*****
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P e
+++++
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
forall (e : Cobham) (_ : In e nil), P e
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.

*****
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
forall (e : Cobham) (_ : In e nil), P e
+++++
simpl.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.
simpl.

*****
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
forall (e : Cobham) (_ : False), P e
+++++
intros.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.
simpl.
intros.

*****
H5 : False
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P e
+++++
tauto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e
l : list Cobham
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
forall (e0 : Cobham) (_ : In e0 (cons e l)), P e0
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.

*****
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e
l : list Cobham
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
forall (e0 : Cobham) (_ : In e0 (cons e l)), P e0
+++++
simpl.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.
simpl.

*****
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e
l : list Cobham
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
forall (e0 : Cobham) (_ : or (eq e e0) (In e0 l)), P e0
+++++
intros e' [ | ].
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.
simpl.
intros e' [ | ].

*****
H5 : eq e e'
e' : Cobham
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e
l : list Cobham
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P e'
+++++
intros.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.
simpl.
intros e' [ | ].
intros.

*****
H5 : eq e e'
e' : Cobham
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e
l : list Cobham
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P e'
+++++
subst.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.
simpl.
intros e' [ | ].
intros.
subst.

*****
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e'
e' : Cobham
l : list Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P e'
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.
simpl.
intros e' [ | ].

*****
H5 : In e' l
e' : Cobham
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e
l : list Cobham
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P e'
+++++
intros.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.
simpl.
intros e' [ | ].
intros.

*****
H5 : In e' l
e' : Cobham
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e
l : list Cobham
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P e'
+++++
subst.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).
auto.
simpl.
intros e' [ | ].
intros.
subst.

*****
H5 : In e' l
e' : Cobham
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e
l : list Cobham
e : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P e'
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P Zero
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
n,i : nat
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P (Proj n i)
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
b : bool
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P (Succ b)
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P Smash
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
IHe4 : P e4
IHe3 : P e3
IHe2 : P e2
IHe1 : P e1
e1,e2,e3,e4 : Cobham
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P (Rec e1 e2 e3 e4)
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
IHe0 : forall (e : Cobham) (_ : In e l), P e
IHe : P e
l : list Cobham
e : Cobham
n : nat
H4 : forall (n : nat) (h : Cobham) (l : list Cobham) (_ : P h)\n (_ : forall (e : Cobham) (_ : In e l), P e), P (Comp n h l)
H3 : forall (j g h0 h1 : Cobham) (_ : P j) (_ : P g) (_ : P h0) (_ : P h1),\nP (Rec j g h0 h1)
H2 : P Smash
H1 : forall b : bool, P (Succ b)
H0 : forall n i : nat, P (Proj n i)
H : P Zero
P : forall _ : Cobham, Prop
*****
P (Comp n e l)
+++++
auto.
-----
Lemma Cobham_ind2 : forall P : Cobham -> Prop, P Zero -> (forall n i, P (Proj n i)) -> (forall b, P (Succ b)) -> P Smash -> (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) -> (forall n h l, P h -> (forall e, In e l -> P e) -> P (Comp n h l)) -> forall e, P e.
Proof.
intros.
induction e using Cobham_ind2' with (Q := fun l => forall e, In e l -> P e).

*****

*****

+++++
Qed.
-----
Inductive Arity : Set :=\n| error_Rec : Arity -> Arity -> Arity -> Arity -> Arity\n| error_Comp : Arity -> list Arity -> Arity\n| error_Proj : nat -> nat -> Arity\n| ok_arity : nat -> Arity.
-----
Definition arity_eq (a1 a2 : Arity) :=\n  match a1, a2 with\n    | ok_arity n1, ok_arity n2 => beq_nat n1 n2\n    | _, _ => false\n  end.
-----
Lemma arity_eq_true x1 x2 :\n  arity_eq x1 x2 = true -> x1 = x2.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.

*****
x1,x2 : Arity
*****
forall _ : eq (arity_eq x1 x2) true, eq x1 x2
+++++
Proof.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.

*****
x1,x2 : Arity
*****
forall _ : eq (arity_eq x1 x2) true, eq x1 x2
+++++
intros.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.

*****
H : eq (arity_eq x1 x2) true
x1,x2 : Arity
*****
eq x1 x2
+++++
unfold arity_eq in H.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.

*****
H : eq\n match x1 with\n | ok_arity n1 =>\n match x2 with\n | ok_arity n2 => Nat.eqb n1 n2\n | _ => false\n end\n | _ => false\n end true
x1,x2 : Arity
*****
eq x1 x2
+++++
destruct x1.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.

*****
H : eq false true
x1_1,x1_2,x1_3,x1_4,x2 : Arity
*****
eq (error_Rec x1_1 x1_2 x1_3 x1_4) x2
+++++
try discriminate.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.

*****
H : eq false true
x2 : Arity
l : list Arity
x1 : Arity
*****
eq (error_Comp x1 l) x2
+++++
try discriminate.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.

*****
H : eq false true
x2 : Arity
n,n0 : nat
*****
eq (error_Proj n n0) x2
+++++
try discriminate.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.

*****
H : eq match x2 with\n | ok_arity n2 => Nat.eqb n n2\n | _ => false\n end true
x2 : Arity
n : nat
*****
eq (ok_arity n) x2
+++++
try discriminate.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.
try discriminate.

*****
H : eq match x2 with\n | ok_arity n2 => Nat.eqb n n2\n | _ => false\n end true
x2 : Arity
n : nat
*****
eq (ok_arity n) x2
+++++
destruct x2.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.
try discriminate.
destruct x2.

*****
H : eq false true
x2_1,x2_2,x2_3,x2_4 : Arity
n : nat
*****
eq (ok_arity n) (error_Rec x2_1 x2_2 x2_3 x2_4)
+++++
try discriminate.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.
try discriminate.
destruct x2.

*****
H : eq false true
l : list Arity
x2 : Arity
n : nat
*****
eq (ok_arity n) (error_Comp x2 l)
+++++
try discriminate.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.
try discriminate.
destruct x2.

*****
H : eq false true
n,n0,n1 : nat
*****
eq (ok_arity n) (error_Proj n0 n1)
+++++
try discriminate.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.
try discriminate.
destruct x2.

*****
H : eq (Nat.eqb n n0) true
n,n0 : nat
*****
eq (ok_arity n) (ok_arity n0)
+++++
try discriminate.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.
try discriminate.
destruct x2.
try discriminate.

*****
H : eq (Nat.eqb n n0) true
n,n0 : nat
*****
eq (ok_arity n) (ok_arity n0)
+++++
apply beq_nat_true in H.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.
try discriminate.
destruct x2.
try discriminate.
apply beq_nat_true in H.

*****
H : eq n n0
n,n0 : nat
*****
eq (ok_arity n) (ok_arity n0)
+++++
subst.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.
try discriminate.
destruct x2.
try discriminate.
apply beq_nat_true in H.
subst.

*****
n0 : nat
*****
eq (ok_arity n0) (ok_arity n0)
+++++
trivial.
-----
Lemma arity_eq_true x1 x2 : arity_eq x1 x2 = true -> x1 = x2.
Proof.
intros.
unfold arity_eq in H.
destruct x1.

*****

*****

+++++
Qed.
-----
Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.
-----
Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.

*****

*****
forall n : nat, eq (arity_eq (ok_arity n) (ok_arity n)) true
+++++
Proof.
-----
Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.
Proof.

*****

*****
forall n : nat, eq (arity_eq (ok_arity n) (ok_arity n)) true
+++++
intros.
-----
Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.
Proof.
intros.

*****
n : nat
*****
eq (arity_eq (ok_arity n) (ok_arity n)) true
+++++
case (ok_arity n).
-----
Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.
Proof.
intros.
case (ok_arity n).

*****
n : nat
*****
forall n : nat, eq (arity_eq (ok_arity n) (ok_arity n)) true
+++++
simpl.
-----
Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.
Proof.
intros.
case (ok_arity n).
simpl.

*****
n : nat
*****
forall n : nat, eq (Nat.eqb n n) true
+++++
intros.
-----
Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.
Proof.
intros.
case (ok_arity n).
simpl.
intros.

*****
n,n0 : nat
*****
eq (Nat.eqb n0 n0) true
+++++
rewrite beq_nat_true_iff.
-----
Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.
Proof.
intros.
case (ok_arity n).
simpl.
intros.
rewrite beq_nat_true_iff.

*****
n,n0 : nat
*****
eq n0 n0
+++++
trivial.
-----
Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.
Proof.
intros.
case (ok_arity n).
simpl.
intros.
rewrite beq_nat_true_iff.
trivial.

*****

*****

+++++
Qed.
-----
Fixpoint arity (e : Cobham) : Arity :=\n  match e with\n    | Zero => ok_arity 0\n    | Proj n j => if leb (S j) n \n      then ok_arity n else error_Proj n j \n    | Succ _ => ok_arity 1\n    | Smash => ok_arity 2\n    | Rec g h0 h1 j => \n      match arity g, arity h0, arity h1, arity j with\n        | ok_arity gn, ok_arity h0n, ok_arity h1n, ok_arity jn =>\n          if beq_nat (S (S gn)) h0n && \n             beq_nat h1n h0n &&\n             beq_nat (S jn) h1n \n            then ok_arity jn \n            else error_Rec (ok_arity gn) (ok_arity h0n) \n              (ok_arity h1n) (ok_arity jn)\n        | ag, ah0, ah1, aj => error_Rec ag ah0 ah1 aj \n      end\n    | Comp n h l => \n      match arity h, map arity l with\n        | ok_arity nh, al => \n          if beq_nat nh (length l) &&\n            forallb (fun e => arity_eq e (ok_arity n)) al then\n              ok_arity n else error_Comp (ok_arity nh) al\n        | e , le => error_Comp e le \n      end\n  end.
-----
Lemma Cobham_ind_inf' :\n  forall (P : nat -> Cobham -> Prop),\n  forall Q : nat -> list Cobham -> Prop,\n  (forall n, Q n nil) ->\n  (forall e n l, P n e -> Q n l -> Q n (e :: l)) ->\n  P 0 Zero ->\n  (forall n i, i < n  ->  P n (Proj n i)) ->\n  (forall b, P 1 (Succ b)) ->\n  (P 2 Smash) ->\n  (forall n g h0 h1 j, \n    arity g = ok_arity n ->\n    arity h0 = ok_arity (S (S n)) ->\n    arity h1 = ok_arity (S (S n)) ->\n    arity j = ok_arity (S n) ->\n    P n g -> \n    P (S (S n)) h0 -> \n    P (S (S n)) h1 -> \n    P (S n) j -> \n    P (S n) (Rec g h0 h1 j)) ->\n  (forall n h rl, \n    arity h = ok_arity (length rl)  ->\n    (forall e, In e rl -> arity e = ok_arity n) ->\n    P (length rl)  h -> \n    Q n rl ->\n    P n (Comp n h rl)) ->\n  forall e n , arity e = ok_arity n -> P n e.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.

*****

*****
forall (P : forall (_ : nat) (_ : Cobham), Prop) (Q : forall (_ : nat) (_ : list Cobham), Prop) (_ : forall n : nat, Q n nil) (_ : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l), Q n (cons e l)) (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i)) (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash) (_ : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)) (_ : forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
+++++
Proof.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.

*****

*****
forall (P : forall (_ : nat) (_ : Cobham), Prop) (Q : forall (_ : nat) (_ : list Cobham), Prop) (_ : forall n : nat, Q n nil) (_ : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l), Q n (cons e l)) (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i)) (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash) (_ : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)) (_ : forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
+++++
fix Cobham_ind_inf' 11.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.

*****
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (P : forall (_ : nat) (_ : Cobham), Prop) (Q : forall (_ : nat) (_ : list Cobham), Prop) (_ : forall n : nat, Q n nil) (_ : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l), Q n (cons e l)) (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i)) (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash) (_ : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)) (_ : forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.

*****
H7 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n e
+++++
destruct e.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.

*****
H7 : eq (arity Zero) (ok_arity n)
n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n Zero
+++++
simpl in *.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.

*****
H7 : eq (ok_arity O) (ok_arity n)
n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n Zero
+++++
injection H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
injection H7.

*****
H7 : eq (ok_arity O) (ok_arity n)
n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq O n, P n Zero
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
injection H7.
intros.

*****
H8 : eq O n
H7 : eq (ok_arity O) (ok_arity n)
n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n Zero
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
injection H7.
intros.
subst.

*****
H7 : eq (ok_arity O) (ok_arity O)
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P O Zero
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.

*****
H7 : eq (arity (Proj n0 n1)) (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj n0 n1)
+++++
simpl in *.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.

*****
H7 : eq\n (if match n0 with\n | O => false\n | S m' => Nat.leb n1 m'\n end\n then ok_arity n0\n else error_Proj n0 n1) (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj n0 n1)
+++++
destruct n0.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.

*****
H7 : eq (error_Proj O n1) (ok_arity n)
n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj O n1)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.

*****
H7 : eq (if Nat.leb n1 n0 then ok_arity (S n0) else error_Proj (S n0) n1)\n (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj (S n0) n1)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.

*****
H7 : eq (if Nat.leb n1 n0 then ok_arity (S n0) else error_Proj (S n0) n1)\n (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj (S n0) n1)
+++++
case_eq (leb n1 n0).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).

*****
H7 : eq (if Nat.leb n1 n0 then ok_arity (S n0) else error_Proj (S n0) n1)\n (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.leb n1 n0) true, P n (Proj (S n0) n1)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.

*****
H8 : eq (Nat.leb n1 n0) true
H7 : eq (if Nat.leb n1 n0 then ok_arity (S n0) else error_Proj (S n0) n1)\n (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj (S n0) n1)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.
rewrite H8 in H7.

*****
H8 : eq (Nat.leb n1 n0) true
H7 : eq (ok_arity (S n0)) (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj (S n0) n1)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.
rewrite H8 in H7.
try discriminate.

*****
H8 : eq (Nat.leb n1 n0) true
H7 : eq (ok_arity (S n0)) (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj (S n0) n1)
+++++
injection H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.
rewrite H8 in H7.
try discriminate.
injection H7.

*****
H8 : eq (Nat.leb n1 n0) true
H7 : eq (ok_arity (S n0)) (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (S n0) n, P n (Proj (S n0) n1)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.
rewrite H8 in H7.
try discriminate.
injection H7.
intros.

*****
H9 : eq (S n0) n
H8 : eq (Nat.leb n1 n0) true
H7 : eq (ok_arity (S n0)) (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj (S n0) n1)
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.
rewrite H8 in H7.
try discriminate.
injection H7.
intros.
subst.

*****
H8 : eq (Nat.leb n1 n0) true
H7 : eq (ok_arity (S n0)) (ok_arity (S n0))
n0,n1 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S n0) (Proj (S n0) n1)
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.
rewrite H8 in H7.
try discriminate.
injection H7.
intros.
subst.
auto.

*****
H8 : eq (Nat.leb n1 n0) true
H7 : eq (ok_arity (S n0)) (ok_arity (S n0))
n0,n1 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S n0) (Proj (S n0) n1)
+++++
apply H2.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.
rewrite H8 in H7.
try discriminate.
injection H7.
intros.
subst.
auto.
apply H2.

*****
H8 : eq (Nat.leb n1 n0) true
H7 : eq (ok_arity (S n0)) (ok_arity (S n0))
n0,n1 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
lt n1 (S n0)
+++++
apply leb_complete in H8.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.
rewrite H8 in H7.
try discriminate.
injection H7.
intros.
subst.
auto.
apply H2.
apply leb_complete in H8.

*****
H8 : le n1 n0
H7 : eq (ok_arity (S n0)) (ok_arity (S n0))
n0,n1 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
lt n1 (S n0)
+++++
omega.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).

*****
H7 : eq (if Nat.leb n1 n0 then ok_arity (S n0) else error_Proj (S n0) n1)\n (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.leb n1 n0) false, P n (Proj (S n0) n1)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.

*****
H8 : eq (Nat.leb n1 n0) false
H7 : eq (if Nat.leb n1 n0 then ok_arity (S n0) else error_Proj (S n0) n1)\n (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj (S n0) n1)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
destruct n0.
try discriminate.
case_eq (leb n1 n0).
intros.
rewrite H8 in H7.

*****
H8 : eq (Nat.leb n1 n0) false
H7 : eq (error_Proj (S n0) n1) (ok_arity n)
n0,n1,n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Proj (S n0) n1)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.

*****
H7 : eq (arity (Succ b)) (ok_arity n)
n : nat
b : bool
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Succ b)
+++++
simpl in *.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.

*****
H7 : eq (ok_arity (S O)) (ok_arity n)
n : nat
b : bool
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Succ b)
+++++
injection H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
injection H7.

*****
H7 : eq (ok_arity (S O)) (ok_arity n)
n : nat
b : bool
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (S O) n, P n (Succ b)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
injection H7.
intros.

*****
H8 : eq (S O) n
H7 : eq (ok_arity (S O)) (ok_arity n)
n : nat
b : bool
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Succ b)
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
injection H7.
intros.
subst.

*****
H7 : eq (ok_arity (S O)) (ok_arity (S O))
b : bool
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S O) (Succ b)
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.

*****
H7 : eq (arity Smash) (ok_arity n)
n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n Smash
+++++
simpl in *.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.

*****
H7 : eq (ok_arity (S (S O))) (ok_arity n)
n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n Smash
+++++
injection H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
injection H7.

*****
H7 : eq (ok_arity (S (S O))) (ok_arity n)
n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (S (S O)) n, P n Smash
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
injection H7.
intros.

*****
H8 : eq (S (S O)) n
H7 : eq (ok_arity (S (S O))) (ok_arity n)
n : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n Smash
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
injection H7.
intros.
subst.

*****
H7 : eq (ok_arity (S (S O))) (ok_arity (S (S O)))
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S O)) Smash
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.

*****
H7 : eq (arity (Rec e1 e2 e3 e4)) (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
simpl in *.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.

*****
H7 : eq\n match arity e1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4)\n | ok_arity gn =>\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) \n (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
case_eq (arity e1).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).

*****
H7 : eq\n match arity e1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4)\n | ok_arity gn =>\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) \n (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a a0 a1 a2 : Arity) (_ : eq (arity e1) (error_Rec a a0 a1 a2)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.

*****
H8 : eq (arity e1) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H7 : eq\n match arity e1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4)\n | ok_arity gn =>\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) \n (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.

*****
H8 : eq (arity e1) (error_Rec a a0 a1 a2)
H7 : eq (error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4))\n (ok_arity n)
a,a0,a1,a2 : Arity
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).

*****
H7 : eq\n match arity e1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4)\n | ok_arity gn =>\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) \n (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a : Arity) (l : list Arity) (_ : eq (arity e1) (error_Comp a l)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.

*****
H8 : eq (arity e1) (error_Comp a l)
l : list Arity
a : Arity
H7 : eq\n match arity e1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4)\n | ok_arity gn =>\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) \n (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.

*****
H8 : eq (arity e1) (error_Comp a l)
H7 : eq (error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4))\n (ok_arity n)
l : list Arity
a : Arity
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).

*****
H7 : eq\n match arity e1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4)\n | ok_arity gn =>\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) \n (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n0 n1 : nat) (_ : eq (arity e1) (error_Proj n0 n1)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.

*****
H8 : eq (arity e1) (error_Proj n0 n1)
n0,n1 : nat
H7 : eq\n match arity e1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4)\n | ok_arity gn =>\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) \n (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.

*****
H8 : eq (arity e1) (error_Proj n0 n1)
H7 : eq (error_Rec (error_Proj n0 n1) (arity e2) (arity e3) (arity e4))\n (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).

*****
H7 : eq\n match arity e1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4)\n | ok_arity gn =>\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) \n (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n0 : nat) (_ : eq (arity e1) (ok_arity n0)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.

*****
H8 : eq (arity e1) (ok_arity n0)
n0 : nat
H7 : eq\n match arity e1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4)\n | ok_arity gn =>\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) \n (arity e3) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity e4)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end (ok_arity n)
n : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.

*****
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.

*****
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
case_eq (arity e2).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).

*****
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a a0 a1 a2 : Arity) (_ : eq (arity e2) (error_Rec a a0 a1 a2)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.

*****
H9 : eq (arity e2) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H9 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.

*****
H9 : eq (arity e2) (error_Rec a a0 a1 a2)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) (arity e3) (arity e4))\n (ok_arity n)
a,a0,a1,a2 : Arity
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).

*****
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a : Arity) (l : list Arity) (_ : eq (arity e2) (error_Comp a l)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.

*****
H9 : eq (arity e2) (error_Comp a l)
l : list Arity
a : Arity
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H9 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.

*****
H9 : eq (arity e2) (error_Comp a l)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq (error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4))\n (ok_arity n)
l : list Arity
a : Arity
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).

*****
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n0 n1 : nat) (_ : eq (arity e2) (error_Proj n0 n1)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.

*****
H9 : eq (arity e2) (error_Proj n1 n2)
n1,n2 : nat
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H9 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.

*****
H9 : eq (arity e2) (error_Proj n1 n2)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq (error_Rec (ok_arity n0) (error_Proj n1 n2) (arity e3) (arity e4))\n (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).

*****
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n0 : nat) (_ : eq (arity e2) (ok_arity n0)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.

*****
H9 : eq (arity e2) (ok_arity n1)
n1 : nat
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e2 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (error_Rec a a0 a1 a2) \n (arity e3) (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (error_Comp a l) (arity e3) (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (error_Proj n n1) (arity e3) (arity e4)\n | ok_arity h0n =>\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Comp a l)\n (arity e4)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) (error_Proj n n1)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n1 =>\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end (ok_arity n)
n,n0 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H9 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.

*****
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.

*****
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
case_eq (arity e3).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).

*****
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a a0 a1 a2 : Arity) (_ : eq (arity e3) (error_Rec a a0 a1 a2)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.

*****
H10 : eq (arity e3) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H10 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.

*****
H10 : eq (arity e3) (error_Rec a a0 a1 a2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)) (ok_arity n)
a,a0,a1,a2 : Arity
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).

*****
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a : Arity) (l : list Arity) (_ : eq (arity e3) (error_Comp a l)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.

*****
H10 : eq (arity e3) (error_Comp a l)
l : list Arity
a : Arity
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H10 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.

*****
H10 : eq (arity e3) (error_Comp a l)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq (error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4))\n (ok_arity n)
l : list Arity
a : Arity
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).

*****
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n0 n1 : nat) (_ : eq (arity e3) (error_Proj n0 n1)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.

*****
H10 : eq (arity e3) (error_Proj n2 n3)
n2,n3 : nat
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H10 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.

*****
H10 : eq (arity e3) (error_Proj n2 n3)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n2 n3) (arity e4))\n (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).

*****
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n0 : nat) (_ : eq (arity e3) (ok_arity n0)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.

*****
H10 : eq (arity e3) (ok_arity n2)
n2 : nat
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e3 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2)\n (arity e4)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Comp a l) (arity e4)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (error_Proj n n2)\n (arity e4)\n | ok_arity h1n =>\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (error_Proj n n2)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb h1n n1))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity h1n)\n (ok_arity jn)\n end\n end (ok_arity n)
n,n0,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H10 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.

*****
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.

*****
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
case_eq (arity e4).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).

*****
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a a0 a1 a2 : Arity) (_ : eq (arity e4) (error_Rec a a0 a1 a2)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.

*****
H11 : eq (arity e4) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H11 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.

*****
H11 : eq (arity e4) (error_Rec a a0 a1 a2)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)) (ok_arity n)
a,a0,a1,a2 : Arity
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).

*****
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a : Arity) (l : list Arity) (_ : eq (arity e4) (error_Comp a l)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.

*****
H11 : eq (arity e4) (error_Comp a l)
l : list Arity
a : Arity
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H11 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.

*****
H11 : eq (arity e4) (error_Comp a l)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2) (error_Comp a l))\n (ok_arity n)
l : list Arity
a : Arity
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).

*****
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n0 n1 : nat) (_ : eq (arity e4) (error_Proj n0 n1)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.

*****
H11 : eq (arity e4) (error_Proj n3 n4)
n3,n4 : nat
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H11 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.

*****
H11 : eq (arity e4) (error_Proj n3 n4)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n3 n4)) (ok_arity n)
n,n0,n1,n2,n3,n4 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).

*****
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n0 : nat) (_ : eq (arity e4) (ok_arity n0)), P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.

*****
H11 : eq (arity e4) (ok_arity n3)
n3 : nat
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n match arity e4 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Comp a l)\n | error_Proj n n3 =>\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (error_Proj n n3)\n | ok_arity jn =>\n if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2)\n (ok_arity jn)\n end (ok_arity n)
n,n0,n1,n2 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H11 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2) (ok_arity n3))\n (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity n1)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb\n (andb\n match n1 with\n | S (S m'0) => Nat.eqb n0 m'0\n | _ => false\n end (Nat.eqb n2 n1))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity n1) (ok_arity n2) (ok_arity n3))\n (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
destruct n1.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity O)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb false (Nat.eqb n2 O))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity O) (ok_arity n2) (ok_arity n3))\n (ok_arity n)
n,n0,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
simpl.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity O)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb false (Nat.eqb n2 O))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity O) (ok_arity n2) (ok_arity n3))\n (ok_arity n)
n,n0,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity O)
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb false (Nat.eqb n2 O))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity O) (ok_arity n2) (ok_arity n3))\n (ok_arity n)
n,n0,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb\n (andb match n1 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 (S n1)))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S n1)) (ok_arity n2)\n (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
simpl.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb\n (andb match n1 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 (S n1)))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S n1)) (ok_arity n2)\n (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb\n (andb match n1 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 (S n1)))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S n1)) (ok_arity n2)\n (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb\n (andb match n1 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 (S n1)))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S n1)) (ok_arity n2)\n (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb\n (andb match n1 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 (S n1)))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S n1)) (ok_arity n2)\n (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
destruct n1.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S O))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb false (Nat.eqb n2 (S O)))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S O)) (ok_arity n2)\n (ok_arity n3)) (ok_arity n)
n,n0,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
simpl.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S O))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb false (Nat.eqb n2 (S O)))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S O)) (ok_arity n2)\n (ok_arity n3)) (ok_arity n)
n,n0,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S O))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb false (Nat.eqb n2 (S O)))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S O)) (ok_arity n2)\n (ok_arity n3)) (ok_arity n)
n,n0,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb (Nat.eqb n0 n1) (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
simpl.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb (Nat.eqb n0 n1) (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb (Nat.eqb n0 n1) (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb (Nat.eqb n0 n1) (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb (Nat.eqb n0 n1) (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
case_eq (beq_nat n0 n1).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb (Nat.eqb n0 n1) (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.eqb n0 n1) true, P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.

*****
H12 : eq (Nat.eqb n0 n1) true
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb (Nat.eqb n0 n1) (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H12 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.

*****
H12 : eq (Nat.eqb n0 n1) true
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb true (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.

*****
H12 : eq (Nat.eqb n0 n1) true
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb true (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
apply beq_nat_true in H12.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.

*****
H12 : eq n0 n1
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb true (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if\n andb (andb true (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
case_eq (beq_nat n2 (S (S n1))).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if\n andb (andb true (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.eqb n2 (S (S n1))) true, P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.

*****
H12 : eq (Nat.eqb n2 (S (S n1))) true
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if\n andb (andb true (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H12 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.

*****
H12 : eq (Nat.eqb n2 (S (S n1))) true
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if\n andb (andb true true)\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.

*****
H12 : eq (Nat.eqb n2 (S (S n1))) true
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if\n andb (andb true true)\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
apply beq_nat_true in H12.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.

*****
H12 : eq n2 (S (S n1))
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if\n andb (andb true true)\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) (Nat.eqb n3 (S n1))\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
case_eq (beq_nat n3 (S n1)).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) (Nat.eqb n3 (S n1))\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.eqb n3 (S n1)) true, P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.

*****
H12 : eq (Nat.eqb n3 (S n1)) true
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) (Nat.eqb n3 (S n1))\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H12 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.

*****
H12 : eq (Nat.eqb n3 (S n1)) true
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) true\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.

*****
H12 : eq (Nat.eqb n3 (S n1)) true
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) true\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
apply beq_nat_true in H12.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.

*****
H12 : eq n3 (S n1)
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) true\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) true\n then ok_arity (S n1)\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity (S n1))) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
simpl in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
injection H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (S n1) n, P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.

*****
H12 : eq (S n1) n
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S n1) (Rec e1 e2 e3 e4)
+++++
apply H5.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e1) (ok_arity n1)
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e2) (ok_arity (S (S n1)))
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e3) (ok_arity (S (S n1)))
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e4) (ok_arity (S n1))
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n1 e1
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n1 e1
+++++
eapply Cobham_ind_inf'.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall n : nat, ?Q n nil
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l), Q n (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P O Zero
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n i : nat) (_ : lt i n), P n (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall b : bool, P (S O) (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S O)) Smash
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e1) (ok_arity n1)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S n1)) e2
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S n1)) e2
+++++
eapply Cobham_ind_inf'.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall n : nat, ?Q n nil
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l), Q n (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P O Zero
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n i : nat) (_ : lt i n), P n (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall b : bool, P (S O) (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S O)) Smash
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e2) (ok_arity (S (S n1)))
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S n1)) e3
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S n1)) e3
+++++
eapply Cobham_ind_inf'.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall n : nat, ?Q n nil
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l), Q n (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P O Zero
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n i : nat) (_ : lt i n), P n (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall b : bool, P (S O) (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S O)) Smash
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e3) (ok_arity (S (S n1)))
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S n1) e4
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S n1) e4
+++++
eapply Cobham_ind_inf'.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall n : nat, ?Q n nil
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l), Q n (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P O Zero
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n i : nat) (_ : lt i n), P n (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall b : bool, P (S O) (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S O)) Smash
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
simpl in H7.
injection H7.
intros.
subst.
apply H5.
auto.
eapply Cobham_ind_inf'.

*****
H11 : eq (arity e4) (ok_arity (S n1))
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq (ok_arity (S n1)) (ok_arity (S n1))
H8 : eq (arity e1) (ok_arity n1)
n1 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e4) (ok_arity (S n1))
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) (Nat.eqb n3 (S n1))\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.eqb n3 (S n1)) false, P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.

*****
H12 : eq (Nat.eqb n3 (S n1)) false
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) (Nat.eqb n3 (S n1))\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H12 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n3 (S n1)).
intros.
rewrite H12 in H7.

*****
H12 : eq (Nat.eqb n3 (S n1)) false
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity (S (S n1)))
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if andb (andb true true) false\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity (S (S n1))) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if\n andb (andb true (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.eqb n2 (S (S n1))) false, P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.

*****
H12 : eq (Nat.eqb n2 (S (S n1))) false
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if\n andb (andb true (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H12 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.
try discriminate.
apply beq_nat_true in H12.
subst.
case_eq (beq_nat n2 (S (S n1))).
intros.
rewrite H12 in H7.

*****
H12 : eq (Nat.eqb n2 (S (S n1))) false
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H7 : eq\n (if\n andb (andb true false)\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n1) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
H8 : eq (arity e1) (ok_arity n1)
n,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).

*****
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb (Nat.eqb n0 n1) (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.eqb n0 n1) false, P n (Rec e1 e2 e3 e4)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.

*****
H12 : eq (Nat.eqb n0 n1) false
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb (Nat.eqb n0 n1) (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
rewrite H12 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e1).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (arity e2).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (arity e3).
intros.
rewrite H10 in H7.
try discriminate.
case_eq (arity e4).
intros.
rewrite H11 in H7.
try discriminate.
destruct n1.
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n0 n1).
intros.
rewrite H12 in H7.

*****
H12 : eq (Nat.eqb n0 n1) false
H11 : eq (arity e4) (ok_arity n3)
H10 : eq (arity e3) (ok_arity n2)
H9 : eq (arity e2) (ok_arity (S (S n1)))
H8 : eq (arity e1) (ok_arity n0)
H7 : eq\n (if\n andb (andb false (Nat.eqb n2 (S (S n1))))\n match n2 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arity n3\n else\n error_Rec (ok_arity n0) (ok_arity (S (S n1))) \n (ok_arity n2) (ok_arity n3)) (ok_arity n)
n,n0,n1,n2,n3 : nat
e1,e2,e3,e4 : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Rec e1 e2 e3 e4)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.

*****
H7 : eq (arity (Comp n0 e l)) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
simpl in *.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.

*****
H7 : eq\n match arity e with\n | error_Rec a a0 a1 a2 =>\n error_Comp (error_Rec a a0 a1 a2) (map arity l)\n | error_Comp a l0 => error_Comp (error_Comp a l0) (map arity l)\n | error_Proj n n0 => error_Comp (error_Proj n n0) (map arity l)\n | ok_arity nh =>\n if\n andb (Nat.eqb nh (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity nh) (map arity l)\n end (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
case_eq (arity e).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).

*****
H7 : eq\n match arity e with\n | error_Rec a a0 a1 a2 =>\n error_Comp (error_Rec a a0 a1 a2) (map arity l)\n | error_Comp a l0 => error_Comp (error_Comp a l0) (map arity l)\n | error_Proj n n0 => error_Comp (error_Proj n n0) (map arity l)\n | ok_arity nh =>\n if\n andb (Nat.eqb nh (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity nh) (map arity l)\n end (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a a0 a1 a2 : Arity) (_ : eq (arity e) (error_Rec a a0 a1 a2)), P n (Comp n0 e l)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.

*****
H8 : eq (arity e) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H7 : eq\n match arity e with\n | error_Rec a a0 a1 a2 =>\n error_Comp (error_Rec a a0 a1 a2) (map arity l)\n | error_Comp a l0 => error_Comp (error_Comp a l0) (map arity l)\n | error_Proj n n0 => error_Comp (error_Proj n n0) (map arity l)\n | ok_arity nh =>\n if\n andb (Nat.eqb nh (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity nh) (map arity l)\n end (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.

*****
H8 : eq (arity e) (error_Rec a a0 a1 a2)
H7 : eq (error_Comp (error_Rec a a0 a1 a2) (map arity l)) (ok_arity n)
a,a0,a1,a2 : Arity
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).

*****
H7 : eq\n match arity e with\n | error_Rec a a0 a1 a2 =>\n error_Comp (error_Rec a a0 a1 a2) (map arity l)\n | error_Comp a l0 => error_Comp (error_Comp a l0) (map arity l)\n | error_Proj n n0 => error_Comp (error_Proj n n0) (map arity l)\n | ok_arity nh =>\n if\n andb (Nat.eqb nh (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity nh) (map arity l)\n end (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (a : Arity) (l0 : list Arity) (_ : eq (arity e) (error_Comp a l0)), P n (Comp n0 e l)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.

*****
H8 : eq (arity e) (error_Comp a l0)
l0 : list Arity
a : Arity
H7 : eq\n match arity e with\n | error_Rec a a0 a1 a2 =>\n error_Comp (error_Rec a a0 a1 a2) (map arity l)\n | error_Comp a l0 => error_Comp (error_Comp a l0) (map arity l)\n | error_Proj n n0 => error_Comp (error_Proj n n0) (map arity l)\n | ok_arity nh =>\n if\n andb (Nat.eqb nh (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity nh) (map arity l)\n end (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.

*****
H8 : eq (arity e) (error_Comp a l0)
H7 : eq (error_Comp (error_Comp a l0) (map arity l)) (ok_arity n)
l0 : list Arity
a : Arity
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).

*****
H7 : eq\n match arity e with\n | error_Rec a a0 a1 a2 =>\n error_Comp (error_Rec a a0 a1 a2) (map arity l)\n | error_Comp a l0 => error_Comp (error_Comp a l0) (map arity l)\n | error_Proj n n0 => error_Comp (error_Proj n n0) (map arity l)\n | ok_arity nh =>\n if\n andb (Nat.eqb nh (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity nh) (map arity l)\n end (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n1 n2 : nat) (_ : eq (arity e) (error_Proj n1 n2)), P n (Comp n0 e l)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.

*****
H8 : eq (arity e) (error_Proj n1 n2)
n1,n2 : nat
H7 : eq\n match arity e with\n | error_Rec a a0 a1 a2 =>\n error_Comp (error_Rec a a0 a1 a2) (map arity l)\n | error_Comp a l0 => error_Comp (error_Comp a l0) (map arity l)\n | error_Proj n n0 => error_Comp (error_Proj n n0) (map arity l)\n | ok_arity nh =>\n if\n andb (Nat.eqb nh (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity nh) (map arity l)\n end (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.

*****
H8 : eq (arity e) (error_Proj n1 n2)
H7 : eq (error_Comp (error_Proj n1 n2) (map arity l)) (ok_arity n)
n,n1,n2 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).

*****
H7 : eq\n match arity e with\n | error_Rec a a0 a1 a2 =>\n error_Comp (error_Rec a a0 a1 a2) (map arity l)\n | error_Comp a l0 => error_Comp (error_Comp a l0) (map arity l)\n | error_Proj n n0 => error_Comp (error_Proj n n0) (map arity l)\n | ok_arity nh =>\n if\n andb (Nat.eqb nh (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity nh) (map arity l)\n end (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n1 : nat) (_ : eq (arity e) (ok_arity n1)), P n (Comp n0 e l)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.

*****
H8 : eq (arity e) (ok_arity n1)
n1 : nat
H7 : eq\n match arity e with\n | error_Rec a a0 a1 a2 =>\n error_Comp (error_Rec a a0 a1 a2) (map arity l)\n | error_Comp a l0 => error_Comp (error_Comp a l0) (map arity l)\n | error_Proj n n0 => error_Comp (error_Proj n n0) (map arity l)\n | ok_arity nh =>\n if\n andb (Nat.eqb nh (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity nh) (map arity l)\n end (ok_arity n)
n : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
rewrite H8 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.

*****
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb (Nat.eqb n1 (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.

*****
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb (Nat.eqb n1 (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
case_eq (beq_nat n1 (length l)).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).

*****
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb (Nat.eqb n1 (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.eqb n1 (length l)) true, P n (Comp n0 e l)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.

*****
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb (Nat.eqb n1 (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
rewrite H9 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.

*****
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb true\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.

*****
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb true\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).

*****
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb true\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)) true, P n (Comp n0 e l)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.

*****
H10 : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l))\n true
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb true\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
rewrite H10 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.

*****
H10 : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l))\n true
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if andb true true\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.

*****
H10 : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l))\n true
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if andb true true\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
simpl in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.

*****
H10 : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l))\n true
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq (ok_arity n0) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
injection H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.

*****
H10 : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l))\n true
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq (ok_arity n0) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq n0 n, P n (Comp n0 e l)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.

*****
H11 : eq n0 n
H10 : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l))\n true
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq (ok_arity n0) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.

*****
H10 : eq (forallb (fun e : Arity => arity_eq e (ok_arity n)) (map arity l))\n true
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq (ok_arity n) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n e l)
+++++
rewrite forallb_forall in H10.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq (ok_arity n) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n e l)
+++++
apply beq_nat_true in H9.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H9 : eq n1 (length l)
H8 : eq (arity e) (ok_arity n1)
H7 : eq (ok_arity n) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n e l)
+++++
subst.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n e l)
+++++
apply H6.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e) (ok_arity (length l))
+++++
trivial.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (e : Cobham) (_ : In e l), eq (arity e) (ok_arity n)
+++++
trivial.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (e : Cobham) (_ : In e l), eq (arity e) (ok_arity n)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
intros.

*****
H9 : In e0 l
e0 : Cobham
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e0) (ok_arity n)
+++++
apply arity_eq_true.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
intros.
apply arity_eq_true.

*****
H9 : In e0 l
e0 : Cobham
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity_eq (arity e0) (ok_arity n)) true
+++++
apply H10.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
intros.
apply arity_eq_true.
apply H10.

*****
H9 : In e0 l
e0 : Cobham
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
In (arity e0) (map arity l)
+++++
apply in_map_iff.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
intros.
apply arity_eq_true.
apply H10.
apply in_map_iff.

*****
H9 : In e0 l
e0 : Cobham
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
ex (fun x : Cobham => and (eq (arity x) (arity e0)) (In x l))
+++++
exists e0.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
intros.
apply arity_eq_true.
apply H10.
apply in_map_iff.
exists e0.

*****
H9 : In e0 l
e0 : Cobham
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
and (eq (arity e0) (arity e0)) (In e0 l)
+++++
split.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
intros.
apply arity_eq_true.
apply H10.
apply in_map_iff.
exists e0.
split.

*****
H9 : In e0 l
e0 : Cobham
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e0) (arity e0)
+++++
trivial.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
intros.
apply arity_eq_true.
apply H10.
apply in_map_iff.
exists e0.
split.

*****
H9 : In e0 l
e0 : Cobham
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
In e0 l
+++++
trivial.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (length l) e
+++++
trivial.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (length l) e
+++++
eapply Cobham_ind_inf'.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall n0 : nat, ?Q n0 nil
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l), Q n (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P O Zero
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n i : nat) (_ : lt i n), P n (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall b : bool, P (S O) (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S O)) Smash
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity e) (ok_arity (length l))
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
Q n l
+++++
trivial.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H8 : eq (arity e) (ok_arity (length l))
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
Q n l
+++++
clear H8.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
H7 : eq (ok_arity n) (ok_arity n)
n : nat
l : list Cobham
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
Q n l
+++++
revert l H10.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.

*****
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (l : list Cobham) (_ : forall (x : Arity) (_ : In x (map arity l)), eq (arity_eq x (ok_arity n)) true), Q n l
+++++
fix Cobham_ind_inf'0 1.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.

*****
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (l : list Cobham) (_ : forall (x : Arity) (_ : In x (map arity l)), eq (arity_eq x (ok_arity n)) true), Q n l
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.

*****
H10 : forall (x : Arity) (_ : In x (map arity l)),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
Q n l
+++++
destruct l.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.

*****
H10 : forall (x : Arity) (_ : In x (map arity nil)),\neq (arity_eq x (ok_arity n)) true
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
Q n nil
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
Q n (cons c l)
+++++
eapply H0.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n c
+++++
eapply Cobham_ind_inf'.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall n0 : nat, ?Q n0 nil
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l), Q n (cons e l)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P O Zero
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n i : nat) (_ : lt i n), P n (Proj n i)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall b : bool, P (S O) (Succ b)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P (S (S O)) Smash
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity c) (ok_arity n)
+++++
eauto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.
eauto.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity c) (ok_arity n)
+++++
apply arity_eq_true.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.
eauto.
apply arity_eq_true.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity_eq (arity c) (ok_arity n)) true
+++++
apply H10.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.
eauto.
apply arity_eq_true.
apply H10.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
In (arity c) (map arity (cons c l))
+++++
simpl.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply Cobham_ind_inf'.
eauto.
apply arity_eq_true.
apply H10.
simpl.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
or (eq (arity c) (arity c)) (In (arity c) (map arity l))
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
Q n l
+++++
apply Cobham_ind_inf'0.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
apply Cobham_ind_inf'0.

*****
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall (x : Arity) (_ : In x (map arity l)), eq (arity_eq x (ok_arity n)) true
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
apply Cobham_ind_inf'0.
intros.

*****
H8 : In x (map arity l)
x : Arity
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
eq (arity_eq x (ok_arity n)) true
+++++
apply H10.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
apply Cobham_ind_inf'0.
intros.
apply H10.

*****
H8 : In x (map arity l)
x : Arity
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
In x (map arity (cons c l))
+++++
simpl.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.
try discriminate.
simpl in H7.
injection H7.
intros.
subst.
rewrite forallb_forall in H10.
apply beq_nat_true in H9.
subst.
apply H6.
trivial.
clear H8.
revert l H10.
fix Cobham_ind_inf'0 1.
intros.
destruct l.
eapply H0.
apply Cobham_ind_inf'0.
intros.
apply H10.
simpl.

*****
H8 : In x (map arity l)
x : Arity
H10 : forall (x : Arity) (_ : In x (map arity (cons c l))),\neq (arity_eq x (ok_arity n)) true
l : list Cobham
c : Cobham
Cobham_ind_inf'0 : forall (l : list Cobham)\n (_ : forall (x : Arity) (_ : In x (map arity l)),\n eq (arity_eq x (ok_arity n)) true), Q n l
H7 : eq (ok_arity n) (ok_arity n)
n : nat
e : Cobham
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
or (eq (arity c) x) (In x (map arity l))
+++++
auto.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).

*****
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb true\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)) false, P n (Comp n0 e l)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.

*****
H10 : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l))\n false
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb true\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
rewrite H10 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.
try discriminate.
case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)).
intros.
rewrite H10 in H7.

*****
H10 : eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l))\n false
H9 : eq (Nat.eqb n1 (length l)) true
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if andb true false\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).

*****
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb (Nat.eqb n1 (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
forall _ : eq (Nat.eqb n1 (length l)) false, P n (Comp n0 e l)
+++++
intros.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.

*****
H9 : eq (Nat.eqb n1 (length l)) false
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb (Nat.eqb n1 (length l))\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
rewrite H9 in H7.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.
simpl in *.
case_eq (arity e).
intros.
rewrite H8 in H7.
try discriminate.
case_eq (beq_nat n1 (length l)).
intros.
rewrite H9 in H7.

*****
H9 : eq (Nat.eqb n1 (length l)) false
H8 : eq (arity e) (ok_arity n1)
H7 : eq\n (if\n andb false\n (forallb (fun e : Arity => arity_eq e (ok_arity n0))\n (map arity l))\n then ok_arity n0\n else error_Comp (ok_arity n1) (map arity l)) (ok_arity n)
n,n1 : nat
l : list Cobham
e : Cobham
n0 : nat
H6 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : Q n rl), P n (Comp n h rl)
H5 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H4 : P (S (S O)) Smash
H3 : forall b : bool, P (S O) (Succ b)
H2 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H1 : P O Zero
H0 : forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : Q n l),\nQ n (cons e l)
H : forall n : nat, Q n nil
Q : forall (_ : nat) (_ : list Cobham), Prop
P : forall (_ : nat) (_ : Cobham), Prop
Cobham_ind_inf' : forall (P : forall (_ : nat) (_ : Cobham), Prop)\n (Q : forall (_ : nat) (_ : list Cobham), Prop)\n (_ : forall n : nat, Q n nil)\n (_ : forall (e : Cobham) (n : nat) (l : list Cobham) \n (_ : P n e) (_ : Q n l), Q n (cons e l)) \n (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i))\n (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash)\n (_ : forall (n : nat) (g h0 h1 j : Cobham)\n (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g)\n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) \n (_ : P (S n) j), P (S n) (Rec g h0 h1 j))\n (_ : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl),\n eq (arity e) (ok_arity n)) (_ : P (length rl) h)\n (_ : Q n rl), P n (Comp n h rl)) (e : Cobham) \n (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
*****
P n (Comp n0 e l)
+++++
try discriminate.
-----
Lemma Cobham_ind_inf' : forall (P : nat -> Cobham -> Prop), forall Q : nat -> list Cobham -> Prop, (forall n, Q n nil) -> (forall e n l, P n e -> Q n l -> Q n (e :: l)) -> P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> Q n rl -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
fix Cobham_ind_inf' 11.
intros.
destruct e.

*****

*****

+++++
Qed.
-----
Lemma Cobham_ind_inf :\n  forall (P : nat -> Cobham -> Prop),\n  P 0 Zero ->\n  (forall n i, i < n  ->  P n (Proj n i)) ->\n  (forall b, P 1 (Succ b)) ->\n  (P 2 Smash) ->\n  (forall n g h0 h1 j, \n    arity g = ok_arity n ->\n    arity h0 = ok_arity (S (S n)) ->\n    arity h1 = ok_arity (S (S n)) ->\n    arity j = ok_arity (S n) ->\n    P n g -> \n    P (S (S n)) h0 -> \n    P (S (S n)) h1 -> \n    P (S n) j ->\n    P (S n) (Rec g h0 h1 j)) ->\n  (forall n h rl, \n    arity h = ok_arity (length rl)  ->\n    (forall e, In e rl -> arity e = ok_arity n) ->\n    P (length rl) h -> \n    (forall r, In r rl -> P n r) ->\n    P n (Comp n h rl)) ->\n  forall e n , arity e = ok_arity n -> P n e.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.

*****

*****
forall (P : forall (_ : nat) (_ : Cobham), Prop) (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i)) (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash) (_ : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)) (_ : forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r), P n (Comp n h rl)) (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
+++++
Proof.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.

*****

*****
forall (P : forall (_ : nat) (_ : Cobham), Prop) (_ : P O Zero) (_ : forall (n i : nat) (_ : lt i n), P n (Proj n i)) (_ : forall b : bool, P (S O) (Succ b)) (_ : P (S (S O)) Smash) (_ : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)) (_ : forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r), P n (Comp n h rl)) (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)), P n e
+++++
intros.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
P n e
+++++
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall (n : nat) (e : Cobham) (_ : In e nil), P n e
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall (n : nat) (e : Cobham) (_ : In e nil), P n e
+++++
simpl in *.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.
simpl in *.

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall (n : nat) (e : Cobham) (_ : False), P n e
+++++
intros.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.
simpl in *.
intros.

*****
H6 : False
e0 : Cobham
n0 : nat
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
P n0 e0
+++++
tauto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : forall (e0 : Cobham) (_ : In e0 l), P n e0) (e0 : Cobham) (_ : In e0 (cons e l)), P n e0
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : forall (e0 : Cobham) (_ : In e0 l), P n e0) (e0 : Cobham) (_ : In e0 (cons e l)), P n e0
+++++
simpl in *.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.
simpl in *.

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall (e : Cobham) (n : nat) (l : list Cobham) (_ : P n e) (_ : forall (e0 : Cobham) (_ : In e0 l), P n e0) (e0 : Cobham) (_ : or (eq e e0) (In e0 l)), P n e0
+++++
intros.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.
simpl in *.
intros.

*****
H8 : or (eq e0 e1) (In e1 l)
e1 : Cobham
H7 : forall (e : Cobham) (_ : In e l), P n0 e
H6 : P n0 e0
l : list Cobham
n0 : nat
e0 : Cobham
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
P n0 e1
+++++
destruct H8.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.
simpl in *.
intros.
destruct H8.

*****
H8 : eq e0 e1
e1 : Cobham
H7 : forall (e : Cobham) (_ : In e l), P n0 e
H6 : P n0 e0
l : list Cobham
n0 : nat
e0 : Cobham
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
P n0 e1
+++++
subst.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.
simpl in *.
intros.
destruct H8.
subst.

*****
H7 : forall (e : Cobham) (_ : In e l), P n0 e
H6 : P n0 e1
e1 : Cobham
l : list Cobham
n0 : nat
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
P n0 e1
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.
simpl in *.
intros.
destruct H8.

*****
H8 : In e1 l
e1 : Cobham
H7 : forall (e : Cobham) (_ : In e l), P n0 e
H6 : P n0 e0
l : list Cobham
n0 : nat
e0 : Cobham
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
P n0 e1
+++++
subst.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).
auto.
simpl in *.
intros.
destruct H8.
subst.

*****
H8 : In e1 l
e1 : Cobham
H7 : forall (e : Cobham) (_ : In e l), P n0 e
H6 : P n0 e0
l : list Cobham
n0 : nat
e0 : Cobham
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
P n0 e1
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
P O Zero
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall (n i : nat) (_ : lt i n), P n (Proj n i)
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall b : bool, P (S O) (Succ b)
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
P (S (S O)) Smash
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j), P (S n) (Rec g h0 h1 j)
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : P (length rl) h) (_ : forall (e : Cobham) (_ : In e rl), P n e), P n (Comp n h rl)
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****
H5 : eq (arity e) (ok_arity n)
n : nat
e : Cobham
H4 : forall (n : nat) (h : Cobham) (rl : list Cobham)\n (_ : eq (arity h) (ok_arity (length rl)))\n (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n))\n (_ : P (length rl) h) (_ : forall (r : Cobham) (_ : In r rl), P n r),\nP n (Comp n h rl)
H3 : forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n))\n (_ : eq (arity h0) (ok_arity (S (S n))))\n (_ : eq (arity h1) (ok_arity (S (S n))))\n (_ : eq (arity j) (ok_arity (S n))) (_ : P n g) \n (_ : P (S (S n)) h0) (_ : P (S (S n)) h1) (_ : P (S n) j),\nP (S n) (Rec g h0 h1 j)
H2 : P (S (S O)) Smash
H1 : forall b : bool, P (S O) (Succ b)
H0 : forall (n i : nat) (_ : lt i n), P n (Proj n i)
H : P O Zero
P : forall (_ : nat) (_ : Cobham), Prop
*****
eq (arity e) (ok_arity n)
+++++
auto.
-----
Lemma Cobham_ind_inf : forall (P : nat -> Cobham -> Prop), P 0 Zero -> (forall n i, i < n -> P n (Proj n i)) -> (forall b, P 1 (Succ b)) -> (P 2 Smash) -> (forall n g h0 h1 j, arity g = ok_arity n -> arity h0 = ok_arity (S (S n)) -> arity h1 = ok_arity (S (S n)) -> arity j = ok_arity (S n) -> P n g -> P (S (S n)) h0 -> P (S (S n)) h1 -> P (S n) j -> P (S n) (Rec g h0 h1 j)) -> (forall n h rl, arity h = ok_arity (length rl) -> (forall e, In e rl -> arity e = ok_arity n) -> P (length rl) h -> (forall r, In r rl -> P n r) -> P n (Comp n h rl)) -> forall e n , arity e = ok_arity n -> P n e.
Proof.
intros.
apply Cobham_ind_inf' with (Q := fun n l => forall e , In e l -> P n e).

*****

*****

+++++
Qed.
-----
Fixpoint sem_Rec (sem_g sem_h0 sem_h1 : list bs -> bs) (v : bs) (vl : list bs) : bs :=\n  match v with\n    | nil => sem_g vl\n    | b::v' => if b then \n      sem_h1 (v' :: (sem_Rec sem_g sem_h0 sem_h1 v' vl) :: vl)\n      else sem_h0 (v' :: (sem_Rec sem_g sem_h0 sem_h1 v' vl) :: vl)\n  end.
-----
Fixpoint smash' (x y : bs) :=\n  match x with \n    | nil => y\n    | _ :: x' => false :: smash' x' y\n  end.
-----
Lemma length_smash' x y :\n  length (smash' x y) = length x + length y.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.

*****
x,y : list bool
*****
eq (length (smash' x y)) (Init.Nat.add (length x) (length y))
+++++
Proof.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.
Proof.

*****
x,y : list bool
*****
eq (length (smash' x y)) (Init.Nat.add (length x) (length y))
+++++
induction x.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.
Proof.
induction x.

*****
y : list bool
*****
eq (length (smash' nil y)) (Init.Nat.add (length nil) (length y))
+++++
simpl.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.
Proof.
induction x.
simpl.

*****
y : list bool
*****
eq (length y) (length y)
+++++
trivial.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.
Proof.
induction x.

*****
IHx : eq (length (smash' x y)) (Init.Nat.add (length x) (length y))
x,y : list bool
a : bool
*****
eq (length (smash' (cons a x) y)) (Init.Nat.add (length (cons a x)) (length y))
+++++
simpl.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.
Proof.
induction x.
simpl.

*****
IHx : eq (length (smash' x y)) (Init.Nat.add (length x) (length y))
x,y : list bool
a : bool
*****
eq (S (length (smash' x y))) (S (Init.Nat.add (length x) (length y)))
+++++
trivial.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.
Proof.
induction x.
simpl.
trivial.

*****
IHx : eq (length (smash' x y)) (Init.Nat.add (length x) (length y))
x,y : list bool
a : bool
*****
eq (S (length (smash' x y))) (S (Init.Nat.add (length x) (length y)))
+++++
intros.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.
Proof.
induction x.
simpl.
trivial.
intros.

*****
IHx : eq (length (smash' x y)) (Init.Nat.add (length x) (length y))
x,y : list bool
a : bool
*****
eq (S (length (smash' x y))) (S (Init.Nat.add (length x) (length y)))
+++++
rewrite IHx.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.
Proof.
induction x.
simpl.
trivial.
intros.
rewrite IHx.

*****
IHx : eq (length (smash' x y)) (Init.Nat.add (length x) (length y))
x,y : list bool
a : bool
*****
eq (S (Init.Nat.add (length x) (length y))) (S (Init.Nat.add (length x) (length y)))
+++++
trivial.
-----
Lemma length_smash' x y : length (smash' x y) = length x + length y.
Proof.
induction x.

*****

*****

+++++
Qed.
-----
Fixpoint smash_bs (x y : bs) : bs :=\n  match x with\n    | nil => true :: nil\n    | _ :: x' => smash' y (smash_bs x' y)\n  end.
-----
Lemma length_smash x y :\n  length (smash_bs x y) = 1 + length x * length y.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.

*****
x,y : list bool
*****
eq (length (smash_bs x y)) (Init.Nat.add (S O) (Init.Nat.mul (length x) (length y)))
+++++
Proof.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.

*****
x,y : list bool
*****
eq (length (smash_bs x y)) (Init.Nat.add (S O) (Init.Nat.mul (length x) (length y)))
+++++
induction x.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.
induction x.

*****
y : list bool
*****
eq (length (smash_bs nil y)) (Init.Nat.add (S O) (Init.Nat.mul (length nil) (length y)))
+++++
simpl.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.
induction x.
simpl.

*****
y : list bool
*****
eq (S O) (S O)
+++++
trivial.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.
induction x.

*****
IHx : eq (length (smash_bs x y))\n (Init.Nat.add (S O) (Init.Nat.mul (length x) (length y)))
x,y : list bool
a : bool
*****
eq (length (smash_bs (cons a x) y)) (Init.Nat.add (S O) (Init.Nat.mul (length (cons a x)) (length y)))
+++++
simpl.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.
induction x.
simpl.

*****
IHx : eq (length (smash_bs x y))\n (Init.Nat.add (S O) (Init.Nat.mul (length x) (length y)))
x,y : list bool
a : bool
*****
eq (length (smash' y (smash_bs x y))) (S (Init.Nat.add (length y) (Init.Nat.mul (length x) (length y))))
+++++
trivial.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.
induction x.
simpl.
trivial.

*****
IHx : eq (length (smash_bs x y))\n (Init.Nat.add (S O) (Init.Nat.mul (length x) (length y)))
x,y : list bool
a : bool
*****
eq (length (smash' y (smash_bs x y))) (S (Init.Nat.add (length y) (Init.Nat.mul (length x) (length y))))
+++++
intros.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.
induction x.
simpl.
trivial.
intros.

*****
IHx : eq (length (smash_bs x y))\n (Init.Nat.add (S O) (Init.Nat.mul (length x) (length y)))
x,y : list bool
a : bool
*****
eq (length (smash' y (smash_bs x y))) (S (Init.Nat.add (length y) (Init.Nat.mul (length x) (length y))))
+++++
rewrite length_smash'.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.
induction x.
simpl.
trivial.
intros.
rewrite length_smash'.

*****
IHx : eq (length (smash_bs x y))\n (Init.Nat.add (S O) (Init.Nat.mul (length x) (length y)))
x,y : list bool
a : bool
*****
eq (Init.Nat.add (length y) (length (smash_bs x y))) (S (Init.Nat.add (length y) (Init.Nat.mul (length x) (length y))))
+++++
rewrite IHx.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.
induction x.
simpl.
trivial.
intros.
rewrite length_smash'.
rewrite IHx.

*****
IHx : eq (length (smash_bs x y))\n (Init.Nat.add (S O) (Init.Nat.mul (length x) (length y)))
x,y : list bool
a : bool
*****
eq (Init.Nat.add (length y) (Init.Nat.add (S O) (Init.Nat.mul (length x) (length y)))) (S (Init.Nat.add (length y) (Init.Nat.mul (length x) (length y))))
+++++
omega.
-----
Lemma length_smash x y : length (smash_bs x y) = 1 + length x * length y.
Proof.
induction x.

*****

*****

+++++
Qed.
-----
Fixpoint Sem (e: Cobham) (vl:list bs) : bs :=\n  match e with\n  | Zero => nil\n  | Proj n j => nth j vl nil\n  | Succ b => b :: hd nil vl\n  | Smash => smash_bs (hd nil vl) (hd nil (tl vl))\n  | Rec g h0 h1 j =>  \n    sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil vl) (tail vl)\n  | Comp _ h l => Sem h (List.map (fun e => Sem e vl) l)\n  end.
-----
Lemma simpl_Rec : forall g h0 h1 j l,\n  Sem (Rec g h0 h1 j) l = sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l).
-----
Lemma simpl_Rec : forall g h0 h1 j l, Sem (Rec g h0 h1 j) l = sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l).

*****

*****
forall (g h0 h1 j : Cobham) (l : list (list bool)), eq (Sem (Rec g h0 h1 j) l) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))
+++++
Proof.
-----
Lemma simpl_Rec : forall g h0 h1 j l, Sem (Rec g h0 h1 j) l = sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l).
Proof.

*****

*****
forall (g h0 h1 j : Cobham) (l : list (list bool)), eq (Sem (Rec g h0 h1 j) l) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))
+++++
intros.
-----
Lemma simpl_Rec : forall g h0 h1 j l, Sem (Rec g h0 h1 j) l = sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l).
Proof.
intros.

*****
l : list (list bool)
g,h0,h1,j : Cobham
*****
eq (Sem (Rec g h0 h1 j) l) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))
+++++
simpl.
-----
Lemma simpl_Rec : forall g h0 h1 j l, Sem (Rec g h0 h1 j) l = sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l).
Proof.
intros.
simpl.

*****
l : list (list bool)
g,h0,h1,j : Cobham
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))
+++++
trivial.
-----
Lemma simpl_Rec : forall g h0 h1 j l, Sem (Rec g h0 h1 j) l = sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l).
Proof.
intros.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma Sem_add_zero : forall e n,\n  arity e = ok_arity n ->\n  forall l,\n  length l <= n ->\n  Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)) (l : list (list bool)) (_ : le (length l) n), eq (Sem e l) (Sem e (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
+++++
Proof.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)) (l : list (list bool)) (_ : le (length l) n), eq (Sem e l) (Sem e (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
+++++
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).

*****

*****
forall (l : list (list bool)) (_ : le (length l) O), eq (Sem Zero l) (Sem Zero (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub O (length l))))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.

*****

*****
forall (l : list (list bool)) (_ : le (length l) O), eq nil nil
+++++
auto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).

*****

*****
forall (n i : nat) (_ : lt i n) (l : list (list bool)) (_ : le (length l) n), eq (Sem (Proj n i) l) (Sem (Proj n i) (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.

*****

*****
forall (n i : nat) (_ : lt i n) (l : list (list bool)) (_ : le (length l) n), eq (nth i l nil) (nth i (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))) nil)
+++++
auto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (n i : nat) (_ : lt i n) (l : list (list bool)) (_ : le (length l) n), eq (nth i l nil) (nth i (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))) nil)
+++++
intros.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
eq (nth i l nil) (nth i (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))) nil)
+++++
destruct (le_lt_dec (length l) i).
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).

*****
l0 : le (length l) i
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
eq (nth i l nil) (nth i (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))) nil)
+++++
rewrite nth_overflow.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).
rewrite nth_overflow.

*****
l0 : le (length l) i
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
eq nil (nth i (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))) nil)
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).
rewrite nth_overflow.
trivial.

*****
l0 : le (length l) i
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
eq nil (nth i (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))) nil)
+++++
rewrite app_nth2.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).
rewrite nth_overflow.
trivial.
rewrite app_nth2.

*****
l0 : le (length l) i
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
eq nil (nth (Init.Nat.sub i (length l)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l)))) nil)
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).
rewrite nth_overflow.
trivial.
rewrite app_nth2.
trivial.

*****
l0 : le (length l) i
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
eq nil (nth (Init.Nat.sub i (length l)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l)))) nil)
+++++
rewrite nth_map_cst.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).
rewrite nth_overflow.
trivial.
rewrite app_nth2.
trivial.
rewrite nth_map_cst.

*****
l0 : le (length l) i
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).
rewrite nth_overflow.
trivial.
rewrite app_nth2.

*****
l0 : le (length l) i
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
ge i (length l)
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).
rewrite nth_overflow.

*****
l0 : le (length l) i
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
le (length l) i
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).

*****
l0 : lt i (length l)
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
eq (nth i l nil) (nth i (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))) nil)
+++++
rewrite app_nth1.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).
rewrite app_nth1.

*****
l0 : lt i (length l)
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
eq (nth i l nil) (nth i l nil)
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct (le_lt_dec (length l) i).
rewrite app_nth1.

*****
l0 : lt i (length l)
H0 : le (length l) n
l : list (list bool)
H : lt i n
n,i : nat
*****
lt i (length l)
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).

*****

*****
forall (b : bool) (l : list (list bool)) (_ : le (length l) (S O)), eq (Sem (Succ b) l) (Sem (Succ b) (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S O) (length l))))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.

*****

*****
forall (b : bool) (l : list (list bool)) (_ : le (length l) (S O)), eq (cons b (hd nil l)) (cons b (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S O | S _ => O end)))))
+++++
auto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (b : bool) (l : list (list bool)) (_ : le (length l) (S O)), eq (cons b (hd nil l)) (cons b (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S O | S _ => O end)))))
+++++
intros.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H : le (length l) (S O)
l : list (list bool)
b : bool
*****
eq (cons b (hd nil l)) (cons b (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S O | S _ => O end)))))
+++++
f_equal.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.

*****
H : le (length l) (S O)
l : list (list bool)
b : bool
*****
eq (hd nil l) (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S O | S _ => O end))))
+++++
destruct l.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.

*****
H : le (length nil) (S O)
b : bool
*****
eq (hd nil nil) (hd nil (app nil (map (fun _ : nat => nil) (seq O match length nil with | O => S O | S _ => O end))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.

*****
H : le (length nil) (S O)
b : bool
*****
eq nil nil
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.

*****
H : le (length (cons l l0)) (S O)
l0 : list (list bool)
l : list bool
b : bool
*****
eq (hd nil (cons l l0)) (hd nil (app (cons l l0) (map (fun _ : nat => nil) (seq O match length (cons l l0) with | O => S O | S _ => O end))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.

*****
H : le (length (cons l l0)) (S O)
l0 : list (list bool)
l : list bool
b : bool
*****
eq l l
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).

*****

*****
forall (l : list (list bool)) (_ : le (length l) (S (S O))), eq (Sem Smash l) (Sem Smash (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S (S O)) (length l))))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.

*****

*****
forall (l : list (list bool)) (_ : le (length l) (S (S O))), eq (smash_bs (hd nil l) (hd nil (tl l))) (smash_bs (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S O) | S O => S O | S (S _) => O end)))) (hd nil (tl (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S O) | S O => S O | S (S _) => O end))))))
+++++
auto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (l : list (list bool)) (_ : le (length l) (S (S O))), eq (smash_bs (hd nil l) (hd nil (tl l))) (smash_bs (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S O) | S O => S O | S (S _) => O end)))) (hd nil (tl (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S O) | S O => S O | S (S _) => O end))))))
+++++
intros.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H : le (length l) (S (S O))
l : list (list bool)
*****
eq (smash_bs (hd nil l) (hd nil (tl l))) (smash_bs (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S O) | S O => S O | S (S _) => O end)))) (hd nil (tl (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S O) | S O => S O | S (S _) => O end))))))
+++++
f_equal.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.

*****
H : le (length l) (S (S O))
l : list (list bool)
*****
eq (hd nil l) (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S O) | S O => S O | S (S _) => O end))))
+++++
destruct l.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.

*****
H : le (length nil) (S (S O))
*****
eq (hd nil nil) (hd nil (app nil (map (fun _ : nat => nil) (seq O match length nil with | O => S (S O) | S O => S O | S (S _) => O end))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.

*****
H : le (length nil) (S (S O))
*****
eq nil nil
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.

*****
H : le (length (cons l l0)) (S (S O))
l0 : list (list bool)
l : list bool
*****
eq (hd nil (cons l l0)) (hd nil (app (cons l l0) (map (fun _ : nat => nil) (seq O match length (cons l l0) with | O => S (S O) | S O => S O | S (S _) => O end))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.

*****
H : le (length (cons l l0)) (S (S O))
l0 : list (list bool)
l : list bool
*****
eq l l
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.

*****
H : le (length l) (S (S O))
l : list (list bool)
*****
eq (hd nil (tl l)) (hd nil (tl (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S O) | S O => S O | S (S _) => O end)))))
+++++
destruct l.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.

*****
H : le (length nil) (S (S O))
*****
eq (hd nil (tl nil)) (hd nil (tl (app nil (map (fun _ : nat => nil) (seq O match length nil with | O => S (S O) | S O => S O | S (S _) => O end)))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.

*****
H : le (length nil) (S (S O))
*****
eq nil nil
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.

*****
H : le (length (cons l l0)) (S (S O))
l0 : list (list bool)
l : list bool
*****
eq (hd nil (tl (cons l l0))) (hd nil (tl (app (cons l l0) (map (fun _ : nat => nil) (seq O match length (cons l l0) with | O => S (S O) | S O => S O | S (S _) => O end)))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.

*****
H : le (length (cons l l0)) (S (S O))
l0 : list (list bool)
l : list bool
*****
eq (hd nil l0) (hd nil (app l0 (map (fun _ : nat => nil) (seq O match length l0 with | O => S O | S _ => O end))))
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.
trivial.

*****
H : le (length (cons l l0)) (S (S O))
l0 : list (list bool)
l : list bool
*****
eq (hd nil l0) (hd nil (app l0 (map (fun _ : nat => nil) (seq O match length l0 with | O => S O | S _ => O end))))
+++++
destruct l0.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.
trivial.
destruct l0.

*****
H : le (length (cons l nil)) (S (S O))
l : list bool
*****
eq (hd nil nil) (hd nil (app nil (map (fun _ : nat => nil) (seq O match length nil with | O => S O | S _ => O end))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.
trivial.
destruct l0.
simpl.

*****
H : le (length (cons l nil)) (S (S O))
l : list bool
*****
eq nil nil
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.
trivial.
destruct l0.

*****
H : le (length (cons l (cons l0 l1))) (S (S O))
l1 : list (list bool)
l,l0 : list bool
*****
eq (hd nil (cons l0 l1)) (hd nil (app (cons l0 l1) (map (fun _ : nat => nil) (seq O match length (cons l0 l1) with | O => S O | S _ => O end))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
destruct l.
simpl.
trivial.
destruct l0.
simpl.

*****
H : le (length (cons l (cons l0 l1))) (S (S O))
l1 : list (list bool)
l,l0 : list bool
*****
eq l0 l0
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : forall (l : list (list bool)) (_ : le (length l) n), eq (Sem g l) (Sem g (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))) (_ : forall (l : list (list bool)) (_ : le (length l) (S (S n))), eq (Sem h0 l) (Sem h0 (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S (S n)) (length l))))))) (_ : forall (l : list (list bool)) (_ : le (length l) (S (S n))), eq (Sem h1 l) (Sem h1 (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S (S n)) (length l))))))) (_ : forall (l : list (list bool)) (_ : le (length l) (S n)), eq (Sem j l) (Sem j (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l))))))) (l : list (list bool)) (_ : le (length l) (S n)), eq (Sem (Rec g h0 h1 j) l) (Sem (Rec g h0 h1 j) (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l))))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : forall (l : list (list bool)) (_ : le (length l) n), eq (Sem g l) (Sem g (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))) (_ : forall (l : list (list bool)) (_ : le (length l) (S (S n))), eq (Sem h0 l) (Sem h0 (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S n) | S O => S n | S (S l1) => Init.Nat.sub n l1 end))))) (_ : forall (l : list (list bool)) (_ : le (length l) (S (S n))), eq (Sem h1 l) (Sem h1 (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S n) | S O => S n | S (S l1) => Init.Nat.sub n l1 end))))) (_ : forall (l : list (list bool)) (_ : le (length l) (S n)), eq (Sem j l) (Sem j (app l (map (fun _ : nat => nil) (seq O match length l with | O => S n | S l0 => Init.Nat.sub n l0 end))))) (l : list (list bool)) (_ : le (length l) (S n)), eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S n | S l0 => Init.Nat.sub n l0 end)))) (tl (app l (map (fun _ : nat => nil) (seq O match length l with | O => S n | S l0 => Init.Nat.sub n l0 end)))))
+++++
auto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : forall (l : list (list bool)) (_ : le (length l) n), eq (Sem g l) (Sem g (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))) (_ : forall (l : list (list bool)) (_ : le (length l) (S (S n))), eq (Sem h0 l) (Sem h0 (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S n) | S O => S n | S (S l1) => Init.Nat.sub n l1 end))))) (_ : forall (l : list (list bool)) (_ : le (length l) (S (S n))), eq (Sem h1 l) (Sem h1 (app l (map (fun _ : nat => nil) (seq O match length l with | O => S (S n) | S O => S n | S (S l1) => Init.Nat.sub n l1 end))))) (_ : forall (l : list (list bool)) (_ : le (length l) (S n)), eq (Sem j l) (Sem j (app l (map (fun _ : nat => nil) (seq O match length l with | O => S n | S l0 => Init.Nat.sub n l0 end))))) (l : list (list bool)) (_ : le (length l) (S n)), eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S n | S l0 => Init.Nat.sub n l0 end)))) (tl (app l (map (fun _ : nat => nil) (seq O match length l with | O => S n | S l0 => Init.Nat.sub n l0 end)))))
+++++
intros.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H7 : le (length l) (S n)
l : list (list bool)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app l (map (fun _ : nat => nil) (seq O match length l with | O => S n | S l => Init.Nat.sub n l end)))) (tl (app l (map (fun _ : nat => nil) (seq O match length l with | O => S n | S l => Init.Nat.sub n l end)))))
+++++
destruct l.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.

*****
H7 : le (length nil) (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil nil) (tl nil)) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app nil (map (fun _ : nat => nil) (seq O match length nil with | O => S n | S l => Init.Nat.sub n l end)))) (tl (app nil (map (fun _ : nat => nil) (seq O match length nil with | O => S n | S l => Init.Nat.sub n l end)))))
+++++
simpl in *.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem g nil) (Sem g (map (fun _ : nat => nil) (seq (S O) n)))
+++++
try discriminate.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem g nil) (Sem g (map (fun _ : nat => nil) (seq (S O) n)))
+++++
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem g nil) (Sem g (app nil (map (fun _ : nat => nil) (seq (S O) n))))
+++++
rewrite <- seq_shift.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).
rewrite <- seq_shift.

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem g nil) (Sem g (app nil (map (fun _ : nat => nil) (map S (seq O n)))))
+++++
rewrite map_map.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).
rewrite <- seq_shift.
rewrite map_map.

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem g nil) (Sem g (app nil (map (fun _ : nat => nil) (seq O n))))
+++++
replace n with (n - length (@nil bs)).
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).
rewrite <- seq_shift.
rewrite map_map.
replace n with (n - length (@nil bs)).

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem g nil) (Sem g (app nil (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length nil))))))
+++++
apply H3.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).
rewrite <- seq_shift.
rewrite map_map.
replace n with (n - length (@nil bs)).
apply H3.

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length nil) n
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).
rewrite <- seq_shift.
rewrite map_map.
replace n with (n - length (@nil bs)).
apply H3.
trivial.

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length nil) n
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).
rewrite <- seq_shift.
rewrite map_map.
replace n with (n - length (@nil bs)).
apply H3.
trivial.
simpl.

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le O n
+++++
omega.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).
rewrite <- seq_shift.
rewrite map_map.
replace n with (n - length (@nil bs)).

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Init.Nat.sub n (length nil)) n
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).
rewrite <- seq_shift.
rewrite map_map.
replace n with (n - length (@nil bs)).
simpl.

*****
H7 : le O (S n)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Init.Nat.sub n O) n
+++++
omega.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.

*****
H7 : le (length (cons l l0)) (S n)
l0 : list (list bool)
l : list bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (cons l l0)) (tl (cons l l0))) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app (cons l l0) (map (fun _ : nat => nil) (seq O match length (cons l l0) with | O => S n | S l => Init.Nat.sub n l end)))) (tl (app (cons l l0) (map (fun _ : nat => nil) (seq O match length (cons l l0) with | O => S n | S l => Init.Nat.sub n l end)))))
+++++
simpl in *.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.

*****
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
try discriminate.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.

*****
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
induction l.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.

*****
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) nil l0) (sem_Rec (Sem g) (Sem h0) (Sem h1) nil (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.

*****
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem g l0) (Sem g (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
apply H3.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
apply H3.

*****
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length l0) n
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
apply H3.
trivial.

*****
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length l0) n
+++++
omega.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (cons a l) l0) (sem_Rec (Sem g) (Sem h0) (Sem h1) (cons a l) (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0)))))) (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0)))))) (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))))
+++++
rewrite <- IHl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))))
+++++
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (if a then Sem h1 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))) else Sem h0 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (if a then Sem h1 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))) else Sem h0 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
case a.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (Sem h1 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
erewrite H5.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H5.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem h1 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O match length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) with | O => S (S n) | S O => S n | S (S l0) => Init.Nat.sub n l0 end)))) (Sem h1 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
eauto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H5.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (S (S n))
+++++
eauto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H5.
eauto.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (S (S n))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H5.
eauto.
simpl.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S (S (length l0))) (S (S n))
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H5.
eauto.
simpl.
trivial.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S (S (length l0))) (S (S n))
+++++
omega.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (Sem h0 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
erewrite H4.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H4.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem h0 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O match length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) with | O => S (S n) | S O => S n | S (S l0) => Init.Nat.sub n l0 end)))) (Sem h0 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
+++++
eauto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H4.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (S (S n))
+++++
eauto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H4.
eauto.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (S (S n))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H4.
eauto.
simpl.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S (S (length l0))) (S (S n))
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).
trivial.
case a.
erewrite H4.
eauto.
simpl.
trivial.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S (S (length l0))) (S (S n))
+++++
omega.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ (map (fun _ : nat => nil) (seq 0 (n - length l0)))).

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l\n (app l0\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))))
H7 : le (S (length l0)) (S n)
l0 : list (list bool)
l : list bool
a : bool
H6 : forall (l : list (list bool)) (_ : le (length l) (S n)),\neq (Sem j l)\n (Sem j\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S n\n | S l0 => Init.Nat.sub n l0\n end))))
H5 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h1 l)\n (Sem h1\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H4 : forall (l : list (list bool)) (_ : le (length l) (S (S n))),\neq (Sem h0 l)\n (Sem h0\n (app l\n (map (fun _ : nat => nil)\n (seq O\n match length l with\n | O => S (S n)\n | S O => S n\n | S (S l1) => Init.Nat.sub n l1\n end))))
H3 : forall (l : list (list bool)) (_ : le (length l) n),\neq (Sem g l)\n (Sem g\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0))))) (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (app l0 (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l0)))))))
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : forall (l : list (list bool)) (_ : le (length l) (length rl)), eq (Sem h l) (Sem h (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (length rl) (length l))))))) (_ : forall (r : Cobham) (_ : In r rl) (l : list (list bool)) (_ : le (length l) n), eq (Sem r l) (Sem r (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))) (l : list (list bool)) (_ : le (length l) n), eq (Sem (Comp n h rl) l) (Sem (Comp n h rl) (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
+++++
simpl.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : forall (l : list (list bool)) (_ : le (length l) (length rl)), eq (Sem h l) (Sem h (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (length rl) (length l))))))) (_ : forall (r : Cobham) (_ : In r rl) (l : list (list bool)) (_ : le (length l) n), eq (Sem r l) (Sem r (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))) (l : list (list bool)) (_ : le (length l) n), eq (Sem h (map (fun e : Cobham => Sem e l) rl)) (Sem h (map (fun e : Cobham => Sem e (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l)))))) rl))
+++++
auto.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : forall (l : list (list bool)) (_ : le (length l) (length rl)), eq (Sem h l) (Sem h (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (length rl) (length l))))))) (_ : forall (r : Cobham) (_ : In r rl) (l : list (list bool)) (_ : le (length l) n), eq (Sem r l) (Sem r (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))) (l : list (list bool)) (_ : le (length l) n), eq (Sem h (map (fun e : Cobham => Sem e l) rl)) (Sem h (map (fun e : Cobham => Sem e (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l)))))) rl))
+++++
intros.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H3 : le (length l) n
l : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l : list (list bool))\n (_ : le (length l) n),\neq (Sem r l)\n (Sem r\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H1 : forall (l : list (list bool)) (_ : le (length l) (length rl)),\neq (Sem h l)\n (Sem h\n (app l\n (map (fun _ : nat => nil)\n (seq O (Init.Nat.sub (length rl) (length l))))))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (Sem h (map (fun e : Cobham => Sem e l) rl)) (Sem h (map (fun e : Cobham => Sem e (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l)))))) rl))
+++++
f_equal.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.

*****
H3 : le (length l) n
l : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l : list (list bool))\n (_ : le (length l) n),\neq (Sem r l)\n (Sem r\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H1 : forall (l : list (list bool)) (_ : le (length l) (length rl)),\neq (Sem h l)\n (Sem h\n (app l\n (map (fun _ : nat => nil)\n (seq O (Init.Nat.sub (length rl) (length l))))))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (map (fun e : Cobham => Sem e l) rl) (map (fun e : Cobham => Sem e (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l)))))) rl)
+++++
apply map_ext2.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
apply map_ext2.

*****
H3 : le (length l) n
l : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l : list (list bool))\n (_ : le (length l) n),\neq (Sem r l)\n (Sem r\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H1 : forall (l : list (list bool)) (_ : le (length l) (length rl)),\neq (Sem h l)\n (Sem h\n (app l\n (map (fun _ : nat => nil)\n (seq O (Init.Nat.sub (length rl) (length l))))))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
forall (a : Cobham) (_ : In a rl), eq (Sem a l) (Sem a (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
+++++
intros.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
apply map_ext2.
intros.

*****
H4 : In a rl
a : Cobham
H3 : le (length l) n
l : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l : list (list bool))\n (_ : le (length l) n),\neq (Sem r l)\n (Sem r\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H1 : forall (l : list (list bool)) (_ : le (length l) (length rl)),\neq (Sem h l)\n (Sem h\n (app l\n (map (fun _ : nat => nil)\n (seq O (Init.Nat.sub (length rl) (length l))))))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (Sem a l) (Sem a (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
+++++
eapply H2.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
apply map_ext2.
intros.
eapply H2.

*****
H4 : In a rl
a : Cobham
H3 : le (length l) n
l : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l : list (list bool))\n (_ : le (length l) n),\neq (Sem r l)\n (Sem r\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H1 : forall (l : list (list bool)) (_ : le (length l) (length rl)),\neq (Sem h l)\n (Sem h\n (app l\n (map (fun _ : nat => nil)\n (seq O (Init.Nat.sub (length rl) (length l))))))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
In a rl
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
apply map_ext2.
intros.
eapply H2.

*****
H4 : In a rl
a : Cobham
H3 : le (length l) n
l : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l : list (list bool))\n (_ : le (length l) n),\neq (Sem r l)\n (Sem r\n (app l\n (map (fun _ : nat => nil) (seq O (Init.Nat.sub n (length l))))))
H1 : forall (l : list (list bool)) (_ : le (length l) (length rl)),\neq (Sem h l)\n (Sem h\n (app l\n (map (fun _ : nat => nil)\n (seq O (Init.Nat.sub (length rl) (length l))))))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
le (length l) n
+++++
trivial.
-----
Lemma Sem_add_zero : forall e n, arity e = ok_arity n -> forall l, length l <= n -> Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).
Proof.
refine (Cobham_ind_inf (fun n e => forall l : list bs, length l <= n -> Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _).

*****

*****

+++++
Qed.
-----
Lemma Sem_remove_zero : forall e n,\n  arity e = ok_arity n ->\n  forall l l',  n = length l ->\n    Sem e l = Sem e (l ++ l').
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)) (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem e l) (Sem e (app l l'))
+++++
Proof.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)) (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem e l) (Sem e (app l l'))
+++++
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).

*****

*****
forall (l l' : list (list bool)) (_ : eq O (length l)), eq (Sem Zero l) (Sem Zero (app l l'))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.

*****

*****
forall (l _ : list (list bool)) (_ : eq O (length l)), eq nil nil
+++++
auto.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).

*****

*****
forall (n i : nat) (_ : lt i n) (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem (Proj n i) l) (Sem (Proj n i) (app l l'))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.

*****

*****
forall (n i : nat) (_ : lt i n) (l l' : list (list bool)) (_ : eq n (length l)), eq (nth i l nil) (nth i (app l l') nil)
+++++
auto.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (n i : nat) (_ : lt i n) (l l' : list (list bool)) (_ : eq n (length l)), eq (nth i l nil) (nth i (app l l') nil)
+++++
intros.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H0 : eq n (length l)
l,l' : list (list bool)
H : lt i n
n,i : nat
*****
eq (nth i l nil) (nth i (app l l') nil)
+++++
rewrite app_nth1.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
rewrite app_nth1.

*****
H0 : eq n (length l)
l,l' : list (list bool)
H : lt i n
n,i : nat
*****
eq (nth i l nil) (nth i l nil)
+++++
trivial.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
rewrite app_nth1.

*****
H0 : eq n (length l)
l,l' : list (list bool)
H : lt i n
n,i : nat
*****
lt i (length l)
+++++
trivial.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
rewrite app_nth1.
trivial.

*****
H0 : eq n (length l)
l,l' : list (list bool)
H : lt i n
n,i : nat
*****
lt i (length l)
+++++
omega.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).

*****

*****
forall (b : bool) (l l' : list (list bool)) (_ : eq (S O) (length l)), eq (Sem (Succ b) l) (Sem (Succ b) (app l l'))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.

*****

*****
forall (b : bool) (l l' : list (list bool)) (_ : eq (S O) (length l)), eq (cons b (hd nil l)) (cons b (hd nil (app l l')))
+++++
auto.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (b : bool) (l l' : list (list bool)) (_ : eq (S O) (length l)), eq (cons b (hd nil l)) (cons b (hd nil (app l l')))
+++++
intros.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H : eq (S O) (length l)
l,l' : list (list bool)
b : bool
*****
eq (cons b (hd nil l)) (cons b (hd nil (app l l')))
+++++
destruct l.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.

*****
H : eq (S O) (length nil)
l' : list (list bool)
b : bool
*****
eq (cons b (hd nil nil)) (cons b (hd nil (app nil l')))
+++++
simpl in *.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.

*****
H : eq (S O) O
l' : list (list bool)
b : bool
*****
eq (cons b nil) (cons b (hd nil l'))
+++++
try discriminate.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.

*****
H : eq (S O) (length (cons l l0))
l0,l' : list (list bool)
l : list bool
b : bool
*****
eq (cons b (hd nil (cons l l0))) (cons b (hd nil (app (cons l l0) l')))
+++++
simpl in *.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.

*****
H : eq (S O) (S (length l0))
l0,l' : list (list bool)
l : list bool
b : bool
*****
eq (cons b l) (cons b l)
+++++
try discriminate.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.

*****
H : eq (S O) (S (length l0))
l0,l' : list (list bool)
l : list bool
b : bool
*****
eq (cons b l) (cons b l)
+++++
trivial.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).

*****

*****
forall (l l' : list (list bool)) (_ : eq (S (S O)) (length l)), eq (Sem Smash l) (Sem Smash (app l l'))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.

*****

*****
forall (l l' : list (list bool)) (_ : eq (S (S O)) (length l)), eq (smash_bs (hd nil l) (hd nil (tl l))) (smash_bs (hd nil (app l l')) (hd nil (tl (app l l'))))
+++++
auto.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (l l' : list (list bool)) (_ : eq (S (S O)) (length l)), eq (smash_bs (hd nil l) (hd nil (tl l))) (smash_bs (hd nil (app l l')) (hd nil (tl (app l l'))))
+++++
intros.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H : eq (S (S O)) (length l)
l,l' : list (list bool)
*****
eq (smash_bs (hd nil l) (hd nil (tl l))) (smash_bs (hd nil (app l l')) (hd nil (tl (app l l'))))
+++++
destruct l.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.

*****
H : eq (S (S O)) (length nil)
l' : list (list bool)
*****
eq (smash_bs (hd nil nil) (hd nil (tl nil))) (smash_bs (hd nil (app nil l')) (hd nil (tl (app nil l'))))
+++++
simpl in *.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.

*****
H : eq (S (S O)) O
l' : list (list bool)
*****
eq (cons true nil) (smash_bs (hd nil l') (hd nil (tl l')))
+++++
try discriminate.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.

*****
H : eq (S (S O)) (length (cons l l0))
l0,l' : list (list bool)
l : list bool
*****
eq (smash_bs (hd nil (cons l l0)) (hd nil (tl (cons l l0)))) (smash_bs (hd nil (app (cons l l0) l')) (hd nil (tl (app (cons l l0) l'))))
+++++
simpl in *.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.

*****
H : eq (S (S O)) (S (length l0))
l0,l' : list (list bool)
l : list bool
*****
eq (smash_bs l (hd nil l0)) (smash_bs l (hd nil (app l0 l')))
+++++
try discriminate.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.

*****
H : eq (S (S O)) (S (length l0))
l0,l' : list (list bool)
l : list bool
*****
eq (smash_bs l (hd nil l0)) (smash_bs l (hd nil (app l0 l')))
+++++
trivial.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
trivial.

*****
H : eq (S (S O)) (S (length l0))
l0,l' : list (list bool)
l : list bool
*****
eq (smash_bs l (hd nil l0)) (smash_bs l (hd nil (app l0 l')))
+++++
destruct l0.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
trivial.
destruct l0.

*****
H : eq (S (S O)) (S (length nil))
l' : list (list bool)
l : list bool
*****
eq (smash_bs l (hd nil nil)) (smash_bs l (hd nil (app nil l')))
+++++
simpl in *.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
trivial.
destruct l0.
simpl in *.

*****
H : eq (S (S O)) (S O)
l' : list (list bool)
l : list bool
*****
eq (smash_bs l nil) (smash_bs l (hd nil l'))
+++++
try discriminate.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
trivial.
destruct l0.

*****
H : eq (S (S O)) (S (length (cons l0 l1)))
l1,l' : list (list bool)
l,l0 : list bool
*****
eq (smash_bs l (hd nil (cons l0 l1))) (smash_bs l (hd nil (app (cons l0 l1) l')))
+++++
simpl in *.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
trivial.
destruct l0.
simpl in *.

*****
H : eq (S (S O)) (S (S (length l1)))
l1,l' : list (list bool)
l,l0 : list bool
*****
eq (smash_bs l l0) (smash_bs l l0)
+++++
try discriminate.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
trivial.
destruct l0.
simpl in *.
try discriminate.

*****
H : eq (S (S O)) (S (S (length l1)))
l1,l' : list (list bool)
l,l0 : list bool
*****
eq (smash_bs l l0) (smash_bs l l0)
+++++
trivial.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : forall (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem g l) (Sem g (app l l'))) (_ : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)), eq (Sem h0 l) (Sem h0 (app l l'))) (_ : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)), eq (Sem h1 l) (Sem h1 (app l l'))) (_ : forall (l l' : list (list bool)) (_ : eq (S n) (length l)), eq (Sem j l) (Sem j (app l l'))) (l l' : list (list bool)) (_ : eq (S n) (length l)), eq (Sem (Rec g h0 h1 j) l) (Sem (Rec g h0 h1 j) (app l l'))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : forall (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem g l) (Sem g (app l l'))) (_ : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)), eq (Sem h0 l) (Sem h0 (app l l'))) (_ : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)), eq (Sem h1 l) (Sem h1 (app l l'))) (_ : forall (l l' : list (list bool)) (_ : eq (S n) (length l)), eq (Sem j l) (Sem j (app l l'))) (l l' : list (list bool)) (_ : eq (S n) (length l)), eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app l l')) (tl (app l l')))
+++++
auto.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : forall (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem g l) (Sem g (app l l'))) (_ : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)), eq (Sem h0 l) (Sem h0 (app l l'))) (_ : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)), eq (Sem h1 l) (Sem h1 (app l l'))) (_ : forall (l l' : list (list bool)) (_ : eq (S n) (length l)), eq (Sem j l) (Sem j (app l l'))) (l l' : list (list bool)) (_ : eq (S n) (length l)), eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app l l')) (tl (app l l')))
+++++
intros.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H7 : eq (S n) (length l)
l,l' : list (list bool)
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app l l')) (tl (app l l')))
+++++
destruct l.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.

*****
H7 : eq (S n) (length nil)
l' : list (list bool)
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil nil) (tl nil)) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app nil l')) (tl (app nil l')))
+++++
simpl in *.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.

*****
H7 : eq (S n) O
l' : list (list bool)
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem g nil) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l') (tl l'))
+++++
try discriminate.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.

*****
H7 : eq (S n) (length (cons l l0))
l0,l' : list (list bool)
l : list bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (cons l l0)) (tl (cons l l0))) (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil (app (cons l l0) l')) (tl (app (cons l l0) l')))
+++++
simpl in *.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.

*****
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
+++++
try discriminate.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.

*****
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
+++++
induction l.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.

*****
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) nil l0) (sem_Rec (Sem g) (Sem h0) (Sem h1) nil (app l0 l'))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.

*****
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem g l0) (Sem g (app l0 l'))
+++++
eapply H3.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
eapply H3.

*****
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq n (length l0)
+++++
eauto.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (sem_Rec (Sem g) (Sem h0) (Sem h1) (cons a l) l0) (sem_Rec (Sem g) (Sem h0) (Sem h1) (cons a l) (app l0 l'))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l')) (app l0 l'))) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l')) (app l0 l'))))
+++++
rewrite <- IHl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (app l0 l'))) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (app l0 l'))))
+++++
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (if a then Sem h1 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) l') else Sem h0 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) l'))
+++++
trivial.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
trivial.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if a then Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) else Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (if a then Sem h1 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) l') else Sem h0 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) l'))
+++++
case a.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
trivial.
case a.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem h1 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (Sem h1 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) l'))
+++++
eapply H5.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
trivial.
case a.
eapply H5.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S (S n)) (length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)))
+++++
eauto.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
trivial.
case a.
eapply H5.
eauto.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S (S n)) (length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
trivial.
case a.
eapply H5.
eauto.
simpl.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S (S n)) (S (S (length l0)))
+++++
omega.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
trivial.
case a.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Sem h0 (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0))) (Sem h0 (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) l'))
+++++
eapply H4.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
trivial.
case a.
eapply H4.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S (S n)) (length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)))
+++++
eauto.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
trivial.
case a.
eapply H4.
eauto.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S (S n)) (length (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').
trivial.
case a.
eapply H4.
eauto.
simpl.

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S (S n)) (S (S (length l0)))
+++++
omega.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
destruct l.
simpl in *.
try discriminate.
induction l.
simpl.
rewrite <- IHl.
replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l').

*****
IHl : eq (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0)\n (sem_Rec (Sem g) (Sem h0) (Sem h1) l (app l0 l'))
H7 : eq (S n) (S (length l0))
l0,l' : list (list bool)
l : list bool
a : bool
H6 : forall (l l' : list (list bool)) (_ : eq (S n) (length l)),\neq (Sem j l) (Sem j (app l l'))
H5 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h1 l) (Sem h1 (app l l'))
H4 : forall (l l' : list (list bool)) (_ : eq (S (S n)) (length l)),\neq (Sem h0 l) (Sem h0 (app l l'))
H3 : forall (l l' : list (list bool)) (_ : eq n (length l)),\neq (Sem g l) (Sem g (app l l'))
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (app (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) l0)) l') (cons l (cons (sem_Rec (Sem g) (Sem h0) (Sem h1) l l0) (app l0 l')))
+++++
trivial.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : forall (l l' : list (list bool)) (_ : eq (length rl) (length l)), eq (Sem h l) (Sem h (app l l'))) (_ : forall (r : Cobham) (_ : In r rl) (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem r l) (Sem r (app l l'))) (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem (Comp n h rl) l) (Sem (Comp n h rl) (app l l'))
+++++
simpl.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : forall (l l' : list (list bool)) (_ : eq (length rl) (length l)), eq (Sem h l) (Sem h (app l l'))) (_ : forall (r : Cobham) (_ : In r rl) (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem r l) (Sem r (app l l'))) (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem h (map (fun e : Cobham => Sem e l) rl)) (Sem h (map (fun e : Cobham => Sem e (app l l')) rl))
+++++
auto.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : forall (l l' : list (list bool)) (_ : eq (length rl) (length l)), eq (Sem h l) (Sem h (app l l'))) (_ : forall (r : Cobham) (_ : In r rl) (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem r l) (Sem r (app l l'))) (l l' : list (list bool)) (_ : eq n (length l)), eq (Sem h (map (fun e : Cobham => Sem e l) rl)) (Sem h (map (fun e : Cobham => Sem e (app l l')) rl))
+++++
intros.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H3 : eq n (length l)
l,l' : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l l' : list (list bool))\n (_ : eq n (length l)), eq (Sem r l) (Sem r (app l l'))
H1 : forall (l l' : list (list bool)) (_ : eq (length rl) (length l)),\neq (Sem h l) (Sem h (app l l'))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (Sem h (map (fun e : Cobham => Sem e l) rl)) (Sem h (map (fun e : Cobham => Sem e (app l l')) rl))
+++++
f_equal.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.

*****
H3 : eq n (length l)
l,l' : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l l' : list (list bool))\n (_ : eq n (length l)), eq (Sem r l) (Sem r (app l l'))
H1 : forall (l l' : list (list bool)) (_ : eq (length rl) (length l)),\neq (Sem h l) (Sem h (app l l'))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (map (fun e : Cobham => Sem e l) rl) (map (fun e : Cobham => Sem e (app l l')) rl)
+++++
apply map_ext2.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
apply map_ext2.

*****
H3 : eq n (length l)
l,l' : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l l' : list (list bool))\n (_ : eq n (length l)), eq (Sem r l) (Sem r (app l l'))
H1 : forall (l l' : list (list bool)) (_ : eq (length rl) (length l)),\neq (Sem h l) (Sem h (app l l'))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
forall (a : Cobham) (_ : In a rl), eq (Sem a l) (Sem a (app l l'))
+++++
intros.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
apply map_ext2.
intros.

*****
H4 : In a rl
a : Cobham
H3 : eq n (length l)
l,l' : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l l' : list (list bool))\n (_ : eq n (length l)), eq (Sem r l) (Sem r (app l l'))
H1 : forall (l l' : list (list bool)) (_ : eq (length rl) (length l)),\neq (Sem h l) (Sem h (app l l'))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (Sem a l) (Sem a (app l l'))
+++++
eapply H2.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
apply map_ext2.
intros.
eapply H2.

*****
H4 : In a rl
a : Cobham
H3 : eq n (length l)
l,l' : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l l' : list (list bool))\n (_ : eq n (length l)), eq (Sem r l) (Sem r (app l l'))
H1 : forall (l l' : list (list bool)) (_ : eq (length rl) (length l)),\neq (Sem h l) (Sem h (app l l'))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
In a rl
+++++
trivial.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).
simpl.
auto.
intros.
f_equal.
apply map_ext2.
intros.
eapply H2.

*****
H4 : In a rl
a : Cobham
H3 : eq n (length l)
l,l' : list (list bool)
H2 : forall (r : Cobham) (_ : In r rl) (l l' : list (list bool))\n (_ : eq n (length l)), eq (Sem r l) (Sem r (app l l'))
H1 : forall (l l' : list (list bool)) (_ : eq (length rl) (length l)),\neq (Sem h l) (Sem h (app l l'))
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq n (length l)
+++++
trivial.
-----
Lemma Sem_remove_zero : forall e n, arity e = ok_arity n -> forall l l', n = length l -> Sem e l = Sem e (l ++ l').
Proof.
refine (Cobham_ind_inf (fun n e => forall l l', n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _).

*****

*****

+++++
Qed.
-----
Fixpoint rec_bounded' (e : Cobham) : Prop :=\n  match e with\n    | Rec g h0 h1 j =>\n      rec_bounded' j  /\ \n      rec_bounded' g /\ \n      rec_bounded' h0 /\ \n      rec_bounded' h1 /\\n      (match (arity e) with\n         | ok_arity n => forall l, length l = n ->\n           length (Sem e l) <= length (Sem j l)\n        | _ => True \n       end)\n    | Comp n h l => rec_bounded' h /\\n        andl rec_bounded' l\n    | _ => True\n  end.
-----
Fixpoint rec_bounded (e : Cobham) : Prop :=\n  match e with\n    | Rec g h0 h1 j =>\n      rec_bounded j  /\ \n      rec_bounded g /\ \n      rec_bounded h0 /\ \n      rec_bounded h1 /\\n      (forall l, \n        length (Sem e l) <= length (Sem j l))\n    | Comp n h l => rec_bounded h /\\n        andl rec_bounded l\n    | _ => True\n  end.
-----
Lemma rec_bounded_spec (e : Cobham) :\n  rec_bounded e -> rec_bounded' e.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.

*****
e : Cobham
*****
forall _ : rec_bounded e, rec_bounded' e
+++++
Proof.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.

*****
e : Cobham
*****
forall _ : rec_bounded e, rec_bounded' e
+++++
induction e using Cobham_ind2.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.

*****

*****
forall _ : rec_bounded Zero, rec_bounded' Zero
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.

*****

*****
forall _ : True, True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.

*****
n,i : nat
*****
forall _ : rec_bounded (Proj n i), rec_bounded' (Proj n i)
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.

*****
n,i : nat
*****
forall _ : True, True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.

*****
b : bool
*****
forall _ : rec_bounded (Succ b), rec_bounded' (Succ b)
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.

*****
b : bool
*****
forall _ : True, True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.

*****

*****
forall _ : rec_bounded Smash, rec_bounded' Smash
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.

*****

*****
forall _ : True, True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.

*****
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : rec_bounded (Rec e1 e2 e3 e4), rec_bounded' (Rec e1 e2 e3 e4)
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.

*****
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : and (rec_bounded e4) (and (rec_bounded e1) (and (rec_bounded e2) (and (rec_bounded e3) (forall l : list (list bool), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)))))), and (rec_bounded' e4) (and (rec_bounded' e1) (and (rec_bounded' e2) (and (rec_bounded' e3) match match arity e1 with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4) | error_Comp a l => error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4) | ok_arity gn => match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (error_Proj n n0) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n n0) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n n0) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end)))
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.

*****
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : and (rec_bounded e4) (and (rec_bounded e1) (and (rec_bounded e2) (and (rec_bounded e3) (forall l : list (list bool), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)))))), and (rec_bounded' e4) (and (rec_bounded' e1) (and (rec_bounded' e2) (and (rec_bounded' e3) match match arity e1 with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4) | error_Comp a l => error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4) | ok_arity gn => match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (error_Proj n n0) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n n0) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n n0) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end)))
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.

*****
H : and (rec_bounded e4)\n (and (rec_bounded e1)\n (and (rec_bounded e2)\n (and (rec_bounded e3)\n (forall l : list (list bool),\n le\n (length\n (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))))))
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
and (rec_bounded' e4) (and (rec_bounded' e1) (and (rec_bounded' e2) (and (rec_bounded' e3) match match arity e1 with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4) | error_Comp a l => error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4) | ok_arity gn => match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (error_Proj n n0) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n n0) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n n0) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end)))
+++++
decompose [and] H.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
H : and (rec_bounded e4)\n (and (rec_bounded e1)\n (and (rec_bounded e2)\n (and (rec_bounded e3)\n (forall l : list (list bool),\n le\n (length\n (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))))))
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
and (rec_bounded' e4) (and (rec_bounded' e1) (and (rec_bounded' e2) (and (rec_bounded' e3) match match arity e1 with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4) | error_Comp a l => error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4) | ok_arity gn => match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (error_Proj n n0) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n n0) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n n0) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end)))
+++++
clear H.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
and (rec_bounded' e4) (and (rec_bounded' e1) (and (rec_bounded' e2) (and (rec_bounded' e3) match match arity e1 with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4) | error_Comp a l => error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4) | ok_arity gn => match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (error_Proj n n0) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n n0) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n n0) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end)))
+++++
repeat (split; try tauto).
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e1 with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity e2) (arity e3) (arity e4) | error_Comp a l => error_Rec (error_Comp a l) (arity e2) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (error_Proj n n0) (arity e2) (arity e3) (arity e4) | ok_arity gn => match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity e3) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (error_Proj n n0) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n n0) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n n0) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
case_eq (arity e1).
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (a a0 a1 a2 : Arity) (_ : eq (arity e1) (error_Rec a a0 a1 a2)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.

*****
H : eq (arity e1) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.

*****
H : eq (arity e1) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (a : Arity) (l : list Arity) (_ : eq (arity e1) (error_Comp a l)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.

*****
H : eq (arity e1) (error_Comp a l)
l : list Arity
a : Arity
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.

*****
H : eq (arity e1) (error_Comp a l)
l : list Arity
a : Arity
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (n n0 : nat) (_ : eq (arity e1) (error_Proj n n0)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.

*****
H : eq (arity e1) (error_Proj n n0)
n,n0 : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.

*****
H : eq (arity e1) (error_Proj n n0)
n,n0 : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (n : nat) (_ : eq (arity e1) (ok_arity n)), match match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (error_Comp a l) (arity e3) (arity e4) | error_Proj n0 n1 => error_Rec (ok_arity n) (error_Proj n0 n1) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (error_Proj n0 n1) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end with | ok_arity n0 => forall (l : list (list bool)) (_ : eq (length l) n0), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.

*****
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (error_Comp a l) (arity e3) (arity e4) | error_Proj n0 n1 => error_Rec (ok_arity n) (error_Proj n0 n1) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (error_Proj n0 n1) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.

*****
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (error_Comp a l) (arity e3) (arity e4) | error_Proj n0 n1 => error_Rec (ok_arity n) (error_Proj n0 n1) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (error_Proj n0 n1) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.

*****
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e2 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (error_Rec a a0 a1 a2) (arity e3) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (error_Comp a l) (arity e3) (arity e4) | error_Proj n0 n1 => error_Rec (ok_arity n) (error_Proj n0 n1) (arity e3) (arity e4) | ok_arity h0n => match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (error_Comp a l) (arity e4) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (error_Proj n0 n1) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
case_eq (arity e2).
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).

*****
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (a a0 a1 a2 : Arity) (_ : eq (arity e2) (error_Rec a a0 a1 a2)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.

*****
H4 : eq (arity e2) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.

*****
H4 : eq (arity e2) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).

*****
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (a : Arity) (l : list Arity) (_ : eq (arity e2) (error_Comp a l)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.

*****
H4 : eq (arity e2) (error_Comp a l)
l : list Arity
a : Arity
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.

*****
H4 : eq (arity e2) (error_Comp a l)
l : list Arity
a : Arity
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).

*****
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (n n0 : nat) (_ : eq (arity e2) (error_Proj n n0)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.

*****
H4 : eq (arity e2) (error_Proj n0 n1)
n0,n1 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.

*****
H4 : eq (arity e2) (error_Proj n0 n1)
n0,n1 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).

*****
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (n0 : nat) (_ : eq (arity e2) (ok_arity n0)), match match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (error_Comp a l) (arity e4) | error_Proj n1 n2 => error_Rec (ok_arity n) (ok_arity n0) (error_Proj n1 n2) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Comp a l) | error_Proj n1 n2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Proj n1 n2) | ok_arity jn => if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n n0)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (ok_arity jn) end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.

*****
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (error_Comp a l) (arity e4) | error_Proj n1 n2 => error_Rec (ok_arity n) (ok_arity n0) (error_Proj n1 n2) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Comp a l) | error_Proj n1 n2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Proj n1 n2) | ok_arity jn => if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n n0)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (ok_arity jn) end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.

*****
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (error_Comp a l) (arity e4) | error_Proj n1 n2 => error_Rec (ok_arity n) (ok_arity n0) (error_Proj n1 n2) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Comp a l) | error_Proj n1 n2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Proj n1 n2) | ok_arity jn => if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n n0)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (ok_arity jn) end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.

*****
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e3 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (error_Rec a a0 a1 a2) (arity e4) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (error_Comp a l) (arity e4) | error_Proj n1 n2 => error_Rec (ok_arity n) (ok_arity n0) (error_Proj n1 n2) (arity e4) | ok_arity h1n => match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Comp a l) | error_Proj n1 n2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (error_Proj n1 n2) | ok_arity jn => if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n n0)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity n0) (ok_arity h1n) (ok_arity jn) end end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
case_eq (arity e3).
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).

*****
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (a a0 a1 a2 : Arity) (_ : eq (arity e3) (error_Rec a a0 a1 a2)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.

*****
H6 : eq (arity e3) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.

*****
H6 : eq (arity e3) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).

*****
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (a : Arity) (l : list Arity) (_ : eq (arity e3) (error_Comp a l)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.

*****
H6 : eq (arity e3) (error_Comp a l)
l : list Arity
a : Arity
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.

*****
H6 : eq (arity e3) (error_Comp a l)
l : list Arity
a : Arity
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).

*****
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (n n0 : nat) (_ : eq (arity e3) (error_Proj n n0)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.

*****
H6 : eq (arity e3) (error_Proj n1 n2)
n1,n2 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.

*****
H6 : eq (arity e3) (error_Proj n1 n2)
n1,n2 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).

*****
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (n1 : nat) (_ : eq (arity e3) (ok_arity n1)), match match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Comp a l) | error_Proj n2 n3 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Proj n2 n3) | ok_arity jn => if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb n1 n0)) match n1 with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (ok_arity jn) end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.

*****
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Comp a l) | error_Proj n2 n3 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Proj n2 n3) | ok_arity jn => if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb n1 n0)) match n1 with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (ok_arity jn) end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.

*****
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Comp a l) | error_Proj n2 n3 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Proj n2 n3) | ok_arity jn => if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb n1 n0)) match n1 with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (ok_arity jn) end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.

*****
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match match arity e4 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Comp a l) | error_Proj n2 n3 => error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (error_Proj n2 n3) | ok_arity jn => if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb n1 n0)) match n1 with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (ok_arity jn) end with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
case_eq (arity e4).
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).

*****
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (a a0 a1 a2 : Arity) (_ : eq (arity e4) (error_Rec a a0 a1 a2)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.

*****
H7 : eq (arity e4) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.

*****
H7 : eq (arity e4) (error_Rec a a0 a1 a2)
a,a0,a1,a2 : Arity
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).

*****
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (a : Arity) (l : list Arity) (_ : eq (arity e4) (error_Comp a l)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.

*****
H7 : eq (arity e4) (error_Comp a l)
l : list Arity
a : Arity
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.

*****
H7 : eq (arity e4) (error_Comp a l)
l : list Arity
a : Arity
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).

*****
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (n n0 : nat) (_ : eq (arity e4) (error_Proj n n0)), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.

*****
H7 : eq (arity e4) (error_Proj n2 n3)
n2,n3 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.

*****
H7 : eq (arity e4) (error_Proj n2 n3)
n2,n3 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).

*****
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (n2 : nat) (_ : eq (arity e4) (ok_arity n2)), match (if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb n1 n0)) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb n1 n0)) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb n1 n0)) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity n0)
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb match n0 with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb n1 n0)) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity n0) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
destruct n0.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity O)
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb false (Nat.eqb n1 O)) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity O) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity O)
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity O)
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity O)
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S n0))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb match n0 with | O => false | S m' => Nat.eqb n m' end (Nat.eqb n1 (S n0))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S n0)) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S n0))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb match n0 with | O => false | S m' => Nat.eqb n m' end (Nat.eqb n1 (S n0))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S n0)) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S n0))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb match n0 with | O => false | S m' => Nat.eqb n m' end (Nat.eqb n1 (S n0))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S n0)) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S n0))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb match n0 with | O => false | S m' => Nat.eqb n m' end (Nat.eqb n1 (S n0))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S n0)) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S n0))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb match n0 with | O => false | S m' => Nat.eqb n m' end (Nat.eqb n1 (S n0))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S n0)) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
destruct n0.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S O))
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb false (Nat.eqb n1 (S O))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S O)) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S O))
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S O))
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S O))
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb (Nat.eqb n n0) (Nat.eqb n1 (S (S n0)))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb (Nat.eqb n n0) (Nat.eqb n1 (S (S n0)))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb (Nat.eqb n n0) (Nat.eqb n1 (S (S n0)))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb (Nat.eqb n n0) (Nat.eqb n1 (S (S n0)))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (andb (Nat.eqb n n0) (Nat.eqb n1 (S (S n0)))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
case_eq (beq_nat n n0).
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n n0) true, match (if andb (andb true (Nat.eqb n1 (S (S n0)))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n n0) true, match (if andb (Nat.eqb n1 (S (S n0))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.

*****
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (Nat.eqb n1 (S (S n0))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.

*****
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (Nat.eqb n1 (S (S n0))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.

*****
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if andb (Nat.eqb n1 (S (S n0))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
case_eq (beq_nat n1 (S (S n0))).
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).

*****
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n1 (S (S n0))) true, match (if andb true match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.

*****
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n1 (S (S n0))) true, match (if match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.

*****
H9 : eq (Nat.eqb n1 (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.

*****
H9 : eq (Nat.eqb n1 (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.

*****
H9 : eq (Nat.eqb n1 (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
destruct n1.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.

*****
H9 : eq (Nat.eqb O (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity O)
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.

*****
H9 : eq (Nat.eqb O (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity O)
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.

*****
H9 : eq (Nat.eqb O (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity O)
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.

*****
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if Nat.eqb n2 n1 then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity (S n1)) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.

*****
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if Nat.eqb n2 n1 then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity (S n1)) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.

*****
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if Nat.eqb n2 n1 then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity (S n1)) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.

*****
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if Nat.eqb n2 n1 then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity (S n1)) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.

*****
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
match (if Nat.eqb n2 n1 then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity (S n1)) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
case_eq (beq_nat n2 n1).
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n2 n1).

*****
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (_ : eq (Nat.eqb n2 n1) true) (l : list (list bool)) (_ : eq (length l) n2), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l))
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n2 n1).
simpl.

*****
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall (_ : eq (Nat.eqb n2 n1) true) (l : list (list bool)) (_ : eq (length l) n2), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l))
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n2 n1).
simpl.
intros.

*****
H11 : eq (length l) n2
l : list (list bool)
H10 : eq (Nat.eqb n2 n1) true
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l))
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n2 n1).
simpl.
intros.
try discriminate.

*****
H11 : eq (length l) n2
l : list (list bool)
H10 : eq (Nat.eqb n2 n1) true
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l))
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n2 n1).

*****
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n2 n1) false, True
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n2 n1).
simpl.

*****
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n2 n1) false, True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n2 n1).
simpl.
intros.

*****
H10 : eq (Nat.eqb n2 n1) false
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.
auto.
destruct n1.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n2 n1).
simpl.
intros.
try discriminate.

*****
H10 : eq (Nat.eqb n2 n1) false
H9 : eq (Nat.eqb (S n1) (S (S n0))) true
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity (S n1))
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).

*****
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n1 (S (S n0))) false, match (if andb false match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.

*****
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n1 (S (S n0))) false, True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.

*****
H9 : eq (Nat.eqb n1 (S (S n0))) false
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n1 (S (S n0))).
simpl.
intros.
try discriminate.

*****
H9 : eq (Nat.eqb n1 (S (S n0))) false
H8 : eq (Nat.eqb n n0) true
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n n0) false, match (if andb (andb false (Nat.eqb n1 (S (S n0)))) match n1 with | O => false | S m' => Nat.eqb n2 m' end then ok_arity n2 else error_Rec (ok_arity n) (ok_arity (S (S n0))) (ok_arity n1) (ok_arity n2)) with | ok_arity n => forall (l : list (list bool)) (_ : eq (length l) n), le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l))) (length (Sem e4 l)) | _ => True end
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.

*****
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
forall _ : eq (Nat.eqb n n0) false, True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.

*****
H8 : eq (Nat.eqb n n0) false
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
try discriminate.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
decompose [and] H.
clear H.
repeat (split; try tauto).
case_eq (arity e1).
intros.
try discriminate.
auto.
case_eq (arity e2).
intros.
try discriminate.
auto.
case_eq (arity e3).
intros.
try discriminate.
auto.
case_eq (arity e4).
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
destruct n0.
simpl.
intros.
try discriminate.
auto.
case_eq (beq_nat n n0).
simpl.
intros.
try discriminate.

*****
H8 : eq (Nat.eqb n n0) false
H7 : eq (arity e4) (ok_arity n2)
n2 : nat
H6 : eq (arity e3) (ok_arity n1)
n1 : nat
H4 : eq (arity e2) (ok_arity (S (S n0)))
n0 : nat
H : eq (arity e1) (ok_arity n)
n : nat
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
IHe4 : forall _ : rec_bounded e4, rec_bounded' e4
IHe3 : forall _ : rec_bounded e3, rec_bounded' e3
IHe2 : forall _ : rec_bounded e2, rec_bounded' e2
IHe1 : forall _ : rec_bounded e1, rec_bounded' e1
e1,e2,e3,e4 : Cobham
*****
True
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.

*****
IHe : forall _ : rec_bounded e, rec_bounded' e
H : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e), rec_bounded' e
l : list Cobham
e : Cobham
n : nat
*****
forall _ : rec_bounded (Comp n e l), rec_bounded' (Comp n e l)
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.

*****
IHe : forall _ : rec_bounded e, rec_bounded' e
H : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e), rec_bounded' e
l : list Cobham
e : Cobham
n : nat
*****
forall _ : and (rec_bounded e) (andl rec_bounded l), and (rec_bounded' e) (andl rec_bounded' l)
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.

*****
IHe : forall _ : rec_bounded e, rec_bounded' e
H : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e), rec_bounded' e
l : list Cobham
e : Cobham
n : nat
*****
forall _ : and (rec_bounded e) (andl rec_bounded l), and (rec_bounded' e) (andl rec_bounded' l)
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
IHe : forall _ : rec_bounded e, rec_bounded' e
H : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e), rec_bounded' e
l : list Cobham
e : Cobham
n : nat
*****
and (rec_bounded' e) (andl rec_bounded' l)
+++++
split.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
IHe : forall _ : rec_bounded e, rec_bounded' e
H : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e), rec_bounded' e
l : list Cobham
e : Cobham
n : nat
*****
rec_bounded' e
+++++
try tauto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
IHe : forall _ : rec_bounded e, rec_bounded' e
H : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e), rec_bounded' e
l : list Cobham
e : Cobham
n : nat
*****
andl rec_bounded' l
+++++
try tauto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
IHe : forall _ : rec_bounded e, rec_bounded' e
H : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e), rec_bounded' e
l : list Cobham
e : Cobham
n : nat
*****
andl rec_bounded' l
+++++
revert e IHe H0.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.

*****
H : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e), rec_bounded' e
l : list Cobham
n : nat
*****
forall (e : Cobham) (_ : forall _ : rec_bounded e, rec_bounded' e) (_ : and (rec_bounded e) (andl rec_bounded l)), andl rec_bounded' l
+++++
induction l.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.

*****
H : forall (e : Cobham) (_ : In e nil) (_ : rec_bounded e), rec_bounded' e
n : nat
*****
forall (e : Cobham) (_ : forall _ : rec_bounded e, rec_bounded' e) (_ : and (rec_bounded e) (andl rec_bounded nil)), andl rec_bounded' nil
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.

*****
H : forall (e : Cobham) (_ : In e nil) (_ : rec_bounded e), rec_bounded' e
n : nat
*****
forall (e : Cobham) (_ : forall _ : rec_bounded e, rec_bounded' e) (_ : and (rec_bounded e) True), True
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.

*****
H0 : and (rec_bounded e) True
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
H : forall (e : Cobham) (_ : In e nil) (_ : rec_bounded e), rec_bounded' e
n : nat
*****
True
+++++
trivial.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.

*****
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
forall (e : Cobham) (_ : forall _ : rec_bounded e, rec_bounded' e) (_ : and (rec_bounded e) (andl rec_bounded (cons a l))), andl rec_bounded' (cons a l)
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.

*****
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
forall (e : Cobham) (_ : forall _ : rec_bounded e, rec_bounded' e) (_ : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))), and (rec_bounded' a) (andl rec_bounded' l)
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
and (rec_bounded' a) (andl rec_bounded' l)
+++++
trivial.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
and (rec_bounded' a) (andl rec_bounded' l)
+++++
split.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
rec_bounded' a
+++++
apply H.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
apply H.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
In a (cons a l)
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
apply H.
simpl.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
or (eq a a) (In a l)
+++++
tauto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
apply H.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
rec_bounded a
+++++
tauto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
andl rec_bounded' l
+++++
eapply IHl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
eapply IHl.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
forall (e : Cobham) (_ : In e l) (_ : rec_bounded e), rec_bounded' e
+++++
intros.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
eapply IHl.
intros.

*****
H2 : rec_bounded e0
H1 : In e0 l
e0 : Cobham
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
rec_bounded' e0
+++++
apply H.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
eapply IHl.
intros.
apply H.

*****
H2 : rec_bounded e0
H1 : In e0 l
e0 : Cobham
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
In e0 (cons a l)
+++++
simpl.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
eapply IHl.
intros.
apply H.
simpl.

*****
H2 : rec_bounded e0
H1 : In e0 l
e0 : Cobham
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
or (eq a e0) (In e0 l)
+++++
tauto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
eapply IHl.
intros.
apply H.

*****
H2 : rec_bounded e0
H1 : In e0 l
e0 : Cobham
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
rec_bounded e0
+++++
trivial.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
eapply IHl.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
forall _ : rec_bounded ?e, rec_bounded' ?e
+++++
auto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.
simpl.
auto.
intros.
split.
try tauto.
revert e IHe H0.
induction l.
simpl.
intros.
trivial.
split.
eapply IHl.

*****
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
IHe : forall _ : rec_bounded e, rec_bounded' e
e : Cobham
IHl : forall\n (_ : forall (e : Cobham) (_ : In e l) (_ : rec_bounded e),\n rec_bounded' e) (e : Cobham)\n (_ : forall _ : rec_bounded e, rec_bounded' e)\n (_ : and (rec_bounded e) (andl rec_bounded l)), \nandl rec_bounded' l
H : forall (e : Cobham) (_ : In e (cons a l)) (_ : rec_bounded e),\nrec_bounded' e
l : list Cobham
a : Cobham
n : nat
*****
and (rec_bounded e) (andl rec_bounded l)
+++++
tauto.
-----
Lemma rec_bounded_spec (e : Cobham) : rec_bounded e -> rec_bounded' e.
Proof.
induction e using Cobham_ind2.

*****

*****

+++++
Qed.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n,\n  arity e = ok_arity n ->\n  rec_bounded' e -> \n  rec_bounded e.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)) (_ : rec_bounded' e), rec_bounded e
+++++
Proof.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)) (_ : rec_bounded' e), rec_bounded e
+++++
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).

*****

*****
forall _ : rec_bounded' Zero, rec_bounded Zero
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.

*****

*****
forall _ : True, True
+++++
auto.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).

*****

*****
forall (n i : nat) (_ : lt i n) (_ : rec_bounded' (Proj n i)), rec_bounded (Proj n i)
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.

*****

*****
forall (n i : nat) (_ : lt i n) (_ : True), True
+++++
auto.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).

*****

*****
forall (b : bool) (_ : rec_bounded' (Succ b)), rec_bounded (Succ b)
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : bool) (_ : True), True
+++++
auto.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).

*****

*****
forall _ : rec_bounded' Smash, rec_bounded Smash
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.

*****

*****
forall _ : True, True
+++++
auto.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : forall _ : rec_bounded' g, rec_bounded g) (_ : forall _ : rec_bounded' h0, rec_bounded h0) (_ : forall _ : rec_bounded' h1, rec_bounded h1) (_ : forall _ : rec_bounded' j, rec_bounded j) (_ : rec_bounded' (Rec g h0 h1 j)), rec_bounded (Rec g h0 h1 j)
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : forall _ : rec_bounded' g, rec_bounded g) (_ : forall _ : rec_bounded' h0, rec_bounded h0) (_ : forall _ : rec_bounded' h1, rec_bounded h1) (_ : forall _ : rec_bounded' j, rec_bounded j) (_ : and (rec_bounded' j) (and (rec_bounded' g) (and (rec_bounded' h0) (and (rec_bounded' h1) match match arity g with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity h0) (arity h1) (arity j) | error_Comp a l => error_Rec (error_Comp a l) (arity h0) (arity h1) (arity j) | error_Proj n0 n1 => error_Rec (error_Proj n0 n1) (arity h0) (arity h1) (arity j) | ok_arity gn => match arity h0 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity h1) (arity j) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity h1) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity gn) (error_Proj n0 n1) (arity h1) (arity j) | ok_arity h0n => match arity h1 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity j) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n0 n1) (arity j) | ok_arity h1n => match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end with | ok_arity n0 => forall (l : list (list bool)) (_ : eq (length l) n0), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l)) | _ => True end)))), and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
auto.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : forall _ : rec_bounded' g, rec_bounded g) (_ : forall _ : rec_bounded' h0, rec_bounded h0) (_ : forall _ : rec_bounded' h1, rec_bounded h1) (_ : forall _ : rec_bounded' j, rec_bounded j) (_ : and (rec_bounded' j) (and (rec_bounded' g) (and (rec_bounded' h0) (and (rec_bounded' h1) match match arity g with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity h0) (arity h1) (arity j) | error_Comp a l => error_Rec (error_Comp a l) (arity h0) (arity h1) (arity j) | error_Proj n0 n1 => error_Rec (error_Proj n0 n1) (arity h0) (arity h1) (arity j) | ok_arity gn => match arity h0 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity h1) (arity j) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity h1) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity gn) (error_Proj n0 n1) (arity h1) (arity j) | ok_arity h0n => match arity h1 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity j) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n0 n1) (arity j) | ok_arity h1n => match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end with | ok_arity n0 => forall (l : list (list bool)) (_ : eq (length l) n0), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l)) | _ => True end)))), and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
intros.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H7 : and (rec_bounded' j)\n (and (rec_bounded' g)\n (and (rec_bounded' h0)\n (and (rec_bounded' h1)\n match\n match arity g with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) \n (arity h0) (arity h1) (arity j)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity h0) \n (arity h1) (arity j)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity h0) \n (arity h1) (arity j)\n | ok_arity gn =>\n match arity h0 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2)\n (arity h1) (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l)\n (arity h1) (arity j)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0)\n (arity h1) (arity j)\n | ok_arity h0n =>\n match arity h1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) \n (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Comp a l) (arity j)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Proj n n0) (arity j)\n | ok_arity h1n =>\n match arity j with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) \n (ok_arity h0n) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) \n (ok_arity h0n) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) \n (ok_arity h0n) (ok_arity h1n)\n (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) \n (ok_arity h0n) (ok_arity h1n)\n (ok_arity jn)\n end\n end\n end\n end\n with\n | ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le\n (length\n (sem_Rec (Sem g) (Sem h0) (Sem h1) \n (hd nil l) (tl l))) (length (Sem j l))\n | _ => True\n end)))
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
decompose [and] H7.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.

*****
H13 : match\n match arity g with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity h0) (arity h1) (arity j)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity h0) (arity h1) (arity j)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity h0) (arity h1) (arity j)\n | ok_arity gn =>\n match arity h0 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity h1) (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) (arity h1) (arity j)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity h1) (arity j)\n | ok_arity h0n =>\n match arity h1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity j)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity j)\n | ok_arity h1n =>\n match arity j with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end\nwith\n| ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))\n| _ => True\nend
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H7 : and (rec_bounded' j)\n (and (rec_bounded' g)\n (and (rec_bounded' h0)\n (and (rec_bounded' h1)\n match\n match arity g with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) \n (arity h0) (arity h1) (arity j)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity h0) \n (arity h1) (arity j)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity h0) \n (arity h1) (arity j)\n | ok_arity gn =>\n match arity h0 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2)\n (arity h1) (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l)\n (arity h1) (arity j)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0)\n (arity h1) (arity j)\n | ok_arity h0n =>\n match arity h1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) \n (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Comp a l) (arity j)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Proj n n0) (arity j)\n | ok_arity h1n =>\n match arity j with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) \n (ok_arity h0n) (ok_arity h1n)\n (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) \n (ok_arity h0n) (ok_arity h1n)\n (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) \n (ok_arity h0n) (ok_arity h1n)\n (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) \n (ok_arity h0n) (ok_arity h1n)\n (ok_arity jn)\n end\n end\n end\n end\n with\n | ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le\n (length\n (sem_Rec (Sem g) (Sem h0) (Sem h1) \n (hd nil l) (tl l))) (length (Sem j l))\n | _ => True\n end)))
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
clear H7.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.

*****
H13 : match\n match arity g with\n | error_Rec a a0 a1 a2 =>\n error_Rec (error_Rec a a0 a1 a2) (arity h0) (arity h1) (arity j)\n | error_Comp a l =>\n error_Rec (error_Comp a l) (arity h0) (arity h1) (arity j)\n | error_Proj n n0 =>\n error_Rec (error_Proj n n0) (arity h0) (arity h1) (arity j)\n | ok_arity gn =>\n match arity h0 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) \n (arity h1) (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (error_Comp a l) (arity h1) (arity j)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (error_Proj n n0) \n (arity h1) (arity j)\n | ok_arity h0n =>\n match arity h1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n)\n (error_Rec a a0 a1 a2) (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Comp a l) (arity j)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (error_Proj n n0) (arity j)\n | ok_arity h1n =>\n match arity j with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n n0 =>\n error_Rec (ok_arity gn) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n n0)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb gn m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity gn) (ok_arity h0n)\n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\n end\nwith\n| ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))\n| _ => True\nend
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
rewrite H in H13.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.

*****
H13 : match\n match arity h0 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n) (error_Rec a a0 a1 a2) \n (arity h1) (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity n) (error_Comp a l) (arity h1) (arity j)\n | error_Proj n0 n1 =>\n error_Rec (ok_arity n) (error_Proj n0 n1) (arity h1) (arity j)\n | ok_arity h0n =>\n match arity h1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n) (ok_arity h0n) (error_Rec a a0 a1 a2)\n (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity n) (ok_arity h0n) (error_Comp a l)\n (arity j)\n | error_Proj n0 n1 =>\n error_Rec (ok_arity n) (ok_arity h0n) (error_Proj n0 n1)\n (arity j)\n | ok_arity h1n =>\n match arity j with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n) (ok_arity h0n) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n) (ok_arity h0n) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n0 n1 =>\n error_Rec (ok_arity n) (ok_arity h0n) \n (ok_arity h1n) (error_Proj n0 n1)\n | ok_arity jn =>\n if\n andb\n (andb\n match h0n with\n | S (S m'0) => Nat.eqb n m'0\n | _ => false\n end (Nat.eqb h1n h0n))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n) (ok_arity h0n) \n (ok_arity h1n) (ok_arity jn)\n end\n end\n end\nwith\n| ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))\n| _ => True\nend
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
rewrite H0 in H13.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.

*****
H13 : match\n match arity h1 with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n) (ok_arity (S (S n)))\n (error_Rec a a0 a1 a2) (arity j)\n | error_Comp a l =>\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (error_Comp a l) (arity j)\n | error_Proj n0 n1 =>\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (error_Proj n0 n1) (arity j)\n | ok_arity h1n =>\n match arity j with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (ok_arity h1n) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (ok_arity h1n) (error_Comp a l)\n | error_Proj n0 n1 =>\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (ok_arity h1n) (error_Proj n0 n1)\n | ok_arity jn =>\n if\n andb (andb (Nat.eqb n n) (Nat.eqb h1n (S (S n))))\n match h1n with\n | O => false\n | S m' => Nat.eqb jn m'\n end\n then ok_arity jn\n else\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (ok_arity h1n) (ok_arity jn)\n end\n end\nwith\n| ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))\n| _ => True\nend
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
rewrite H1 in H13.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.

*****
H13 : match\n match arity j with\n | error_Rec a a0 a1 a2 =>\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (ok_arity (S (S n))) (error_Rec a a0 a1 a2)\n | error_Comp a l =>\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (ok_arity (S (S n))) (error_Comp a l)\n | error_Proj n0 n1 =>\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (ok_arity (S (S n))) (error_Proj n0 n1)\n | ok_arity jn =>\n if\n andb (andb (Nat.eqb n n) (Nat.eqb (S (S n)) (S (S n))))\n (Nat.eqb jn (S n))\n then ok_arity jn\n else\n error_Rec (ok_arity n) (ok_arity (S (S n))) \n (ok_arity (S (S n))) (ok_arity jn)\n end\nwith\n| ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))\n| _ => True\nend
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
rewrite H2 in H13.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.

*****
H13 : match\n (if\n andb (andb (Nat.eqb n n) (Nat.eqb (S (S n)) (S (S n))))\n (Nat.eqb (S n) (S n))\n then ok_arity (S n)\n else\n error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n)))\n (ok_arity (S n)))\nwith\n| ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))\n| _ => True\nend
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
simpl in H13.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.

*****
H13 : match\n (if andb (andb (Nat.eqb n n) (Nat.eqb n n)) (Nat.eqb n n)\n then ok_arity (S n)\n else\n error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n)))\n (ok_arity (S n)))\nwith\n| ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))\n| _ => True\nend
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
rewrite <- beq_nat_refl in H13.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.

*****
H13 : match\n (if andb (andb true true) true\n then ok_arity (S n)\n else\n error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n)))\n (ok_arity (S n)))\nwith\n| ok_arity n =>\n forall (l : list (list bool)) (_ : eq (length l) n),\n le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))\n| _ => True\nend
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
simpl in H13.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.

*****
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
and (rec_bounded j) (and (rec_bounded g) (and (rec_bounded h0) (and (rec_bounded h1) (forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))))))
+++++
repeat (split; try tauto).
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).

*****
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
forall l : list (list bool), le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))
+++++
intros.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.

*****
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l))) (length (Sem j l))
+++++
rewrite <- simpl_Rec with (j := j).
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).

*****
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) l)) (length (Sem j l))
+++++
destruct (le_lt_dec (length l) (S n)).
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) l)) (length (Sem j l))
+++++
rewrite Sem_add_zero with (n := S n).
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l))))))) (length (Sem j l))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l))))))) (length (Sem j l))
+++++
rewrite Sem_add_zero with (e := j) (n := S n).
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
rewrite Sem_add_zero with (e := j) (n := S n).

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l))))))) (length (Sem j (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l)))))))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
rewrite Sem_add_zero with (e := j) (n := S n).
trivial.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l))))))) (length (Sem j (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l)))))))
+++++
apply H13.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
rewrite Sem_add_zero with (e := j) (n := S n).
trivial.
apply H13.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (length (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l)))))) (S n)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
rewrite Sem_add_zero with (e := j) (n := S n).
trivial.
apply H13.
trivial.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (length (app l (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l)))))) (S n)
+++++
rewrite app_length.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
rewrite Sem_add_zero with (e := j) (n := S n).
trivial.
apply H13.
trivial.
rewrite app_length.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Init.Nat.add (length l) (length (map (fun _ : nat => nil) (seq O (Init.Nat.sub (S n) (length l)))))) (S n)
+++++
rewrite map_length.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
rewrite Sem_add_zero with (e := j) (n := S n).
trivial.
apply H13.
trivial.
rewrite app_length.
rewrite map_length.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Init.Nat.add (length l) (length (seq O (Init.Nat.sub (S n) (length l))))) (S n)
+++++
rewrite seq_length.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
rewrite Sem_add_zero with (e := j) (n := S n).
trivial.
apply H13.
trivial.
rewrite app_length.
rewrite map_length.
rewrite seq_length.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Init.Nat.add (length l) (Init.Nat.sub (S n) (length l))) (S n)
+++++
omega.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
rewrite Sem_add_zero with (e := j) (n := S n).

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (arity j) (ok_arity (S n))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
rewrite Sem_add_zero with (e := j) (n := S n).

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length l) (S n)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (arity (Rec g h0 h1 j)) (ok_arity (S n))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (arity (Rec g h0 h1 j)) (ok_arity (S n))
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
simpl.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq match arity g with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity h0) (arity h1) (arity j) | error_Comp a l => error_Rec (error_Comp a l) (arity h0) (arity h1) (arity j) | error_Proj n n0 => error_Rec (error_Proj n n0) (arity h0) (arity h1) (arity j) | ok_arity gn => match arity h0 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity h1) (arity j) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity h1) (arity j) | error_Proj n n0 => error_Rec (ok_arity gn) (error_Proj n n0) (arity h1) (arity j) | ok_arity h0n => match arity h1 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity j) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity j) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n n0) (arity j) | ok_arity h1n => match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n n0) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end (ok_arity (S n))
+++++
rewrite H.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
simpl.
rewrite H.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq match arity h0 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (error_Rec a a0 a1 a2) (arity h1) (arity j) | error_Comp a l => error_Rec (ok_arity n) (error_Comp a l) (arity h1) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity n) (error_Proj n0 n1) (arity h1) (arity j) | ok_arity h0n => match arity h1 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity j) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (error_Comp a l) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (error_Proj n0 n1) (arity j) | ok_arity h1n => match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end (ok_arity (S n))
+++++
rewrite H0.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq match arity h1 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity (S (S n))) (error_Rec a a0 a1 a2) (arity j) | error_Comp a l => error_Rec (ok_arity n) (ok_arity (S (S n))) (error_Comp a l) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity (S (S n))) (error_Proj n0 n1) (arity j) | ok_arity h1n => match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb (Nat.eqb n n) (Nat.eqb h1n (S (S n)))) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity h1n) (ok_arity jn) end end (ok_arity (S n))
+++++
rewrite H1.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.
rewrite H1.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (error_Proj n0 n1) | ok_arity jn => if andb (andb (Nat.eqb n n) (Nat.eqb (S (S n)) (S (S n)))) (Nat.eqb jn (S n)) then ok_arity jn else error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (ok_arity jn) end (ok_arity (S n))
+++++
rewrite H2.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.
rewrite H1.
rewrite H2.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb (S (S n)) (S (S n)))) (Nat.eqb (S n) (S n)) then ok_arity (S n) else error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (ok_arity (S n))) (ok_arity (S n))
+++++
repeat rewrite <- beq_nat_refl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.
rewrite H1.
rewrite H2.
repeat rewrite <- beq_nat_refl.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if andb (andb true true) true then ok_arity (S n) else error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (ok_arity (S n))) (ok_arity (S n))
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.
rewrite H1.
rewrite H2.
repeat rewrite <- beq_nat_refl.
simpl.

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (ok_arity (S n)) (ok_arity (S n))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite Sem_add_zero with (n := S n).

*****
l0 : le (length l) (S n)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length l) (S n)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) l)) (length (Sem j l))
+++++
rewrite <- firstn_skipn with (n := S n) (l := l).
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) (app (firstn (S n) l) (skipn (S n) l)))) (length (Sem j (app (firstn (S n) l) (skipn (S n) l))))
+++++
rewrite <- Sem_remove_zero with (n := S n).
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) (firstn (S n) l))) (length (Sem j (app (firstn (S n) l) (skipn (S n) l))))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) (firstn (S n) l))) (length (Sem j (app (firstn (S n) l) (skipn (S n) l))))
+++++
rewrite <- Sem_remove_zero with (n := S n).
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) (firstn (S n) l))) (length (Sem j (firstn (S n) l)))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (length (Sem (Rec g h0 h1 j) (firstn (S n) l))) (length (Sem j (firstn (S n) l)))
+++++
apply H13.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
apply H13.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (length (firstn (S n) l)) (S n)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
apply H13.
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (length (firstn (S n) l)) (S n)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
apply H13.
trivial.
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (length (firstn (S n) l)) (S n)
+++++
rewrite firstn_length.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
apply H13.
trivial.
trivial.
rewrite firstn_length.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (Init.Nat.min (S n) (length l)) (S n)
+++++
rewrite min_l.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
apply H13.
trivial.
trivial.
rewrite firstn_length.
rewrite min_l.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S n) (S n)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
apply H13.
trivial.
trivial.
rewrite firstn_length.
rewrite min_l.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S n) (length l)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
apply H13.
trivial.
trivial.
rewrite firstn_length.
rewrite min_l.
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S n) (length l)
+++++
omega.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (arity j) (ok_arity (S n))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S n) (length (firstn (S n) l))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S n) (length (firstn (S n) l))
+++++
rewrite firstn_length.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite firstn_length.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S n) (Init.Nat.min (S n) (length l))
+++++
rewrite min_l.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite firstn_length.
rewrite min_l.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S n) (S n)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite firstn_length.
rewrite min_l.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S n) (length l)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite firstn_length.
rewrite min_l.
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S n) (length l)
+++++
omega.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (arity (Rec g h0 h1 j)) (ok_arity (S n))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (arity (Rec g h0 h1 j)) (ok_arity (S n))
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
simpl.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq match arity g with | error_Rec a a0 a1 a2 => error_Rec (error_Rec a a0 a1 a2) (arity h0) (arity h1) (arity j) | error_Comp a l => error_Rec (error_Comp a l) (arity h0) (arity h1) (arity j) | error_Proj n n0 => error_Rec (error_Proj n n0) (arity h0) (arity h1) (arity j) | ok_arity gn => match arity h0 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (error_Rec a a0 a1 a2) (arity h1) (arity j) | error_Comp a l => error_Rec (ok_arity gn) (error_Comp a l) (arity h1) (arity j) | error_Proj n n0 => error_Rec (ok_arity gn) (error_Proj n n0) (arity h1) (arity j) | ok_arity h0n => match arity h1 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity j) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (error_Comp a l) (arity j) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (error_Proj n n0) (arity j) | ok_arity h1n => match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n n0 => error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (error_Proj n n0) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb gn m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity gn) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end end (ok_arity (S n))
+++++
rewrite H.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
simpl.
rewrite H.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq match arity h0 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (error_Rec a a0 a1 a2) (arity h1) (arity j) | error_Comp a l => error_Rec (ok_arity n) (error_Comp a l) (arity h1) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity n) (error_Proj n0 n1) (arity h1) (arity j) | ok_arity h0n => match arity h1 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (error_Rec a a0 a1 a2) (arity j) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (error_Comp a l) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (error_Proj n0 n1) (arity j) | ok_arity h1n => match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb match h0n with | S (S m'0) => Nat.eqb n m'0 | _ => false end (Nat.eqb h1n h0n)) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity h0n) (ok_arity h1n) (ok_arity jn) end end end (ok_arity (S n))
+++++
rewrite H0.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq match arity h1 with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity (S (S n))) (error_Rec a a0 a1 a2) (arity j) | error_Comp a l => error_Rec (ok_arity n) (ok_arity (S (S n))) (error_Comp a l) (arity j) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity (S (S n))) (error_Proj n0 n1) (arity j) | ok_arity h1n => match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity h1n) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity h1n) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity h1n) (error_Proj n0 n1) | ok_arity jn => if andb (andb (Nat.eqb n n) (Nat.eqb h1n (S (S n)))) match h1n with | O => false | S m' => Nat.eqb jn m' end then ok_arity jn else error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity h1n) (ok_arity jn) end end (ok_arity (S n))
+++++
rewrite H1.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.
rewrite H1.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq match arity j with | error_Rec a a0 a1 a2 => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (error_Rec a a0 a1 a2) | error_Comp a l => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (error_Comp a l) | error_Proj n0 n1 => error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (error_Proj n0 n1) | ok_arity jn => if andb (andb (Nat.eqb n n) (Nat.eqb (S (S n)) (S (S n)))) (Nat.eqb jn (S n)) then ok_arity jn else error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (ok_arity jn) end (ok_arity (S n))
+++++
rewrite H2.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.
rewrite H1.
rewrite H2.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb (S (S n)) (S (S n)))) (Nat.eqb (S n) (S n)) then ok_arity (S n) else error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (ok_arity (S n))) (ok_arity (S n))
+++++
repeat rewrite <- beq_nat_refl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.
rewrite H1.
rewrite H2.
repeat rewrite <- beq_nat_refl.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (if andb (andb true true) true then ok_arity (S n) else error_Rec (ok_arity n) (ok_arity (S (S n))) (ok_arity (S (S n))) (ok_arity (S n))) (ok_arity (S n))
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
simpl.
rewrite H.
rewrite H0.
rewrite H1.
rewrite H2.
repeat rewrite <- beq_nat_refl.
simpl.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (ok_arity (S n)) (ok_arity (S n))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S n) (length (firstn (S n) l))
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S n) (length (firstn (S n) l))
+++++
rewrite firstn_length.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite firstn_length.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S n) (Init.Nat.min (S n) (length l))
+++++
rewrite min_l.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite firstn_length.
rewrite min_l.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
eq (S n) (S n)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite firstn_length.
rewrite min_l.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S n) (length l)
+++++
trivial.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
decompose [and] H7.
clear H7.
rewrite H in H13.
rewrite H0 in H13.
rewrite H1 in H13.
rewrite H2 in H13.
simpl in H13.
rewrite <- beq_nat_refl in H13.
simpl in H13.
repeat (split; try tauto).
intros.
rewrite <- simpl_Rec with (j := j).
destruct (le_lt_dec (length l) (S n)).
rewrite <- firstn_skipn with (n := S n) (l := l).
rewrite <- Sem_remove_zero with (n := S n).
trivial.
rewrite firstn_length.
rewrite min_l.
trivial.

*****
l0 : lt (S n) (length l)
l : list (list bool)
H13 : forall (l : list (list bool)) (_ : eq (length l) (S n)),\nle (length (sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l)))\n (length (Sem j l))
H11 : rec_bounded' h1
H9 : rec_bounded' h0
H10 : rec_bounded' g
H8 : rec_bounded' j
H6 : forall _ : rec_bounded' j, rec_bounded j
H5 : forall _ : rec_bounded' h1, rec_bounded h1
H4 : forall _ : rec_bounded' h0, rec_bounded h0
H3 : forall _ : rec_bounded' g, rec_bounded g
H2 : eq (arity j) (ok_arity (S n))
H1 : eq (arity h1) (ok_arity (S (S n)))
H0 : eq (arity h0) (ok_arity (S (S n)))
H : eq (arity g) (ok_arity n)
g,h0,h1,j : Cobham
n : nat
*****
le (S n) (length l)
+++++
omega.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : forall _ : rec_bounded' h, rec_bounded h) (_ : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r) (_ : rec_bounded' (Comp n h rl)), rec_bounded (Comp n h rl)
+++++
simpl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : forall _ : rec_bounded' h, rec_bounded h) (_ : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r) (_ : and (rec_bounded' h) (andl rec_bounded' rl)), and (rec_bounded h) (andl rec_bounded rl)
+++++
auto.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : forall _ : rec_bounded' h, rec_bounded h) (_ : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r) (_ : and (rec_bounded' h) (andl rec_bounded' rl)), and (rec_bounded h) (andl rec_bounded rl)
+++++
intros.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.

*****
H3 : and (rec_bounded' h) (andl rec_bounded' rl)
H2 : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r
H1 : forall _ : rec_bounded' h, rec_bounded h
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
and (rec_bounded h) (andl rec_bounded rl)
+++++
split.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
split.

*****
H3 : and (rec_bounded' h) (andl rec_bounded' rl)
H2 : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r
H1 : forall _ : rec_bounded' h, rec_bounded h
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
rec_bounded h
+++++
tauto.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
split.

*****
H3 : and (rec_bounded' h) (andl rec_bounded' rl)
H2 : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r
H1 : forall _ : rec_bounded' h, rec_bounded h
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
andl rec_bounded rl
+++++
apply forall_andl.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
split.
apply forall_andl.

*****
H3 : and (rec_bounded' h) (andl rec_bounded' rl)
H2 : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r
H1 : forall _ : rec_bounded' h, rec_bounded h
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
forall (x : Cobham) (_ : In x rl), rec_bounded x
+++++
intros.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
split.
apply forall_andl.
intros.

*****
H4 : In x rl
x : Cobham
H3 : and (rec_bounded' h) (andl rec_bounded' rl)
H2 : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r
H1 : forall _ : rec_bounded' h, rec_bounded h
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
rec_bounded x
+++++
destruct H3.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
split.
apply forall_andl.
intros.
destruct H3.

*****
H4 : In x rl
x : Cobham
H5 : andl rec_bounded' rl
H3 : rec_bounded' h
H2 : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r
H1 : forall _ : rec_bounded' h, rec_bounded h
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
rec_bounded x
+++++
rewrite <- forall_andl in H5.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).
simpl.
auto.
intros.
split.
apply forall_andl.
intros.
destruct H3.
rewrite <- forall_andl in H5.

*****
H4 : In x rl
x : Cobham
H5 : forall (x : Cobham) (_ : In x rl), rec_bounded' x
H3 : rec_bounded' h
H2 : forall (r : Cobham) (_ : In r rl) (_ : rec_bounded' r), rec_bounded r
H1 : forall _ : rec_bounded' h, rec_bounded h
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
rec_bounded x
+++++
auto.
-----
Lemma rec_bounded'_spec : forall (e : Cobham) n, arity e = ok_arity n -> rec_bounded' e -> rec_bounded e.
Proof.
refine (Cobham_ind_inf (fun n e => rec_bounded' e -> rec_bounded e) _ _ _ _ _ _).

*****

*****

+++++
Qed.
-----
Fixpoint poly_Cobham (e : Cobham) :=\n  match e with\n    | Zero => pcst 0 0\n    | Proj n i => pproj n i\n    | Succ b => pplus (pcst 0 1) (pproj 1 0)\n    | Smash => pplus (pcst 0 1) (pmult (pproj 2 0) (pproj 2 1))\n    | Rec g h0 h1 j => poly_Cobham j\n    | Comp n h l => \n      pplus (pcst n 0) \n      (pcomp (poly_Cobham h) (map poly_Cobham l))\n  end.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n,\n  arity e = ok_arity n ->\n  parity (poly_Cobham e) = n.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)), eq (fst (poly_Cobham e)) n
+++++
Proof.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)), eq (fst (poly_Cobham e)) n
+++++
apply Cobham_ind_inf.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.

*****

*****
eq (fst (poly_Cobham Zero)) O
+++++
simpl.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
eq O O
+++++
auto.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.

*****

*****
forall (n i : nat) (_ : lt i n), eq (fst (poly_Cobham (Proj n i))) n
+++++
simpl.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
forall (n i : nat) (_ : lt i n), eq n n
+++++
auto.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.

*****

*****
forall b : bool, eq (fst (poly_Cobham (Succ b))) (S O)
+++++
simpl.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
forall _ : bool, eq (S O) (S O)
+++++
auto.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.

*****

*****
eq (fst (poly_Cobham Smash)) (S (S O))
+++++
simpl.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
eq (S (S O)) (S (S O))
+++++
auto.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : eq (fst (poly_Cobham g)) n) (_ : eq (fst (poly_Cobham h0)) (S (S n))) (_ : eq (fst (poly_Cobham h1)) (S (S n))) (_ : eq (fst (poly_Cobham j)) (S n)), eq (fst (poly_Cobham (Rec g h0 h1 j))) (S n)
+++++
simpl.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : eq (fst (poly_Cobham g)) n) (_ : eq (fst (poly_Cobham h0)) (S (S n))) (_ : eq (fst (poly_Cobham h1)) (S (S n))) (_ : eq (fst (poly_Cobham j)) (S n)), eq (fst (poly_Cobham j)) (S n)
+++++
auto.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : eq (fst (poly_Cobham h)) (length rl)) (_ : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n), eq (fst (poly_Cobham (Comp n h rl))) n
+++++
simpl.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : eq (fst (poly_Cobham h)) (length rl)) (_ : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n), eq (Init.Nat.max n (maxl (map fst (map poly_Cobham rl)))) n
+++++
auto.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.
auto.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : eq (fst (poly_Cobham h)) (length rl)) (_ : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n), eq (Init.Nat.max n (maxl (map fst (map poly_Cobham rl)))) n
+++++
intros.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.

*****
H2 : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n
H1 : eq (fst (poly_Cobham h)) (length rl)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (Init.Nat.max n (maxl (map fst (map poly_Cobham rl)))) n
+++++
apply max_l.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
apply max_l.

*****
H2 : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n
H1 : eq (fst (poly_Cobham h)) (length rl)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
le (maxl (map fst (map poly_Cobham rl))) n
+++++
apply maxl_map.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
apply max_l.
apply maxl_map.

*****
H2 : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n
H1 : eq (fst (poly_Cobham h)) (length rl)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
forall (x : prod nat (list mon)) (_ : In x (map poly_Cobham rl)), eq (fst x) n
+++++
intros.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
apply max_l.
apply maxl_map.
intros.

*****
H3 : In x (map poly_Cobham rl)
x : prod nat (list mon)
H2 : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n
H1 : eq (fst (poly_Cobham h)) (length rl)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (fst x) n
+++++
apply in_map_iff in H3.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
apply max_l.
apply maxl_map.
intros.
apply in_map_iff in H3.

*****
H3 : ex (fun x0 : Cobham => and (eq (poly_Cobham x0) x) (In x0 rl))
x : prod nat (list mon)
H2 : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n
H1 : eq (fst (poly_Cobham h)) (length rl)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (fst x) n
+++++
destruct H3 as (? & ? & ?).
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
apply max_l.
apply maxl_map.
intros.
apply in_map_iff in H3.
destruct H3 as (? & ? & ?).

*****
H4 : In x0 rl
H3 : eq (poly_Cobham x0) x
x0 : Cobham
x : prod nat (list mon)
H2 : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n
H1 : eq (fst (poly_Cobham h)) (length rl)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (fst x) n
+++++
subst.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
apply max_l.
apply maxl_map.
intros.
apply in_map_iff in H3.
destruct H3 as (? & ? & ?).
subst.

*****
H4 : In x0 rl
x0 : Cobham
H2 : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n
H1 : eq (fst (poly_Cobham h)) (length rl)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
eq (fst (poly_Cobham x0)) n
+++++
apply H2.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
apply max_l.
apply maxl_map.
intros.
apply in_map_iff in H3.
destruct H3 as (? & ? & ?).
subst.
apply H2.

*****
H4 : In x0 rl
x0 : Cobham
H2 : forall (r : Cobham) (_ : In r rl), eq (fst (poly_Cobham r)) n
H1 : eq (fst (poly_Cobham h)) (length rl)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
In x0 rl
+++++
trivial.
-----
Lemma parity_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> parity (poly_Cobham e) = n.
Proof.
apply Cobham_ind_inf.

*****

*****

+++++
Qed.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n,\n  arity e = ok_arity n ->\n  pWF (poly_Cobham e).
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)), pWF (poly_Cobham e)
+++++
Proof.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.

*****

*****
forall (e : Cobham) (n : nat) (_ : eq (arity e) (ok_arity n)), pWF (poly_Cobham e)
+++++
apply Cobham_ind_inf.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.

*****

*****
pWF (poly_Cobham Zero)
+++++
simpl.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
pWF (pcst O O)
+++++
auto.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.

*****

*****
pWF (pcst O O)
+++++
intros.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.

*****

*****
pWF (pcst O O)
+++++
try pWF.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.

*****

*****
forall (n i : nat) (_ : lt i n), pWF (poly_Cobham (Proj n i))
+++++
simpl.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
forall (n i : nat) (_ : lt i n), pWF (pproj n i)
+++++
auto.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.

*****

*****
forall (n i : nat) (_ : lt i n), pWF (pproj n i)
+++++
intros.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.

*****
H : lt i n
n,i : nat
*****
pWF (pproj n i)
+++++
try pWF.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.

*****

*****
forall b : bool, pWF (poly_Cobham (Succ b))
+++++
simpl.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
forall _ : bool, pWF (pplus (pcst O (S O)) (pproj (S O) O))
+++++
auto.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.

*****

*****
forall _ : bool, pWF (pplus (pcst O (S O)) (pproj (S O) O))
+++++
intros.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.

*****
b : bool
*****
pWF (pplus (pcst O (S O)) (pproj (S O) O))
+++++
try pWF.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.

*****

*****
pWF (poly_Cobham Smash)
+++++
simpl.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
pWF (pplus (pcst O (S O)) (pmult (pproj (S (S O)) O) (pproj (S (S O)) (S O))))
+++++
auto.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.

*****

*****
pWF (pplus (pcst O (S O)) (pmult (pproj (S (S O)) O) (pproj (S (S O)) (S O))))
+++++
intros.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.

*****

*****
pWF (pplus (pcst O (S O)) (pmult (pproj (S (S O)) O) (pproj (S (S O)) (S O))))
+++++
try pWF.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : pWF (poly_Cobham g)) (_ : pWF (poly_Cobham h0)) (_ : pWF (poly_Cobham h1)) (_ : pWF (poly_Cobham j)), pWF (poly_Cobham (Rec g h0 h1 j))
+++++
simpl.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
forall (n : nat) (g h0 h1 j : Cobham) (_ : eq (arity g) (ok_arity n)) (_ : eq (arity h0) (ok_arity (S (S n)))) (_ : eq (arity h1) (ok_arity (S (S n)))) (_ : eq (arity j) (ok_arity (S n))) (_ : pWF (poly_Cobham g)) (_ : pWF (poly_Cobham h0)) (_ : pWF (poly_Cobham h1)) (_ : pWF (poly_Cobham j)), pWF (poly_Cobham j)
+++++
auto.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : pWF (poly_Cobham h)) (_ : forall (r : Cobham) (_ : In r rl), pWF (poly_Cobham r)), pWF (poly_Cobham (Comp n h rl))
+++++
simpl.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : pWF (poly_Cobham h)) (_ : forall (r : Cobham) (_ : In r rl), pWF (poly_Cobham r)), pWF (pplus (pcst n O) (pcomp (poly_Cobham h) (map poly_Cobham rl)))
+++++
auto.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.

*****

*****
forall (n : nat) (h : Cobham) (rl : list Cobham) (_ : eq (arity h) (ok_arity (length rl))) (_ : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)) (_ : pWF (poly_Cobham h)) (_ : forall (r : Cobham) (_ : In r rl), pWF (poly_Cobham r)), pWF (pplus (pcst n O) (pcomp (poly_Cobham h) (map poly_Cobham rl)))
+++++
intros.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.

*****
H2 : forall (r : Cobham) (_ : In r rl), pWF (poly_Cobham r)
H1 : pWF (poly_Cobham h)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
pWF (pplus (pcst n O) (pcomp (poly_Cobham h) (map poly_Cobham rl)))
+++++
try pWF.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
try pWF.

*****
H3 : In x (map poly_Cobham rl)
x : pol
H2 : forall (r : Cobham) (_ : In r rl), pWF (poly_Cobham r)
H1 : pWF (poly_Cobham h)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
pWF x
+++++
apply in_map_iff in H3.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
try pWF.
apply in_map_iff in H3.

*****
H3 : ex (fun x0 : Cobham => and (eq (poly_Cobham x0) x) (In x0 rl))
x : pol
H2 : forall (r : Cobham) (_ : In r rl), pWF (poly_Cobham r)
H1 : pWF (poly_Cobham h)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
pWF x
+++++
destruct H3 as (? & ? & ?).
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
try pWF.
apply in_map_iff in H3.
destruct H3 as (? & ? & ?).

*****
H4 : In x0 rl
H3 : eq (poly_Cobham x0) x
x0 : Cobham
x : pol
H2 : forall (r : Cobham) (_ : In r rl), pWF (poly_Cobham r)
H1 : pWF (poly_Cobham h)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
pWF x
+++++
subst.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
try pWF.
apply in_map_iff in H3.
destruct H3 as (? & ? & ?).
subst.

*****
H4 : In x0 rl
x0 : Cobham
H2 : forall (r : Cobham) (_ : In r rl), pWF (poly_Cobham r)
H1 : pWF (poly_Cobham h)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
pWF (poly_Cobham x0)
+++++
apply H2.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.
simpl.
auto.
intros.
try pWF.
apply in_map_iff in H3.
destruct H3 as (? & ? & ?).
subst.
apply H2.

*****
H4 : In x0 rl
x0 : Cobham
H2 : forall (r : Cobham) (_ : In r rl), pWF (poly_Cobham r)
H1 : pWF (poly_Cobham h)
H0 : forall (e : Cobham) (_ : In e rl), eq (arity e) (ok_arity n)
H : eq (arity h) (ok_arity (length rl))
rl : list Cobham
h : Cobham
n : nat
*****
In x0 rl
+++++
trivial.
-----
Lemma pWF_poly_Cobham : forall (e : Cobham) n, arity e = ok_arity n -> pWF (poly_Cobham e).
Proof.
apply Cobham_ind_inf.

*****

*****

+++++
Qed.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl,\n  rec_bounded e ->  \n  length (Sem e xl) <= \n  peval (poly_Cobham e) (map (@length _) xl).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).

*****

*****
forall (e : Cobham) (xl : list (list bool)) (_ : rec_bounded e), le (length (Sem e xl)) (peval (poly_Cobham e) (map (length (A:=bool)) xl))
+++++
Proof.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.

*****

*****
forall (e : Cobham) (xl : list (list bool)) (_ : rec_bounded e), le (length (Sem e xl)) (peval (poly_Cobham e) (map (length (A:=bool)) xl))
+++++
induction e using Cobham_ind2.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.

*****

*****
forall (xl : list (list bool)) (_ : rec_bounded Zero), le (length (Sem Zero xl)) (peval (poly_Cobham Zero) (map (length (A:=bool)) xl))
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.

*****
H : rec_bounded Zero
xl : list (list bool)
*****
le (length (Sem Zero xl)) (peval (poly_Cobham Zero) (map (length (A:=bool)) xl))
+++++
simpl in *.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.

*****
H : True
xl : list (list bool)
*****
le O (peval (pcst O O) (map (length (A:=bool)) xl))
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.

*****
n,i : nat
*****
forall (xl : list (list bool)) (_ : rec_bounded (Proj n i)), le (length (Sem (Proj n i) xl)) (peval (poly_Cobham (Proj n i)) (map (length (A:=bool)) xl))
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.

*****
H : rec_bounded (Proj n i)
xl : list (list bool)
n,i : nat
*****
le (length (Sem (Proj n i) xl)) (peval (poly_Cobham (Proj n i)) (map (length (A:=bool)) xl))
+++++
simpl in *.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.

*****
H : True
xl : list (list bool)
n,i : nat
*****
le (length (nth i xl nil)) (peval (pproj n i) (map (length (A:=bool)) xl))
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.

*****
H : True
xl : list (list bool)
n,i : nat
*****
le (length (nth i xl nil)) (peval (pproj n i) (map (length (A:=bool)) xl))
+++++
rewrite <- (@map_nth _ _ (@length _) xl).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite <- (@map_nth _ _ (@length _) xl).

*****
H : True
xl : list (list bool)
n,i : nat
*****
le (nth i (map (length (A:=bool)) xl) (length nil)) (peval (pproj n i) (map (length (A:=bool)) xl))
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite <- (@map_nth _ _ (@length _) xl).
simpl.

*****
H : True
xl : list (list bool)
n,i : nat
*****
le (nth i (map (length (A:=bool)) xl) O) (peval (pproj n i) (map (length (A:=bool)) xl))
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite <- (@map_nth _ _ (@length _) xl).
simpl.
trivial.

*****
H : True
xl : list (list bool)
n,i : nat
*****
le (nth i (map (length (A:=bool)) xl) O) (peval (pproj n i) (map (length (A:=bool)) xl))
+++++
rewrite pproj_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite <- (@map_nth _ _ (@length _) xl).
simpl.
trivial.
rewrite pproj_correct.

*****
H : True
xl : list (list bool)
n,i : nat
*****
le (nth i (map (length (A:=bool)) xl) O) (nth i (map (length (A:=bool)) xl) O)
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.

*****
b : bool
*****
forall (xl : list (list bool)) (_ : rec_bounded (Succ b)), le (length (Sem (Succ b) xl)) (peval (poly_Cobham (Succ b)) (map (length (A:=bool)) xl))
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.

*****
H : rec_bounded (Succ b)
xl : list (list bool)
b : bool
*****
le (length (Sem (Succ b) xl)) (peval (poly_Cobham (Succ b)) (map (length (A:=bool)) xl))
+++++
simpl in *.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.

*****
H : True
xl : list (list bool)
b : bool
*****
le (S (length (hd nil xl))) (peval (pplus (pcst O (S O)) (pproj (S O) O)) (map (length (A:=bool)) xl))
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.

*****
H : True
xl : list (list bool)
b : bool
*****
le (S (length (hd nil xl))) (peval (pplus (pcst O (S O)) (pproj (S O) O)) (map (length (A:=bool)) xl))
+++++
rewrite pplus_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.

*****
H : True
xl : list (list bool)
b : bool
*****
le (S (length (hd nil xl))) (Init.Nat.add (peval (pcst O (S O)) (map (length (A:=bool)) xl)) (peval (pproj (S O) O) (map (length (A:=bool)) xl)))
+++++
rewrite pproj_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pproj_correct.

*****
H : True
xl : list (list bool)
b : bool
*****
le (S (length (hd nil xl))) (Init.Nat.add (peval (pcst O (S O)) (map (length (A:=bool)) xl)) (nth O (map (length (A:=bool)) xl) O))
+++++
rewrite <- hd_nth_0.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pproj_correct.
rewrite <- hd_nth_0.

*****
H : True
xl : list (list bool)
b : bool
*****
le (S (length (hd nil xl))) (Init.Nat.add (peval (pcst O (S O)) (map (length (A:=bool)) xl)) (hd O (map (length (A:=bool)) xl)))
+++++
rewrite (map_hd _ _ (@length _)).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pproj_correct.
rewrite <- hd_nth_0.
rewrite (map_hd _ _ (@length _)).

*****
H : True
xl : list (list bool)
b : bool
*****
le (S (hd (length nil) (map (length (A:=bool)) xl))) (Init.Nat.add (peval (pcst O (S O)) (map (length (A:=bool)) xl)) (hd O (map (length (A:=bool)) xl)))
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pproj_correct.
rewrite <- hd_nth_0.
rewrite (map_hd _ _ (@length _)).
simpl.

*****
H : True
xl : list (list bool)
b : bool
*****
le (S (hd O (map (length (A:=bool)) xl))) (S (hd O (map (length (A:=bool)) xl)))
+++++
omega.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.

*****

*****
forall (xl : list (list bool)) (_ : rec_bounded Smash), le (length (Sem Smash xl)) (peval (poly_Cobham Smash) (map (length (A:=bool)) xl))
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.

*****
H : rec_bounded Smash
xl : list (list bool)
*****
le (length (Sem Smash xl)) (peval (poly_Cobham Smash) (map (length (A:=bool)) xl))
+++++
simpl in *.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.

*****
H : True
xl : list (list bool)
*****
le (length (smash_bs (hd nil xl) (hd nil (tl xl)))) (peval (pplus (pcst O (S O)) (pmult (pproj (S (S O)) O) (pproj (S (S O)) (S O)))) (map (length (A:=bool)) xl))
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.

*****
H : True
xl : list (list bool)
*****
le (length (smash_bs (hd nil xl) (hd nil (tl xl)))) (peval (pplus (pcst O (S O)) (pmult (pproj (S (S O)) O) (pproj (S (S O)) (S O)))) (map (length (A:=bool)) xl))
+++++
rewrite length_smash.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.

*****
H : True
xl : list (list bool)
*****
le (Init.Nat.add (S O) (Init.Nat.mul (length (hd nil xl)) (length (hd nil (tl xl))))) (peval (pplus (pcst O (S O)) (pmult (pproj (S (S O)) O) (pproj (S (S O)) (S O)))) (map (length (A:=bool)) xl))
+++++
rewrite pplus_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.

*****
H : True
xl : list (list bool)
*****
le (Init.Nat.add (S O) (Init.Nat.mul (length (hd nil xl)) (length (hd nil (tl xl))))) (Init.Nat.add (peval (pcst O (S O)) (map (length (A:=bool)) xl)) (peval (pmult (pproj (S (S O)) O) (pproj (S (S O)) (S O))) (map (length (A:=bool)) xl)))
+++++
rewrite pmult_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.

*****
H : True
xl : list (list bool)
*****
le (Init.Nat.add (S O) (Init.Nat.mul (length (hd nil xl)) (length (hd nil (tl xl))))) (Init.Nat.add (peval (pcst O (S O)) (map (length (A:=bool)) xl)) (Init.Nat.mul (peval (pproj (S (S O)) O) (map (length (A:=bool)) xl)) (peval (pproj (S (S O)) (S O)) (map (length (A:=bool)) xl))))
+++++
rewrite pcst_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.
rewrite pcst_correct.

*****
H : True
xl : list (list bool)
*****
le (Init.Nat.add (S O) (Init.Nat.mul (length (hd nil xl)) (length (hd nil (tl xl))))) (Init.Nat.add (S O) (Init.Nat.mul (peval (pproj (S (S O)) O) (map (length (A:=bool)) xl)) (peval (pproj (S (S O)) (S O)) (map (length (A:=bool)) xl))))
+++++
rewrite pproj_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.
rewrite pcst_correct.
rewrite pproj_correct.

*****
H : True
xl : list (list bool)
*****
le (Init.Nat.add (S O) (Init.Nat.mul (length (hd nil xl)) (length (hd nil (tl xl))))) (Init.Nat.add (S O) (Init.Nat.mul (nth O (map (length (A:=bool)) xl) O) (peval (pproj (S (S O)) (S O)) (map (length (A:=bool)) xl))))
+++++
rewrite pproj_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.
rewrite pcst_correct.
rewrite pproj_correct.
rewrite pproj_correct.

*****
H : True
xl : list (list bool)
*****
le (Init.Nat.add (S O) (Init.Nat.mul (length (hd nil xl)) (length (hd nil (tl xl))))) (Init.Nat.add (S O) (Init.Nat.mul (nth O (map (length (A:=bool)) xl) O) (nth (S O) (map (length (A:=bool)) xl) O)))
+++++
rewrite <- hd_nth_0.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.
rewrite pcst_correct.
rewrite pproj_correct.
rewrite pproj_correct.
rewrite <- hd_nth_0.

*****
H : True
xl : list (list bool)
*****
le (Init.Nat.add (S O) (Init.Nat.mul (length (hd nil xl)) (length (hd nil (tl xl))))) (Init.Nat.add (S O) (Init.Nat.mul (hd O (map (length (A:=bool)) xl)) (nth (S O) (map (length (A:=bool)) xl) O)))
+++++
rewrite hd_nth_1.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.
rewrite pcst_correct.
rewrite pproj_correct.
rewrite pproj_correct.
rewrite <- hd_nth_0.
rewrite hd_nth_1.

*****
H : True
xl : list (list bool)
*****
le (Init.Nat.add (S O) (Init.Nat.mul (length (hd nil xl)) (length (nth (S O) xl nil)))) (Init.Nat.add (S O) (Init.Nat.mul (hd O (map (length (A:=bool)) xl)) (nth (S O) (map (length (A:=bool)) xl) O)))
+++++
rewrite (map_hd _ _ (@length _)).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.
rewrite pcst_correct.
rewrite pproj_correct.
rewrite pproj_correct.
rewrite <- hd_nth_0.
rewrite hd_nth_1.
rewrite (map_hd _ _ (@length _)).

*****
H : True
xl : list (list bool)
*****
le (Init.Nat.add (S O) (Init.Nat.mul (hd (length nil) (map (length (A:=bool)) xl)) (length (nth (S O) xl nil)))) (Init.Nat.add (S O) (Init.Nat.mul (hd O (map (length (A:=bool)) xl)) (nth (S O) (map (length (A:=bool)) xl) O)))
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.
rewrite pcst_correct.
rewrite pproj_correct.
rewrite pproj_correct.
rewrite <- hd_nth_0.
rewrite hd_nth_1.
rewrite (map_hd _ _ (@length _)).
simpl.

*****
H : True
xl : list (list bool)
*****
le (S (Init.Nat.mul (hd O (map (length (A:=bool)) xl)) (length (nth (S O) xl nil)))) (S (Init.Nat.mul (hd O (map (length (A:=bool)) xl)) (nth (S O) (map (length (A:=bool)) xl) O)))
+++++
rewrite <- (@map_nth _ _ (@length _) xl).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.
rewrite pcst_correct.
rewrite pproj_correct.
rewrite pproj_correct.
rewrite <- hd_nth_0.
rewrite hd_nth_1.
rewrite (map_hd _ _ (@length _)).
simpl.
rewrite <- (@map_nth _ _ (@length _) xl).

*****
H : True
xl : list (list bool)
*****
le (S (Init.Nat.mul (hd O (map (length (A:=bool)) xl)) (nth (S O) (map (length (A:=bool)) xl) (length nil)))) (S (Init.Nat.mul (hd O (map (length (A:=bool)) xl)) (nth (S O) (map (length (A:=bool)) xl) O)))
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite length_smash.
rewrite pplus_correct.
rewrite pmult_correct.
rewrite pcst_correct.
rewrite pproj_correct.
rewrite pproj_correct.
rewrite <- hd_nth_0.
rewrite hd_nth_1.
rewrite (map_hd _ _ (@length _)).
simpl.
rewrite <- (@map_nth _ _ (@length _) xl).
simpl.

*****
H : True
xl : list (list bool)
*****
le (S (Init.Nat.mul (hd O (map (length (A:=bool)) xl)) (nth (S O) (map (length (A:=bool)) xl) O))) (S (Init.Nat.mul (hd O (map (length (A:=bool)) xl)) (nth (S O) (map (length (A:=bool)) xl) O)))
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.

*****
IHe4 : forall (xl : list (list bool)) (_ : rec_bounded e4),\nle (length (Sem e4 xl))\n (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
IHe3 : forall (xl : list (list bool)) (_ : rec_bounded e3),\nle (length (Sem e3 xl))\n (peval (poly_Cobham e3) (map (length (A:=bool)) xl))
IHe2 : forall (xl : list (list bool)) (_ : rec_bounded e2),\nle (length (Sem e2 xl))\n (peval (poly_Cobham e2) (map (length (A:=bool)) xl))
IHe1 : forall (xl : list (list bool)) (_ : rec_bounded e1),\nle (length (Sem e1 xl))\n (peval (poly_Cobham e1) (map (length (A:=bool)) xl))
e1,e2,e3,e4 : Cobham
*****
forall (xl : list (list bool)) (_ : rec_bounded (Rec e1 e2 e3 e4)), le (length (Sem (Rec e1 e2 e3 e4) xl)) (peval (poly_Cobham (Rec e1 e2 e3 e4)) (map (length (A:=bool)) xl))
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.

*****
H : rec_bounded (Rec e1 e2 e3 e4)
xl : list (list bool)
IHe4 : forall (xl : list (list bool)) (_ : rec_bounded e4),\nle (length (Sem e4 xl))\n (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
IHe3 : forall (xl : list (list bool)) (_ : rec_bounded e3),\nle (length (Sem e3 xl))\n (peval (poly_Cobham e3) (map (length (A:=bool)) xl))
IHe2 : forall (xl : list (list bool)) (_ : rec_bounded e2),\nle (length (Sem e2 xl))\n (peval (poly_Cobham e2) (map (length (A:=bool)) xl))
IHe1 : forall (xl : list (list bool)) (_ : rec_bounded e1),\nle (length (Sem e1 xl))\n (peval (poly_Cobham e1) (map (length (A:=bool)) xl))
e1,e2,e3,e4 : Cobham
*****
le (length (Sem (Rec e1 e2 e3 e4) xl)) (peval (poly_Cobham (Rec e1 e2 e3 e4)) (map (length (A:=bool)) xl))
+++++
simpl in *.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.

*****
H : and (rec_bounded e4)\n (and (rec_bounded e1)\n (and (rec_bounded e2)\n (and (rec_bounded e3)\n (forall l : list (list bool),\n le\n (length\n (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))))))
xl : list (list bool)
IHe4 : forall (xl : list (list bool)) (_ : rec_bounded e4),\nle (length (Sem e4 xl))\n (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
IHe3 : forall (xl : list (list bool)) (_ : rec_bounded e3),\nle (length (Sem e3 xl))\n (peval (poly_Cobham e3) (map (length (A:=bool)) xl))
IHe2 : forall (xl : list (list bool)) (_ : rec_bounded e2),\nle (length (Sem e2 xl))\n (peval (poly_Cobham e2) (map (length (A:=bool)) xl))
IHe1 : forall (xl : list (list bool)) (_ : rec_bounded e1),\nle (length (Sem e1 xl))\n (peval (poly_Cobham e1) (map (length (A:=bool)) xl))
e1,e2,e3,e4 : Cobham
*****
le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil xl) (tl xl))) (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.

*****
H : and (rec_bounded e4)\n (and (rec_bounded e1)\n (and (rec_bounded e2)\n (and (rec_bounded e3)\n (forall l : list (list bool),\n le\n (length\n (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))))))
xl : list (list bool)
IHe4 : forall (xl : list (list bool)) (_ : rec_bounded e4),\nle (length (Sem e4 xl))\n (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
IHe3 : forall (xl : list (list bool)) (_ : rec_bounded e3),\nle (length (Sem e3 xl))\n (peval (poly_Cobham e3) (map (length (A:=bool)) xl))
IHe2 : forall (xl : list (list bool)) (_ : rec_bounded e2),\nle (length (Sem e2 xl))\n (peval (poly_Cobham e2) (map (length (A:=bool)) xl))
IHe1 : forall (xl : list (list bool)) (_ : rec_bounded e1),\nle (length (Sem e1 xl))\n (peval (poly_Cobham e1) (map (length (A:=bool)) xl))
e1,e2,e3,e4 : Cobham
*****
le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil xl) (tl xl))) (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
+++++
decompose [and] H.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
decompose [and] H.

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
H : and (rec_bounded e4)\n (and (rec_bounded e1)\n (and (rec_bounded e2)\n (and (rec_bounded e3)\n (forall l : list (list bool),\n le\n (length\n (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))))))
xl : list (list bool)
IHe4 : forall (xl : list (list bool)) (_ : rec_bounded e4),\nle (length (Sem e4 xl))\n (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
IHe3 : forall (xl : list (list bool)) (_ : rec_bounded e3),\nle (length (Sem e3 xl))\n (peval (poly_Cobham e3) (map (length (A:=bool)) xl))
IHe2 : forall (xl : list (list bool)) (_ : rec_bounded e2),\nle (length (Sem e2 xl))\n (peval (poly_Cobham e2) (map (length (A:=bool)) xl))
IHe1 : forall (xl : list (list bool)) (_ : rec_bounded e1),\nle (length (Sem e1 xl))\n (peval (poly_Cobham e1) (map (length (A:=bool)) xl))
e1,e2,e3,e4 : Cobham
*****
le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil xl) (tl xl))) (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
+++++
clear H.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
decompose [and] H.
clear H.

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
xl : list (list bool)
IHe4 : forall (xl : list (list bool)) (_ : rec_bounded e4),\nle (length (Sem e4 xl))\n (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
IHe3 : forall (xl : list (list bool)) (_ : rec_bounded e3),\nle (length (Sem e3 xl))\n (peval (poly_Cobham e3) (map (length (A:=bool)) xl))
IHe2 : forall (xl : list (list bool)) (_ : rec_bounded e2),\nle (length (Sem e2 xl))\n (peval (poly_Cobham e2) (map (length (A:=bool)) xl))
IHe1 : forall (xl : list (list bool)) (_ : rec_bounded e1),\nle (length (Sem e1 xl))\n (peval (poly_Cobham e1) (map (length (A:=bool)) xl))
e1,e2,e3,e4 : Cobham
*****
le (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil xl) (tl xl))) (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
+++++
apply le_trans with (1 := H5 xl).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
decompose [and] H.
clear H.
apply le_trans with (1 := H5 xl).

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
xl : list (list bool)
IHe4 : forall (xl : list (list bool)) (_ : rec_bounded e4),\nle (length (Sem e4 xl))\n (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
IHe3 : forall (xl : list (list bool)) (_ : rec_bounded e3),\nle (length (Sem e3 xl))\n (peval (poly_Cobham e3) (map (length (A:=bool)) xl))
IHe2 : forall (xl : list (list bool)) (_ : rec_bounded e2),\nle (length (Sem e2 xl))\n (peval (poly_Cobham e2) (map (length (A:=bool)) xl))
IHe1 : forall (xl : list (list bool)) (_ : rec_bounded e1),\nle (length (Sem e1 xl))\n (peval (poly_Cobham e1) (map (length (A:=bool)) xl))
e1,e2,e3,e4 : Cobham
*****
le (length (Sem e4 xl)) (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
+++++
apply IHe4.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
decompose [and] H.
clear H.
apply le_trans with (1 := H5 xl).
apply IHe4.

*****
H5 : forall l : list (list bool),\nle (length (sem_Rec (Sem e1) (Sem e2) (Sem e3) (hd nil l) (tl l)))\n (length (Sem e4 l))
H3 : rec_bounded e3
H1 : rec_bounded e2
H2 : rec_bounded e1
H0 : rec_bounded e4
xl : list (list bool)
IHe4 : forall (xl : list (list bool)) (_ : rec_bounded e4),\nle (length (Sem e4 xl))\n (peval (poly_Cobham e4) (map (length (A:=bool)) xl))
IHe3 : forall (xl : list (list bool)) (_ : rec_bounded e3),\nle (length (Sem e3 xl))\n (peval (poly_Cobham e3) (map (length (A:=bool)) xl))
IHe2 : forall (xl : list (list bool)) (_ : rec_bounded e2),\nle (length (Sem e2 xl))\n (peval (poly_Cobham e2) (map (length (A:=bool)) xl))
IHe1 : forall (xl : list (list bool)) (_ : rec_bounded e1),\nle (length (Sem e1 xl))\n (peval (poly_Cobham e1) (map (length (A:=bool)) xl))
e1,e2,e3,e4 : Cobham
*****
rec_bounded e4
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.

*****
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
forall (xl : list (list bool)) (_ : rec_bounded (Comp n e l)), le (length (Sem (Comp n e l) xl)) (peval (poly_Cobham (Comp n e l)) (map (length (A:=bool)) xl))
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.

*****
H0 : rec_bounded (Comp n e l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem (Comp n e l) xl)) (peval (poly_Cobham (Comp n e l)) (map (length (A:=bool)) xl))
+++++
simpl in *.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem e (map (fun e : Cobham => Sem e xl) l))) (peval (pplus (pcst n O) (pcomp (poly_Cobham e) (map poly_Cobham l))) (map (length (A:=bool)) xl))
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem e (map (fun e : Cobham => Sem e xl) l))) (peval (pplus (pcst n O) (pcomp (poly_Cobham e) (map poly_Cobham l))) (map (length (A:=bool)) xl))
+++++
rewrite pplus_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem e (map (fun e : Cobham => Sem e xl) l))) (Init.Nat.add (peval (pcst n O) (map (length (A:=bool)) xl)) (peval (pcomp (poly_Cobham e) (map poly_Cobham l)) (map (length (A:=bool)) xl)))
+++++
rewrite pcst_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem e (map (fun e : Cobham => Sem e xl) l))) (Init.Nat.add O (peval (pcomp (poly_Cobham e) (map poly_Cobham l)) (map (length (A:=bool)) xl)))
+++++
rewrite pcomp_correct.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem e (map (fun e : Cobham => Sem e xl) l))) (Init.Nat.add O (peval (poly_Cobham e) (map (fun p : pol => peval p (map (length (A:=bool)) xl)) (map poly_Cobham l))))
+++++
eapply le_trans.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem e (map (fun e : Cobham => Sem e xl) l))) ?m
+++++
apply IHe.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
apply IHe.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
rec_bounded e
+++++
tauto.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (peval (poly_Cobham e) (map (length (A:=bool)) (map (fun e : Cobham => Sem e xl) l))) (Init.Nat.add O (peval (poly_Cobham e) (map (fun p : pol => peval p (map (length (A:=bool)) xl)) (map poly_Cobham l))))
+++++
repeat rewrite map_map.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (peval (poly_Cobham e) (map (fun x : Cobham => length (Sem x xl)) l)) (Init.Nat.add O (peval (poly_Cobham e) (map (fun x : Cobham => peval (poly_Cobham x) (map (length (A:=bool)) xl)) l)))
+++++
apply peval_monotonic.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
forall i : nat, le (nth i (map (fun x : Cobham => length (Sem x xl)) l) O) (nth i (map (fun x : Cobham => peval (poly_Cobham x) (map (length (A:=bool)) xl)) l) O)
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (nth i (map (fun x : Cobham => length (Sem x xl)) l) O) (nth i (map (fun x : Cobham => peval (poly_Cobham x) (map (length (A:=bool)) xl)) l) O)
+++++
rewrite map_nth2 with (d := Zero).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem (nth i l Zero) xl)) (nth i (map (fun x : Cobham => peval (poly_Cobham x) (map (length (A:=bool)) xl)) l) O)
+++++
idtac.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem (nth i l Zero) xl)) (nth i (map (fun x : Cobham => peval (poly_Cobham x) (map (length (A:=bool)) xl)) l) O)
+++++
rewrite map_nth2 with (d := Zero).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem (nth i l Zero) xl)) (peval (poly_Cobham (nth i l Zero)) (map (length (A:=bool)) xl))
+++++
idtac.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem (nth i l Zero) xl)) (peval (poly_Cobham (nth i l Zero)) (map (length (A:=bool)) xl))
+++++
clear IHe.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem (nth i l Zero) xl)) (peval (poly_Cobham (nth i l Zero)) (map (length (A:=bool)) xl))
+++++
assert (rec_bounded (nth i l Zero)).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
rec_bounded (nth i l Zero)
+++++
clear H.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
l : list Cobham
e : Cobham
n : nat
*****
rec_bounded (nth i l Zero)
+++++
revert i.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.

*****
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
l : list Cobham
e : Cobham
n : nat
*****
forall i : nat, rec_bounded (nth i l Zero)
+++++
induction l.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.

*****
H0 : and (rec_bounded e) (andl rec_bounded nil)
xl : list (list bool)
e : Cobham
n : nat
*****
forall i : nat, rec_bounded (nth i nil Zero)
+++++
simpl in *.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.

*****
H0 : and (rec_bounded e) True
xl : list (list bool)
e : Cobham
n : nat
*****
forall i : nat, rec_bounded match i with | O | _ => Zero end
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.

*****
i : nat
H0 : and (rec_bounded e) True
xl : list (list bool)
e : Cobham
n : nat
*****
rec_bounded match i with | O | _ => Zero end
+++++
case i.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.

*****
i : nat
H0 : and (rec_bounded e) True
xl : list (list bool)
e : Cobham
n : nat
*****
rec_bounded Zero
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.
simpl.

*****
i : nat
H0 : and (rec_bounded e) True
xl : list (list bool)
e : Cobham
n : nat
*****
True
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.

*****
i : nat
H0 : and (rec_bounded e) True
xl : list (list bool)
e : Cobham
n : nat
*****
forall _ : nat, rec_bounded Zero
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.
simpl.

*****
i : nat
H0 : and (rec_bounded e) True
xl : list (list bool)
e : Cobham
n : nat
*****
forall _ : nat, True
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.

*****
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (andl rec_bounded (cons a l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
forall i : nat, rec_bounded (nth i (cons a l) Zero)
+++++
simpl in *.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.

*****
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
forall i : nat, rec_bounded match i with | O => a | S m => nth m l Zero end
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.

*****
i : nat
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
rec_bounded match i with | O => a | S m => nth m l Zero end
+++++
case i.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.

*****
i : nat
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
rec_bounded a
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.
simpl.

*****
i : nat
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
rec_bounded a
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.
simpl.
trivial.

*****
i : nat
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
rec_bounded a
+++++
tauto.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.

*****
i : nat
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
forall n : nat, rec_bounded (nth n l Zero)
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.
simpl.

*****
i : nat
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
forall n : nat, rec_bounded (nth n l Zero)
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.
simpl.
trivial.

*****
i : nat
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
forall n : nat, rec_bounded (nth n l Zero)
+++++
intros.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.
simpl.
trivial.
intros.

*****
i,n0 : nat
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
rec_bounded (nth n0 l Zero)
+++++
apply IHl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
clear H.
revert i.
induction l.
simpl in *.
intros.
case i.
simpl.
trivial.
intros.
apply IHl.

*****
i,n0 : nat
IHl : forall (_ : and (rec_bounded e) (andl rec_bounded l)) (i : nat),\nrec_bounded (nth i l Zero)
H0 : and (rec_bounded e) (and (rec_bounded a) (andl rec_bounded l))
xl : list (list bool)
l : list Cobham
e,a : Cobham
n : nat
*****
and (rec_bounded e) (andl rec_bounded l)
+++++
tauto.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).

*****
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem (nth i l Zero) xl)) (peval (poly_Cobham (nth i l Zero)) (map (length (A:=bool)) xl))
+++++
destruct (lt_dec i (length l)).
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
destruct (lt_dec i (length l)).

*****
l0 : lt i (length l)
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem (nth i l Zero) xl)) (peval (poly_Cobham (nth i l Zero)) (map (length (A:=bool)) xl))
+++++
apply H.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
destruct (lt_dec i (length l)).
apply H.

*****
l0 : lt i (length l)
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
In (nth i l Zero) l
+++++
apply nth_In.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
destruct (lt_dec i (length l)).
apply H.
apply nth_In.

*****
l0 : lt i (length l)
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
lt i (length l)
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
destruct (lt_dec i (length l)).
apply H.

*****
l0 : lt i (length l)
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
rec_bounded (nth i l Zero)
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
destruct (lt_dec i (length l)).

*****
n0 : not (lt i (length l))
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem (nth i l Zero) xl)) (peval (poly_Cobham (nth i l Zero)) (map (length (A:=bool)) xl))
+++++
rewrite nth_overflow.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
destruct (lt_dec i (length l)).
rewrite nth_overflow.

*****
n0 : not (lt i (length l))
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length (Sem Zero xl)) (peval (poly_Cobham Zero) (map (length (A:=bool)) xl))
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
destruct (lt_dec i (length l)).
rewrite nth_overflow.
simpl.

*****
n0 : not (lt i (length l))
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le O (peval (pcst O O) (map (length (A:=bool)) xl))
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
destruct (lt_dec i (length l)).
rewrite nth_overflow.

*****
n0 : not (lt i (length l))
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length l) i
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
idtac.
clear IHe.
assert (rec_bounded (nth i l Zero)).
destruct (lt_dec i (length l)).
rewrite nth_overflow.
simpl.

*****
n0 : not (lt i (length l))
H1 : rec_bounded (nth i l Zero)
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
le (length l) i
+++++
omega.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
eq (peval (poly_Cobham Zero) (map (length (A:=bool)) xl)) O
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
idtac.
rewrite map_nth2 with (d := Zero).
simpl.

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
eq (peval (pcst O O) (map (length (A:=bool)) xl)) O
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
eq (length (Sem Zero xl)) O
+++++
simpl.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.
intros.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pcomp_correct.
eapply le_trans.
repeat rewrite map_map.
apply peval_monotonic.
intros.
rewrite map_nth2 with (d := Zero).
simpl.

*****
i : nat
H0 : and (rec_bounded e) (andl rec_bounded l)
xl : list (list bool)
IHe : forall (xl : list (list bool)) (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
H : forall (e : Cobham) (_ : In e l) (xl : list (list bool))\n (_ : rec_bounded e),\nle (length (Sem e xl))\n (peval (poly_Cobham e) (map (length (A:=bool)) xl))
l : list Cobham
e : Cobham
n : nat
*****
eq O O
+++++
trivial.
-----
Lemma poly_Cobham_correct : forall (e : Cobham) xl, rec_bounded e -> length (Sem e xl) <= peval (poly_Cobham e) (map (@length _) xl).
Proof.
induction e using Cobham_ind2.

*****

*****

+++++
Qed.
-----
