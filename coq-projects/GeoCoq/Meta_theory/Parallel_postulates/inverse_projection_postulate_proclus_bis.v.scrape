Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Tarski_dev.Ch13_1.
-----
Section inverse_projection_postulate_proclus_bis.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma inverse_projection_postulate__proclus_bis :\n  inverse_projection_postulate -> alternative_proclus_postulate.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : inverse_projection_postulate, alternative_proclus_postulate
+++++
Proof.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : inverse_projection_postulate, alternative_proclus_postulate
+++++
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.

*****
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp2 A B C D P
A,B,C,D,P,Q : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
elim(col_dec C D P).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).

*****
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp2 A B C D P
A,B,C,D,P,Q : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col C D P, ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
intro; exists P; split; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.

*****
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp2 A B C D P
A,B,C,D,P,Q : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col C D P), ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
intro HNCol1.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.

*****
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp2 A B C D P
A,B,C,D,P,Q : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(Par_strict C D A B).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).

*****
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp2 A B C D P
A,B,C,D,P,Q : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict C D A B
+++++
apply (par_not_col_strict _ _ _ _ P); auto.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.

*****
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp2 A B C D P
A,B,C,D,P,Q : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par C D A B
+++++
apply par_symmetry.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.
apply par_symmetry.

*****
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp2 A B C D P
A,B,C,D,P,Q : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B C D
+++++
destruct HPerp2 as [X [Y [HCol1 [HPerp1 HPerp2]]]].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.
apply par_symmetry.
destruct HPerp2 as [X [Y [HCol1 [HPerp1 HPerp2]]]].

*****
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp X Y C D
HPerp1 : Perp X Y A B
HCol1 : Col P X Y
A,B,C,D,P,Q,X,Y : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B C D
+++++
assert (HI1 := HPerp1); assert (HI2 := HPerp2).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.
apply par_symmetry.
destruct HPerp2 as [X [Y [HCol1 [HPerp1 HPerp2]]]].
assert (HI1 := HPerp1); assert (HI2 := HPerp2).

*****
HI2 : Perp X Y C D
HI1 : Perp X Y A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp X Y C D
HPerp1 : Perp X Y A B
HCol1 : Col P X Y
A,B,C,D,P,Q,X,Y : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B C D
+++++
destruct HI1 as [I1 H1]; destruct HI2 as [I2 H2].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.
apply par_symmetry.
destruct HPerp2 as [X [Y [HCol1 [HPerp1 HPerp2]]]].
assert (HI1 := HPerp1); assert (HI2 := HPerp2).
destruct HI1 as [I1 H1]; destruct HI2 as [I2 H2].

*****
H2 : Perp_at I2 X Y C D
I2 : Tpoint
H1 : Perp_at I1 X Y A B
I1 : Tpoint
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp X Y C D
HPerp1 : Perp X Y A B
HCol1 : Col P X Y
A,B,C,D,P,Q,X,Y : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B C D
+++++
apply perp_in_col in H1; apply perp_in_col in H2.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.
apply par_symmetry.
destruct HPerp2 as [X [Y [HCol1 [HPerp1 HPerp2]]]].
assert (HI1 := HPerp1); assert (HI2 := HPerp2).
destruct HI1 as [I1 H1]; destruct HI2 as [I2 H2].
apply perp_in_col in H1; apply perp_in_col in H2.

*****
H2 : and (Col X Y I2) (Col C D I2)
I2 : Tpoint
H1 : and (Col X Y I1) (Col A B I1)
I1 : Tpoint
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp X Y C D
HPerp1 : Perp X Y A B
HCol1 : Col P X Y
A,B,C,D,P,Q,X,Y : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B C D
+++++
destruct H1 as [HCol2 HCol3]; destruct H2 as [HCol4 HCol5].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.
apply par_symmetry.
destruct HPerp2 as [X [Y [HCol1 [HPerp1 HPerp2]]]].
assert (HI1 := HPerp1); assert (HI2 := HPerp2).
destruct HI1 as [I1 H1]; destruct HI2 as [I2 H2].
apply perp_in_col in H1; apply perp_in_col in H2.
destruct H1 as [HCol2 HCol3]; destruct H2 as [HCol4 HCol5].

*****
HCol5 : Col C D I2
HCol4 : Col X Y I2
I2 : Tpoint
HCol3 : Col A B I1
HCol2 : Col X Y I1
I1 : Tpoint
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp X Y C D
HPerp1 : Perp X Y A B
HCol1 : Col P X Y
A,B,C,D,P,Q,X,Y : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B C D
+++++
assert (P = I1); [|treat_equalities; rename I2 into R].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.
apply par_symmetry.
destruct HPerp2 as [X [Y [HCol1 [HPerp1 HPerp2]]]].
assert (HI1 := HPerp1); assert (HI2 := HPerp2).
destruct HI1 as [I1 H1]; destruct HI2 as [I2 H2].
apply perp_in_col in H1; apply perp_in_col in H2.
destruct H1 as [HCol2 HCol3]; destruct H2 as [HCol4 HCol5].
assert (P = I1); [|treat_equalities; rename I2 into R].

*****
HCol5 : Col C D I2
HCol4 : Col X Y I2
I2 : Tpoint
HCol3 : Col A B I1
HCol2 : Col X Y I1
I1 : Tpoint
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp X Y C D
HPerp1 : Perp X Y A B
HCol1 : Col P X Y
A,B,C,D,P,Q,X,Y : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq P I1
+++++
elim (perp_not_col2 _ _ _ _ (perp_sym _ _ _ _ HPerp1)); intro; [apply l6_21 with A B X Y|apply l6_21 with A B Y X]; assert_diffs; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.
apply par_symmetry.
destruct HPerp2 as [X [Y [HCol1 [HPerp1 HPerp2]]]].
assert (HI1 := HPerp1); assert (HI2 := HPerp2).
destruct HI1 as [I1 H1]; destruct HI2 as [I2 H2].
apply perp_in_col in H1; apply perp_in_col in H2.
destruct H1 as [HCol2 HCol3]; destruct H2 as [HCol4 HCol5].
assert (P = I1); [|treat_equalities; rename I2 into R].

*****
HCol5 : Col C D R
HCol4 : Col X Y R
R : Tpoint
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp X Y C D
HPerp1 : Perp X Y A B
HCol1 : Col P X Y
A,B,C,D,P,Q,X,Y : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B C D
+++++
elim (eq_dec_points P R); intro HNE; treat_equalities; [exfalso; Col|].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
apply (par_not_col_strict _ _ _ _ P); auto.
apply par_symmetry.
destruct HPerp2 as [X [Y [HCol1 [HPerp1 HPerp2]]]].
assert (HI1 := HPerp1); assert (HI2 := HPerp2).
destruct HI1 as [I1 H1]; destruct HI2 as [I2 H2].
apply perp_in_col in H1; apply perp_in_col in H2.
destruct H1 as [HCol2 HCol3]; destruct H2 as [HCol4 HCol5].
assert (P = I1); [|treat_equalities; rename I2 into R].
elim (eq_dec_points P R); intro HNE; treat_equalities; [exfalso; Col|].

*****
HNE : not (eq P R)
HCol5 : Col C D R
HCol4 : Col X Y R
R : Tpoint
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp X Y C D
HPerp1 : Perp X Y A B
HCol1 : Col P X Y
A,B,C,D,P,Q,X,Y : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A B C D
+++++
apply (l12_9 _ _ _ _ X Y); Perp; apply coplanar_perm_16; apply col2_cop__cop with P R; try solve [assert_diffs; ColR]; apply coplanar_perm_2; [apply col_cop__cop with D|apply col_cop__cop with C| apply col_cop__cop with D|apply col_cop__cop with C]; Col; try solve [assert_diffs; auto]; apply coplanar_perm_16; [apply col_cop__cop with B|apply col_cop__cop with B| apply col_cop__cop with A|apply col_cop__cop with A]; assert_diffs; Col; Cop.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).

*****
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerp2 : Perp2 A B C D P
A,B,C,D,P,Q : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].

*****
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp P1 P2 A B
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HC0 := HPerpCP); auto.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.

*****
HC0 : Perp P1 P2 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp P1 P2 A B
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].

*****
HC0C : Col C0 C D
HC0P : Col C0 P1 P2
C0 : Tpoint
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp P1 P2 A B
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HP' := HPerpAP); auto.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.

*****
HP' : Perp P1 P2 A B
HC0C : Col C0 C D
HC0P : Col C0 P1 P2
C0 : Tpoint
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp P1 P2 A B
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HP' as [P' HPerpP].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].

*****
HPerpP : Perp_at P' P1 P2 A B
P' : Tpoint
HC0C : Col C0 C D
HC0P : Col C0 P1 P2
C0 : Tpoint
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp P1 P2 A B
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).

*****
H0 : eq P' P
HPerpP : Perp_at P' P1 P2 A B
P' : Tpoint
HC0C : Col C0 C D
HC0P : Col C0 P1 P2
C0 : Tpoint
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp P1 P2 A B
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
subst P'.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.

*****
HPerpP : Perp_at P P1 P2 A B
HC0C : Col C0 C D
HC0P : Col C0 P1 P2
C0 : Tpoint
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp P1 P2 A B
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HPerpP as [_ [_ [HPP _]]].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].

*****
HPP : Col P P1 P2
HC0C : Col C0 C D
HC0P : Col C0 P1 P2
C0 : Tpoint
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp P1 P2 A B
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(P<>C0) by (intro; subst C0; Col).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).

*****
H0 : not (eq P C0)
HPP : Col P P1 P2
HC0C : Col C0 C D
HC0P : Col C0 P1 P2
C0 : Tpoint
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp P1 P2 A B
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.

*****
H0 : not (eq P C0)
HPP : Col P P1 P2
HC0C : Col C0 C D
HC0P : Col C0 P1 P2
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp P1 P2 C D
HPerpAP : Perp A B P C0
C0 : Tpoint
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.

*****
H0 : not (eq P C0)
HPP : Col P P1 P2
HC0C : Col C0 C D
HC0P : Col C0 P1 P2
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
C0 : Tpoint
HP : Col P P1 P2
A,B,C,D,P,Q,P1,P2 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
clear dependent P1.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.

*****
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,P2,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
clear dependent P2.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.

*****
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(P<>Q) by (intro; subst; auto).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).

*****
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
elim(col_dec P Q C0).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).

*****
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col P Q C0, ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
intro; exists C0; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.

*****
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col P Q C0), ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
intro HNCol2.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.

*****
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).

*****
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).

*****
HQ0 : forall (_ : not (eq Q P)) (_ : Col A B P) (_ : Col Q P P)\n (_ : not (Col A B Q)) (_ : not (Col A B C0)) (_ : Coplanar A B Q C0),\nex (fun Q0 : Tpoint => and (Col Q P Q0) (OS A B C0 Q0))
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HQ0 as [Q0 []]; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.

*****
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B Q C0
+++++
assert (Coplanar C D P C0) by Cop.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.

*****
H2 : Coplanar C D P C0
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B Q C0
+++++
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).

*****
H3 : Coplanar C D P A
H2 : Coplanar C D P C0
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B Q C0
+++++
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).

*****
H4 : Coplanar C D P B
H3 : Coplanar C D P A
H2 : Coplanar C D P C0
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B Q C0
+++++
CopR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.

*****
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).

*****
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(P<>Q0) by (intro; subst; auto).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).

*****
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).

*****
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HNCol1 : not (Col C D P)
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert_diffs.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.

*****
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HC1 : exists C1, Col C D C1 /\ C1 <> C0).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).

*****
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C1 : Tpoint => and (Col C D C1) (not (eq C1 C0)))
+++++
elim(eq_dec_points C C0).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
elim(eq_dec_points C C0).

*****
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : eq C C0, ex (fun C1 : Tpoint => and (Col C D C1) (not (eq C1 C0)))
+++++
intro; subst C0; exists D; split; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
elim(eq_dec_points C C0).
intro; subst C0; exists D; split; Col.

*****
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq C C0), ex (fun C1 : Tpoint => and (Col C D C1) (not (eq C1 C0)))
+++++
intro; exists C; split; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).

*****
HC1 : ex (fun C1 : Tpoint => and (Col C D C1) (not (eq C1 C0)))
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HC1 as [C1 []].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].

*****
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert (Coplanar C D P C0) by Cop.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.

*****
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).

*****
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).

*****
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert (Coplanar A B P C0) by Cop.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.

*****
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HA0 : exists A0, Col A B A0 /\ OS P C0 Q0 A0).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).

*****
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
+++++
elim(col_dec P C0 A).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).

*****
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col P C0 A, ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
+++++
-
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-

*****
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col P C0 A, ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
+++++
intro.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.

*****
H23 : Col P C0 A
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
+++++
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).

*****
H24 : not (Col P C0 B)
H23 : Col P C0 A
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
+++++
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).

*****
HA0 : forall (_ : not (eq B A)) (_ : Col P C0 P) (_ : Col B A P)\n (_ : not (Col P C0 B)) (_ : not (Col P C0 Q0))\n (_ : Coplanar P C0 B Q0),\nex (fun Q : Tpoint => and (Col B A Q) (OS P C0 Q0 Q))
H24 : not (Col P C0 B)
H23 : Col P C0 A
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
+++++
destruct HA0 as [A0 []]; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.

*****
H24 : not (Col P C0 B)
H23 : Col P C0 A
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P C0 B Q0
+++++
assert (Coplanar B P Q Q0) by Cop.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.

*****
H25 : Coplanar B P Q Q0
H24 : not (Col P C0 B)
H23 : Col P C0 A
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P C0 B Q0
+++++
assert (Coplanar B P Q C0) by CopR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.

*****
H26 : Coplanar B P Q C0
H25 : Coplanar B P Q Q0
H24 : not (Col P C0 B)
H23 : Col P C0 A
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P C0 B Q0
+++++
assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.
assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR].

*****
H26 : OS P C0 Q0 A0
H25 : Col B A A0
A0 : Tpoint
H24 : not (Col P C0 B)
H23 : Col P C0 A
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
+++++
exists A0.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.
assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR].
exists A0.

*****
H26 : OS P C0 Q0 A0
H25 : Col B A A0
A0 : Tpoint
H24 : not (Col P C0 B)
H23 : Col P C0 A
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col A B A0) (OS P C0 Q0 A0)
+++++
split; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.
assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR].
exists A0.
split; Col.

*****

*****

+++++
-
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.
assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR].
exists A0.
split; Col.
-

*****
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col P C0 A), ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
+++++
intro.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.
assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR].
exists A0.
split; Col.
-
intro.

*****
H23 : not (Col P C0 A)
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
+++++
apply (cop_not_par_same_side _ _ _ _ P); Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.
assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR].
exists A0.
split; Col.
-
intro.
apply (cop_not_par_same_side _ _ _ _ P); Col.

*****
H23 : not (Col P C0 A)
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P C0 A Q0
+++++
assert (Coplanar A P Q Q0) by Cop.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.
assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR].
exists A0.
split; Col.
-
intro.
apply (cop_not_par_same_side _ _ _ _ P); Col.
assert (Coplanar A P Q Q0) by Cop.

*****
H24 : Coplanar A P Q Q0
H23 : not (Col P C0 A)
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P C0 A Q0
+++++
assert (Coplanar A P Q C0) by CopR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
elim(col_dec P C0 A).
-
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (HA0 := cop_not_par_same_side P C0 B A P Q0).
destruct HA0 as [A0 []]; Col.
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.
assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR].
exists A0.
split; Col.
-
intro.
apply (cop_not_par_same_side _ _ _ _ P); Col.
assert (Coplanar A P Q Q0) by Cop.
assert (Coplanar A P Q C0) by CopR.

*****
H25 : Coplanar A P Q C0
H24 : Coplanar A P Q Q0
H23 : not (Col P C0 A)
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P C0 A Q0
+++++
assert (~ Col A P Q); [intro; apply HNC2; ColR|CopR].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).

*****
HA0 : ex (fun A0 : Tpoint => and (Col A B A0) (OS P C0 Q0 A0))
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HA0 as [A0 []].
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].

*****
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).

*****
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert_diffs.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
assert(HY := ip C0 P Q0 C0 C1).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).

*****
HY : forall (_ : Acute C0 P Q0) (_ : Out P C0 C0) (_ : not (eq C0 C1))\n (_ : Per P C0 C1) (_ : Coplanar C0 P Q0 C1),\nex (fun Y : Tpoint => and (Out P Q0 Y) (Col C0 C1 Y))
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
destruct HY as [Y []]; auto.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute C0 P Q0
+++++
exists C0, P, A0; split.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per C0 P A0
+++++
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA C0 P Q0 C0 P A0
+++++
split.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA C0 P Q0 C0 P A0
+++++
exists Q0; split; CongA.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
exists Q0; split; CongA.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle Q0 C0 P A0
+++++
apply os2__inangle; Side.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
exists Q0; split; CongA.
apply os2__inangle; Side.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS P A0 C0 Q0
+++++
apply (col2_os__os A B); auto.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (CongA C0 P Q0 C0 P A0)
+++++
intro.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.

*****
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).

*****
Habs : forall (_ : Coplanar C0 P Q0 A0) (_ : CongA C0 P Q0 C0 P A0),\nor (Out P Q0 A0) (TS C0 P Q0 A0)
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct Habs as [Habs|Habs]; auto.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.

*****
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
elim(col_dec P C0 A).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).

*****
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : Col P C0 A, Coplanar C0 P Q0 A0
+++++
intro.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
intro.

*****
H26 : Col P C0 A
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).

*****
H28 : not (Col P C0 B)
H26 : Col P C0 A
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
assert (Coplanar B P Q Q0) by Cop.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (Coplanar B P Q Q0) by Cop.

*****
H29 : Coplanar B P Q Q0
H28 : not (Col P C0 B)
H26 : Col P C0 A
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
assert (Coplanar B P Q C0) by CopR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.

*****
H31 : Coplanar B P Q C0
H29 : Coplanar B P Q Q0
H28 : not (Col P C0 B)
H26 : Col P C0 A
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
assert (Coplanar B P C0 Q0) by (assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR]).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
intro.
assert(~ Col P C0 B) by (intro; apply HNCol3; ColR).
assert (Coplanar B P Q Q0) by Cop.
assert (Coplanar B P Q C0) by CopR.
assert (Coplanar B P C0 Q0) by (assert (~ Col B P Q); [intro; apply HNC2; ColR|CopR]).

*****
H32 : Coplanar B P C0 Q0
H31 : Coplanar B P Q C0
H29 : Coplanar B P Q Q0
H28 : not (Col P C0 B)
H26 : Col P C0 A
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
apply coplanar_perm_2; apply col2_cop__cop with P B; assert_diffs; Cop; Col; ColR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).

*****
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (Col P C0 A), Coplanar C0 P Q0 A0
+++++
intro.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
intro.

*****
H26 : not (Col P C0 A)
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
assert (Coplanar A P Q Q0) by Cop.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
intro.
assert (Coplanar A P Q Q0) by Cop.

*****
H28 : Coplanar A P Q Q0
H26 : not (Col P C0 A)
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
assert (Coplanar A P Q C0) by CopR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
intro.
assert (Coplanar A P Q Q0) by Cop.
assert (Coplanar A P Q C0) by CopR.

*****
H29 : Coplanar A P Q C0
H28 : Coplanar A P Q Q0
H26 : not (Col P C0 A)
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
assert (Coplanar A P C0 Q0) by (assert (~ Col A P Q); [intro; apply HNC2; ColR|CopR]).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
intro.
assert (Coplanar A P Q Q0) by Cop.
assert (Coplanar A P Q C0) by CopR.
assert (Coplanar A P C0 Q0) by (assert (~ Col A P Q); [intro; apply HNC2; ColR|CopR]).

*****
H31 : Coplanar A P C0 Q0
H29 : Coplanar A P Q C0
H28 : Coplanar A P Q Q0
H26 : not (Col P C0 A)
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 A0
+++++
apply coplanar_perm_2; apply col2_cop__cop with P A; assert_diffs; Cop; Col; ColR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).

*****
Habs : Out P Q0 A0
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol4; ColR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
exists C0, P, A0; split.
assert(HPer := l8_16_1 A B C0 A0 P); destruct HPer; Col; Perp.
split.
intro.
assert(Habs := conga_cop__or_out_ts C0 P Q0 A0).
destruct Habs as [Habs|Habs]; auto.
elim(col_dec P C0 A).
apply HNCol4; ColR.

*****
Habs : TS C0 P Q0 A0
H25 : CongA C0 P Q0 C0 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply l9_9 in Habs; apply Habs; Side.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out P C0 C0
+++++
apply out_trivial; auto.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per P C0 C1
+++++
assert(HPer := l8_16_1 C D P C1 C0); destruct HPer; Col; Perp.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 C1
+++++
assert (Coplanar C0 C1 P A0).
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
assert (Coplanar C0 C1 P A0).

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 C1 P A0
+++++
apply col2_cop__cop with A B; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
assert (Coplanar C0 C1 P A0).
apply col2_cop__cop with A B; Col.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 C1 A B
+++++
apply coplanar_perm_16.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
assert (Coplanar C0 C1 P A0).
apply col2_cop__cop with A B; Col.
apply coplanar_perm_16.

*****
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A B C0 C1
+++++
apply col2_cop__cop with C D; Col.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
assert (Coplanar C0 C1 P A0).

*****
H25 : Coplanar C0 C1 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 C1
+++++
assert (Coplanar P C0 Q0 A0) by Cop.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.
assert (Coplanar C0 C1 P A0).
assert (Coplanar P C0 Q0 A0) by Cop.

*****
H26 : Coplanar P C0 Q0 A0
H25 : Coplanar C0 C1 P A0
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C0 P Q0 C1
+++++
CopR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.

*****
H26 : Col C0 C1 Y
H25 : Out P Q0 Y
Y : Tpoint
H30 : not (eq P A0)
H27 : not (eq C0 A0)
HNCol6 : not (Col P C0 A0)
H24 : OS P C0 Q0 A0
H23 : Col A B A0
A0 : Tpoint
H22 : Coplanar A B P C0
H21 : Coplanar C D P B
H20 : Coplanar C D P A
H18 : Coplanar C D P C0
H6 : not (eq C1 C0)
H5 : Col C D C1
C1 : Tpoint
H19 : not (eq C P)
H15 : not (eq D P)
H16 : not (eq C D)
H17 : not (eq A Q)
H13 : not (eq B Q)
H10 : not (eq Q C0)
H14 : not (eq C0 B)
H12 : not (eq C0 A)
H11 : not (eq A Q0)
H8 : not (eq B Q0)
H9 : not (eq A B)
H7 : not (eq C0 Q0)
HNCol5 : not (Col P C0 Q0)
H4 : not (eq P Q0)
HNCol4 : not (Col A B Q0)
H3 : OS A B C0 Q0
H2 : Col Q P Q0
Q0 : Tpoint
HNCol3 : not (Col C0 A B)
HNCol2 : not (Col P Q C0)
H1 : not (eq P Q)
H0 : not (eq P C0)
HC0C : Col C0 C D
H : Par_strict C D A B
HCop2 : Coplanar C D P Q
HNC2 : not (Col A B Q)
HInter : Col A B P
HCop1 : Coplanar A B C D
HNC1 : not (Col C D P)
HPerpCP : Perp C D P C0
HPerpAP : Perp A B P C0
A,B,C,D,P,Q,C0 : Tpoint
ip : inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y : Tpoint => and (Col P Q Y) (Col C D Y))
+++++
exists Y; split; assert_diffs; ColR.
-----
Lemma inverse_projection_postulate__proclus_bis : inverse_projection_postulate -> alternative_proclus_postulate.
Proof.
intros ip A B C D P Q HPerp2 HNC1 HCop1 HInter HNC2 HCop2.
elim(col_dec C D P).
intro; exists P; split; Col.
intro HNCol1.
assert(Par_strict C D A B).
destruct HPerp2 as [P1 [P2 [HP [HPerpAP HPerpCP]]]].
assert(HC0 := HPerpCP); auto.
destruct HC0 as [C0 [_ [_ [HC0P [HC0C _]]]]].
assert(HP' := HPerpAP); auto.
destruct HP' as [P' HPerpP].
assert(P'=P) by (apply (l8_14_2_1b _ P1 P2 A B); Col).
subst P'.
destruct HPerpP as [_ [_ [HPP _]]].
assert(P<>C0) by (intro; subst C0; Col).
apply (perp_col0 _ _ _ _ P C0) in HPerpAP; Col.
apply (perp_col0 _ _ _ _ P C0) in HPerpCP; Col.
clear dependent P1.
clear dependent P2.
assert(P<>Q) by (intro; subst; auto).
elim(col_dec P Q C0).
intro; exists C0; Col.
intro HNCol2.
assert(HNCol3 : ~ Col C0 A B) by (apply (par_not_col C D); auto).
assert(HQ0 := cop_not_par_same_side A B Q P P C0).
destruct HQ0 as [Q0 []]; Col.
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
CopR.
assert(HNCol4 : ~ Col A B Q0) by (apply (one_side_not_col123 _ _ _ C0); Side).
assert(P<>Q0) by (intro; subst; auto).
assert(HNCol5 : ~ Col P C0 Q0) by (intro; apply HNCol2; ColR).
assert_diffs.
assert(HC1 : exists C1, Col C D C1 /\\ C1 <> C0).
destruct HC1 as [C1 []].
assert (Coplanar C D P C0) by Cop.
assert (Coplanar C D P A) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar C D P B) by (apply col2_cop__cop with A B; assert_diffs; Col; Cop).
assert (Coplanar A B P C0) by Cop.
assert(HA0 : exists A0, Col A B A0 /\\ OS P C0 Q0 A0).
destruct HA0 as [A0 []].
assert(HNCol6 : ~ Col P C0 A0) by (apply (one_side_not_col123 _ _ _ Q0); Side).
assert_diffs.
assert(HY := ip C0 P Q0 C0 C1).
destruct HY as [Y []]; auto.

*****

*****

+++++
Qed.
-----
End inverse_projection_postulate_proclus_bis.
-----
