Require Import mathcomp.ssreflect.ssreflect.
-----
From mathcomp\nRequire Import ssrbool ssrfun ssrnat eqtype choice seq.
-----
From mathcomp\nRequire Import fintype finset finfun bigop.
-----
From mathcomp\nRequire Import ssralg ssrnum path generic_quotient matrix mxalgebra.
-----
From mathcomp\nRequire Import zmodp.
-----
Set Implicit Arguments.
-----
Unset Strict Implicit.
-----
Unset Printing Implicit Defensive.
-----
Import GRing.Theory Num.Theory.
-----
Local Open Scope ring_scope.
-----
Require Import GeoCoq.Axioms.tarski_axioms.
-----
Require Import GeoCoq.Axioms.gupta_inspired_variant_axioms.
-----
Require Import GeoCoq.Meta_theory.Models.gupta_inspired_to_tarski.
-----
Require Import GeoCoq.Meta_theory.Parallel_postulates.parallel_postulates.
-----
Section Aux.
-----
Definition andb_assoc := Bool.andb_assoc.
-----
Variable R : realFieldType.
-----
Variable n : nat.
-----
Definition Vector := 'rV[R]_(n.+1).
-----
Implicit Types (v : Vector).
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
eqfun (fun k : ordinal (S n) => negb (eq_op (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) (fun k : ordinal (S n) => negb (eq_op ((GRing.opp v) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R)))
+++++
Proof.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
eqfun (fun k : ordinal (S n) => negb (eq_op (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) (fun k : ordinal (S n) => negb (eq_op ((GRing.opp v) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R)))
+++++
move=> k /=.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.

*****
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (negb (eq_op (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) (negb (eq_op ((GRing.opp v) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R)))
+++++
rewrite mxE.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.

*****
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (negb (eq_op (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) (negb (eq_op (GRing.opp (v (GRing.zero (Zp_zmodType O)) k)) (GRing.zero R)))
+++++
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.

*****
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (negb (eq_op (GRing.opp (GRing.opp (v (GRing.zero (Zp_zmodType O)) k))) (GRing.zero R))) (negb (eq_op (GRing.opp (v (GRing.zero (Zp_zmodType O)) k)) (GRing.zero R)))
+++++
case (- v 0 k =P 0) => [->|/eqP neq].
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.
case (- v 0 k =P 0) => [->|/eqP neq].

*****
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (negb (eq_op (GRing.opp (GRing.zero R)) (GRing.zero R))) (negb (eq_op (GRing.zero R) (GRing.zero R)))
+++++
rewrite ?oppr0 // neq.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.
case (- v 0 k =P 0) => [->|/eqP neq].

*****
neq : is_true\n (negb\n (eq_op (GRing.opp (v (GRing.zero (Zp_zmodType O)) k))\n (GRing.zero R)))
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (negb (eq_op (GRing.opp (GRing.opp (v (GRing.zero (Zp_zmodType O)) k))) (GRing.zero R))) (negb (eq_op (GRing.opp (v (GRing.zero (Zp_zmodType O)) k)) (GRing.zero R)))
+++++
rewrite ?oppr0 // neq.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.
case (- v 0 k =P 0) => [->|/eqP neq].
rewrite ?oppr0 // neq.

*****
neq : is_true\n (negb\n (eq_op (GRing.opp (v (GRing.zero (Zp_zmodType O)) k))\n (GRing.zero R)))
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (negb (eq_op (GRing.opp (GRing.opp (v (GRing.zero (Zp_zmodType O)) k))) (GRing.zero R))) true
+++++
apply /eqP.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.
case (- v 0 k =P 0) => [->|/eqP neq].
rewrite ?oppr0 // neq.
apply /eqP.

*****
neq : is_true\n (negb\n (eq_op (GRing.opp (v (GRing.zero (Zp_zmodType O)) k))\n (GRing.zero R)))
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
not (eq (GRing.opp (GRing.opp (v (GRing.zero (Zp_zmodType O)) k))) (GRing.zero R))
+++++
rewrite -[X in -X]sub0r opprB subr0.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.
case (- v 0 k =P 0) => [->|/eqP neq].
rewrite ?oppr0 // neq.
apply /eqP.
rewrite -[X in -X]sub0r opprB subr0.

*****
neq : is_true\n (negb\n (eq_op (GRing.opp (v (GRing.zero (Zp_zmodType O)) k))\n (GRing.zero R)))
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
not (eq (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))
+++++
move=> v2_eq0.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.
case (- v 0 k =P 0) => [->|/eqP neq].
rewrite ?oppr0 // neq.
apply /eqP.
rewrite -[X in -X]sub0r opprB subr0.
move=> v2_eq0.

*****
v2_eq0 : eq (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R)
neq : is_true\n (negb\n (eq_op (GRing.opp (v (GRing.zero (Zp_zmodType O)) k))\n (GRing.zero R)))
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
False
+++++
move/eqP: neq.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.
case (- v 0 k =P 0) => [->|/eqP neq].
rewrite ?oppr0 // neq.
apply /eqP.
rewrite -[X in -X]sub0r opprB subr0.
move=> v2_eq0.
move/eqP: neq.

*****
v2_eq0 : eq (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R)
k : ordinal (S n)
v : Vector
n : nat
R : Num\.RealField\.type
*****
forall _ : not (eq (GRing.opp (v (GRing.zero (Zp_zmodType O)) k)) (GRing.zero R)), False
+++++
by rewrite v2_eq0 oppr0.
-----
Lemma eq_pick_neq0 v : (fun k => v 0 k != 0) =1 (fun k => (- v) 0 k != 0).
Proof.
move=> k /=.
rewrite mxE.
rewrite -[X in (X!=0)=_]subr0 -opprB sub0r.
case (- v 0 k =P 0) => [->|/eqP neq].

*****

*****

+++++
Qed.
-----
Lemma quad_eq0 v : (v *m v^T == 0) = (v == 0).
-----
Lemma quad_eq0 v : (v *m v^T == 0) = (v == 0).

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (mulmx v (trmx v)) (GRing.zero (matrix_zmodType R (S O) (S O)))) (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n))))
+++++
Proof.
-----
Lemma quad_eq0 v : (v *m v^T == 0) = (v == 0).
Proof.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (mulmx v (trmx v)) (GRing.zero (matrix_zmodType R (S O) (S O)))) (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n))))
+++++
apply/eqP/eqP => [/matrixP /(_ 0 0) /eqP|->]; last by rewrite mul0mx.
-----
Lemma quad_eq0 v : (v *m v^T == 0) = (v == 0).
Proof.
apply/eqP/eqP => [/matrixP /(_ 0 0) /eqP|->]; last by rewrite mul0mx.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))) ((GRing.zero (matrix_zmodType R (S O) (S O))) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))), eq v (GRing.zero (matrix_zmodType R (S O) (S n)))
+++++
rewrite !mxE psumr_eq0 /=; last by move=> i _; rewrite mxE sqr_ge0.
-----
Lemma quad_eq0 v : (v *m v^T == 0) = (v == 0).
Proof.
apply/eqP/eqP => [/matrixP /(_ 0 0) /eqP|->]; last by rewrite mul0mx.
rewrite !mxE psumr_eq0 /=; last by move=> i _; rewrite mxE sqr_ge0.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
forall _ : all (fun i : ordinal (S n) => eq_op (GRing.mul (v (GRing.zero (Zp_zmodType O)) i) ((trmx v) i (GRing.zero (Zp_zmodType O)))) (GRing.zero R)) (index_enum (ordinal_finType (S n))), eq v (GRing.zero (matrix_zmodType R (S O) (S n)))
+++++
move => /allP /= sqp_eq0; apply/rowP => k; rewrite mxE.
-----
Lemma quad_eq0 v : (v *m v^T == 0) = (v == 0).
Proof.
apply/eqP/eqP => [/matrixP /(_ 0 0) /eqP|->]; last by rewrite mul0mx.
rewrite !mxE psumr_eq0 /=; last by move=> i _; rewrite mxE sqr_ge0.
move => /allP /= sqp_eq0; apply/rowP => k; rewrite mxE.

*****
k : ordinal (S n)
sqp_eq0 : forall (x : ordinal (S n))\n (_ : in_mem x (mem (index_enum (ordinal_finType (S n))))),\neq_op\n (GRing.mul (v (GRing.zero (Zp_zmodType O)) x)\n ((trmx v) x (GRing.zero (Zp_zmodType O)))) (GRing.zero R)
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R)
+++++
by have := sqp_eq0 k; rewrite mem_index_enum !mxE sqrf_eq0 => /(_ isT) /eqP.
-----
Lemma quad_eq0 v : (v *m v^T == 0) = (v == 0).
Proof.
apply/eqP/eqP => [/matrixP /(_ 0 0) /eqP|->]; last by rewrite mul0mx.
rewrite !mxE psumr_eq0 /=; last by move=> i _; rewrite mxE sqr_ge0.
move => /allP /= sqp_eq0; apply/rowP => k; rewrite mxE.
by have := sqp_eq0 k; rewrite mem_index_enum !mxE sqrf_eq0 => /(_ isT) /eqP.

*****

*****

+++++
Qed.
-----
Lemma quad_eq0' v : ((v *m v^T) 0 0 == 0) = (v == 0).
-----
Lemma quad_eq0' v : ((v *m v^T) 0 0 == 0) = (v == 0).

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (eq_op ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))) (GRing.zero R)) (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n))))
+++++
Proof.
-----
Lemma quad_eq0' v : ((v *m v^T) 0 0 == 0) = (v == 0).
Proof.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (eq_op ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))) (GRing.zero R)) (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n))))
+++++
apply/eqP/eqP => [/eqP|->]; last by rewrite mul0mx mxE /=.
-----
Lemma quad_eq0' v : ((v *m v^T) 0 0 == 0) = (v == 0).
Proof.
apply/eqP/eqP => [/eqP|->]; last by rewrite mul0mx mxE /=.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))) (GRing.zero R), eq v (GRing.zero (matrix_zmodType R (S O) (S n)))
+++++
rewrite !mxE psumr_eq0 /=; last by move=> i _; rewrite mxE sqr_ge0.
-----
Lemma quad_eq0' v : ((v *m v^T) 0 0 == 0) = (v == 0).
Proof.
apply/eqP/eqP => [/eqP|->]; last by rewrite mul0mx mxE /=.
rewrite !mxE psumr_eq0 /=; last by move=> i _; rewrite mxE sqr_ge0.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
forall _ : all (fun i : ordinal (S n) => eq_op (GRing.mul (v (GRing.zero (Zp_zmodType O)) i) ((trmx v) i (GRing.zero (Zp_zmodType O)))) (GRing.zero R)) (index_enum (ordinal_finType (S n))), eq v (GRing.zero (matrix_zmodType R (S O) (S n)))
+++++
move => /allP /= sqp_eq0; apply/rowP => k; rewrite mxE.
-----
Lemma quad_eq0' v : ((v *m v^T) 0 0 == 0) = (v == 0).
Proof.
apply/eqP/eqP => [/eqP|->]; last by rewrite mul0mx mxE /=.
rewrite !mxE psumr_eq0 /=; last by move=> i _; rewrite mxE sqr_ge0.
move => /allP /= sqp_eq0; apply/rowP => k; rewrite mxE.

*****
k : ordinal (S n)
sqp_eq0 : forall (x : ordinal (S n))\n (_ : in_mem x (mem (index_enum (ordinal_finType (S n))))),\neq_op\n (GRing.mul (v (GRing.zero (Zp_zmodType O)) x)\n ((trmx v) x (GRing.zero (Zp_zmodType O)))) (GRing.zero R)
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R)
+++++
by have := sqp_eq0 k; rewrite mem_index_enum !mxE sqrf_eq0 => /(_ isT) /eqP.
-----
Lemma quad_eq0' v : ((v *m v^T) 0 0 == 0) = (v == 0).
Proof.
apply/eqP/eqP => [/eqP|->]; last by rewrite mul0mx mxE /=.
rewrite !mxE psumr_eq0 /=; last by move=> i _; rewrite mxE sqr_ge0.
move => /allP /= sqp_eq0; apply/rowP => k; rewrite mxE.
by have := sqp_eq0 k; rewrite mem_index_enum !mxE sqrf_eq0 => /(_ isT) /eqP.

*****

*****

+++++
Qed.
-----
Lemma quad_neq0 v : ((v *m v^T) 0 0 != 0) = (v != 0).
-----
Lemma quad_neq0 v : ((v *m v^T) 0 0 != 0) = (v != 0).

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (negb (eq_op ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))) (GRing.zero R))) (negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))))
+++++
Proof.
-----
Lemma quad_neq0 v : ((v *m v^T) 0 0 != 0) = (v != 0).
Proof.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq (negb (eq_op ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))) (GRing.zero R))) (negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))))
+++++
rewrite -quad_eq0; apply/eqP; case: (v *m v^T =P 0) => [->|HF H] /=; first by rewrite mxE.
-----
Lemma quad_neq0 v : ((v *m v^T) 0 0 != 0) = (v != 0).
Proof.
rewrite -quad_eq0; apply/eqP; case: (v *m v^T =P 0) => [->|HF H] /=; first by rewrite mxE.

*****
H : eq\n ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType O))) (GRing.zero R)
HF : not\n (eq (mulmx v (trmx v)) (GRing.zero (matrix_zmodType R (S O) (S O))))
v : Vector
n : nat
R : Num\.RealField\.type
*****
False
+++++
apply HF; apply/matrixP => i j.
-----
Lemma quad_neq0 v : ((v *m v^T) 0 0 != 0) = (v != 0).
Proof.
rewrite -quad_eq0; apply/eqP; case: (v *m v^T =P 0) => [->|HF H] /=; first by rewrite mxE.
apply HF; apply/matrixP => i j.

*****
i,j : ordinal (S O)
H : eq\n ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType O))) (GRing.zero R)
HF : not\n (eq (mulmx v (trmx v)) (GRing.zero (matrix_zmodType R (S O) (S O))))
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq ((mulmx v (trmx v)) i j) ((GRing.zero (matrix_zmodType R (S O) (S O))) i j)
+++++
case: i => [] [|[| //]] //= pi; case: j => [] [|[| //]] //= pj.
-----
Lemma quad_neq0 v : ((v *m v^T) 0 0 != 0) = (v != 0).
Proof.
rewrite -quad_eq0; apply/eqP; case: (v *m v^T =P 0) => [->|HF H] /=; first by rewrite mxE.
apply HF; apply/matrixP => i j.
case: i => [] [|[| //]] //= pi; case: j => [] [|[| //]] //= pj.

*****
pi,pj : is_true (leq (S O) (S O))
H : eq\n ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType O))) (GRing.zero R)
HF : not\n (eq (mulmx v (trmx v)) (GRing.zero (matrix_zmodType R (S O) (S O))))
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq ((mulmx v (trmx v)) (Ordinal pi) (Ordinal pj)) ((GRing.zero (matrix_zmodType R (S O) (S O))) (Ordinal pi) (Ordinal pj))
+++++
by rewrite (@ord_inj _ (Ordinal pi) 0) // (@ord_inj _ (Ordinal pj) 0) // H mxE.
-----
Lemma quad_neq0 v : ((v *m v^T) 0 0 != 0) = (v != 0).
Proof.
rewrite -quad_eq0; apply/eqP; case: (v *m v^T =P 0) => [->|HF H] /=; first by rewrite mxE.
apply HF; apply/matrixP => i j.
case: i => [] [|[| //]] //= pi; case: j => [] [|[| //]] //= pj.
by rewrite (@ord_inj _ (Ordinal pi) 0) // (@ord_inj _ (Ordinal pj) 0) // H mxE.

*****

*****

+++++
Qed.
-----
Lemma quad_ge0 v : 0 <= (v *m v^T) 0 0.
-----
Lemma quad_ge0 v : 0 <= (v *m v^T) 0 0.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ler (GRing.zero R) ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))))
+++++
Proof.
-----
Lemma quad_ge0 v : 0 <= (v *m v^T) 0 0.
Proof.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ler (GRing.zero R) ((mulmx v (trmx v)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))))
+++++
by rewrite !mxE sumr_ge0 // => i _; rewrite mxE sqr_ge0.
-----
Lemma quad_ge0 v : 0 <= (v *m v^T) 0 0.
Proof.
by rewrite !mxE sumr_ge0 // => i _; rewrite mxE sqr_ge0.

*****

*****

+++++
Qed.
-----
Lemma all_v_neq0 v : v != 0 ->\n  ~ (fun k : 'I_(n.+1) => v 0 k != 0) =1 xpred0.
-----
Lemma all_v_neq0 v : v != 0 -> ~ (fun k : 'I_(n.+1) => v 0 k != 0) =1 xpred0.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))), not (eqfun (fun k : ordinal (S n) => negb (eq_op (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) (fun _ : ordinal (S n) => false))
+++++
Proof.
-----
Lemma all_v_neq0 v : v != 0 -> ~ (fun k : 'I_(n.+1) => v 0 k != 0) =1 xpred0.
Proof.

*****
v : Vector
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))), not (eqfun (fun k : ordinal (S n) => negb (eq_op (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) (fun _ : ordinal (S n) => false))
+++++
move=> v_neq0 all_v_neq0; have := v_neq0; suff -> : v = 0 by rewrite eqxx.
-----
Lemma all_v_neq0 v : v != 0 -> ~ (fun k : 'I_(n.+1) => v 0 k != 0) =1 xpred0.
Proof.
move=> v_neq0 all_v_neq0; have := v_neq0; suff -> : v = 0 by rewrite eqxx.

*****
all_v_neq0 : eqfun\n (fun k : ordinal (S n) =>\n negb (eq_op (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R)))\n (fun _ : ordinal (S n) => false)
v_neq0 : is_true (negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))))
v : Vector
n : nat
R : Num\.RealField\.type
*****
eq v (GRing.zero (matrix_zmodType R (S O) (S n)))
+++++
by apply/rowP => k; rewrite !mxE; have/negPn/eqP := all_v_neq0 k.
-----
Lemma all_v_neq0 v : v != 0 -> ~ (fun k : 'I_(n.+1) => v 0 k != 0) =1 xpred0.
Proof.
move=> v_neq0 all_v_neq0; have := v_neq0; suff -> : v = 0 by rewrite eqxx.
by apply/rowP => k; rewrite !mxE; have/negPn/eqP := all_v_neq0 k.

*****

*****

+++++
Qed.
-----
Lemma add11_neq0 : 1 + 1 != 0 :> R.
-----
Lemma add11_neq0 : 1 + 1 != 0 :> R.

*****
n : nat
R : Num\.RealField\.type
*****
is_true (negb (eq_op (GRing.add (GRing.one R) (GRing.one R) : R) (GRing.zero R : R)))
+++++
Proof.
-----
Lemma add11_neq0 : 1 + 1 != 0 :> R.
Proof.

*****
n : nat
R : Num\.RealField\.type
*****
is_true (negb (eq_op (GRing.add (GRing.one R) (GRing.one R) : R) (GRing.zero R : R)))
+++++
by rewrite lt0r_neq0 ?addr_gt0 ?ltr01.
-----
Lemma add11_neq0 : 1 + 1 != 0 :> R.
Proof.
by rewrite lt0r_neq0 ?addr_gt0 ?ltr01.

*****

*****

+++++
Qed.
-----
Lemma addrBDB (ZT : zmodType) (v1 v2 v3 : ZT) : v1 - v2 + (v2 - v3) = v1 - v3.
-----
Lemma addrBDB (ZT : zmodType) (v1 v2 v3 : ZT) : v1 - v2 + (v2 - v3) = v1 - v3.

*****
v1,v2,v3 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 (GRing.opp v2)) (GRing.add v2 (GRing.opp v3))) (GRing.add v1 (GRing.opp v3))
+++++
Proof.
-----
Lemma addrBDB (ZT : zmodType) (v1 v2 v3 : ZT) : v1 - v2 + (v2 - v3) = v1 - v3.
Proof.

*****
v1,v2,v3 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 (GRing.opp v2)) (GRing.add v2 (GRing.opp v3))) (GRing.add v1 (GRing.opp v3))
+++++
by rewrite addrACA -addrA [X in _+X]addrA subrr sub0r.
-----
Lemma addrBDB (ZT : zmodType) (v1 v2 v3 : ZT) : v1 - v2 + (v2 - v3) = v1 - v3.
Proof.
by rewrite addrACA -addrA [X in _+X]addrA subrr sub0r.

*****

*****

+++++
Qed.
-----
Lemma addrDBD (ZT : zmodType) (v1 v2 v3 : ZT) : v1 + v3 - (v2 + v3) = v1 - v2.
-----
Lemma addrDBD (ZT : zmodType) (v1 v2 v3 : ZT) : v1 + v3 - (v2 + v3) = v1 - v2.

*****
v1,v2,v3 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 v3) (GRing.opp (GRing.add v2 v3))) (GRing.add v1 (GRing.opp v2))
+++++
Proof.
-----
Lemma addrDBD (ZT : zmodType) (v1 v2 v3 : ZT) : v1 + v3 - (v2 + v3) = v1 - v2.
Proof.

*****
v1,v2,v3 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 v3) (GRing.opp (GRing.add v2 v3))) (GRing.add v1 (GRing.opp v2))
+++++
by rewrite -addrA -opprB -addrA subrr addr0.
-----
Lemma addrDBD (ZT : zmodType) (v1 v2 v3 : ZT) : v1 + v3 - (v2 + v3) = v1 - v2.
Proof.
by rewrite -addrA -opprB -addrA subrr addr0.

*****

*****

+++++
Qed.
-----
Lemma addrBBB (ZT : zmodType) (v1 v2 v3 : ZT) : v1 - v2 - (v1 - v3) = v3 - v2.
-----
Lemma addrBBB (ZT : zmodType) (v1 v2 v3 : ZT) : v1 - v2 - (v1 - v3) = v3 - v2.

*****
v1,v2,v3 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 (GRing.opp v2)) (GRing.opp (GRing.add v1 (GRing.opp v3)))) (GRing.add v3 (GRing.opp v2))
+++++
Proof.
-----
Lemma addrBBB (ZT : zmodType) (v1 v2 v3 : ZT) : v1 - v2 - (v1 - v3) = v3 - v2.
Proof.

*****
v1,v2,v3 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 (GRing.opp v2)) (GRing.opp (GRing.add v1 (GRing.opp v3)))) (GRing.add v3 (GRing.opp v2))
+++++
by rewrite opprB addrCA [v1 - v2]addrC -addrA subrr addr0.
-----
Lemma addrBBB (ZT : zmodType) (v1 v2 v3 : ZT) : v1 - v2 - (v1 - v3) = v3 - v2.
Proof.
by rewrite opprB addrCA [v1 - v2]addrC -addrA subrr addr0.

*****

*****

+++++
Qed.
-----
Lemma addrDBB (ZT : zmodType) (v1 v2 : ZT) : (v1 + v2 - (v1 - v2) = v2 *+ 2).
-----
Lemma addrDBB (ZT : zmodType) (v1 v2 : ZT) : (v1 + v2 - (v1 - v2) = v2 *+ 2).

*****
v1,v2 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 v2) (GRing.opp (GRing.add v1 (GRing.opp v2)))) (GRing.natmul v2 (S (S O)))
+++++
Proof.
-----
Lemma addrDBB (ZT : zmodType) (v1 v2 : ZT) : (v1 + v2 - (v1 - v2) = v2 *+ 2).
Proof.

*****
v1,v2 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 v2) (GRing.opp (GRing.add v1 (GRing.opp v2)))) (GRing.natmul v2 (S (S O)))
+++++
by rewrite opprB addrCA [X in _ + X]addrAC subrr add0r mulr2n.
-----
Lemma addrDBB (ZT : zmodType) (v1 v2 : ZT) : (v1 + v2 - (v1 - v2) = v2 *+ 2).
Proof.
by rewrite opprB addrCA [X in _ + X]addrAC subrr add0r mulr2n.

*****

*****

+++++
Qed.
-----
Lemma addrBDD (ZT : zmodType) (v1 v2 : ZT) : (v1 - v2 + (v1 + v2) = v1 *+ 2).
-----
Lemma addrBDD (ZT : zmodType) (v1 v2 : ZT) : (v1 - v2 + (v1 + v2) = v1 *+ 2).

*****
v1,v2 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 (GRing.opp v2)) (GRing.add v1 v2)) (GRing.natmul v1 (S (S O)))
+++++
Proof.
-----
Lemma addrBDD (ZT : zmodType) (v1 v2 : ZT) : (v1 - v2 + (v1 + v2) = v1 *+ 2).
Proof.

*****
v1,v2 : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add v1 (GRing.opp v2)) (GRing.add v1 v2)) (GRing.natmul v1 (S (S O)))
+++++
by rewrite addrAC -!addrA subrr addr0 mulr2n.
-----
Lemma addrBDD (ZT : zmodType) (v1 v2 : ZT) : (v1 - v2 + (v1 + v2) = v1 *+ 2).
Proof.
by rewrite addrAC -!addrA subrr addr0 mulr2n.

*****

*****

+++++
Qed.
-----
Lemma add2r_eq (ZT : zmodType) (x y z : ZT) : (x + y == x + z) = (y == z).
-----
Lemma add2r_eq (ZT : zmodType) (x y z : ZT) : (x + y == x + z) = (y == z).

*****
x,y,z : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (GRing.add x y) (GRing.add x z)) (eq_op y z)
+++++
Proof.
-----
Lemma add2r_eq (ZT : zmodType) (x y z : ZT) : (x + y == x + z) = (y == z).
Proof.

*****
x,y,z : GRing.Zmodule.sort ZT
ZT : GRing\.Zmodule\.type
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (GRing.add x y) (GRing.add x z)) (eq_op y z)
+++++
by rewrite [X in _ == X]addrC -subr_eq addrAC subrr add0r.
-----
Lemma add2r_eq (ZT : zmodType) (x y z : ZT) : (x + y == x + z) = (y == z).
Proof.
by rewrite [X in _ == X]addrC -subr_eq addrAC subrr add0r.

*****

*****

+++++
Qed.
-----
Lemma bet_gt0 (k1 k2 : R) : 0 < k1 -> k2 < 1 -> 0 < k1-k1*k2.
-----
Lemma bet_gt0 (k1 k2 : R) : 0 < k1 -> k2 < 1 -> 0 < k1-k1*k2.

*****
k1,k2 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k2 (GRing.one R)), Num.Def.ltr (GRing.zero R) (GRing.add k1 (GRing.opp (GRing.mul k1 k2)))
+++++
Proof.
-----
Lemma bet_gt0 (k1 k2 : R) : 0 < k1 -> k2 < 1 -> 0 < k1-k1*k2.
Proof.

*****
k1,k2 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k2 (GRing.one R)), Num.Def.ltr (GRing.zero R) (GRing.add k1 (GRing.opp (GRing.mul k1 k2)))
+++++
by move=> ? ?; rewrite subr_gt0 gtr_pmulr.
-----
Lemma bet_gt0 (k1 k2 : R) : 0 < k1 -> k2 < 1 -> 0 < k1-k1*k2.
Proof.
by move=> ? ?; rewrite subr_gt0 gtr_pmulr.

*****

*****

+++++
Qed.
-----
Lemma bet_gt0' (k1 k2 k3 : R) :\n  0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> 0 < ((k1+k2-k1*k2)/k3)^-1.
-----
Lemma bet_gt0' (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> 0 < ((k1+k2-k1*k2)/k3)^-1.

*****
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : Num.Def.ltr (GRing.zero R) k3), Num.Def.ltr (GRing.zero R) (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)))
+++++
Proof.
-----
Lemma bet_gt0' (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> 0 < ((k1+k2-k1*k2)/k3)^-1.
Proof.

*****
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : Num.Def.ltr (GRing.zero R) k3), Num.Def.ltr (GRing.zero R) (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)))
+++++
move=> ? ? ? ?.
-----
Lemma bet_gt0' (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> 0 < ((k1+k2-k1*k2)/k3)^-1.
Proof.
move=> ? ? ? ?.

*****
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))))
+++++
rewrite invr_gt0 divr_gt0 //.
-----
Lemma bet_gt0' (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> 0 < ((k1+k2-k1*k2)/k3)^-1.
Proof.
move=> ? ? ? ?.
rewrite invr_gt0 divr_gt0 //.

*****
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
+++++
by rewrite subr_gt0 ltr_paddl ?ltrW // gtr_pmull.
-----
Lemma bet_gt0' (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> 0 < ((k1+k2-k1*k2)/k3)^-1.
Proof.
move=> ? ? ? ?.
rewrite invr_gt0 divr_gt0 //.
by rewrite subr_gt0 ltr_paddl ?ltrW // gtr_pmull.

*****

*****

+++++
Qed.
-----
Lemma bet_neq0 (k1 k2 k3 : R) :\n  0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> (k1+k2-k1*k2)/k3 != 0.
-----
Lemma bet_neq0 (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> (k1+k2-k1*k2)/k3 != 0.

*****
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : Num.Def.ltr (GRing.zero R) k3), negb (eq_op (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)) (GRing.zero R))
+++++
Proof.
-----
Lemma bet_neq0 (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> (k1+k2-k1*k2)/k3 != 0.
Proof.

*****
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : Num.Def.ltr (GRing.zero R) k3), negb (eq_op (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)) (GRing.zero R))
+++++
by move=> ? ? ? ?; apply lt0r_neq0; rewrite -invr_gt0 bet_gt0'.
-----
Lemma bet_neq0 (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> (k1+k2-k1*k2)/k3 != 0.
Proof.
by move=> ? ? ? ?; apply lt0r_neq0; rewrite -invr_gt0 bet_gt0'.

*****

*****

+++++
Qed.
-----
Lemma bet_neq0' (k1 k2 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> k1+k2-k1*k2 != 0.
-----
Lemma bet_neq0' (k1 k2 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> k1+k2-k1*k2 != 0.

*****
k1,k2 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)), negb (eq_op (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.zero R))
+++++
Proof.
-----
Lemma bet_neq0' (k1 k2 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> k1+k2-k1*k2 != 0.
Proof.

*****
k1,k2 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)), negb (eq_op (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.zero R))
+++++
by move=> ? ? ?; rewrite -[X in X!=0]divr1 bet_neq0 ?ltr01.
-----
Lemma bet_neq0' (k1 k2 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> k1+k2-k1*k2 != 0.
Proof.
by move=> ? ? ?; rewrite -[X in X!=0]divr1 bet_neq0 ?ltr01.

*****

*****

+++++
Qed.
-----
Lemma bet_lt (k1 k2 : R) : 0 < k2 -> k1-k1*k2 < k1+k2-k1*k2.
-----
Lemma bet_lt (k1 k2 : R) : 0 < k2 -> k1-k1*k2 < k1+k2-k1*k2.

*****
k1,k2 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (GRing.zero R) k2, Num.Def.ltr (GRing.add k1 (GRing.opp (GRing.mul k1 k2))) (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2)))
+++++
Proof.
-----
Lemma bet_lt (k1 k2 : R) : 0 < k2 -> k1-k1*k2 < k1+k2-k1*k2.
Proof.

*****
k1,k2 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (GRing.zero R) k2, Num.Def.ltr (GRing.add k1 (GRing.opp (GRing.mul k1 k2))) (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2)))
+++++
by move=> ?; rewrite -addrA ltr_add2l -{1}[-(k1*k2)]add0r ltr_add2r.
-----
Lemma bet_lt (k1 k2 : R) : 0 < k2 -> k1-k1*k2 < k1+k2-k1*k2.
Proof.
by move=> ?; rewrite -addrA ltr_add2l -{1}[-(k1*k2)]add0r ltr_add2r.

*****

*****

+++++
Qed.
-----
Lemma bet_lt1 (k1 k2 k3 : R) :\n  0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 ->\n  ((k1+k2-k1*k2)/k3)^-1 < 1.
-----
Lemma bet_lt1 (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> ((k1+k2-k1*k2)/k3)^-1 < 1.

*****
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : Num.Def.ltr (GRing.zero R) k3) (_ : Num.Def.ltr k3 (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2)))), Num.Def.ltr (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.one R)
+++++
Proof.
-----
Lemma bet_lt1 (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> ((k1+k2-k1*k2)/k3)^-1 < 1.
Proof.

*****
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : Num.Def.ltr (GRing.zero R) k3) (_ : Num.Def.ltr k3 (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2)))), Num.Def.ltr (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.one R)
+++++
move=> ? ? ? ? ?.
-----
Lemma bet_lt1 (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> ((k1+k2-k1*k2)/k3)^-1 < 1.
Proof.
move=> ? ? ? ? ?.

*****
_Hyp4_ : is_true\n (Num.Def.ltr k3\n (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.one R))
+++++
rewrite invf_lte1 -1?invr_gt0 ?bet_gt0' //.
-----
Lemma bet_lt1 (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> ((k1+k2-k1*k2)/k3)^-1 < 1.
Proof.
move=> ? ? ? ? ?.
rewrite invf_lte1 -1?invr_gt0 ?bet_gt0' //.

*****
_Hyp4_ : is_true\n (Num.Def.ltr k3\n (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.RealField.sort R
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.one R) (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)))
+++++
by rewrite -ltr_pdivr_mulr ?invr_gt0 // div1r -[k3^-1]div1r invf_div divr1.
-----
Lemma bet_lt1 (k1 k2 k3 : R) : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> ((k1+k2-k1*k2)/k3)^-1 < 1.
Proof.
move=> ? ? ? ? ?.
rewrite invf_lte1 -1?invr_gt0 ?bet_gt0' //.
by rewrite -ltr_pdivr_mulr ?invr_gt0 // div1r -[k3^-1]div1r invf_div divr1.

*****

*****

+++++
Qed.
-----
Lemma eq_inv_scale (V : lmodType R) (s : R) (x y : V) :\n  s != 0 -> (x == s^-1 *: y) = (s *: x == y).
-----
Lemma eq_inv_scale (V : lmodType R) (s : R) (x y : V) : s != 0 -> (x == s^-1 *: y) = (s *: x == y).

*****
x,y : GRing.Lmodule.sort V
s : Num.RealField.sort R
V : GRing.Lmodule.type (Phant R)
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op s (GRing.zero R)), eq (eq_op x (GRing.scale (GRing.inv s) y)) (eq_op (GRing.scale s x) y)
+++++
Proof.
-----
Lemma eq_inv_scale (V : lmodType R) (s : R) (x y : V) : s != 0 -> (x == s^-1 *: y) = (s *: x == y).
Proof.

*****
x,y : GRing.Lmodule.sort V
s : Num.RealField.sort R
V : GRing.Lmodule.type (Phant R)
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op s (GRing.zero R)), eq (eq_op x (GRing.scale (GRing.inv s) y)) (eq_op (GRing.scale s x) y)
+++++
by move=> ?; apply/eqP/eqP=> [->|<-]; rewrite scalerA 1?[X in X*:x]mulrC divff // scale1r.
-----
Lemma eq_inv_scale (V : lmodType R) (s : R) (x y : V) : s != 0 -> (x == s^-1 *: y) = (s *: x == y).
Proof.
by move=> ?; apply/eqP/eqP=> [->|<-]; rewrite scalerA 1?[X in X*:x]mulrC divff // scale1r.

*****

*****

+++++
Qed.
-----
Lemma eq_div_scale (V : lmodType R) (s1 s2 : R) (x y : V) :\n  s2 != 0 -> (x == (s1/s2) *: y) = (s2 *: x == s1 *: y).
-----
Lemma eq_div_scale (V : lmodType R) (s1 s2 : R) (x y : V) : s2 != 0 -> (x == (s1/s2) *: y) = (s2 *: x == s1 *: y).

*****
x,y : GRing.Lmodule.sort V
s1,s2 : Num.RealField.sort R
V : GRing.Lmodule.type (Phant R)
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op s2 (GRing.zero R)), eq (eq_op x (GRing.scale (GRing.mul s1 (GRing.inv s2)) y)) (eq_op (GRing.scale s2 x) (GRing.scale s1 y))
+++++
Proof.
-----
Lemma eq_div_scale (V : lmodType R) (s1 s2 : R) (x y : V) : s2 != 0 -> (x == (s1/s2) *: y) = (s2 *: x == s1 *: y).
Proof.

*****
x,y : GRing.Lmodule.sort V
s1,s2 : Num.RealField.sort R
V : GRing.Lmodule.type (Phant R)
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op s2 (GRing.zero R)), eq (eq_op x (GRing.scale (GRing.mul s1 (GRing.inv s2)) y)) (eq_op (GRing.scale s2 x) (GRing.scale s1 y))
+++++
move=> ?; apply/eqP/eqP=> [->|]; rewrite mulrC ?scalerA ?mulrA ?divff ?mul1r //.
-----
Lemma eq_div_scale (V : lmodType R) (s1 s2 : R) (x y : V) : s2 != 0 -> (x == (s1/s2) *: y) = (s2 *: x == s1 *: y).
Proof.
move=> ?; apply/eqP/eqP=> [->|]; rewrite mulrC ?scalerA ?mulrA ?divff ?mul1r //.

*****
_Hyp_ : is_true (negb (eq_op s2 (GRing.zero R)))
x,y : GRing.Lmodule.sort V
s1,s2 : Num.RealField.sort R
V : GRing.Lmodule.type (Phant R)
n : nat
R : Num\.RealField\.type
*****
forall _ : eq (GRing.scale s2 x) (GRing.scale s1 y), eq x (GRing.scale (GRing.mul (GRing.inv s2) s1) y)
+++++
by rewrite -scalerA => <-; rewrite scalerA mulrC divff ?scale1r.
-----
Lemma eq_div_scale (V : lmodType R) (s1 s2 : R) (x y : V) : s2 != 0 -> (x == (s1/s2) *: y) = (s2 *: x == s1 *: y).
Proof.
move=> ?; apply/eqP/eqP=> [->|]; rewrite mulrC ?scalerA ?mulrA ?divff ?mul1r //.
by rewrite -scalerA => <-; rewrite scalerA mulrC divff ?scale1r.

*****

*****

+++++
Qed.
-----
Lemma addf_divrr (F : fieldType) (x1 x2 y : F) :\n  y != 0 -> x1/y + x2/y = (x1+x2)/y.
-----
Lemma addf_divrr (F : fieldType) (x1 x2 y : F) : y != 0 -> x1/y + x2/y = (x1+x2)/y.

*****
x1,x2,y : GRing.Field.sort F
F : GRing\.Field\.type
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op y (GRing.zero F)), eq (GRing.add (GRing.mul x1 (GRing.inv y)) (GRing.mul x2 (GRing.inv y))) (GRing.mul (GRing.add x1 x2) (GRing.inv y))
+++++
Proof.
-----
Lemma addf_divrr (F : fieldType) (x1 x2 y : F) : y != 0 -> x1/y + x2/y = (x1+x2)/y.
Proof.

*****
x1,x2,y : GRing.Field.sort F
F : GRing\.Field\.type
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op y (GRing.zero F)), eq (GRing.add (GRing.mul x1 (GRing.inv y)) (GRing.mul x2 (GRing.inv y))) (GRing.mul (GRing.add x1 x2) (GRing.inv y))
+++++
by move=> ?; rewrite addf_div // -mulrDl -mulf_div divff // mulr1.
-----
Lemma addf_divrr (F : fieldType) (x1 x2 y : F) : y != 0 -> x1/y + x2/y = (x1+x2)/y.
Proof.
by move=> ?; rewrite addf_div // -mulrDl -mulf_div divff // mulr1.

*****

*****

+++++
Qed.
-----
Lemma dotC v1 v2 : v1 *m v2^T = v2 *m v1^T.
-----
Lemma dotC v1 v2 : v1 *m v2^T = v2 *m v1^T.

*****
v1,v2 : Vector
n : nat
R : Num\.RealField\.type
*****
eq (mulmx v1 (trmx v2)) (mulmx v2 (trmx v1))
+++++
Proof.
-----
Lemma dotC v1 v2 : v1 *m v2^T = v2 *m v1^T.
Proof.

*****
v1,v2 : Vector
n : nat
R : Num\.RealField\.type
*****
eq (mulmx v1 (trmx v2)) (mulmx v2 (trmx v1))
+++++
rewrite [X in X = _]mx11_scalar -tr_scalar_mx -mx11_scalar trmx_mul.
-----
Lemma dotC v1 v2 : v1 *m v2^T = v2 *m v1^T.
Proof.
rewrite [X in X = _]mx11_scalar -tr_scalar_mx -mx11_scalar trmx_mul.

*****
v1,v2 : Vector
n : nat
R : Num\.RealField\.type
*****
eq (mulmx (trmx (trmx v2)) (trmx v1)) (mulmx v2 (trmx v1))
+++++
suff: ((v2^T)^T = v2) by move->.
-----
Lemma dotC v1 v2 : v1 *m v2^T = v2 *m v1^T.
Proof.
rewrite [X in X = _]mx11_scalar -tr_scalar_mx -mx11_scalar trmx_mul.
suff: ((v2^T)^T = v2) by move->.

*****
v1,v2 : Vector
n : nat
R : Num\.RealField\.type
*****
eq (trmx (trmx v2)) v2
+++++
by apply/matrixP=> i j; rewrite !mxE.
-----
Lemma dotC v1 v2 : v1 *m v2^T = v2 *m v1^T.
Proof.
rewrite [X in X = _]mx11_scalar -tr_scalar_mx -mx11_scalar trmx_mul.
suff: ((v2^T)^T = v2) by move->.
by apply/matrixP=> i j; rewrite !mxE.

*****

*****

+++++
Qed.
-----
Lemma cosine_rule v1 v2 v3 :\n  (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T\n                             - 2%:R * ((v2 - v1) *m (v3 - v1)^T).
-----
Lemma cosine_rule v1 v2 v3 : (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T - 2%:R * ((v2 - v1) *m (v3 - v1)^T).

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
eq (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))) (GRing.add (GRing.add (mulmx (GRing.add v3 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v2 (GRing.opp v1))))) (GRing.opp (GRing.mul (GRing.natmul (GRing.one (matrix_ringType R O)) (S (S O))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))))))
+++++
Proof.
-----
Lemma cosine_rule v1 v2 v3 : (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T - 2%:R * ((v2 - v1) *m (v3 - v1)^T).
Proof.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
eq (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))) (GRing.add (GRing.add (mulmx (GRing.add v3 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v2 (GRing.opp v1))))) (GRing.opp (GRing.mul (GRing.natmul (GRing.one (matrix_ringType R O)) (S (S O))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))))))
+++++
apply /eqP.
-----
Lemma cosine_rule v1 v2 v3 : (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T - 2%:R * ((v2 - v1) *m (v3 - v1)^T).
Proof.
apply /eqP.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))) (GRing.add (GRing.add (mulmx (GRing.add v3 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v2 (GRing.opp v1))))) (GRing.opp (GRing.mul (GRing.natmul (GRing.one (matrix_ringType R O)) (S (S O))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1))))))))
+++++
rewrite mulrDl !mul1r eq_sym subr_eq addrA -!subr_eq addrAC.
-----
Lemma cosine_rule v1 v2 v3 : (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T - 2%:R * ((v2 - v1) *m (v3 - v1)^T).
Proof.
apply /eqP.
rewrite mulrDl !mul1r eq_sym subr_eq addrA -!subr_eq addrAC.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.add (GRing.add (mulmx (GRing.add v3 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))) (GRing.opp (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v2 (GRing.opp v1))))) (GRing.opp (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))))) (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))))
+++++
rewrite -mulmxBl -!addrA opprB [X in (_+X)*m_]addrA [X in (_+(X+_))*m_]addrC.
-----
Lemma cosine_rule v1 v2 v3 : (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T - 2%:R * ((v2 - v1) *m (v3 - v1)^T).
Proof.
apply /eqP.
rewrite mulrDl !mul1r eq_sym subr_eq addrA -!subr_eq addrAC.
rewrite -mulmxBl -!addrA opprB [X in (_+X)*m_]addrA [X in (_+(X+_))*m_]addrC.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (mulmx (GRing.add v3 (GRing.add (GRing.add v1 (GRing.opp v1)) (GRing.opp v2))) (trmx (GRing.add v3 (GRing.opp v1)))) (GRing.add (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v2 (GRing.opp v1)))) (GRing.opp (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1))))))) (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))))
+++++
rewrite subrr sub0r [X in _+(_-X)]dotC -mulmxBl opprB -[X in _+X*m_]addrA.
-----
Lemma cosine_rule v1 v2 v3 : (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T - 2%:R * ((v2 - v1) *m (v3 - v1)^T).
Proof.
apply /eqP.
rewrite mulrDl !mul1r eq_sym subr_eq addrA -!subr_eq addrAC.
rewrite -mulmxBl -!addrA opprB [X in (_+X)*m_]addrA [X in (_+(X+_))*m_]addrC.
rewrite subrr sub0r [X in _+(_-X)]dotC -mulmxBl opprB -[X in _+X*m_]addrA.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v1)))) (mulmx (GRing.add v2 (GRing.add (GRing.opp v1) (GRing.add v1 (GRing.opp v3)))) (trmx (GRing.add v2 (GRing.opp v1))))) (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))))
+++++
rewrite [X in _+(_+X)*m_]addrCA [X in _+(_+X)*m_]addrA subrr sub0r.
-----
Lemma cosine_rule v1 v2 v3 : (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T - 2%:R * ((v2 - v1) *m (v3 - v1)^T).
Proof.
apply /eqP.
rewrite mulrDl !mul1r eq_sym subr_eq addrA -!subr_eq addrAC.
rewrite -mulmxBl -!addrA opprB [X in (_+X)*m_]addrA [X in (_+(X+_))*m_]addrC.
rewrite subrr sub0r [X in _+(_-X)]dotC -mulmxBl opprB -[X in _+X*m_]addrA.
rewrite [X in _+(_+X)*m_]addrCA [X in _+(_+X)*m_]addrA subrr sub0r.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v1)))) (mulmx (GRing.add v2 (GRing.opp v3)) (trmx (GRing.add v2 (GRing.opp v1))))) (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))))
+++++
rewrite -[X in _+X*m_]opprB mulNmx dotC [X in _-X]dotC -mulmxBl opprB.
-----
Lemma cosine_rule v1 v2 v3 : (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T - 2%:R * ((v2 - v1) *m (v3 - v1)^T).
Proof.
apply /eqP.
rewrite mulrDl !mul1r eq_sym subr_eq addrA -!subr_eq addrAC.
rewrite -mulmxBl -!addrA opprB [X in (_+X)*m_]addrA [X in (_+(X+_))*m_]addrC.
rewrite subrr sub0r [X in _+(_-X)]dotC -mulmxBl opprB -[X in _+X*m_]addrA.
rewrite [X in _+(_+X)*m_]addrCA [X in _+(_+X)*m_]addrA subrr sub0r.
rewrite -[X in _+X*m_]opprB mulNmx dotC [X in _-X]dotC -mulmxBl opprB.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (mulmx (GRing.add (GRing.add v3 (GRing.opp v1)) (GRing.add v1 (GRing.opp v2))) (trmx (GRing.add v3 (GRing.opp v2)))) (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))))
+++++
by rewrite addrA -[X in X-_]addrA [X in _+X-_]addrC subrr addr0.
-----
Lemma cosine_rule v1 v2 v3 : (v3 - v2) *m (v3 - v2)^T = (v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T - 2%:R * ((v2 - v1) *m (v3 - v1)^T).
Proof.
apply /eqP.
rewrite mulrDl !mul1r eq_sym subr_eq addrA -!subr_eq addrAC.
rewrite -mulmxBl -!addrA opprB [X in (_+X)*m_]addrA [X in (_+(X+_))*m_]addrC.
rewrite subrr sub0r [X in _+(_-X)]dotC -mulmxBl opprB -[X in _+X*m_]addrA.
rewrite [X in _+(_+X)*m_]addrCA [X in _+(_+X)*m_]addrA subrr sub0r.
rewrite -[X in _+X*m_]opprB mulNmx dotC [X in _-X]dotC -mulmxBl opprB.
by rewrite addrA -[X in X-_]addrA [X in _+X-_]addrC subrr addr0.

*****

*****

+++++
Qed.
-----
Lemma cosine_rule' v1 v2 v3 :\n  2%:R * ((v1 - v2) *m (v3 - v1)^T) =\n  (v3 - v2) *m (v3 - v2)^T\n  - ((v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T).
-----
Lemma cosine_rule' v1 v2 v3 : 2%:R * ((v1 - v2) *m (v3 - v1)^T) = (v3 - v2) *m (v3 - v2)^T - ((v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T).

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
eq (GRing.mul (GRing.natmul (GRing.one (matrix_ringType R O)) (S (S O))) (mulmx (GRing.add v1 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v1))))) (GRing.add (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))) (GRing.opp (GRing.add (mulmx (GRing.add v3 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v2 (GRing.opp v1)))))))
+++++
Proof.
-----
Lemma cosine_rule' v1 v2 v3 : 2%:R * ((v1 - v2) *m (v3 - v1)^T) = (v3 - v2) *m (v3 - v2)^T - ((v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T).
Proof.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
eq (GRing.mul (GRing.natmul (GRing.one (matrix_ringType R O)) (S (S O))) (mulmx (GRing.add v1 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v1))))) (GRing.add (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))) (GRing.opp (GRing.add (mulmx (GRing.add v3 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v2 (GRing.opp v1)))))))
+++++
apply /eqP.
-----
Lemma cosine_rule' v1 v2 v3 : 2%:R * ((v1 - v2) *m (v3 - v1)^T) = (v3 - v2) *m (v3 - v2)^T - ((v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T).
Proof.
apply /eqP.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.natmul (GRing.one (matrix_ringType R O)) (S (S O))) (mulmx (GRing.add v1 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v1))))) (GRing.add (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))) (GRing.opp (GRing.add (mulmx (GRing.add v3 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v2 (GRing.opp v1))))))))
+++++
rewrite -[v1-v2]opprB mulNmx mulrN eq_sym subr_eq.
-----
Lemma cosine_rule' v1 v2 v3 : 2%:R * ((v1 - v2) *m (v3 - v1)^T) = (v3 - v2) *m (v3 - v2)^T - ((v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T).
Proof.
apply /eqP.
rewrite -[v1-v2]opprB mulNmx mulrN eq_sym subr_eq.

*****
v1,v2,v3 : Vector
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (mulmx (GRing.add v3 (GRing.opp v2)) (trmx (GRing.add v3 (GRing.opp v2)))) (GRing.add (GRing.opp (GRing.mul (GRing.natmul (GRing.one (matrix_ringType R O)) (S (S O))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))))) (GRing.add (mulmx (GRing.add v3 (GRing.opp v1)) (trmx (GRing.add v3 (GRing.opp v1)))) (mulmx (GRing.add v2 (GRing.opp v1)) (trmx (GRing.add v2 (GRing.opp v1)))))))
+++++
by rewrite [X in _ == X]addrC (cosine_rule v1).
-----
Lemma cosine_rule' v1 v2 v3 : 2%:R * ((v1 - v2) *m (v3 - v1)^T) = (v3 - v2) *m (v3 - v2)^T - ((v3 - v1) *m (v3 - v1)^T + (v2 - v1) *m (v2 - v1)^T).
Proof.
apply /eqP.
rewrite -[v1-v2]opprB mulNmx mulrN eq_sym subr_eq.
by rewrite [X in _ == X]addrC (cosine_rule v1).

*****

*****

+++++
Qed.
-----
End Aux.
-----
Section Ratio.
-----
Variable R : realFieldType.
-----
Variable n : nat.
-----
Implicit Types (v : (@Vector R n)).
-----
Definition ratio v1 v2 :=\n  if [pick k : 'I_(n.+1) | v2 0 k != 0] is Some k\n  then v1 0 k / v2 0 k else 0.
-----
Lemma ratio0p p : ratio 0 p = 0.
-----
Lemma ratio0p p : ratio 0 p = 0.

*****
p : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio (GRing.zero (matrix_zmodType R (S O) (S n))) p) (GRing.zero R)
+++++
Proof.
-----
Lemma ratio0p p : ratio 0 p = 0.
Proof.

*****
p : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio (GRing.zero (matrix_zmodType R (S O) (S n))) p) (GRing.zero R)
+++++
by rewrite /ratio; case: pickP => /= [? _|//]; rewrite mxE mul0r.
-----
Lemma ratio0p p : ratio 0 p = 0.
Proof.
by rewrite /ratio; case: pickP => /= [? _|//]; rewrite mxE mul0r.

*****

*****

+++++
Qed.
-----
Lemma ratiovv v : v != 0 -> ratio v v = 1.
-----
Lemma ratiovv v : v != 0 -> ratio v v = 1.

*****
v : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))), eq (ratio v v) (GRing.one R)
+++++
Proof.
-----
Lemma ratiovv v : v != 0 -> ratio v v = 1.
Proof.

*****
v : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))), eq (ratio v v) (GRing.one R)
+++++
move=> v_neq0.
-----
Lemma ratiovv v : v != 0 -> ratio v v = 1.
Proof.
move=> v_neq0.

*****
v_neq0 : is_true (negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))))
v : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio v v) (GRing.one R)
+++++
rewrite /ratio.
-----
Lemma ratiovv v : v != 0 -> ratio v v = 1.
Proof.
move=> v_neq0.
rewrite /ratio.

*****
v_neq0 : is_true (negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))))
v : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq match pick (fun k : ordinal (S n) => negb (eq_op (v (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v (GRing.zero (Zp_zmodType O)) k) (GRing.inv (v (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end (GRing.one R)
+++++
case: pickP => /= [x px|/all_v_neq0 //].
-----
Lemma ratiovv v : v != 0 -> ratio v v = 1.
Proof.
move=> v_neq0.
rewrite /ratio.
case: pickP => /= [x px|/all_v_neq0 //].

*****
px : is_true\n (negb (eq_op (v (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)))
x : ordinal (S n)
v_neq0 : is_true (negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S n)))))
v : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.mul (v (GRing.zero (Zp_zmodType O)) x) (GRing.inv (v (GRing.zero (Zp_zmodType O)) x))) (GRing.one R)
+++++
by rewrite divrr ?unitfE.
-----
Lemma ratiovv v : v != 0 -> ratio v v = 1.
Proof.
move=> v_neq0.
rewrite /ratio.
case: pickP => /= [x px|/all_v_neq0 //].
by rewrite divrr ?unitfE.

*****

*****

+++++
Qed.
-----
Lemma ratiop0 p : ratio p 0 = 0.
-----
Lemma ratiop0 p : ratio p 0 = 0.

*****
p : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio p (GRing.zero (matrix_zmodType R (S O) (S n)))) (GRing.zero R)
+++++
Proof.
-----
Lemma ratiop0 p : ratio p 0 = 0.
Proof.

*****
p : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio p (GRing.zero (matrix_zmodType R (S O) (S n)))) (GRing.zero R)
+++++
by rewrite /ratio; case: pickP => /= [x px|//]; rewrite mxE invr0 mulr0.
-----
Lemma ratiop0 p : ratio p 0 = 0.
Proof.
by rewrite /ratio; case: pickP => /= [x px|//]; rewrite mxE invr0 mulr0.

*****

*****

+++++
Qed.
-----
Lemma ratioNr v1 v2 : ratio (- v1) v2 = - ratio v1 v2.
-----
Lemma ratioNr v1 v2 : ratio (- v1) v2 = - ratio v1 v2.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio (GRing.opp v1) v2) (GRing.opp (ratio v1 v2))
+++++
Proof.
-----
Lemma ratioNr v1 v2 : ratio (- v1) v2 = - ratio v1 v2.
Proof.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio (GRing.opp v1) v2) (GRing.opp (ratio v1 v2))
+++++
case: (v2 =P 0)=> [->|/eqP v2_neq0]; rewrite ?ratiop0 ?oppr0 //.
-----
Lemma ratioNr v1 v2 : ratio (- v1) v2 = - ratio v1 v2.
Proof.
case: (v2 =P 0)=> [->|/eqP v2_neq0]; rewrite ?ratiop0 ?oppr0 //.

*****
v2_neq0 : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio (GRing.opp v1) v2) (GRing.opp (ratio v1 v2))
+++++
by rewrite /ratio; case: pickP => /= [? _|/all_v_neq0 //]; rewrite !mxE -mulNr.
-----
Lemma ratioNr v1 v2 : ratio (- v1) v2 = - ratio v1 v2.
Proof.
case: (v2 =P 0)=> [->|/eqP v2_neq0]; rewrite ?ratiop0 ?oppr0 //.
by rewrite /ratio; case: pickP => /= [? _|/all_v_neq0 //]; rewrite !mxE -mulNr.

*****

*****

+++++
Qed.
-----
Lemma ratiorN v1 v2 : ratio v1 (- v2) = - ratio v1 v2.
-----
Lemma ratiorN v1 v2 : ratio v1 (- v2) = - ratio v1 v2.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio v1 (GRing.opp v2)) (GRing.opp (ratio v1 v2))
+++++
Proof.
-----
Lemma ratiorN v1 v2 : ratio v1 (- v2) = - ratio v1 v2.
Proof.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio v1 (GRing.opp v2)) (GRing.opp (ratio v1 v2))
+++++
case: (-v2 =P 0)=> [eq|/eqP opp_v2_neq0].
-----
Lemma ratiorN v1 v2 : ratio v1 (- v2) = - ratio v1 v2.
Proof.
case: (-v2 =P 0)=> [eq|/eqP opp_v2_neq0].

*****
eq : Logic.eq (GRing.opp v2) (GRing.zero (matrix_zmodType R (S O) (S n)))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio v1 (GRing.opp v2)) (GRing.opp (ratio v1 v2))
+++++
rewrite -[X in _=-ratio _ X]subr0 -opprB sub0r eq oppr0 ratiop0 oppr0 //.
-----
Lemma ratiorN v1 v2 : ratio v1 (- v2) = - ratio v1 v2.
Proof.
case: (-v2 =P 0)=> [eq|/eqP opp_v2_neq0].
rewrite -[X in _=-ratio _ X]subr0 -opprB sub0r eq oppr0 ratiop0 oppr0 //.

*****
opp_v2_neq0 : is_true\n (negb\n (eq_op (GRing.opp v2) (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio v1 (GRing.opp v2)) (GRing.opp (ratio v1 v2))
+++++
rewrite /ratio.
-----
Lemma ratiorN v1 v2 : ratio v1 (- v2) = - ratio v1 v2.
Proof.
case: (-v2 =P 0)=> [eq|/eqP opp_v2_neq0].
rewrite -[X in _=-ratio _ X]subr0 -opprB sub0r eq oppr0 ratiop0 oppr0 //.
rewrite /ratio.

*****
opp_v2_neq0 : is_true\n (negb\n (eq_op (GRing.opp v2) (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq match pick (fun k : ordinal (S n) => negb (eq_op ((GRing.opp v2) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v1 (GRing.zero (Zp_zmodType O)) k) (GRing.inv ((GRing.opp v2) (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end (GRing.opp match pick (fun k : ordinal (S n) => negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v1 (GRing.zero (Zp_zmodType O)) k) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end)
+++++
rewrite (eq_pick (eq_pick_neq0 v2)).
-----
Lemma ratiorN v1 v2 : ratio v1 (- v2) = - ratio v1 v2.
Proof.
case: (-v2 =P 0)=> [eq|/eqP opp_v2_neq0].
rewrite -[X in _=-ratio _ X]subr0 -opprB sub0r eq oppr0 ratiop0 oppr0 //.
rewrite /ratio.
rewrite (eq_pick (eq_pick_neq0 v2)).

*****
opp_v2_neq0 : is_true\n (negb\n (eq_op (GRing.opp v2) (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq match pick (fun k : ordinal (S n) => negb (eq_op ((GRing.opp v2) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v1 (GRing.zero (Zp_zmodType O)) k) (GRing.inv ((GRing.opp v2) (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end (GRing.opp match pick (fun k : ordinal (S n) => negb (eq_op ((GRing.opp v2) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v1 (GRing.zero (Zp_zmodType O)) k) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end)
+++++
by case: pickP => /= [? _|/all_v_neq0 //]; rewrite !mxE -mulrN invrN.
-----
Lemma ratiorN v1 v2 : ratio v1 (- v2) = - ratio v1 v2.
Proof.
case: (-v2 =P 0)=> [eq|/eqP opp_v2_neq0].
rewrite -[X in _=-ratio _ X]subr0 -opprB sub0r eq oppr0 ratiop0 oppr0 //.
rewrite /ratio.
rewrite (eq_pick (eq_pick_neq0 v2)).
by case: pickP => /= [? _|/all_v_neq0 //]; rewrite !mxE -mulrN invrN.

*****

*****

+++++
Qed.
-----
Lemma ratioNN v1 v2 : ratio v1 v2 = ratio (- v1) (- v2).
-----
Lemma ratioNN v1 v2 : ratio v1 v2 = ratio (- v1) (- v2).

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio v1 v2) (ratio (GRing.opp v1) (GRing.opp v2))
+++++
Proof.
-----
Lemma ratioNN v1 v2 : ratio v1 v2 = ratio (- v1) (- v2).
Proof.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio v1 v2) (ratio (GRing.opp v1) (GRing.opp v2))
+++++
by apply /eqP; rewrite ratioNr ratiorN -addr_eq0 subrr.
-----
Lemma ratioNN v1 v2 : ratio v1 v2 = ratio (- v1) (- v2).
Proof.
by apply /eqP; rewrite ratioNr ratiorN -addr_eq0 subrr.

*****

*****

+++++
Qed.
-----
Lemma add_ratio v1 v2 v3 : v3 != 0 ->\n  ratio v1 v3 + ratio v2 v3 = ratio (v1 + v2) v3.
-----
Lemma add_ratio v1 v2 v3 : v3 != 0 -> ratio v1 v3 + ratio v2 v3 = ratio (v1 + v2) v3.

*****
v1,v2,v3 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v3 (GRing.zero (matrix_zmodType R (S O) (S n)))), eq (GRing.add (ratio v1 v3) (ratio v2 v3)) (ratio (GRing.add v1 v2) v3)
+++++
Proof.
-----
Lemma add_ratio v1 v2 v3 : v3 != 0 -> ratio v1 v3 + ratio v2 v3 = ratio (v1 + v2) v3.
Proof.

*****
v1,v2,v3 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v3 (GRing.zero (matrix_zmodType R (S O) (S n)))), eq (GRing.add (ratio v1 v3) (ratio v2 v3)) (ratio (GRing.add v1 v2) v3)
+++++
move=> v_neq0.
-----
Lemma add_ratio v1 v2 v3 : v3 != 0 -> ratio v1 v3 + ratio v2 v3 = ratio (v1 + v2) v3.
Proof.
move=> v_neq0.

*****
v_neq0 : is_true (negb (eq_op v3 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2,v3 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (ratio v1 v3) (ratio v2 v3)) (ratio (GRing.add v1 v2) v3)
+++++
rewrite /ratio.
-----
Lemma add_ratio v1 v2 v3 : v3 != 0 -> ratio v1 v3 + ratio v2 v3 = ratio (v1 + v2) v3.
Proof.
move=> v_neq0.
rewrite /ratio.

*****
v_neq0 : is_true (negb (eq_op v3 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2,v3 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add match pick (fun k : ordinal (S n) => negb (eq_op (v3 (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v1 (GRing.zero (Zp_zmodType O)) k) (GRing.inv (v3 (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end match pick (fun k : ordinal (S n) => negb (eq_op (v3 (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v2 (GRing.zero (Zp_zmodType O)) k) (GRing.inv (v3 (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end) match pick (fun k : ordinal (S n) => negb (eq_op (v3 (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul ((GRing.add v1 v2) (GRing.zero (Zp_zmodType O)) k) (GRing.inv (v3 (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end
+++++
case: pickP => /= [x px|/all_v_neq0 //].
-----
Lemma add_ratio v1 v2 v3 : v3 != 0 -> ratio v1 v3 + ratio v2 v3 = ratio (v1 + v2) v3.
Proof.
move=> v_neq0.
rewrite /ratio.
case: pickP => /= [x px|/all_v_neq0 //].

*****
px : is_true\n (negb (eq_op (v3 (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)))
x : ordinal (S n)
v_neq0 : is_true (negb (eq_op v3 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2,v3 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) x) (GRing.inv (v3 (GRing.zero (Zp_zmodType O)) x))) (GRing.mul (v2 (GRing.zero (Zp_zmodType O)) x) (GRing.inv (v3 (GRing.zero (Zp_zmodType O)) x)))) (GRing.mul ((GRing.add v1 v2) (GRing.zero (Zp_zmodType O)) x) (GRing.inv (v3 (GRing.zero (Zp_zmodType O)) x)))
+++++
rewrite addf_div //= mxE -[X in (_ = X)]mulr1 -(mulfV px).
-----
Lemma add_ratio v1 v2 v3 : v3 != 0 -> ratio v1 v3 + ratio v2 v3 = ratio (v1 + v2) v3.
Proof.
move=> v_neq0.
rewrite /ratio.
case: pickP => /= [x px|/all_v_neq0 //].
rewrite addf_div //= mxE -[X in (_ = X)]mulr1 -(mulfV px).

*****
px : is_true\n (negb (eq_op (v3 (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)))
x : ordinal (S n)
v_neq0 : is_true (negb (eq_op v3 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2,v3 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.mul (GRing.add (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) x) (v3 (GRing.zero (Zp_zmodType O)) x)) (GRing.mul (v2 (GRing.zero (Zp_zmodType O)) x) (v3 (GRing.zero (Zp_zmodType O)) x))) (GRing.inv (GRing.mul (v3 (GRing.zero (Zp_zmodType O)) x) (v3 (GRing.zero (Zp_zmodType O)) x)))) (GRing.mul (GRing.mul (GRing.add (v1 (GRing.zero (Zp_zmodType O)) x) (v2 (GRing.zero (Zp_zmodType O)) x)) (GRing.inv (v3 (GRing.zero (Zp_zmodType O)) x))) (GRing.mul (v3 (GRing.zero (Zp_zmodType O)) x) (GRing.inv (v3 (GRing.zero (Zp_zmodType O)) x))))
+++++
by rewrite mulf_div [X in (_ = X/ _)]mulrDl.
-----
Lemma add_ratio v1 v2 v3 : v3 != 0 -> ratio v1 v3 + ratio v2 v3 = ratio (v1 + v2) v3.
Proof.
move=> v_neq0.
rewrite /ratio.
case: pickP => /= [x px|/all_v_neq0 //].
rewrite addf_div //= mxE -[X in (_ = X)]mulr1 -(mulfV px).
by rewrite mulf_div [X in (_ = X/ _)]mulrDl.

*****

*****

+++++
Qed.
-----
Lemma add_ratio_1 v1 v2 : v2 != 0 ->\n  ratio v1 v2 + 1 = ratio (v1 + v2) v2.
-----
Lemma add_ratio_1 v1 v2 : v2 != 0 -> ratio v1 v2 + 1 = ratio (v1 + v2) v2.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))), eq (GRing.add (ratio v1 v2) (GRing.one R)) (ratio (GRing.add v1 v2) v2)
+++++
Proof.
-----
Lemma add_ratio_1 v1 v2 : v2 != 0 -> ratio v1 v2 + 1 = ratio (v1 + v2) v2.
Proof.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))), eq (GRing.add (ratio v1 v2) (GRing.one R)) (ratio (GRing.add v1 v2) v2)
+++++
by move=> v_neq0; rewrite -(ratiovv v_neq0) add_ratio.
-----
Lemma add_ratio_1 v1 v2 : v2 != 0 -> ratio v1 v2 + 1 = ratio (v1 + v2) v2.
Proof.
by move=> v_neq0; rewrite -(ratiovv v_neq0) add_ratio.

*****

*****

+++++
Qed.
-----
Lemma sub_1_ratio v1 v2 : v2 != 0 ->\n  1 - ratio v1 v2 = ratio (v2 - v1) v2.
-----
Lemma sub_1_ratio v1 v2 : v2 != 0 -> 1 - ratio v1 v2 = ratio (v2 - v1) v2.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))), eq (GRing.add (GRing.one R) (GRing.opp (ratio v1 v2))) (ratio (GRing.add v2 (GRing.opp v1)) v2)
+++++
Proof.
-----
Lemma sub_1_ratio v1 v2 : v2 != 0 -> 1 - ratio v1 v2 = ratio (v2 - v1) v2.
Proof.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))), eq (GRing.add (GRing.one R) (GRing.opp (ratio v1 v2))) (ratio (GRing.add v2 (GRing.opp v1)) v2)
+++++
move=> v_neq0.
-----
Lemma sub_1_ratio v1 v2 : v2 != 0 -> 1 - ratio v1 v2 = ratio (v2 - v1) v2.
Proof.
move=> v_neq0.

*****
v_neq0 : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.one R) (GRing.opp (ratio v1 v2))) (ratio (GRing.add v2 (GRing.opp v1)) v2)
+++++
apply /eqP.
-----
Lemma sub_1_ratio v1 v2 : v2 != 0 -> 1 - ratio v1 v2 = ratio (v2 - v1) v2.
Proof.
move=> v_neq0.
apply /eqP.

*****
v_neq0 : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.one R) (GRing.opp (ratio v1 v2))) (ratio (GRing.add v2 (GRing.opp v1)) v2))
+++++
rewrite subr_eq add_ratio //.
-----
Lemma sub_1_ratio v1 v2 : v2 != 0 -> 1 - ratio v1 v2 = ratio (v2 - v1) v2.
Proof.
move=> v_neq0.
apply /eqP.
rewrite subr_eq add_ratio //.

*****
v_neq0 : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.one R) (ratio (GRing.add (GRing.add v2 (GRing.opp v1)) v1) v2))
+++++
by rewrite addrAC -addrA subrr addr0 ratiovv.
-----
Lemma sub_1_ratio v1 v2 : v2 != 0 -> 1 - ratio v1 v2 = ratio (v2 - v1) v2.
Proof.
move=> v_neq0.
apply /eqP.
rewrite subr_eq add_ratio //.
by rewrite addrAC -addrA subrr addr0 ratiovv.

*****

*****

+++++
Qed.
-----
Lemma ratio_neq0 v1 v2:\n  v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 != 0.
-----
Lemma ratio_neq0 v1 v2: v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 != 0.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op v1 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : eq_op v1 (GRing.scale (ratio v1 v2) v2)), negb (eq_op (ratio v1 v2) (GRing.zero R))
+++++
Proof.
-----
Lemma ratio_neq0 v1 v2: v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 != 0.
Proof.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op v1 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : eq_op v1 (GRing.scale (ratio v1 v2) v2)), negb (eq_op (ratio v1 v2) (GRing.zero R))
+++++
move=> /eqP v1P ?; rewrite /ratio; case: pickP=> /= [x px rP|/all_v_neq0 //].
-----
Lemma ratio_neq0 v1 v2: v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 != 0.
Proof.
move=> /eqP v1P ?; rewrite /ratio; case: pickP=> /= [x px rP|/all_v_neq0 //].

*****
rP : is_true\n (eq_op v1\n (GRing.scale\n (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) x)\n (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) x))) v2))
px : is_true\n (negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)))
x : ordinal (S n)
_Hyp_ : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1P : not (eq v1 (GRing.zero (matrix_zmodType R (S O) (S n))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (negb (eq_op (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) x) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) x))) (GRing.zero R)))
+++++
by apply/eqP; move=> neq; move: rP; rewrite neq scale0r=> /eqP ?; apply v1P.
-----
Lemma ratio_neq0 v1 v2: v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 != 0.
Proof.
move=> /eqP v1P ?; rewrite /ratio; case: pickP=> /= [x px rP|/all_v_neq0 //].
by apply/eqP; move=> neq; move: rP; rewrite neq scale0r=> /eqP ?; apply v1P.

*****

*****

+++++
Qed.
-----
Lemma ratio_eq v1 v2 r : v2 != 0 -> v1 == r *: v2 -> ratio v1 v2 = r.
-----
Lemma ratio_eq v1 v2 r : v2 != 0 -> v1 == r *: v2 -> ratio v1 v2 = r.

*****
r : GRing.Ring.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : eq_op v1 (GRing.scale r v2)), eq (ratio v1 v2) r
+++++
Proof.
-----
Lemma ratio_eq v1 v2 r : v2 != 0 -> v1 == r *: v2 -> ratio v1 v2 = r.
Proof.

*****
r : GRing.Ring.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : eq_op v1 (GRing.scale r v2)), eq (ratio v1 v2) r
+++++
move=> v2_neq0 /eqP Hr.
-----
Lemma ratio_eq v1 v2 r : v2 != 0 -> v1 == r *: v2 -> ratio v1 v2 = r.
Proof.
move=> v2_neq0 /eqP Hr.

*****
Hr : eq v1 (GRing.scale r v2)
v2_neq0 : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
r : GRing.Ring.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio v1 v2) r
+++++
rewrite /ratio.
-----
Lemma ratio_eq v1 v2 r : v2 != 0 -> v1 == r *: v2 -> ratio v1 v2 = r.
Proof.
move=> v2_neq0 /eqP Hr.
rewrite /ratio.

*****
Hr : eq v1 (GRing.scale r v2)
v2_neq0 : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
r : GRing.Ring.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq match pick (fun k : ordinal (S n) => negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v1 (GRing.zero (Zp_zmodType O)) k) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end r
+++++
case: pickP=> /= [x px|/all_v_neq0 //].
-----
Lemma ratio_eq v1 v2 r : v2 != 0 -> v1 == r *: v2 -> ratio v1 v2 = r.
Proof.
move=> v2_neq0 /eqP Hr.
rewrite /ratio.
case: pickP=> /= [x px|/all_v_neq0 //].

*****
px : is_true\n (negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)))
x : ordinal (S n)
Hr : eq v1 (GRing.scale r v2)
v2_neq0 : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
r : GRing.Ring.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) x) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) x))) r
+++++
by rewrite Hr mxE -mulrA mulfV // mulr1.
-----
Lemma ratio_eq v1 v2 r : v2 != 0 -> v1 == r *: v2 -> ratio v1 v2 = r.
Proof.
move=> v2_neq0 /eqP Hr.
rewrite /ratio.
case: pickP=> /= [x px|/all_v_neq0 //].
by rewrite Hr mxE -mulrA mulfV // mulr1.

*****

*****

+++++
Qed.
-----
Lemma ratio_bet' v1 v2 k1 :\n  0 < k1 -> v1 != v2 -> k1 = ratio (v2 - v1) (k1^-1 *: (v2 - v1)).
-----
Lemma ratio_bet' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1 = ratio (v2 - v1) (k1^-1 *: (v2 - v1)).

*****
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : negb (eq_op v1 v2)), eq k1 (ratio (GRing.add v2 (GRing.opp v1)) (GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1))))
+++++
Proof.
-----
Lemma ratio_bet' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1 = ratio (v2 - v1) (k1^-1 *: (v2 - v1)).
Proof.

*****
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : negb (eq_op v1 v2)), eq k1 (ratio (GRing.add v2 (GRing.opp v1)) (GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1))))
+++++
move=> ? ?; rewrite /ratio.
-----
Lemma ratio_bet' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1 = ratio (v2 - v1) (k1^-1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.

*****
_Hyp1_ : is_true (negb (eq_op v1 v2))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq k1 match pick (fun k : ordinal (S n) => negb (eq_op ((GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul ((GRing.add v2 (GRing.opp v1)) (GRing.zero (Zp_zmodType O)) k) (GRing.inv ((GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end
+++++
have: (k1^-1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or invr_eq0 lt0r_neq0 // subr_eq0 eq_sym.
-----
Lemma ratio_bet' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1 = ratio (v2 - v1) (k1^-1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.
have: (k1^-1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or invr_eq0 lt0r_neq0 // subr_eq0 eq_sym.

*****
_Hyp1_ : is_true (negb (eq_op v1 v2))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op (GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1))) (GRing.zero (GRing.Zmodule.Pack (GRing.Lmodule.class (matrix_lmodType R (S O) (S n)))))), eq k1 match pick (fun k : ordinal (S n) => negb (eq_op ((GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul ((GRing.add v2 (GRing.opp v1)) (GRing.zero (Zp_zmodType O)) k) (GRing.inv ((GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end
+++++
move=> neq; case: pickP => /=[x px|/all_v_neq0 //].
-----
Lemma ratio_bet' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1 = ratio (v2 - v1) (k1^-1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.
have: (k1^-1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or invr_eq0 lt0r_neq0 // subr_eq0 eq_sym.
move=> neq; case: pickP => /=[x px|/all_v_neq0 //].

*****
px : is_true\n (negb\n (eq_op\n ((GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1)))\n (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)))
x : ordinal (S n)
neq : is_true\n (negb\n (eq_op (GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1)))\n (GRing.zero\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n)))))))
_Hyp1_ : is_true (negb (eq_op v1 v2))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq k1 (GRing.mul ((GRing.add v2 (GRing.opp v1)) (GRing.zero (Zp_zmodType O)) x) (GRing.inv ((GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) x)))
+++++
rewrite !mxE -{1}[(v2 0 x - v1 0 x)]mul1r -mulf_div mulfV; last by apply /eqP; move=> eq; move/eqP: px; rewrite !mxE eq mulr0.
-----
Lemma ratio_bet' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1 = ratio (v2 - v1) (k1^-1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.
have: (k1^-1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or invr_eq0 lt0r_neq0 // subr_eq0 eq_sym.
move=> neq; case: pickP => /=[x px|/all_v_neq0 //].
rewrite !mxE -{1}[(v2 0 x - v1 0 x)]mul1r -mulf_div mulfV; last by apply /eqP; move=> eq; move/eqP: px; rewrite !mxE eq mulr0.

*****
px : is_true\n (negb\n (eq_op\n ((GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1)))\n (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)))
x : ordinal (S n)
neq : is_true\n (negb\n (eq_op (GRing.scale (GRing.inv k1) (GRing.add v2 (GRing.opp v1)))\n (GRing.zero\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n)))))))
_Hyp1_ : is_true (negb (eq_op v1 v2))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq k1 (GRing.mul (GRing.mul (GRing.one R) (GRing.inv (GRing.inv k1))) (GRing.one R))
+++++
by rewrite mulr1 -[k1^-1]div1r invf_div divr1 mul1r.
-----
Lemma ratio_bet' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1 = ratio (v2 - v1) (k1^-1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.
have: (k1^-1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or invr_eq0 lt0r_neq0 // subr_eq0 eq_sym.
move=> neq; case: pickP => /=[x px|/all_v_neq0 //].
rewrite !mxE -{1}[(v2 0 x - v1 0 x)]mul1r -mulf_div mulfV; last by apply /eqP; move=> eq; move/eqP: px; rewrite !mxE eq mulr0.
by rewrite mulr1 -[k1^-1]div1r invf_div divr1 mul1r.

*****

*****

+++++
Qed.
-----
Lemma ratio_bet'' v1 v2 k1 :\n  0 < k1 -> v1 != v2 -> k1^-1 = ratio (v2 - v1) (k1 *: (v2 - v1)).
-----
Lemma ratio_bet'' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1^-1 = ratio (v2 - v1) (k1 *: (v2 - v1)).

*****
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : negb (eq_op v1 v2)), eq (GRing.inv k1) (ratio (GRing.add v2 (GRing.opp v1)) (GRing.scale k1 (GRing.add v2 (GRing.opp v1))))
+++++
Proof.
-----
Lemma ratio_bet'' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1^-1 = ratio (v2 - v1) (k1 *: (v2 - v1)).
Proof.

*****
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : negb (eq_op v1 v2)), eq (GRing.inv k1) (ratio (GRing.add v2 (GRing.opp v1)) (GRing.scale k1 (GRing.add v2 (GRing.opp v1))))
+++++
move=> ? ?; rewrite /ratio.
-----
Lemma ratio_bet'' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1^-1 = ratio (v2 - v1) (k1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.

*****
_Hyp1_ : is_true (negb (eq_op v1 v2))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.inv k1) match pick (fun k : ordinal (S n) => negb (eq_op ((GRing.scale k1 (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul ((GRing.add v2 (GRing.opp v1)) (GRing.zero (Zp_zmodType O)) k) (GRing.inv ((GRing.scale k1 (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end
+++++
have: (k1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or lt0r_neq0 // subr_eq0 eq_sym.
-----
Lemma ratio_bet'' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1^-1 = ratio (v2 - v1) (k1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.
have: (k1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or lt0r_neq0 // subr_eq0 eq_sym.

*****
_Hyp1_ : is_true (negb (eq_op v1 v2))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op (GRing.scale k1 (GRing.add v2 (GRing.opp v1))) (GRing.zero (GRing.Zmodule.Pack (GRing.Lmodule.class (matrix_lmodType R (S O) (S n)))))), eq (GRing.inv k1) match pick (fun k : ordinal (S n) => negb (eq_op ((GRing.scale k1 (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul ((GRing.add v2 (GRing.opp v1)) (GRing.zero (Zp_zmodType O)) k) (GRing.inv ((GRing.scale k1 (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end
+++++
move=> neq; case: pickP => /=[x px|/all_v_neq0 //].
-----
Lemma ratio_bet'' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1^-1 = ratio (v2 - v1) (k1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.
have: (k1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or lt0r_neq0 // subr_eq0 eq_sym.
move=> neq; case: pickP => /=[x px|/all_v_neq0 //].

*****
px : is_true\n (negb\n (eq_op\n ((GRing.scale k1 (GRing.add v2 (GRing.opp v1)))\n (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)))
x : ordinal (S n)
neq : is_true\n (negb\n (eq_op (GRing.scale k1 (GRing.add v2 (GRing.opp v1)))\n (GRing.zero\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n)))))))
_Hyp1_ : is_true (negb (eq_op v1 v2))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.inv k1) (GRing.mul ((GRing.add v2 (GRing.opp v1)) (GRing.zero (Zp_zmodType O)) x) (GRing.inv ((GRing.scale k1 (GRing.add v2 (GRing.opp v1))) (GRing.zero (Zp_zmodType O)) x)))
+++++
rewrite !mxE -{1}[(v2 0 x - v1 0 x)]mul1r -mulf_div mulfV ?mulr1 ?div1r //.
-----
Lemma ratio_bet'' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1^-1 = ratio (v2 - v1) (k1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.
have: (k1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or lt0r_neq0 // subr_eq0 eq_sym.
move=> neq; case: pickP => /=[x px|/all_v_neq0 //].
rewrite !mxE -{1}[(v2 0 x - v1 0 x)]mul1r -mulf_div mulfV ?mulr1 ?div1r //.

*****
px : is_true\n (negb\n (eq_op\n ((GRing.scale k1 (GRing.add v2 (GRing.opp v1)))\n (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)))
x : ordinal (S n)
neq : is_true\n (negb\n (eq_op (GRing.scale k1 (GRing.add v2 (GRing.opp v1)))\n (GRing.zero\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n)))))))
_Hyp1_ : is_true (negb (eq_op v1 v2))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (negb (eq_op (GRing.add (v2 (GRing.zero (Zp_zmodType O)) x) (GRing.opp (v1 (GRing.zero (Zp_zmodType O)) x))) (GRing.zero R)))
+++++
by apply /eqP; move=> eq; move/eqP: px; rewrite !mxE eq mulr0.
-----
Lemma ratio_bet'' v1 v2 k1 : 0 < k1 -> v1 != v2 -> k1^-1 = ratio (v2 - v1) (k1 *: (v2 - v1)).
Proof.
move=> ? ?; rewrite /ratio.
have: (k1 *: (v2 - v1) != 0) by rewrite scalemx_eq0 negb_or lt0r_neq0 // subr_eq0 eq_sym.
move=> neq; case: pickP => /=[x px|/all_v_neq0 //].
rewrite !mxE -{1}[(v2 0 x - v1 0 x)]mul1r -mulf_div mulfV ?mulr1 ?div1r //.
by apply /eqP; move=> eq; move/eqP: px; rewrite !mxE eq mulr0.

*****

*****

+++++
Qed.
-----
Lemma ratio_lt0_v1_neq0 v1 v2 : ratio v1 v2 < 0 -> v1 != 0.
-----
Lemma ratio_lt0_v1_neq0 v1 v2 : ratio v1 v2 < 0 -> v1 != 0.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (ratio v1 v2) (GRing.zero R), negb (eq_op v1 (GRing.zero (matrix_zmodType R (S O) (S n))))
+++++
Proof.
-----
Lemma ratio_lt0_v1_neq0 v1 v2 : ratio v1 v2 < 0 -> v1 != 0.
Proof.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (ratio v1 v2) (GRing.zero R), negb (eq_op v1 (GRing.zero (matrix_zmodType R (S O) (S n))))
+++++
by case: (v1 =P 0)=> [->|//]; rewrite ratio0p ltrr.
-----
Lemma ratio_lt0_v1_neq0 v1 v2 : ratio v1 v2 < 0 -> v1 != 0.
Proof.
by case: (v1 =P 0)=> [->|//]; rewrite ratio0p ltrr.

*****

*****

+++++
Qed.
-----
Lemma ratio_lt0_v2_neq0 v1 v2 : ratio v1 v2 < 0 -> v2 != 0.
-----
Lemma ratio_lt0_v2_neq0 v1 v2 : ratio v1 v2 < 0 -> v2 != 0.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (ratio v1 v2) (GRing.zero R), negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n))))
+++++
Proof.
-----
Lemma ratio_lt0_v2_neq0 v1 v2 : ratio v1 v2 < 0 -> v2 != 0.
Proof.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (ratio v1 v2) (GRing.zero R), negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n))))
+++++
by case: (v2 =P 0)=> [->|//]; rewrite ratiop0 ltrr.
-----
Lemma ratio_lt0_v2_neq0 v1 v2 : ratio v1 v2 < 0 -> v2 != 0.
Proof.
by case: (v2 =P 0)=> [->|//]; rewrite ratiop0 ltrr.

*****

*****

+++++
Qed.
-----
Lemma ratio_inv v1 v2 :\n  v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 ->\n  ratio v1 v2 = 1 / ratio v2 v1.
-----
Lemma ratio_inv v1 v2 : v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 = 1 / ratio v2 v1.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op v1 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : eq_op v1 (GRing.scale (ratio v1 v2) v2)), eq (ratio v1 v2) (GRing.mul (GRing.one R) (GRing.inv (ratio v2 v1)))
+++++
Proof.
-----
Lemma ratio_inv v1 v2 : v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 = 1 / ratio v2 v1.
Proof.

*****
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op v1 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n))))) (_ : eq_op v1 (GRing.scale (ratio v1 v2) v2)), eq (ratio v1 v2) (GRing.mul (GRing.one R) (GRing.inv (ratio v2 v1)))
+++++
move=> NE1 NE2 /eqP E; apply /eqP; rewrite eq_sym /ratio {2}E /ratio.
-----
Lemma ratio_inv v1 v2 : v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 = 1 / ratio v2 v1.
Proof.
move=> NE1 NE2 /eqP E; apply /eqP; rewrite eq_sym /ratio {2}E /ratio.

*****
E : eq v1 (GRing.scale (ratio v1 v2) v2)
NE2 : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
NE1 : is_true (negb (eq_op v1 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.one R) (GRing.inv match pick (fun k : ordinal (S n) => negb (eq_op (v1 (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v2 (GRing.zero (Zp_zmodType O)) k) (GRing.inv ((GRing.scale match pick (fun k0 : ordinal (S n) => negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) k0) (GRing.zero R))) with | Some k0 => GRing.mul (v1 (GRing.zero (Zp_zmodType O)) k0) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) k0)) | None => GRing.zero R end v2) (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end)) match pick (fun k : ordinal (S n) => negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) k) (GRing.zero R))) with | Some k => GRing.mul (v1 (GRing.zero (Zp_zmodType O)) k) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) k)) | None => GRing.zero R end)
+++++
case: pickP=> [x /eqP px|/all_v_neq0 //]; case: pickP=> [y py|/all_v_neq0 //].
-----
Lemma ratio_inv v1 v2 : v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 = 1 / ratio v2 v1.
Proof.
move=> NE1 NE2 /eqP E; apply /eqP; rewrite eq_sym /ratio {2}E /ratio.
case: pickP=> [x /eqP px|/all_v_neq0 //]; case: pickP=> [y py|/all_v_neq0 //].

*****
py : is_true\n (negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) y) (GRing.zero R)))
y : Finite.sort (ordinal_finType (S n))
px : not (eq (v1 (GRing.zero (Zp_zmodType O)) x) (GRing.zero R))
x : Finite.sort (ordinal_finType (S n))
E : eq v1 (GRing.scale (ratio v1 v2) v2)
NE2 : is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S n)))))
NE1 : is_true (negb (eq_op v1 (GRing.zero (matrix_zmodType R (S O) (S n)))))
v1,v2 : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.one R) (GRing.inv (GRing.mul (v2 (GRing.zero (Zp_zmodType O)) x) (GRing.inv ((GRing.scale (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) y) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) y))) v2) (GRing.zero (Zp_zmodType O)) x))))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) y) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) y))))
+++++
rewrite mxE [X in _ / (_ / X)]mulrC -{1}[v2 0 x]mulr1 -mulf_div mulfV ?mul1r; rewrite ?invf_div //; by apply /eqP=> px'; apply px; rewrite E mxE px' mulr0.
-----
Lemma ratio_inv v1 v2 : v1 != 0 -> v2 != 0 -> v1 == ratio v1 v2 *: v2 -> ratio v1 v2 = 1 / ratio v2 v1.
Proof.
move=> NE1 NE2 /eqP E; apply /eqP; rewrite eq_sym /ratio {2}E /ratio.
case: pickP=> [x /eqP px|/all_v_neq0 //]; case: pickP=> [y py|/all_v_neq0 //].
rewrite mxE [X in _ / (_ / X)]mulrC -{1}[v2 0 x]mulr1 -mulf_div mulfV ?mul1r; rewrite ?invf_div //; by apply /eqP=> px'; apply px; rewrite E mxE px' mulr0.

*****

*****

+++++
Qed.
-----
End Ratio.
-----
Section TarskiGe1.
-----
Variable R : realFieldType.
-----
Variable n : nat.
-----
Implicit Types (a b c d : (@ Vector R n)).
-----
Definition cong a b c d := (b - a) *m (b - a)^T == (d - c) *m (d - c)^T.
-----
Lemma cong_pseudo_reflexivity a b : cong a b b a.
-----
Lemma cong_pseudo_reflexivity a b : cong a b b a.

*****
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (cong a b b a)
+++++
Proof.
-----
Lemma cong_pseudo_reflexivity a b : cong a b b a.
Proof.

*****
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (cong a b b a)
+++++
by rewrite /cong -opprB linearN mulmxN mulNmx opprK.
-----
Lemma cong_pseudo_reflexivity a b : cong a b b a.
Proof.
by rewrite /cong -opprB linearN mulmxN mulNmx opprK.

*****

*****

+++++
Qed.
-----
Lemma cong_identity a b c : cong a b c c -> a = b.
-----
Lemma cong_identity a b c : cong a b c c -> a = b.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : cong a b c c, eq a b
+++++
Proof.
-----
Lemma cong_identity a b c : cong a b c c -> a = b.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : cong a b c c, eq a b
+++++
by rewrite /cong subrr linear0 mulmx0 quad_eq0 subr_eq0 => /eqP ->.
-----
Lemma cong_identity a b c : cong a b c c -> a = b.
Proof.
by rewrite /cong subrr linear0 mulmx0 quad_eq0 subr_eq0 => /eqP ->.

*****

*****

+++++
Qed.
-----
Lemma cong_inner_transitivity a b c d e f :\n   cong a b e f -> cong c d e f -> cong a b c d.
-----
Lemma cong_inner_transitivity a b c d e f : cong a b e f -> cong c d e f -> cong a b c d.

*****
a,b,c,d,e,f : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : cong a b e f) (_ : cong c d e f), cong a b c d
+++++
Proof.
-----
Lemma cong_inner_transitivity a b c d e f : cong a b e f -> cong c d e f -> cong a b c d.
Proof.

*****
a,b,c,d,e,f : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : cong a b e f) (_ : cong c d e f), cong a b c d
+++++
by rewrite /cong => /eqP -> /eqP ->.
-----
Lemma cong_inner_transitivity a b c d e f : cong a b e f -> cong c d e f -> cong a b c d.
Proof.
by rewrite /cong => /eqP -> /eqP ->.

*****

*****

+++++
Qed.
-----
Definition betE a b c := [ || [ && a == b & b == c ], a == b | b == c ].
-----
Lemma betEP a b c :\n  reflect ([ \/ [ /\ a = b & b = c ], a = b | b = c ]) (betE a b c).
-----
Lemma betEP a b c : reflect ([ \\/ [ /\\ a = b & b = c ], a = b | b = c ]) (betE a b c).

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
Bool.reflect (or3 (and (eq a b) (eq b c)) (eq a b) (eq b c)) (betE a b c)
+++++
Proof.
-----
Lemma betEP a b c : reflect ([ \\/ [ /\\ a = b & b = c ], a = b | b = c ]) (betE a b c).
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
Bool.reflect (or3 (and (eq a b) (eq b c)) (eq a b) (eq b c)) (betE a b c)
+++++
by rewrite /betE; case: (a =P b)=>[->|?]; case: (b =P c)=>[->|?]=> /=; constructor; [apply Or32|apply Or32|apply Or33|]=> //; case=> [[? ?]|?|?].
-----
Lemma betEP a b c : reflect ([ \\/ [ /\\ a = b & b = c ], a = b | b = c ]) (betE a b c).
Proof.
by rewrite /betE; case: (a =P b)=>[->|?]; case: (b =P c)=>[->|?]=> /=; constructor; [apply Or32|apply Or32|apply Or33|]=> //; case=> [[? ?]|?|?].

*****

*****

+++++
Qed.
-----
Lemma betE_sym a b c : betE a b c = betE c b a.
-----
Lemma betE_sym a b c : betE a b c = betE c b a.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betE a b c) (betE c b a)
+++++
Proof.
-----
Lemma betE_sym a b c : betE a b c = betE c b a.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betE a b c) (betE c b a)
+++++
by rewrite /betE !Bool.orb_assoc eq_sym andbC eq_sym orbAC.
-----
Lemma betE_sym a b c : betE a b c = betE c b a.
Proof.
by rewrite /betE !Bool.orb_assoc eq_sym andbC eq_sym orbAC.

*****

*****

+++++
Qed.
-----
Definition betR a b c := ratio (b - a) (c - a).
-----
Definition betS a b c (r := betR a b c) :=\n  [ && b - a == r *: (c - a), 0 < r & r < 1].
-----
Lemma betSP a b c (r := betR a b c) :\n  reflect ([ /\ b - a = r *: (c - a), 0 < r & r < 1 ]) (betS a b c).
-----
Lemma betSP a b c (r := betR a b c) : reflect ([ /\\ b - a = r *: (c - a), 0 < r & r < 1 ]) (betS a b c).

*****
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
Bool.reflect (and3 (eq (GRing.add b (GRing.opp a)) (GRing.scale r (GRing.add c (GRing.opp a)))) (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))) (betS a b c)
+++++
Proof.
-----
Lemma betSP a b c (r := betR a b c) : reflect ([ /\\ b - a = r *: (c - a), 0 < r & r < 1 ]) (betS a b c).
Proof.

*****
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
Bool.reflect (and3 (eq (GRing.add b (GRing.opp a)) (GRing.scale r (GRing.add c (GRing.opp a)))) (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))) (betS a b c)
+++++
rewrite /betS -/r; case: (b-a =P r*:(c-a))=> [<-|/=]; last by constructor; case.
-----
Lemma betSP a b c (r := betR a b c) : reflect ([ /\\ b - a = r *: (c - a), 0 < r & r < 1 ]) (betS a b c).
Proof.
rewrite /betS -/r; case: (b-a =P r*:(c-a))=> [<-|/=]; last by constructor; case.

*****
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
Bool.reflect (and3 (eq (GRing.add b (GRing.opp a)) (GRing.add b (GRing.opp a))) (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))) (andb true (andb (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))))
+++++
by case: (0 < r); case: (r < 1)=> /=; constructor; try (case=> //).
-----
Lemma betSP a b c (r := betR a b c) : reflect ([ /\\ b - a = r *: (c - a), 0 < r & r < 1 ]) (betS a b c).
Proof.
rewrite /betS -/r; case: (b-a =P r*:(c-a))=> [<-|/=]; last by constructor; case.
by case: (0 < r); case: (r < 1)=> /=; constructor; try (case=> //).

*****

*****

+++++
Qed.
-----
Lemma betS_sym a b c : betS a b c = betS c b a.
-----
Lemma betS_sym a b c : betS a b c = betS c b a.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b c) (betS c b a)
+++++
Proof.
-----
Lemma betS_sym a b c : betS a b c = betS c b a.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b c) (betS c b a)
+++++
rewrite /betS /betR !andb_assoc -(addrBDB b c a) -[c-a]opprB ratiorN oppr_gt0.
-----
Lemma betS_sym a b c : betS a b c = betS c b a.
Proof.
rewrite /betS /betR !andb_assoc -(addrBDB b c a) -[c-a]opprB ratiorN oppr_gt0.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (andb (eq_op (GRing.add (GRing.add b (GRing.opp c)) (GRing.opp (GRing.add a (GRing.opp c)))) (GRing.scale (GRing.opp (ratio (GRing.add (GRing.add b (GRing.opp c)) (GRing.opp (GRing.add a (GRing.opp c)))) (GRing.add a (GRing.opp c)))) (GRing.opp (GRing.add a (GRing.opp c))))) (Num.Def.ltr (ratio (GRing.add (GRing.add b (GRing.opp c)) (GRing.opp (GRing.add a (GRing.opp c)))) (GRing.add a (GRing.opp c))) (GRing.zero R))) (Num.Def.ltr (GRing.opp (ratio (GRing.add (GRing.add b (GRing.opp c)) (GRing.opp (GRing.add a (GRing.opp c)))) (GRing.add a (GRing.opp c)))) (GRing.one R))) (andb (andb (eq_op (GRing.add b (GRing.opp c)) (GRing.scale (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))) (GRing.add a (GRing.opp c)))) (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))) (GRing.one R)))
+++++
case (a-c =P 0)=> [->|/eqP ?]; first by rewrite !ratiop0 ltrr !andbF.
-----
Lemma betS_sym a b c : betS a b c = betS c b a.
Proof.
rewrite /betS /betR !andb_assoc -(addrBDB b c a) -[c-a]opprB ratiorN oppr_gt0.
case (a-c =P 0)=> [->|/eqP ?]; first by rewrite !ratiop0 ltrr !andbF.

*****
__view_subject_1_ : is_true\n (negb\n (eq_op (GRing.add a (GRing.opp c))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (andb (eq_op (GRing.add (GRing.add b (GRing.opp c)) (GRing.opp (GRing.add a (GRing.opp c)))) (GRing.scale (GRing.opp (ratio (GRing.add (GRing.add b (GRing.opp c)) (GRing.opp (GRing.add a (GRing.opp c)))) (GRing.add a (GRing.opp c)))) (GRing.opp (GRing.add a (GRing.opp c))))) (Num.Def.ltr (ratio (GRing.add (GRing.add b (GRing.opp c)) (GRing.opp (GRing.add a (GRing.opp c)))) (GRing.add a (GRing.opp c))) (GRing.zero R))) (Num.Def.ltr (GRing.opp (ratio (GRing.add (GRing.add b (GRing.opp c)) (GRing.opp (GRing.add a (GRing.opp c)))) (GRing.add a (GRing.opp c)))) (GRing.one R))) (andb (andb (eq_op (GRing.add b (GRing.opp c)) (GRing.scale (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))) (GRing.add a (GRing.opp c)))) (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))) (GRing.one R)))
+++++
rewrite -add_ratio ?ratioNr ?ratiovv // andbAC subr_lt0 ltr_oppl ltr_subr_addl.
-----
Lemma betS_sym a b c : betS a b c = betS c b a.
Proof.
rewrite /betS /betR !andb_assoc -(addrBDB b c a) -[c-a]opprB ratiorN oppr_gt0.
case (a-c =P 0)=> [->|/eqP ?]; first by rewrite !ratiop0 ltrr !andbF.
rewrite -add_ratio ?ratioNr ?ratiovv // andbAC subr_lt0 ltr_oppl ltr_subr_addl.

*****
__view_subject_1_ : is_true\n (negb\n (eq_op (GRing.add a (GRing.opp c))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (andb (eq_op (GRing.add (GRing.add b (GRing.opp c)) (GRing.opp (GRing.add a (GRing.opp c)))) (GRing.scale (GRing.opp (GRing.add (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))) (GRing.opp (GRing.one R)))) (GRing.opp (GRing.add a (GRing.opp c))))) (Num.Def.ltr (GRing.add (GRing.one R) (GRing.opp (GRing.one R))) (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))) (GRing.one R))) (andb (andb (eq_op (GRing.add b (GRing.opp c)) (GRing.scale (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))) (GRing.add a (GRing.opp c)))) (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp c)) (GRing.add a (GRing.opp c))) (GRing.one R)))
+++++
by rewrite scaleNr -scalerN scalerBl scale1r -subr_eq !opprB !addrBDB subrr.
-----
Lemma betS_sym a b c : betS a b c = betS c b a.
Proof.
rewrite /betS /betR !andb_assoc -(addrBDB b c a) -[c-a]opprB ratiorN oppr_gt0.
case (a-c =P 0)=> [->|/eqP ?]; first by rewrite !ratiop0 ltrr !andbF.
rewrite -add_ratio ?ratioNr ?ratiovv // andbAC subr_lt0 ltr_oppl ltr_subr_addl.
by rewrite scaleNr -scalerN scalerBl scale1r -subr_eq !opprB !addrBDB subrr.

*****

*****

+++++
Qed.
-----
Definition bet a b c := betE a b c || betS a b c.
-----
Lemma bet_sym a b c : bet a b c = bet c b a.
-----
Lemma bet_sym a b c : bet a b c = bet c b a.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet a b c) (bet c b a)
+++++
Proof.
-----
Lemma bet_sym a b c : bet a b c = bet c b a.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet a b c) (bet c b a)
+++++
by rewrite /bet betE_sym betS_sym.
-----
Lemma bet_sym a b c : bet a b c = bet c b a.
Proof.
by rewrite /bet betE_sym betS_sym.

*****

*****

+++++
Qed.
-----
Lemma bet_symmetry a b c : bet a b c -> bet c b a.
-----
Lemma bet_symmetry a b c : bet a b c -> bet c b a.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : bet a b c, bet c b a
+++++
Proof.
-----
Lemma bet_symmetry a b c : bet a b c -> bet c b a.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : bet a b c, bet c b a
+++++
by rewrite bet_sym.
-----
Lemma bet_symmetry a b c : bet a b c -> bet c b a.
Proof.
by rewrite bet_sym.

*****

*****

+++++
Qed.
-----
Lemma betS_neq12 a b c : betS a b c = betS a b c && (a != b).
-----
Lemma betS_neq12 a b c : betS a b c = betS a b c && (a != b).

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b c) (andb (betS a b c) (negb (eq_op a b)))
+++++
Proof.
-----
Lemma betS_neq12 a b c : betS a b c = betS a b c && (a != b).
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b c) (andb (betS a b c) (negb (eq_op a b)))
+++++
rewrite /betS/ betR.
-----
Lemma betS_neq12 a b c : betS a b c = betS a b c && (a != b).
Proof.
rewrite /betS/ betR.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.one R)))) (andb (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.one R)))) (negb (eq_op a b)))
+++++
case (a =P b)=> [->|/eqP ?]; last by rewrite andbT.
-----
Lemma betS_neq12 a b c : betS a b c = betS a b c && (a != b).
Proof.
rewrite /betS/ betR.
case (a =P b)=> [->|/eqP ?]; last by rewrite andbT.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (eq_op (GRing.add b (GRing.opp b)) (GRing.scale (ratio (GRing.add b (GRing.opp b)) (GRing.add c (GRing.opp b))) (GRing.add c (GRing.opp b)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp b)) (GRing.add c (GRing.opp b)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp b)) (GRing.add c (GRing.opp b))) (GRing.one R)))) (andb (andb (eq_op (GRing.add b (GRing.opp b)) (GRing.scale (ratio (GRing.add b (GRing.opp b)) (GRing.add c (GRing.opp b))) (GRing.add c (GRing.opp b)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp b)) (GRing.add c (GRing.opp b)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp b)) (GRing.add c (GRing.opp b))) (GRing.one R)))) (negb true))
+++++
by rewrite subrr ratio0p ltrr /= !andbF.
-----
Lemma betS_neq12 a b c : betS a b c = betS a b c && (a != b).
Proof.
rewrite /betS/ betR.
case (a =P b)=> [->|/eqP ?]; last by rewrite andbT.
by rewrite subrr ratio0p ltrr /= !andbF.

*****

*****

+++++
Qed.
-----
Lemma betS_neq23 a b c : betS a b c = betS a b c && (b != c).
-----
Lemma betS_neq23 a b c : betS a b c = betS a b c && (b != c).

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b c) (andb (betS a b c) (negb (eq_op b c)))
+++++
Proof.
-----
Lemma betS_neq23 a b c : betS a b c = betS a b c && (b != c).
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b c) (andb (betS a b c) (negb (eq_op b c)))
+++++
by rewrite betS_sym eq_sym {1}betS_neq12.
-----
Lemma betS_neq23 a b c : betS a b c = betS a b c && (b != c).
Proof.
by rewrite betS_sym eq_sym {1}betS_neq12.

*****

*****

+++++
Qed.
-----
Lemma betS_neq13 a b c : betS a b c = betS a b c && (a != c).
-----
Lemma betS_neq13 a b c : betS a b c = betS a b c && (a != c).

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b c) (andb (betS a b c) (negb (eq_op a c)))
+++++
Proof.
-----
Lemma betS_neq13 a b c : betS a b c = betS a b c && (a != c).
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b c) (andb (betS a b c) (negb (eq_op a c)))
+++++
rewrite /betS /betR.
-----
Lemma betS_neq13 a b c : betS a b c = betS a b c && (a != c).
Proof.
rewrite /betS /betR.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.one R)))) (andb (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.one R)))) (negb (eq_op a c)))
+++++
case (a =P c)=> [->|/eqP ?].
-----
Lemma betS_neq13 a b c : betS a b c = betS a b c && (a != c).
Proof.
rewrite /betS /betR.
case (a =P c)=> [->|/eqP ?].

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (eq_op (GRing.add b (GRing.opp c)) (GRing.scale (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.add c (GRing.opp c)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.one R)))) (andb (andb (eq_op (GRing.add b (GRing.opp c)) (GRing.scale (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.add c (GRing.opp c)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.one R)))) (negb true))
+++++
rewrite ?andbT //.
-----
Lemma betS_neq13 a b c : betS a b c = betS a b c && (a != c).
Proof.
rewrite /betS /betR.
case (a =P c)=> [->|/eqP ?].
rewrite ?andbT //.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (eq_op (GRing.add b (GRing.opp c)) (GRing.scale (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.add c (GRing.opp c)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.one R)))) (andb (andb (eq_op (GRing.add b (GRing.opp c)) (GRing.scale (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.add c (GRing.opp c)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.one R)))) (negb true))
+++++
by rewrite subrr ratiop0 ltrr /= andbF !andFb.
-----
Lemma betS_neq13 a b c : betS a b c = betS a b c && (a != c).
Proof.
rewrite /betS /betR.
case (a =P c)=> [->|/eqP ?].

*****
__view_subject_1_ : is_true (negb (eq_op a c))
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.one R)))) (andb (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.one R)))) (negb false))
+++++
rewrite ?andbT //.
-----
Lemma betS_neq13 a b c : betS a b c = betS a b c && (a != c).
Proof.
rewrite /betS /betR.
case (a =P c)=> [->|/eqP ?].

*****

*****

+++++
Qed.
-----
Lemma betS_id a b : betS a b a = false.
-----
Lemma betS_id a b : betS a b a = false.

*****
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b a) false
+++++
Proof.
-----
Lemma betS_id a b : betS a b a = false.
Proof.

*****
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betS a b a) false
+++++
by rewrite /betS /betR subrr ratiop0 ltrr andbF.
-----
Lemma betS_id a b : betS a b a = false.
Proof.
by rewrite /betS /betR subrr ratiop0 ltrr andbF.

*****

*****

+++++
Qed.
-----
Lemma bet_betE a b c : bet a b c = betE a b c || bet a b c.
-----
Lemma bet_betE a b c : bet a b c = betE a b c || bet a b c.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet a b c) (orb (betE a b c) (bet a b c))
+++++
Proof.
-----
Lemma bet_betE a b c : bet a b c = betE a b c || bet a b c.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet a b c) (orb (betE a b c) (bet a b c))
+++++
by rewrite /bet orbA orbb.
-----
Lemma bet_betE a b c : bet a b c = betE a b c || bet a b c.
Proof.
by rewrite /bet orbA orbb.

*****

*****

+++++
Qed.
-----
Lemma betE_axx a x : betE a x x.
-----
Lemma betE_axx a x : betE a x x.

*****
a,x : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (betE a x x)
+++++
Proof.
-----
Lemma betE_axx a x : betE a x x.
Proof.

*****
a,x : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (betE a x x)
+++++
by rewrite /betE eqxx !orbT.
-----
Lemma betE_axx a x : betE a x x.
Proof.
by rewrite /betE eqxx !orbT.

*****

*****

+++++
Qed.
-----
Lemma betE_xxa x a : betE x x a.
-----
Lemma betE_xxa x a : betE x x a.

*****
x,a : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (betE x x a)
+++++
Proof.
-----
Lemma betE_xxa x a : betE x x a.
Proof.

*****
x,a : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (betE x x a)
+++++
by rewrite /betE eqxx orbT.
-----
Lemma betE_xxa x a : betE x x a.
Proof.
by rewrite /betE eqxx orbT.

*****

*****

+++++
Qed.
-----
Lemma bet_axx a x : bet a x x.
-----
Lemma bet_axx a x : bet a x x.

*****
a,x : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet a x x)
+++++
Proof.
-----
Lemma bet_axx a x : bet a x x.
Proof.

*****
a,x : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet a x x)
+++++
by rewrite /bet betE_axx orTb.
-----
Lemma bet_axx a x : bet a x x.
Proof.
by rewrite /bet betE_axx orTb.

*****

*****

+++++
Qed.
-----
Lemma bet_xxa x a : bet x x a.
-----
Lemma bet_xxa x a : bet x x a.

*****
x,a : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet x x a)
+++++
Proof.
-----
Lemma bet_xxa x a : bet x x a.
Proof.

*****
x,a : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet x x a)
+++++
by rewrite /bet betE_xxa orTb.
-----
Lemma bet_xxa x a : bet x x a.
Proof.
by rewrite /bet betE_xxa orTb.

*****

*****

+++++
Qed.
-----
Lemma bet_opp a b c : bet a b c = bet (-a) (-b) (-c).
-----
Lemma bet_opp a b c : bet a b c = bet (-a) (-b) (-c).

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet a b c) (bet (GRing.opp a) (GRing.opp b) (GRing.opp c))
+++++
Proof.
-----
Lemma bet_opp a b c : bet a b c = bet (-a) (-b) (-c).
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet a b c) (bet (GRing.opp a) (GRing.opp b) (GRing.opp c))
+++++
rewrite /bet /betE /betS !eqr_opp.
-----
Lemma bet_opp a b c : bet a b c = bet (-a) (-b) (-c).
Proof.
rewrite /bet /betE /betS !eqr_opp.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (betR a b c) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (betR a b c)) (Num.Def.ltr (betR a b c) (GRing.one R))))) (orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (andb (eq_op (GRing.add (GRing.opp b) (GRing.opp (GRing.opp a))) (GRing.scale (betR (GRing.opp a) (GRing.opp b) (GRing.opp c)) (GRing.add (GRing.opp c) (GRing.opp (GRing.opp a))))) (andb (Num.Def.ltr (GRing.zero R) (betR (GRing.opp a) (GRing.opp b) (GRing.opp c))) (Num.Def.ltr (betR (GRing.opp a) (GRing.opp b) (GRing.opp c)) (GRing.one R)))))
+++++
apply orb_id2l => _.
-----
Lemma bet_opp a b c : bet a b c = bet (-a) (-b) (-c).
Proof.
rewrite /bet /betE /betS !eqr_opp.
apply orb_id2l => _.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (betR a b c) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (betR a b c)) (Num.Def.ltr (betR a b c) (GRing.one R)))) (andb (eq_op (GRing.add (GRing.opp b) (GRing.opp (GRing.opp a))) (GRing.scale (betR (GRing.opp a) (GRing.opp b) (GRing.opp c)) (GRing.add (GRing.opp c) (GRing.opp (GRing.opp a))))) (andb (Num.Def.ltr (GRing.zero R) (betR (GRing.opp a) (GRing.opp b) (GRing.opp c))) (Num.Def.ltr (betR (GRing.opp a) (GRing.opp b) (GRing.opp c)) (GRing.one R))))
+++++
rewrite -eqr_opp opprB opprK -scalerN opprB ![a + _]addrC.
-----
Lemma bet_opp a b c : bet a b c = bet (-a) (-b) (-c).
Proof.
rewrite /bet /betE /betS !eqr_opp.
apply orb_id2l => _.
rewrite -eqr_opp opprB opprK -scalerN opprB ![a + _]addrC.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (andb (eq_op (GRing.add (GRing.opp b) a) (GRing.scale (betR a b c) (GRing.add (GRing.opp c) a))) (andb (Num.Def.ltr (GRing.zero R) (betR a b c)) (Num.Def.ltr (betR a b c) (GRing.one R)))) (andb (eq_op (GRing.add (GRing.opp b) a) (GRing.scale (betR (GRing.opp a) (GRing.opp b) (GRing.opp c)) (GRing.add (GRing.opp c) a))) (andb (Num.Def.ltr (GRing.zero R) (betR (GRing.opp a) (GRing.opp b) (GRing.opp c))) (Num.Def.ltr (betR (GRing.opp a) (GRing.opp b) (GRing.opp c)) (GRing.one R))))
+++++
suffices: betR a b c = betR (-a) (-b) (-c) by move ->.
-----
Lemma bet_opp a b c : bet a b c = bet (-a) (-b) (-c).
Proof.
rewrite /bet /betE /betS !eqr_opp.
apply orb_id2l => _.
rewrite -eqr_opp opprB opprK -scalerN opprB ![a + _]addrC.
suffices: betR a b c = betR (-a) (-b) (-c) by move ->.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betR a b c) (betR (GRing.opp a) (GRing.opp b) (GRing.opp c))
+++++
by rewrite /betR !opprK ![_ +a]addrC -![a+_]opprB ratioNN.
-----
Lemma bet_opp a b c : bet a b c = bet (-a) (-b) (-c).
Proof.
rewrite /bet /betE /betS !eqr_opp.
apply orb_id2l => _.
rewrite -eqr_opp opprB opprK -scalerN opprB ![a + _]addrC.
suffices: betR a b c = betR (-a) (-b) (-c) by move ->.
by rewrite /betR !opprK ![_ +a]addrC -![a+_]opprB ratioNN.

*****

*****

+++++
Qed.
-----
Lemma bet_trans a b c d : bet a b c = bet (a+d) (b+d) (c+d).
-----
Lemma bet_trans a b c d : bet a b c = bet (a+d) (b+d) (c+d).

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet a b c) (bet (GRing.add a d) (GRing.add b d) (GRing.add c d))
+++++
Proof.
-----
Lemma bet_trans a b c d : bet a b c = bet (a+d) (b+d) (c+d).
Proof.

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet a b c) (bet (GRing.add a d) (GRing.add b d) (GRing.add c d))
+++++
rewrite ![_+d]addrC /bet /betE /betS !add2r_eq ![d+_]addrC !addrDBD.
-----
Lemma bet_trans a b c d : bet a b c = bet (a+d) (b+d) (c+d).
Proof.
rewrite ![_+d]addrC /bet /betE /betS !add2r_eq ![d+_]addrC !addrDBD.

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (betR a b c) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (betR a b c)) (Num.Def.ltr (betR a b c) (GRing.one R))))) (orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (betR (GRing.add a d) (GRing.add b d) (GRing.add c d)) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (betR (GRing.add a d) (GRing.add b d) (GRing.add c d))) (Num.Def.ltr (betR (GRing.add a d) (GRing.add b d) (GRing.add c d)) (GRing.one R)))))
+++++
suffices: betR a b c = betR (a+d) (b+d) (c+d) by move ->.
-----
Lemma bet_trans a b c d : bet a b c = bet (a+d) (b+d) (c+d).
Proof.
rewrite ![_+d]addrC /bet /betE /betS !add2r_eq ![d+_]addrC !addrDBD.
suffices: betR a b c = betR (a+d) (b+d) (c+d) by move ->.

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betR a b c) (betR (GRing.add a d) (GRing.add b d) (GRing.add c d))
+++++
by rewrite /betR !addrDBD.
-----
Lemma bet_trans a b c d : bet a b c = bet (a+d) (b+d) (c+d).
Proof.
rewrite ![_+d]addrC /bet /betE /betS !add2r_eq ![d+_]addrC !addrDBD.
suffices: betR a b c = betR (a+d) (b+d) (c+d) by move ->.
by rewrite /betR !addrDBD.

*****

*****

+++++
Qed.
-----
Lemma bet_xax x a : bet x a x = (x == a).
-----
Lemma bet_xax x a : bet x a x = (x == a).

*****
x,a : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet x a x) (eq_op x a)
+++++
Proof.
-----
Lemma bet_xax x a : bet x a x = (x == a).
Proof.

*****
x,a : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (bet x a x) (eq_op x a)
+++++
rewrite /bet /betS /betR subrr ratiop0 ltr_def eqxx andbF orbF /betE.
-----
Lemma bet_xax x a : bet x a x = (x == a).
Proof.
rewrite /bet /betS /betR subrr ratiop0 ltr_def eqxx andbF orbF /betE.

*****
x,a : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (orb (andb (eq_op x a) (eq_op a x)) (orb (eq_op x a) (eq_op a x))) (eq_op x a)
+++++
by rewrite [a == x]eq_sym Bool.andb_diag !Bool.orb_diag.
-----
Lemma bet_xax x a : bet x a x = (x == a).
Proof.
rewrite /bet /betS /betR subrr ratiop0 ltr_def eqxx andbF orbF /betE.
by rewrite [a == x]eq_sym Bool.andb_diag !Bool.orb_diag.

*****

*****

+++++
Qed.
-----
Lemma bet_ratio a b k1 : 0 < k1 -> k1 < 1 -> bet a b (k1^-1 *: (b - a) + a).
-----
Lemma bet_ratio a b k1 : 0 < k1 -> k1 < 1 -> bet a b (k1^-1 *: (b - a) + a).

*****
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), bet a b (GRing.add (GRing.scale (GRing.inv k1) (GRing.add b (GRing.opp a))) a)
+++++
Proof.
-----
Lemma bet_ratio a b k1 : 0 < k1 -> k1 < 1 -> bet a b (k1^-1 *: (b - a) + a).
Proof.

*****
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), bet a b (GRing.add (GRing.scale (GRing.inv k1) (GRing.add b (GRing.opp a))) a)
+++++
case: (a =P b)=> [->|/eqP ?].
-----
Lemma bet_ratio a b k1 : 0 < k1 -> k1 < 1 -> bet a b (k1^-1 *: (b - a) + a).
Proof.
case: (a =P b)=> [->|/eqP ?].

*****
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), bet b b (GRing.add (GRing.scale (GRing.inv k1) (GRing.add b (GRing.opp b))) b)
+++++
rewrite ?bet_xxa //.
-----
Lemma bet_ratio a b k1 : 0 < k1 -> k1 < 1 -> bet a b (k1^-1 *: (b - a) + a).
Proof.
case: (a =P b)=> [->|/eqP ?].

*****
__view_subject_1_ : is_true (negb (eq_op a b))
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), bet a b (GRing.add (GRing.scale (GRing.inv k1) (GRing.add b (GRing.opp a))) a)
+++++
rewrite ?bet_xxa //.
-----
Lemma bet_ratio a b k1 : 0 < k1 -> k1 < 1 -> bet a b (k1^-1 *: (b - a) + a).
Proof.
case: (a =P b)=> [->|/eqP ?].
rewrite ?bet_xxa //.

*****
__view_subject_1_ : is_true (negb (eq_op a b))
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), bet a b (GRing.add (GRing.scale (GRing.inv k1) (GRing.add b (GRing.opp a))) a)
+++++
move=> L G.
-----
Lemma bet_ratio a b k1 : 0 < k1 -> k1 < 1 -> bet a b (k1^-1 *: (b - a) + a).
Proof.
case: (a =P b)=> [->|/eqP ?].
rewrite ?bet_xxa //.
move=> L G.

*****
G : is_true (Num.Def.ltr k1 (GRing.one R))
L : is_true (Num.Def.ltr (GRing.zero R) k1)
__view_subject_1_ : is_true (negb (eq_op a b))
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet a b (GRing.add (GRing.scale (GRing.inv k1) (GRing.add b (GRing.opp a))) a))
+++++
rewrite /bet /betS /betR -addrA subrr addr0 -ratio_bet' // scalerA.
-----
Lemma bet_ratio a b k1 : 0 < k1 -> k1 < 1 -> bet a b (k1^-1 *: (b - a) + a).
Proof.
case: (a =P b)=> [->|/eqP ?].
rewrite ?bet_xxa //.
move=> L G.
rewrite /bet /betS /betR -addrA subrr addr0 -ratio_bet' // scalerA.

*****
G : is_true (Num.Def.ltr k1 (GRing.one R))
L : is_true (Num.Def.ltr (GRing.zero R) k1)
__view_subject_1_ : is_true (negb (eq_op a b))
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (orb (betE a b (GRing.add (GRing.scale (GRing.inv k1) (GRing.add b (GRing.opp a))) a)) (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (GRing.mul k1 (GRing.inv k1)) (GRing.add b (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) k1) (Num.Def.ltr k1 (GRing.one R)))))
+++++
by rewrite mulfV ?lt0r_neq0 // scale1r L G eqxx !andbb orbT.
-----
Lemma bet_ratio a b k1 : 0 < k1 -> k1 < 1 -> bet a b (k1^-1 *: (b - a) + a).
Proof.
case: (a =P b)=> [->|/eqP ?].

*****

*****

+++++
Qed.
-----
Definition extension a b k := k^-1 *: (b - a) + a.
-----
Definition contraction a b k := k *: (b - a) + a.
-----
Lemma extension_eq a b c k :\n  k != 0 -> (extension a b k == extension a c k) = (b == c).
-----
Lemma extension_eq a b c k : k != 0 -> (extension a b k == extension a c k) = (b == c).

*****
k : Equality.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op k (GRing.zero R)), eq (eq_op (extension a b k) (extension a c k)) (eq_op b c)
+++++
Proof.
-----
Lemma extension_eq a b c k : k != 0 -> (extension a b k == extension a c k) = (b == c).
Proof.

*****
k : Equality.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op k (GRing.zero R)), eq (eq_op (extension a b k) (extension a c k)) (eq_op b c)
+++++
move=>/eqP ?; rewrite /extension -subr_eq -addrA subrr addr0.
-----
Lemma extension_eq a b c k : k != 0 -> (extension a b k == extension a c k) = (b == c).
Proof.
move=>/eqP ?; rewrite /extension -subr_eq -addrA subrr addr0.

*****
__view_subject_1_ : not (eq k (GRing.zero R))
k : Equality.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) (GRing.scale (GRing.inv k) (GRing.add c (GRing.opp a)))) (eq_op b c)
+++++
rewrite -subr_eq0 -scalerBr opprB addrBDB scalemx_eq0 invr_eq0.
-----
Lemma extension_eq a b c k : k != 0 -> (extension a b k == extension a c k) = (b == c).
Proof.
move=>/eqP ?; rewrite /extension -subr_eq -addrA subrr addr0.
rewrite -subr_eq0 -scalerBr opprB addrBDB scalemx_eq0 invr_eq0.

*****
__view_subject_1_ : not (eq k (GRing.zero R))
k : Equality.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (orb (eq_op k (GRing.zero R)) (eq_op (GRing.add b (GRing.opp c)) (GRing.zero (matrix_zmodType R (S O) (S n))))) (eq_op b c)
+++++
by case: (k =P 0); rewrite // subr_eq0 orFb.
-----
Lemma extension_eq a b c k : k != 0 -> (extension a b k == extension a c k) = (b == c).
Proof.
move=>/eqP ?; rewrite /extension -subr_eq -addrA subrr addr0.
rewrite -subr_eq0 -scalerBr opprB addrBDB scalemx_eq0 invr_eq0.
by case: (k =P 0); rewrite // subr_eq0 orFb.

*****

*****

+++++
Qed.
-----
Lemma contraction_eq x y z k :\n  k != 0 -> (contraction x y k == contraction x z k) = (y == z).
-----
Lemma contraction_eq x y z k : k != 0 -> (contraction x y k == contraction x z k) = (y == z).

*****
k : Equality.sort R
x,y,z : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op k (GRing.zero R)), eq (eq_op (contraction x y k) (contraction x z k)) (eq_op y z)
+++++
Proof.
-----
Lemma contraction_eq x y z k : k != 0 -> (contraction x y k == contraction x z k) = (y == z).
Proof.

*****
k : Equality.sort R
x,y,z : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op k (GRing.zero R)), eq (eq_op (contraction x y k) (contraction x z k)) (eq_op y z)
+++++
move=>/eqP ?; rewrite -subr_eq -addrA subrr addr0.
-----
Lemma contraction_eq x y z k : k != 0 -> (contraction x y k == contraction x z k) = (y == z).
Proof.
move=>/eqP ?; rewrite -subr_eq -addrA subrr addr0.

*****
__view_subject_1_ : not (eq k (GRing.zero R))
k : Equality.sort R
x,y,z : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (GRing.scale k (GRing.add y (GRing.opp x))) (GRing.scale k (GRing.add z (GRing.opp x)))) (eq_op y z)
+++++
rewrite -subr_eq0 -scalerBr opprB addrBDB scalemx_eq0.
-----
Lemma contraction_eq x y z k : k != 0 -> (contraction x y k == contraction x z k) = (y == z).
Proof.
move=>/eqP ?; rewrite -subr_eq -addrA subrr addr0.
rewrite -subr_eq0 -scalerBr opprB addrBDB scalemx_eq0.

*****
__view_subject_1_ : not (eq k (GRing.zero R))
k : Equality.sort R
x,y,z : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (orb (eq_op k (GRing.zero R)) (eq_op (GRing.add y (GRing.opp z)) (GRing.zero (matrix_zmodType R (S O) (S n))))) (eq_op y z)
+++++
by case: (k =P 0); rewrite // subr_eq0 orFb.
-----
Lemma contraction_eq x y z k : k != 0 -> (contraction x y k == contraction x z k) = (y == z).
Proof.
move=>/eqP ?; rewrite -subr_eq -addrA subrr addr0.
rewrite -subr_eq0 -scalerBr opprB addrBDB scalemx_eq0.
by case: (k =P 0); rewrite // subr_eq0 orFb.

*****

*****

+++++
Qed.
-----
Lemma extension_contraction x y z k:\n  k != 0 -> extension x y k == z = (contraction x z k == y).
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).

*****
k : Equality.sort R
z : Equality.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x,y : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op k (GRing.zero R)), eq (eq_op (extension x y k) z) (eq_op (contraction x z k) y)
+++++
Proof.
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).
Proof.

*****
k : Equality.sort R
z : Equality.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x,y : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op k (GRing.zero R)), eq (eq_op (extension x y k) z) (eq_op (contraction x z k) y)
+++++
move=> k_neq0.
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).
Proof.
move=> k_neq0.

*****
k_neq0 : is_true (negb (eq_op k (GRing.zero R)))
k : Equality.sort R
z : Equality.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x,y : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (extension x y k) z) (eq_op (contraction x z k) y)
+++++
rewrite /extension /contraction.
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).
Proof.
move=> k_neq0.
rewrite /extension /contraction.

*****
k_neq0 : is_true (negb (eq_op k (GRing.zero R)))
k : Equality.sort R
z : Equality.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x,y : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (GRing.add (GRing.scale (GRing.inv k) (GRing.add y (GRing.opp x))) x) z) (eq_op (GRing.add (GRing.scale k (GRing.add z (GRing.opp x))) x) y)
+++++
suffices: (k*:(k^-1 *: (y - x) + x) == k*:z) = (k^-1 *: (y - x) + x == z).
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).
Proof.
move=> k_neq0.
rewrite /extension /contraction.
suffices: (k*:(k^-1 *: (y - x) + x) == k*:z) = (k^-1 *: (y - x) + x == z).

*****
k_neq0 : is_true (negb (eq_op k (GRing.zero R)))
k : Equality.sort R
z : Equality.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x,y : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq (eq_op (GRing.scale k (GRing.add (GRing.scale (GRing.inv k) (GRing.add y (GRing.opp x))) x)) (GRing.scale k z)) (eq_op (GRing.add (GRing.scale (GRing.inv k) (GRing.add y (GRing.opp x))) x) z), eq (eq_op (GRing.add (GRing.scale (GRing.inv k) (GRing.add y (GRing.opp x))) x) z) (eq_op (GRing.add (GRing.scale k (GRing.add z (GRing.opp x))) x) y)
+++++
move<-.
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).
Proof.
move=> k_neq0.
rewrite /extension /contraction.
suffices: (k*:(k^-1 *: (y - x) + x) == k*:z) = (k^-1 *: (y - x) + x == z).
move<-.

*****
k_neq0 : is_true (negb (eq_op k (GRing.zero R)))
k : Equality.sort R
z : Equality.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x,y : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (GRing.scale k (GRing.add (GRing.scale (GRing.inv k) (GRing.add y (GRing.opp x))) x)) (GRing.scale k z)) (eq_op (GRing.add (GRing.scale k (GRing.add z (GRing.opp x))) x) y)
+++++
rewrite scalerDr scalerA divff // scale1r eq_sym -subr_eq.
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).
Proof.
move=> k_neq0.
rewrite /extension /contraction.
suffices: (k*:(k^-1 *: (y - x) + x) == k*:z) = (k^-1 *: (y - x) + x == z).
move<-.
rewrite scalerDr scalerA divff // scale1r eq_sym -subr_eq.

*****
k_neq0 : is_true (negb (eq_op k (GRing.zero R)))
k : Equality.sort R
z : Equality.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x,y : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (GRing.add (GRing.scale k z) (GRing.opp (GRing.scale k x))) (GRing.add y (GRing.opp x))) (eq_op (GRing.add (GRing.scale k (GRing.add z (GRing.opp x))) x) y)
+++++
by rewrite -subr_eq opprK -scalerBr.
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).
Proof.
move=> k_neq0.
rewrite /extension /contraction.
suffices: (k*:(k^-1 *: (y - x) + x) == k*:z) = (k^-1 *: (y - x) + x == z).

*****
k_neq0 : is_true (negb (eq_op k (GRing.zero R)))
k : Equality.sort R
z : Equality.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x,y : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (GRing.scale k (GRing.add (GRing.scale (GRing.inv k) (GRing.add y (GRing.opp x))) x)) (GRing.scale k z)) (eq_op (GRing.add (GRing.scale (GRing.inv k) (GRing.add y (GRing.opp x))) x) z)
+++++
rewrite -subr_eq0 -[X in _ = X]subr_eq0 -scalerBr scaler_eq0.
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).
Proof.
move=> k_neq0.
rewrite /extension /contraction.
suffices: (k*:(k^-1 *: (y - x) + x) == k*:z) = (k^-1 *: (y - x) + x == z).
rewrite -subr_eq0 -[X in _ = X]subr_eq0 -scalerBr scaler_eq0.

*****
k_neq0 : is_true (negb (eq_op k (GRing.zero R)))
k : Equality.sort R
z : Equality.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x,y : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (orb (eq_op k (GRing.zero R)) (eq_op (GRing.add (GRing.add (GRing.scale (GRing.inv k) (GRing.add y (GRing.opp x))) x) (GRing.opp z)) (GRing.zero (matrix_lmodType R (S O) (S n))))) (eq_op (GRing.add (GRing.add (GRing.scale (GRing.inv k) (GRing.add y (GRing.opp x))) x) (GRing.opp z)) (GRing.zero (GRing.Zmodule.Pack (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))))
+++++
by move/negPf: k_neq0 ->.
-----
Lemma extension_contraction x y z k: k != 0 -> extension x y k == z = (contraction x z k == y).
Proof.
move=> k_neq0.
rewrite /extension /contraction.
suffices: (k*:(k^-1 *: (y - x) + x) == k*:z) = (k^-1 *: (y - x) + x == z).

*****

*****

+++++
Qed.
-----
Lemma extensionP a b c :\n  a != b -> b - a = ratio (b - a) (c - a) *: (c - a) ->\n  extension a b (ratio (b - a) (c - a)) = c.
-----
Lemma extensionP a b c : a != b -> b - a = ratio (b - a) (c - a) *: (c - a) -> extension a b (ratio (b - a) (c - a)) = c.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op a b)) (_ : eq (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))), eq (extension a b (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) c
+++++
Proof.
-----
Lemma extensionP a b c : a != b -> b - a = ratio (b - a) (c - a) *: (c - a) -> extension a b (ratio (b - a) (c - a)) = c.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op a b)) (_ : eq (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))), eq (extension a b (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) c
+++++
move=> neq_ab ratioP; apply /eqP; rewrite /extension eq_sym -subr_eq.
-----
Lemma extensionP a b c : a != b -> b - a = ratio (b - a) (c - a) *: (c - a) -> extension a b (ratio (b - a) (c - a)) = c.
Proof.
move=> neq_ab ratioP; apply /eqP; rewrite /extension eq_sym -subr_eq.

*****
ratioP : eq (GRing.add b (GRing.opp a))\n (GRing.scale\n (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))\n (GRing.add c (GRing.opp a)))
neq_ab : is_true (negb (eq_op a b))
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add c (GRing.opp a)) (GRing.scale (GRing.inv (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (GRing.add b (GRing.opp a))))
+++++
case: (a =P c)=> [->|/eqP ?]; first by rewrite subrr ratiop0 invr0 scale0r.
-----
Lemma extensionP a b c : a != b -> b - a = ratio (b - a) (c - a) *: (c - a) -> extension a b (ratio (b - a) (c - a)) = c.
Proof.
move=> neq_ab ratioP; apply /eqP; rewrite /extension eq_sym -subr_eq.
case: (a =P c)=> [->|/eqP ?]; first by rewrite subrr ratiop0 invr0 scale0r.

*****
__view_subject_1_ : is_true (negb (eq_op a c))
ratioP : eq (GRing.add b (GRing.opp a))\n (GRing.scale\n (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))\n (GRing.add c (GRing.opp a)))
neq_ab : is_true (negb (eq_op a b))
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add c (GRing.opp a)) (GRing.scale (GRing.inv (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (GRing.add b (GRing.opp a))))
+++++
rewrite {2}ratioP scalerA -div1r -mulrC mulrA mulr1 divff ?scale1r ?eqxx //.
-----
Lemma extensionP a b c : a != b -> b - a = ratio (b - a) (c - a) *: (c - a) -> extension a b (ratio (b - a) (c - a)) = c.
Proof.
move=> neq_ab ratioP; apply /eqP; rewrite /extension eq_sym -subr_eq.
case: (a =P c)=> [->|/eqP ?]; first by rewrite subrr ratiop0 invr0 scale0r.
rewrite {2}ratioP scalerA -div1r -mulrC mulrA mulr1 divff ?scale1r ?eqxx //.

*****
__view_subject_1_ : is_true (negb (eq_op a c))
ratioP : eq (GRing.add b (GRing.opp a))\n (GRing.scale\n (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))\n (GRing.add c (GRing.opp a)))
neq_ab : is_true (negb (eq_op a b))
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (negb (eq_op (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.zero R)))
+++++
by move/eqP: ratioP=> ?; rewrite ratio_neq0 // subr_eq add0r eq_sym.
-----
Lemma extensionP a b c : a != b -> b - a = ratio (b - a) (c - a) *: (c - a) -> extension a b (ratio (b - a) (c - a)) = c.
Proof.
move=> neq_ab ratioP; apply /eqP; rewrite /extension eq_sym -subr_eq.
case: (a =P c)=> [->|/eqP ?]; first by rewrite subrr ratiop0 invr0 scale0r.
rewrite {2}ratioP scalerA -div1r -mulrC mulrA mulr1 divff ?scale1r ?eqxx //.
by move/eqP: ratioP=> ?; rewrite ratio_neq0 // subr_eq add0r eq_sym.

*****

*****

+++++
Qed.
-----
Lemma betS_extension x y z:\n  betS x y z -> z = extension x y (betR x y z).
-----
Lemma betS_extension x y z: betS x y z -> z = extension x y (betR x y z).

*****
x,y,z : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : betS x y z, eq z (extension x y (betR x y z))
+++++
Proof.
-----
Lemma betS_extension x y z: betS x y z -> z = extension x y (betR x y z).
Proof.

*****
x,y,z : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : betS x y z, eq z (extension x y (betR x y z))
+++++
rewrite betS_neq12=> /andP[/betSP[bet_eq betR_gt0 betR_lt1] neq_xy].
-----
Lemma betS_extension x y z: betS x y z -> z = extension x y (betR x y z).
Proof.
rewrite betS_neq12=> /andP[/betSP[bet_eq betR_gt0 betR_lt1] neq_xy].

*****
neq_xy : is_true (negb (eq_op x y))
betR_lt1 : is_true (Num.Def.ltr (betR x y z) (GRing.one R))
betR_gt0 : is_true (Num.Def.ltr (GRing.zero R) (betR x y z))
bet_eq : eq (GRing.add y (GRing.opp x))\n (GRing.scale (betR x y z) (GRing.add z (GRing.opp x)))
x,y,z : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq z (extension x y (betR x y z))
+++++
by rewrite /betR extensionP.
-----
Lemma betS_extension x y z: betS x y z -> z = extension x y (betR x y z).
Proof.
rewrite betS_neq12=> /andP[/betSP[bet_eq betR_gt0 betR_lt1] neq_xy].
by rewrite /betR extensionP.

*****

*****

+++++
Qed.
-----
Lemma extension_bet a b k1 :\n  0 < k1 -> k1 < 1 -> bet a b (extension a b k1).
-----
Lemma extension_bet a b k1 : 0 < k1 -> k1 < 1 -> bet a b (extension a b k1).

*****
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), bet a b (extension a b k1)
+++++
Proof.
-----
Lemma extension_bet a b k1 : 0 < k1 -> k1 < 1 -> bet a b (extension a b k1).
Proof.

*****
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), bet a b (extension a b k1)
+++++
by move=> ? ? ; rewrite /extension bet_ratio.
-----
Lemma extension_bet a b k1 : 0 < k1 -> k1 < 1 -> bet a b (extension a b k1).
Proof.
by move=> ? ? ; rewrite /extension bet_ratio.

*****

*****

+++++
Qed.
-----
Lemma contraction_bet a b k1:\n  0 < k1 -> k1 < 1 -> bet a (contraction a b k1) b.
-----
Lemma contraction_bet a b k1: 0 < k1 -> k1 < 1 -> bet a (contraction a b k1) b.

*****
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), bet a (contraction a b k1) b
+++++
Proof.
-----
Lemma contraction_bet a b k1: 0 < k1 -> k1 < 1 -> bet a (contraction a b k1) b.
Proof.

*****
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), bet a (contraction a b k1) b
+++++
move=> ? ?; have: extension a (contraction a b k1) k1 == b.
-----
Lemma contraction_bet a b k1: 0 < k1 -> k1 < 1 -> bet a (contraction a b k1) b.
Proof.
move=> ? ?; have: extension a (contraction a b k1) k1 == b.

*****
_Hyp1_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (extension a (contraction a b k1) k1) b)
+++++
by rewrite extension_contraction ?lt0r_neq0.
-----
Lemma contraction_bet a b k1: 0 < k1 -> k1 < 1 -> bet a (contraction a b k1) b.
Proof.
move=> ? ?; have: extension a (contraction a b k1) k1 == b.
by rewrite extension_contraction ?lt0r_neq0.

*****
_Hyp1_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op (extension a (contraction a b k1) k1) b, bet a (contraction a b k1) b
+++++
by move/eqP=> P1 ; rewrite -{2}P1 extension_bet.
-----
Lemma contraction_bet a b k1: 0 < k1 -> k1 < 1 -> bet a (contraction a b k1) b.
Proof.
move=> ? ?; have: extension a (contraction a b k1) k1 == b.
by rewrite extension_contraction ?lt0r_neq0.
by move/eqP=> P1 ; rewrite -{2}P1 extension_bet.

*****

*****

+++++
Qed.
-----
Lemma contraction_betR a b k1 :\n  b != a -> 0 < k1 -> k1 < 1 -> betR a (contraction a b k1) b = k1.
-----
Lemma contraction_betR a b k1 : b != a -> 0 < k1 -> k1 < 1 -> betR a (contraction a b k1) b = k1.

*****
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op b a)) (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), eq (betR a (contraction a b k1) b) k1
+++++
Proof.
-----
Lemma contraction_betR a b k1 : b != a -> 0 < k1 -> k1 < 1 -> betR a (contraction a b k1) b = k1.
Proof.

*****
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op b a)) (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)), eq (betR a (contraction a b k1) b) k1
+++++
move=> ? ? ?; rewrite /betR /contraction -addrA subrr addr0.
-----
Lemma contraction_betR a b k1 : b != a -> 0 < k1 -> k1 < 1 -> betR a (contraction a b k1) b = k1.
Proof.
move=> ? ? ?; rewrite /betR /contraction -addrA subrr addr0.

*****
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k1)
_Hyp_ : is_true (negb (eq_op b a))
k1 : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio (GRing.scale k1 (GRing.add b (GRing.opp a))) (GRing.add b (GRing.opp a))) k1
+++++
by apply ratio_eq; rewrite ?subr_eq0 ?eqxx.
-----
Lemma contraction_betR a b k1 : b != a -> 0 < k1 -> k1 < 1 -> betR a (contraction a b k1) b = k1.
Proof.
move=> ? ? ?; rewrite /betR /contraction -addrA subrr addr0.
by apply ratio_eq; rewrite ?subr_eq0 ?eqxx.

*****

*****

+++++
Qed.
-----
Lemma contraction_betS a b k :\n  b != a -> 0 < k -> k < 1 -> betS a (contraction a b k) b.
-----
Lemma contraction_betS a b k : b != a -> 0 < k -> k < 1 -> betS a (contraction a b k) b.

*****
k : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op b a)) (_ : Num.Def.ltr (GRing.zero R) k) (_ : Num.Def.ltr k (GRing.one R)), betS a (contraction a b k) b
+++++
Proof.
-----
Lemma contraction_betS a b k : b != a -> 0 < k -> k < 1 -> betS a (contraction a b k) b.
Proof.

*****
k : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op b a)) (_ : Num.Def.ltr (GRing.zero R) k) (_ : Num.Def.ltr k (GRing.one R)), betS a (contraction a b k) b
+++++
move=> ? k_gt0 k_lt1.
-----
Lemma contraction_betS a b k : b != a -> 0 < k -> k < 1 -> betS a (contraction a b k) b.
Proof.
move=> ? k_gt0 k_lt1.

*****
k_lt1 : is_true (Num.Def.ltr k (GRing.one R))
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
_Hyp_ : is_true (negb (eq_op b a))
k : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (betS a (contraction a b k) b)
+++++
rewrite /betS contraction_betR// /contraction -!addrA.
-----
Lemma contraction_betS a b k : b != a -> 0 < k -> k < 1 -> betS a (contraction a b k) b.
Proof.
move=> ? k_gt0 k_lt1.
rewrite /betS contraction_betR// /contraction -!addrA.

*****
k_lt1 : is_true (Num.Def.ltr k (GRing.one R))
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
_Hyp_ : is_true (negb (eq_op b a))
k : Num.NumDomain.sort R
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (andb (eq_op (GRing.add (GRing.scale k (GRing.add b (GRing.opp a))) (GRing.add a (GRing.opp a))) (GRing.scale k (GRing.add b (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) k) (Num.Def.ltr k (GRing.one R))))
+++++
by rewrite subrr addr0 eqxx k_gt0 k_lt1.
-----
Lemma contraction_betS a b k : b != a -> 0 < k -> k < 1 -> betS a (contraction a b k) b.
Proof.
move=> ? k_gt0 k_lt1.
rewrite /betS contraction_betR// /contraction -!addrA.
by rewrite subrr addr0 eqxx k_gt0 k_lt1.

*****

*****

+++++
Qed.
-----
Lemma extension_col a b c k :\n  c == extension a b k -> bet a b c \/ bet b c a \/ bet c a b.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.

*****
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op c (extension a b k), or (bet a b c) (or (bet b c a) (bet c a b))
+++++
Proof.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.

*****
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op c (extension a b k), or (bet a b c) (or (bet b c a) (bet c a b))
+++++
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].

*****
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op c (GRing.add (GRing.scale (GRing.inv (GRing.zero R)) (GRing.add b (GRing.opp a))) a), or (bet a b c) (or (bet b c a) (bet c a b))
+++++
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.

*****
k_neq0 : is_true (negb (eq_op k (GRing.zero R)))
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op c (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a), or (bet a b c) (or (bet b c a) (bet c a b))
+++++
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].

*****
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
or (bet a b c) (or (bet b c a) (bet c a b))
+++++
suffices: (bet c a b) by auto.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.

*****
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet c a b)
+++++
set k' := k / (k-1).
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).

*****
k' : GRing.Ring.sort R
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet c a b)
+++++
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].

*****
k' : GRing.Ring.sort R
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op c (extension b a k'))
+++++
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.

*****
k' : GRing.Ring.sort R
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a) (GRing.add (GRing.scale (GRing.add (GRing.one R) (GRing.opp (GRing.mul (GRing.one R) (GRing.inv k)))) (GRing.add a (GRing.opp b))) b))
+++++
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.

*****
k' : GRing.Ring.sort R
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.add (GRing.add (GRing.opp b) b) (GRing.opp (GRing.scale (GRing.mul (GRing.one R) (GRing.inv k)) (GRing.add a (GRing.opp b))))) a) (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a))
+++++
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.

*****
k' : GRing.Ring.sort R
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet b a (extension b a k'))
+++++
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.

*****
k_lt1 : is_true (Num.Def.ltr k (GRing.one R))
k' : GRing.Ring.sort R
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet b a (extension b a k'))
+++++
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.

*****
k_lt1 : is_true (Num.Def.ltr k (GRing.one R))
k' : GRing.Ring.sort R
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) (GRing.add (GRing.one R) (GRing.opp (GRing.mul k (GRing.inv (GRing.add k (GRing.opp (GRing.one R))))))))
+++++
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.

*****
k_lt1 : is_true (Num.Def.ltr k (GRing.one R))
k' : GRing.Ring.sort R
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.one R) (GRing.mul (GRing.add k (GRing.opp (GRing.one R))) (GRing.inv (GRing.add k (GRing.opp (GRing.one R))))), Num.Def.ltr (GRing.zero R) (GRing.add (GRing.one R) (GRing.opp (GRing.mul k (GRing.inv (GRing.add k (GRing.opp (GRing.one R)))))))
+++++
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.

*****
k_lt1 : is_true (Num.Def.ltr k (GRing.one R))
k' : GRing.Ring.sort R
k_lt0 : is_true (Num.Def.ltr k (GRing.zero R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.one R) (GRing.opp (GRing.inv (GRing.add k (GRing.opp (GRing.one R)))))))
+++++
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.

*****
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
or (bet a b c) (or (bet b c a) (bet c a b))
+++++
move: c_def; case: (k =P 1)=> [->|/eqP k_neq1 c_def].
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.
move: c_def; case: (k =P 1)=> [->|/eqP k_neq1 c_def].

*****
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq c (GRing.add (GRing.scale (GRing.inv (GRing.one R)) (GRing.add b (GRing.opp a))) a), or (bet a b c) (or (bet b c a) (bet c a b))
+++++
by rewrite invr1 scale1r addrAC addrK=> ->; rewrite bet_axx; auto.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.
move: c_def; case: (k =P 1)=> [->|/eqP k_neq1 c_def].
by rewrite invr1 scale1r addrAC addrK=> ->; rewrite bet_axx; auto.

*****
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k_neq1 : is_true (negb (eq_op k (GRing.one R)))
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
or (bet a b c) (or (bet b c a) (bet c a b))
+++++
apply ltr_total in k_neq1; move: k_neq1=> /orP[k_lt1|k_gt1].
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.
move: c_def; case: (k =P 1)=> [->|/eqP k_neq1 c_def].
by rewrite invr1 scale1r addrAC addrK=> ->; rewrite bet_axx; auto.
apply ltr_total in k_neq1; move: k_neq1=> /orP[k_lt1|k_gt1].

*****
k_lt1 : is_true (Num.Def.ltr k (GRing.one R))
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
or (bet a b c) (or (bet b c a) (bet c a b))
+++++
by rewrite c_def extension_bet; auto.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.
move: c_def; case: (k =P 1)=> [->|/eqP k_neq1 c_def].
by rewrite invr1 scale1r addrAC addrK=> ->; rewrite bet_axx; auto.
apply ltr_total in k_neq1; move: k_neq1=> /orP[k_lt1|k_gt1].
by rewrite c_def extension_bet; auto.

*****
k_gt1 : is_true (Num.Def.ltr (GRing.one R) k)
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
or (bet a b c) (or (bet b c a) (bet c a b))
+++++
suffices: (bet b c a) by auto.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.
move: c_def; case: (k =P 1)=> [->|/eqP k_neq1 c_def].
by rewrite invr1 scale1r addrAC addrK=> ->; rewrite bet_axx; auto.
apply ltr_total in k_neq1; move: k_neq1=> /orP[k_lt1|k_gt1].
by rewrite c_def extension_bet; auto.
suffices: (bet b c a) by auto.

*****
k_gt1 : is_true (Num.Def.ltr (GRing.one R) k)
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet b c a)
+++++
set k' := k^-1; have: (c == contraction a b k').
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.
move: c_def; case: (k =P 1)=> [->|/eqP k_neq1 c_def].
by rewrite invr1 scale1r addrAC addrK=> ->; rewrite bet_axx; auto.
apply ltr_total in k_neq1; move: k_neq1=> /orP[k_lt1|k_gt1].
by rewrite c_def extension_bet; auto.
suffices: (bet b c a) by auto.
set k' := k^-1; have: (c == contraction a b k').

*****
k' : GRing.UnitRing.sort R
k_gt1 : is_true (Num.Def.ltr (GRing.one R) k)
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op c (contraction a b k'))
+++++
by rewrite c_def /extension /contraction /k' eqxx.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.
move: c_def; case: (k =P 1)=> [->|/eqP k_neq1 c_def].
by rewrite invr1 scale1r addrAC addrK=> ->; rewrite bet_axx; auto.
apply ltr_total in k_neq1; move: k_neq1=> /orP[k_lt1|k_gt1].
by rewrite c_def extension_bet; auto.
suffices: (bet b c a) by auto.
set k' := k^-1; have: (c == contraction a b k').
by rewrite c_def /extension /contraction /k' eqxx.

*****
k' : GRing.UnitRing.sort R
k_gt1 : is_true (Num.Def.ltr (GRing.one R) k)
c_def : eq c\n (GRing.add (GRing.scale (GRing.inv k) (GRing.add b (GRing.opp a))) a)
k_gt0 : is_true (Num.Def.ltr (GRing.zero R) k)
k : GRing.UnitRing.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op c (contraction a b k'), bet b c a
+++++
by move=> /eqP ->; rewrite bet_sym contraction_bet ?/k' ?invr_gt0 ?invf_lt1.
-----
Lemma extension_col a b c k : c == extension a b k -> bet a b c \\/ bet b c a \\/ bet c a b.
Proof.
rewrite /extension; case: (k =P 0)=> [->|/eqP k_neq0].
by rewrite invr0 scale0r add0r=> /eqP ->; rewrite bet_axx /=; auto.
apply ltr_total in k_neq0=> /eqP c_def; move: k_neq0=> /orP[k_lt0|k_gt0].
suffices: (bet c a b) by auto.
set k' := k / (k-1).
have: (c == extension b a k')=> [|/eqP ->]; [|rewrite bet_sym].
rewrite c_def /extension /k' invf_div mulrBl divff ?ltr0_neq0 //.
rewrite eq_sym scalerBl scale1r addrAC -!addrA addrC !addrA.
by rewrite [-b+b]addrC subrr add0r -scalerN opprB mul1r eqxx.
have: (k < 1)=> [|k_lt1]; first by apply ltr_trans with 0; rewrite ?ltr01 //.
rewrite extension_bet ?/k' // ?nmulr_rgt0 ?invr_lt0 ?subr_lt0 // -1?subr_gt0.
have: (1 == (k-1)/(k-1)) by rewrite divff ?ltr0_neq0 ?subr_lt0 //.
move=> /eqP {1}->; rewrite -mulrBl addrAC subrr add0r mulNr -mulrN.
by rewrite mulr_gt0 ?ltr01 // oppr_gt0 invr_lt0 subr_lt0.
move: c_def; case: (k =P 1)=> [->|/eqP k_neq1 c_def].
by rewrite invr1 scale1r addrAC addrK=> ->; rewrite bet_axx; auto.
apply ltr_total in k_neq1; move: k_neq1=> /orP[k_lt1|k_gt1].
by rewrite c_def extension_bet; auto.
suffices: (bet b c a) by auto.
set k' := k^-1; have: (c == contraction a b k').
by rewrite c_def /extension /contraction /k' eqxx.
by move=> /eqP ->; rewrite bet_sym contraction_bet ?/k' ?invr_gt0 ?invf_lt1.

*****

*****

+++++
Qed.
-----
Lemma ratio_bet a b c k1 k2 k3 :\n  0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 ->\n  b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.

*****
k1,k2,k3 : Num.NumDomain.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : Num.Def.ltr (GRing.zero R) k3) (_ : Num.Def.ltr k3 (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2)))) (_ : eq_op (GRing.add b (GRing.opp a)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.add c (GRing.opp a)))), bet a b c
+++++
Proof.
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
Proof.

*****
k1,k2,k3 : Num.NumDomain.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr (GRing.zero R) k2) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : Num.Def.ltr (GRing.zero R) k3) (_ : Num.Def.ltr k3 (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2)))) (_ : eq_op (GRing.add b (GRing.opp a)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.add c (GRing.opp a)))), bet a b c
+++++
move=> ? ? ? ? ?.
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
Proof.
move=> ? ? ? ? ?.

*****
_Hyp4_ : is_true\n (Num.Def.ltr k3\n (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.NumDomain.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add b (GRing.opp a)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.add c (GRing.opp a))), bet a b c
+++++
rewrite /bet /betE /betS/ betR.
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
Proof.
move=> ? ? ? ? ?.
rewrite /bet /betE /betS/ betR.

*****
_Hyp4_ : is_true\n (Num.Def.ltr k3\n (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.NumDomain.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add b (GRing.opp a)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.add c (GRing.opp a))), orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.one R))))
+++++
case: (a =P c)=> [->|].
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
Proof.
move=> ? ? ? ? ?.
rewrite /bet /betE /betS/ betR.
case: (a =P c)=> [->|].

*****
_Hyp4_ : is_true\n (Num.Def.ltr k3\n (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.NumDomain.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add b (GRing.opp c)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.add c (GRing.opp c))), orb (orb (andb (eq_op c b) (eq_op b c)) (orb (eq_op c b) (eq_op b c))) (andb (eq_op (GRing.add b (GRing.opp c)) (GRing.scale (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.add c (GRing.opp c)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp c)) (GRing.add c (GRing.opp c))) (GRing.one R))))
+++++
by rewrite subrr scaler0 subr_eq0=> ->; rewrite !orbT orTb.
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
Proof.
move=> ? ? ? ? ?.
rewrite /bet /betE /betS/ betR.
case: (a =P c)=> [->|].
by rewrite subrr scaler0 subr_eq0=> ->; rewrite !orbT orTb.

*****
_Hyp4_ : is_true\n (Num.Def.ltr k3\n (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.NumDomain.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : not (eq a c)) (_ : eq_op (GRing.add b (GRing.opp a)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.add c (GRing.opp a)))), orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.one R))))
+++++
move/eqP=> ? k3_eq.
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
Proof.
move=> ? ? ? ? ?.
rewrite /bet /betE /betS/ betR.
case: (a =P c)=> [->|].
by rewrite subrr scaler0 subr_eq0=> ->; rewrite !orbT orTb.
move/eqP=> ? k3_eq.

*****
k3_eq : is_true\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.scale\n (GRing.inv\n (GRing.mul\n (GRing.add (GRing.add k1 k2)\n (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)))\n (GRing.add c (GRing.opp a))))
__view_subject_1_ : is_true (negb (eq_op a c))
_Hyp4_ : is_true\n (Num.Def.ltr k3\n (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.NumDomain.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a)))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.one R)))))
+++++
suff: (ratio (b-a) (c-a) = ((k1+k2-k1*k2)/k3)^-1)=> [->|].
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
Proof.
move=> ? ? ? ? ?.
rewrite /bet /betE /betS/ betR.
case: (a =P c)=> [->|].
by rewrite subrr scaler0 subr_eq0=> ->; rewrite !orbT orTb.
move/eqP=> ? k3_eq.
suff: (ratio (b-a) (c-a) = ((k1+k2-k1*k2)/k3)^-1)=> [->|].

*****
k3_eq : is_true\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.scale\n (GRing.inv\n (GRing.mul\n (GRing.add (GRing.add k1 k2)\n (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)))\n (GRing.add c (GRing.opp a))))
__view_subject_1_ : is_true (negb (eq_op a c))
_Hyp4_ : is_true\n (Num.Def.ltr k3\n (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.NumDomain.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.add c (GRing.opp a)))) (andb (Num.Def.ltr (GRing.zero R) (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)))) (Num.Def.ltr (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3))) (GRing.one R)))))
+++++
by rewrite bet_gt0' ?bet_lt1 // k3_eq orbT.
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
Proof.
move=> ? ? ? ? ?.
rewrite /bet /betE /betS/ betR.
case: (a =P c)=> [->|].
by rewrite subrr scaler0 subr_eq0=> ->; rewrite !orbT orTb.
move/eqP=> ? k3_eq.
suff: (ratio (b-a) (c-a) = ((k1+k2-k1*k2)/k3)^-1)=> [->|].
by rewrite bet_gt0' ?bet_lt1 // k3_eq orbT.

*****
k3_eq : is_true\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.scale\n (GRing.inv\n (GRing.mul\n (GRing.add (GRing.add k1 k2)\n (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)))\n (GRing.add c (GRing.opp a))))
__view_subject_1_ : is_true (negb (eq_op a c))
_Hyp4_ : is_true\n (Num.Def.ltr k3\n (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
_Hyp3_ : is_true (Num.Def.ltr (GRing.zero R) k3)
_Hyp2_ : is_true (Num.Def.ltr k1 (GRing.one R))
_Hyp1_ : is_true (Num.Def.ltr (GRing.zero R) k2)
_Hyp_ : is_true (Num.Def.ltr (GRing.zero R) k1)
k1,k2,k3 : Num.NumDomain.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (ratio (GRing.add b (GRing.opp a)) (GRing.add c (GRing.opp a))) (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k3)))
+++++
by apply ratio_eq => //; rewrite subr_eq0 eq_sym.
-----
Lemma ratio_bet a b c k1 k2 k3 : 0 < k1 -> 0 < k2 -> k1 < 1 -> 0 < k3 -> k3 < k1+k2-k1*k2 -> b - a == ((k1+k2-k1*k2)/k3)^-1 *: (c - a) -> bet a b c.
Proof.
move=> ? ? ? ? ?.
rewrite /bet /betE /betS/ betR.
case: (a =P c)=> [->|].
by rewrite subrr scaler0 subr_eq0=> ->; rewrite !orbT orTb.
move/eqP=> ? k3_eq.
suff: (ratio (b-a) (c-a) = ((k1+k2-k1*k2)/k3)^-1)=> [->|].
by rewrite bet_gt0' ?bet_lt1 // k3_eq orbT.
by apply ratio_eq => //; rewrite subr_eq0 eq_sym.

*****

*****

+++++
Qed.
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) :\n  betS a b d -> betS b c d -> bet a b c.
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.

*****
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : betS a b d) (_ : betS b c d), bet a b c
+++++
Proof.
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.

*****
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : betS a b d) (_ : betS b c d), bet a b c
+++++
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (bet a b c)
+++++
apply ratio_bet with k1 k2 k1.
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) k1)
+++++
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) k2)
+++++
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr k1 (GRing.one R))
+++++
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) k1)
+++++
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr k1 (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))
+++++
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k1))) (GRing.add c (GRing.opp a))))
+++++
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv k1))) (GRing.add c (GRing.opp a))))
+++++
rewrite eq_inv_scale ?bet_neq0 // -addrA addrC -addf_divrr ?divff ?lt0r_neq0 //.
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].
rewrite eq_inv_scale ?bet_neq0 // -addrA addrC -addf_divrr ?divff ?lt0r_neq0 //.

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.scale (GRing.add (GRing.mul (GRing.add k2 (GRing.opp (GRing.mul k1 k2))) (GRing.inv k1)) (GRing.one R)) (GRing.add b (GRing.opp a))) (GRing.add c (GRing.opp a)))
+++++
rewrite scalerDl scale1r eq_sym -subr_eq opprB eq_div_scale ?lt0r_neq0 //.
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].
rewrite eq_inv_scale ?bet_neq0 // -addrA addrC -addf_divrr ?divff ?lt0r_neq0 //.
rewrite scalerDl scale1r eq_sym -subr_eq opprB eq_div_scale ?lt0r_neq0 //.

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.scale k1 (GRing.add (GRing.add c (GRing.opp a)) (GRing.add a (GRing.opp b)))) (GRing.scale (GRing.add k2 (GRing.opp (GRing.mul k1 k2))) (GRing.add b (GRing.opp a))))
+++++
rewrite addrBDB k2P scalerA scalerBl eq_sym subr_eq.
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.
try solve [rewrite /k1 /k2 /betR // -addrA mulrC ltr_spaddr ?lerr ?bet_gt0 //].
rewrite eq_inv_scale ?bet_neq0 // -addrA addrC -addf_divrr ?divff ?lt0r_neq0 //.
rewrite scalerDl scale1r eq_sym -subr_eq opprB eq_div_scale ?lt0r_neq0 //.
rewrite addrBDB k2P scalerA scalerBl eq_sym subr_eq.

*****
_p3_ : is_true (Num.Def.ltr (betR b c d) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR b c d))
k2P : eq (GRing.add c (GRing.opp b))\n (GRing.scale (betR b c d) (GRing.add d (GRing.opp b)))
_p1_ : is_true (Num.Def.ltr (betR a b d) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b d))
k1P : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b d) (GRing.add d (GRing.opp a)))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.scale k2 (GRing.add b (GRing.opp a))) (GRing.add (GRing.scale (GRing.mul k1 (betR b c d)) (GRing.add d (GRing.opp b))) (GRing.scale (GRing.mul k1 k2) (GRing.add b (GRing.opp a)))))
+++++
by rewrite -scalerDr addrBDB k1P scalerA mulrC.
-----
Lemma betS_inner_transitivity a b c d (k1 := betR a b d) (k2 := betR b c d) : betS a b d -> betS b c d -> bet a b c.
Proof.
move=> /betSP[k1P ? ?] /betSP[k2P ? ?].
apply ratio_bet with k1 k2 k1.

*****

*****

+++++
Qed.
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a b d) (_ : bet b c d), bet a b c
+++++
Proof.
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.
Proof.

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a b d) (_ : bet b c d), bet a b c
+++++
rewrite {2}/bet /betE.
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.
Proof.
rewrite {2}/bet /betE.

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a b d) (_ : orb (orb (andb (eq_op b c) (eq_op c d)) (orb (eq_op b c) (eq_op c d))) (betS b c d)), bet a b c
+++++
case: (c =P d)=> [-> //|?].
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.
Proof.
rewrite {2}/bet /betE.
case: (c =P d)=> [-> //|?].

*****
_n_ : not (eq c d)
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a b d) (_ : orb (orb (andb (eq_op b c) false) (orb (eq_op b c) false)) (betS b c d)), bet a b c
+++++
rewrite {1}/bet bet_betE.
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.
Proof.
rewrite {2}/bet /betE.
case: (c =P d)=> [-> //|?].
rewrite {1}/bet bet_betE.

*****
_n_ : not (eq c d)
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : orb (betE a b d) (betS a b d)) (_ : orb (orb (andb (eq_op b c) false) (orb (eq_op b c) false)) (betS b c d)), orb (betE a b c) (bet a b c)
+++++
rewrite /betE; case: (b =P c)=> [->|?]; rewrite ?orbT ?orTb // andbF !orFb.
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.
Proof.
rewrite {2}/bet /betE.
case: (c =P d)=> [-> //|?].
rewrite {1}/bet bet_betE.
rewrite /betE; case: (b =P c)=> [->|?]; rewrite ?orbT ?orTb // andbF !orFb.

*****
_n1_ : not (eq b c)
_n_ : not (eq c d)
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : orb (orb (andb (eq_op a b) (eq_op b d)) (orb (eq_op a b) (eq_op b d))) (betS a b d)) (_ : betS b c d), orb (orb (andb (eq_op a b) false) (orb (eq_op a b) false)) (bet a b c)
+++++
case: (a =P b)=> [->|?]; rewrite ?orTb ?orbT // andFb !orFb.
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.
Proof.
rewrite {2}/bet /betE.
case: (c =P d)=> [-> //|?].
rewrite {1}/bet bet_betE.
rewrite /betE; case: (b =P c)=> [->|?]; rewrite ?orbT ?orTb // andbF !orFb.
case: (a =P b)=> [->|?]; rewrite ?orTb ?orbT // andFb !orFb.

*****
_n2_ : not (eq a b)
_n1_ : not (eq b c)
_n_ : not (eq c d)
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : orb (eq_op b d) (betS a b d)) (_ : betS b c d), bet a b c
+++++
case: (b =P d)=> [->|?]; rewrite ?subrr ?betS_id // orFb.
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.
Proof.
rewrite {2}/bet /betE.
case: (c =P d)=> [-> //|?].
rewrite {1}/bet bet_betE.
rewrite /betE; case: (b =P c)=> [->|?]; rewrite ?orbT ?orTb // andbF !orFb.
case: (a =P b)=> [->|?]; rewrite ?orTb ?orbT // andFb !orFb.
case: (b =P d)=> [->|?]; rewrite ?subrr ?betS_id // orFb.

*****
_n3_ : not (eq b d)
_n2_ : not (eq a b)
_n1_ : not (eq b c)
_n_ : not (eq c d)
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : betS a b d) (_ : betS b c d), bet a b c
+++++
by move=> bet1 bet2; apply betS_inner_transitivity with d.
-----
Lemma bet_inner_transitivity a b c d: bet a b d -> bet b c d -> bet a b c.
Proof.
rewrite {2}/bet /betE.
case: (c =P d)=> [-> //|?].
rewrite {1}/bet bet_betE.
rewrite /betE; case: (b =P c)=> [->|?]; rewrite ?orbT ?orTb // andbF !orFb.
case: (a =P b)=> [->|?]; rewrite ?orTb ?orbT // andFb !orFb.
case: (b =P d)=> [->|?]; rewrite ?subrr ?betS_id // orFb.
by move=> bet1 bet2; apply betS_inner_transitivity with d.

*****

*****

+++++
Qed.
-----
Lemma bet_betS a b c : a <> b -> b <> c -> bet a b c = betS a b c.
-----
Lemma bet_betS a b c : a <> b -> b <> c -> bet a b c = betS a b c.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : not (eq a b)) (_ : not (eq b c)), eq (bet a b c) (betS a b c)
+++++
Proof.
-----
Lemma bet_betS a b c : a <> b -> b <> c -> bet a b c = betS a b c.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : not (eq a b)) (_ : not (eq b c)), eq (bet a b c) (betS a b c)
+++++
rewrite /bet /betE.
-----
Lemma bet_betS a b c : a <> b -> b <> c -> bet a b c = betS a b c.
Proof.
rewrite /bet /betE.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : not (eq a b)) (_ : not (eq b c)), eq (orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (betS a b c)) (betS a b c)
+++++
case: (a =P b)=>[-> /eqP|? ?]; first by rewrite eqxx.
-----
Lemma bet_betS a b c : a <> b -> b <> c -> bet a b c = betS a b c.
Proof.
rewrite /bet /betE.
case: (a =P b)=>[-> /eqP|? ?]; first by rewrite eqxx.

*****
_n_,_Hyp_ : not (eq a b)
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : not (eq b c), eq (orb (orb (andb false (eq_op b c)) (orb false (eq_op b c))) (betS a b c)) (betS a b c)
+++++
case: (b =P c)=> [-> /eqP|? ?]; by rewrite ?eqxx andFb !orFb.
-----
Lemma bet_betS a b c : a <> b -> b <> c -> bet a b c = betS a b c.
Proof.
rewrite /bet /betE.
case: (a =P b)=>[-> /eqP|? ?]; first by rewrite eqxx.
case: (b =P c)=> [-> /eqP|? ?]; by rewrite ?eqxx andFb !orFb.

*****

*****

+++++
Qed.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) :\n  a <> p -> p <> c -> b <> q -> q <> c ->\n  bet a p c -> bet b q c ->\n  exists x, bet p x b /\ bet q x a.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.

*****
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : not (eq a p)) (_ : not (eq p c)) (_ : not (eq b q)) (_ : not (eq q c)) (_ : bet a p c) (_ : bet b q c), ex (fun x : Vector R n => and (bet p x b) (bet q x a))
+++++
Proof.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.

*****
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : not (eq a p)) (_ : not (eq p c)) (_ : not (eq b q)) (_ : not (eq q c)) (_ : bet a p c) (_ : bet b q c), ex (fun x : Vector R n => and (bet p x b) (bet q x a))
+++++
move=> ? ? ? ?.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.

*****
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a p c) (_ : bet b q c), ex (fun x : Vector R n => and (bet p x b) (bet q x a))
+++++
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
ex (fun x : Vector R n => and (bet p x b) (bet q x a))
+++++
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
and (bet p (GRing.add (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv (GRing.add k1 (GRing.opp (GRing.mul k1 k2)))))) (GRing.add b (GRing.opp p))) p) b) (bet q (GRing.add (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv (GRing.add k1 (GRing.opp (GRing.mul k1 k2)))))) (GRing.add b (GRing.opp p))) p) a)
+++++
apply/andP.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (andb (bet p (GRing.add (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv (GRing.add k1 (GRing.opp (GRing.mul k1 k2)))))) (GRing.add b (GRing.opp p))) p) b) (bet q (GRing.add (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv (GRing.add k1 (GRing.opp (GRing.mul k1 k2)))))) (GRing.add b (GRing.opp p))) p) a))
+++++
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (andb true true)
+++++
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (betR b q c) (GRing.one R))
+++++
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.add (betR b q c) (GRing.opp (GRing.mul (betR b q c) (betR a p c)))) (GRing.add (GRing.add (betR b q c) (betR a p c)) (GRing.opp (GRing.mul (betR b q c) (betR a p c)))))
+++++
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.add (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv (GRing.add k1 (GRing.opp (GRing.mul k1 k2)))))) (GRing.add b (GRing.opp p))) p) (GRing.opp q)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add (betR b q c) (betR a p c)) (GRing.opp (GRing.mul (betR b q c) (betR a p c)))) (GRing.inv (GRing.add (betR b q c) (GRing.opp (GRing.mul (betR b q c) (betR a p c))))))) (GRing.add a (GRing.opp q))))
+++++
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.scale (GRing.mul (GRing.add k1 (GRing.opp (GRing.mul k1 k2))) (GRing.inv (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))))) (GRing.add b (GRing.opp p))) (GRing.add p (GRing.opp q))) (GRing.scale (GRing.mul (GRing.add (betR b q c) (GRing.opp (GRing.mul (betR a p c) k2))) (GRing.inv (GRing.add (GRing.add (betR b q c) (betR a p c)) (GRing.opp (GRing.mul (betR a p c) k2))))) (GRing.add a (GRing.opp q))))
+++++
rewrite [k2+k1]addrC eq_div_scale ?bet_neq0' // scalerDr scalerA mulrCA mulfV.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
rewrite [k2+k1]addrC eq_div_scale ?bet_neq0' // scalerDr scalerA mulrCA mulfV.

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.scale (GRing.mul (GRing.add k1 (GRing.opp (GRing.mul k1 k2))) (GRing.one R)) (GRing.add b (GRing.opp p))) (GRing.scale (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul (betR a p c) k2))) (GRing.add p (GRing.opp q)))) (GRing.scale (GRing.add (betR b q c) (GRing.opp (GRing.mul (betR a p c) k2))) (GRing.add a (GRing.opp q))))
+++++
rewrite ?bet_neq0' // mulr1 -subr_eq0 -[a-q]opprB scalerN !scalerBl !opprB.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
rewrite [k2+k1]addrC eq_div_scale ?bet_neq0' // scalerDr scalerA mulrCA mulfV.
rewrite ?bet_neq0' // mulr1 -subr_eq0 -[a-q]opprB scalerN !scalerBl !opprB.

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.add (GRing.add (GRing.scale k1 (GRing.add b (GRing.opp p))) (GRing.opp (GRing.scale (GRing.mul k1 k2) (GRing.add b (GRing.opp p))))) (GRing.add (GRing.scale (GRing.add k1 k2) (GRing.add p (GRing.opp q))) (GRing.opp (GRing.scale (GRing.mul (betR a p c) k2) (GRing.add p (GRing.opp q)))))) (GRing.add (GRing.scale (betR b q c) (GRing.add q (GRing.opp a))) (GRing.opp (GRing.scale (GRing.mul (betR a p c) k2) (GRing.add q (GRing.opp a)))))) (GRing.zero (GRing.Zmodule.Pack (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))))
+++++
rewrite addrACA -[X in _+X]addrA -!scaleNr -scalerDr addrBDB -addrCA addrAC.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
rewrite [k2+k1]addrC eq_div_scale ?bet_neq0' // scalerDr scalerA mulrCA mulfV.
rewrite ?bet_neq0' // mulr1 -subr_eq0 -[a-q]opprB scalerN !scalerBl !opprB.
rewrite addrACA -[X in _+X]addrA -!scaleNr -scalerDr addrBDB -addrCA addrAC.

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.scale (GRing.add k1 k2) (GRing.add p (GRing.opp q))) (GRing.add (GRing.add (GRing.add (GRing.scale k1 (GRing.add b (GRing.opp p))) (GRing.scale (GRing.opp (GRing.mul k1 k2)) (GRing.add b (GRing.opp p)))) (GRing.scale (GRing.opp (GRing.mul (betR a p c) k2)) (GRing.add p (GRing.opp a)))) (GRing.scale (betR b q c) (GRing.add q (GRing.opp a))))) (GRing.zero (GRing.Zmodule.Pack (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))))
+++++
rewrite -[X in _+(X+_)]addrA -scalerDr addrBDB -addrCA scalerDl -!addrA.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
rewrite [k2+k1]addrC eq_div_scale ?bet_neq0' // scalerDr scalerA mulrCA mulfV.
rewrite ?bet_neq0' // mulr1 -subr_eq0 -[a-q]opprB scalerN !scalerBl !opprB.
rewrite addrACA -[X in _+X]addrA -!scaleNr -scalerDr addrBDB -addrCA addrAC.
rewrite -[X in _+(X+_)]addrA -scalerDr addrBDB -addrCA scalerDl -!addrA.

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.scale k1 (GRing.add b (GRing.opp p))) (GRing.add (GRing.scale (GRing.opp (GRing.mul k1 k2)) (GRing.add b (GRing.opp a))) (GRing.add (GRing.scale k1 (GRing.add p (GRing.opp q))) (GRing.add (GRing.scale k2 (GRing.add p (GRing.opp q))) (GRing.scale (betR b q c) (GRing.add q (GRing.opp a))))))) (GRing.zero (GRing.Zmodule.Pack (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))))
+++++
rewrite -scalerDr addrBDB addrCA addr_eq0 addrA -scalerDr addrBDB -[b-q]opprB.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
rewrite [k2+k1]addrC eq_div_scale ?bet_neq0' // scalerDr scalerA mulrCA mulfV.
rewrite ?bet_neq0' // mulr1 -subr_eq0 -[a-q]opprB scalerN !scalerBl !opprB.
rewrite addrACA -[X in _+X]addrA -!scaleNr -scalerDr addrBDB -addrCA addrAC.
rewrite -[X in _+(X+_)]addrA -scalerDr addrBDB -addrCA scalerDl -!addrA.
rewrite -scalerDr addrBDB addrCA addr_eq0 addrA -scalerDr addrBDB -[b-q]opprB.

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.scale (GRing.opp (GRing.mul k1 k2)) (GRing.add b (GRing.opp a))) (GRing.opp (GRing.add (GRing.scale k1 (GRing.opp (GRing.add q (GRing.opp b)))) (GRing.scale k2 (GRing.add p (GRing.opp a))))))
+++++
by rewrite P1 P2 -scalerN opprB !scalerA [k2*_]mulrC -scalerDr addrBDB scaleNr.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
rewrite [k2+k1]addrC eq_div_scale ?bet_neq0' // scalerDr scalerA mulrCA mulfV.

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (negb (eq_op (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul (betR a p c) k2))) (GRing.zero R)))
+++++
rewrite ?bet_neq0' // mulr1 -subr_eq0 -[a-q]opprB scalerN !scalerBl !opprB.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (betR a p c) (GRing.one R))
+++++
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.add (betR a p c) (GRing.opp (GRing.mul (betR a p c) (betR b q c)))) (GRing.add (GRing.add (betR a p c) (betR b q c)) (GRing.opp (GRing.mul (betR a p c) (betR b q c)))))
+++++
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).

*****
L2 : is_true (Num.Def.ltr (betR b q c) (GRing.one R))
G2 : is_true (Num.Def.ltr (GRing.zero R) (betR b q c))
P2 : eq (GRing.add q (GRing.opp b))\n (GRing.scale (betR b q c) (GRing.add c (GRing.opp b)))
L1 : is_true (Num.Def.ltr (betR a p c) (GRing.one R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (betR a p c))
P1 : eq (GRing.add p (GRing.opp a))\n (GRing.scale (betR a p c) (GRing.add c (GRing.opp a)))
_Hyp3_ : not (eq q c)
_Hyp2_ : not (eq b q)
_Hyp1_ : not (eq p c)
_Hyp_ : not (eq a p)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add (GRing.add (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add k1 k2) (GRing.opp (GRing.mul k1 k2))) (GRing.inv (GRing.add k1 (GRing.opp (GRing.mul k1 k2)))))) (GRing.add b (GRing.opp p))) p) (GRing.opp p)) (GRing.scale (GRing.inv (GRing.mul (GRing.add (GRing.add (betR a p c) (betR b q c)) (GRing.opp (GRing.mul (betR a p c) (betR b q c)))) (GRing.inv (GRing.add (betR a p c) (GRing.opp (GRing.mul (betR a p c) (betR b q c))))))) (GRing.add b (GRing.opp p))))
+++++
rewrite ?bet_lt -?addrA ?subrr ?addr0 // [k2*_]mulrC !invf_div !addrA -addrA.
-----
Lemma inner_pasch' a b c p q (k1 := betR a p c) (k2 := betR b q c) : a <> p -> p <> c -> b <> q -> q <> c -> bet a p c -> bet b q c -> exists x, bet p x b /\\ bet q x a.
Proof.
move=> ? ? ? ?.
rewrite 2?bet_betS // => /betSP[P1 G1 L1] /betSP[P2 G2 L2].
exists (((k1+k2-k1*k2)/(k1-k1*k2))^-1*:(b-p)+p).
apply/andP.
rewrite (ratio_bet G1 G2 _ (bet_gt0 G1 L2))?(ratio_bet G2 G1 _ (bet_gt0 G2 L1)).

*****

*****

+++++
Qed.
-----
Lemma inner_pasch a b c p q :\n  bet a p c -> bet b q c ->\n  a <> p -> p <> c -> b <> q -> q <> c ->\n  ~ (bet a b c \/ bet b c a \/ bet c a b) ->\n  exists x, bet p x b /\ bet q x a.
-----
Lemma inner_pasch a b c p q : bet a p c -> bet b q c -> a <> p -> p <> c -> b <> q -> q <> c -> ~ (bet a b c \\/ bet b c a \\/ bet c a b) -> exists x, bet p x b /\\ bet q x a.

*****
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a p c) (_ : bet b q c) (_ : not (eq a p)) (_ : not (eq p c)) (_ : not (eq b q)) (_ : not (eq q c)) (_ : not (or (bet a b c) (or (bet b c a) (bet c a b)))), ex (fun x : Vector R n => and (bet p x b) (bet q x a))
+++++
Proof.
-----
Lemma inner_pasch a b c p q : bet a p c -> bet b q c -> a <> p -> p <> c -> b <> q -> q <> c -> ~ (bet a b c \\/ bet b c a \\/ bet c a b) -> exists x, bet p x b /\\ bet q x a.
Proof.

*****
a,b,c,p,q : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a p c) (_ : bet b q c) (_ : not (eq a p)) (_ : not (eq p c)) (_ : not (eq b q)) (_ : not (eq q c)) (_ : not (or (bet a b c) (or (bet b c a) (bet c a b)))), ex (fun x : Vector R n => and (bet p x b) (bet q x a))
+++++
by move=> ? ? ? ? ? ? ? ; apply inner_pasch' with c.
-----
Lemma inner_pasch a b c p q : bet a p c -> bet b q c -> a <> p -> p <> c -> b <> q -> q <> c -> ~ (bet a b c \\/ bet b c a \\/ bet c a b) -> exists x, bet p x b /\\ bet q x a.
Proof.
by move=> ? ? ? ? ? ? ? ; apply inner_pasch' with c.

*****

*****

+++++
Qed.
-----
Lemma bet_col a b c:\n    bet a b c -> (bet a b c \/ bet b c a \/ bet c a b).
-----
Lemma bet_col a b c: bet a b c -> (bet a b c \\/ bet b c a \\/ bet c a b).

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : bet a b c, or (bet a b c) (or (bet b c a) (bet c a b))
+++++
Proof.
-----
Lemma bet_col a b c: bet a b c -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : bet a b c, or (bet a b c) (or (bet b c a) (bet c a b))
+++++
by auto.
-----
Lemma bet_col a b c: bet a b c -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
by auto.

*****

*****

+++++
Qed.
-----
Lemma bet_colF a b c :\n  bet a b c -> ~ (bet b a c \/ bet a c b \/ bet c b a) -> False.
-----
Lemma bet_colF a b c : bet a b c -> ~ (bet b a c \\/ bet a c b \\/ bet c b a) -> False.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a b c) (_ : not (or (bet b a c) (or (bet a c b) (bet c b a)))), False
+++++
Proof.
-----
Lemma bet_colF a b c : bet a b c -> ~ (bet b a c \\/ bet a c b \\/ bet c b a) -> False.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a b c) (_ : not (or (bet b a c) (or (bet a c b) (bet c b a)))), False
+++++
by move=>/bet_symmetry bet nbet; exfalso; apply nbet; rewrite bet; right; right.
-----
Lemma bet_colF a b c : bet a b c -> ~ (bet b a c \\/ bet a c b \\/ bet c b a) -> False.
Proof.
by move=>/bet_symmetry bet nbet; exfalso; apply nbet; rewrite bet; right; right.

*****

*****

+++++
Qed.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) :\n  0 < k1 -> k1 < 1 -> bet b d c -> b != c ->\n  bet (extension a b k1) (extension a d k1) (extension a c k1).
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).

*****
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : bet b d c) (_ : negb (eq_op b c)), bet (extension a b k1) (extension a d k1) (extension a c k1)
+++++
Proof.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.

*****
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : bet b d c) (_ : negb (eq_op b c)), bet (extension a b k1) (extension a d k1) (extension a c k1)
+++++
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.

*****
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
t : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : Num.Def.ltr (GRing.zero R) k1) (_ : Num.Def.ltr k1 (GRing.one R)) (_ : bet b d c) (_ : negb (eq_op b c)), bet x t y
+++++
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.

*****
bc_neq : is_true (negb (eq_op b c))
bet_bdc : is_true (bet b d c)
k1_lt1 : is_true (Num.Def.ltr k1 (GRing.one R))
k1_gt0 : is_true (Num.Def.ltr (GRing.zero R) k1)
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
t : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : negb (eq_op k1 (GRing.zero R)), bet x t y
+++++
move=> k1_neq0; move: bet_bdc; rewrite /bet /betE !extension_eq ?k1_neq0 //.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.
move=> k1_neq0; move: bet_bdc; rewrite /bet /betE !extension_eq ?k1_neq0 //.

*****
k1_neq0 : is_true (negb (eq_op k1 (GRing.zero R)))
bc_neq : is_true (negb (eq_op b c))
k1_lt1 : is_true (Num.Def.ltr k1 (GRing.one R))
k1_gt0 : is_true (Num.Def.ltr (GRing.zero R) k1)
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
t : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : orb (orb (andb (eq_op b d) (eq_op d c)) (orb (eq_op b d) (eq_op d c))) (betS b d c), orb (orb (andb (eq_op b d) (eq_op d c)) (orb (eq_op b d) (eq_op d c))) (betS x t y)
+++++
case (b =P d); [rewrite orbT //|]; case (d =P c) ; [rewrite orbT //|rewrite /=].
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.
move=> k1_neq0; move: bet_bdc; rewrite /bet /betE !extension_eq ?k1_neq0 //.
case (b =P d); [rewrite orbT //|]; case (d =P c) ; [rewrite orbT //|rewrite /=].

*****
k1_neq0 : is_true (negb (eq_op k1 (GRing.zero R)))
bc_neq : is_true (negb (eq_op b c))
k1_lt1 : is_true (Num.Def.ltr k1 (GRing.one R))
k1_gt0 : is_true (Num.Def.ltr (GRing.zero R) k1)
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
t : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : not (eq d c)) (_ : not (eq b d)) (_ : betS b d c), betS x t y
+++++
move=> _ _ /betSP[P1 k2_gt0 k2_lt1]; rewrite /betS.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.
move=> k1_neq0; move: bet_bdc; rewrite /bet /betE !extension_eq ?k1_neq0 //.
case (b =P d); [rewrite orbT //|]; case (d =P c) ; [rewrite orbT //|rewrite /=].
move=> _ _ /betSP[P1 k2_gt0 k2_lt1]; rewrite /betS.

*****
k2_lt1 : is_true (Num.Def.ltr (betR b d c) (GRing.one R))
k2_gt0 : is_true (Num.Def.ltr (GRing.zero R) (betR b d c))
P1 : eq (GRing.add d (GRing.opp b))\n (GRing.scale (betR b d c) (GRing.add c (GRing.opp b)))
k1_neq0 : is_true (negb (eq_op k1 (GRing.zero R)))
bc_neq : is_true (negb (eq_op b c))
k1_lt1 : is_true (Num.Def.ltr k1 (GRing.one R))
k1_gt0 : is_true (Num.Def.ltr (GRing.zero R) k1)
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
t : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (andb (eq_op (GRing.add t (GRing.opp x)) (GRing.scale (betR x t y) (GRing.add y (GRing.opp x)))) (andb (Num.Def.ltr (GRing.zero R) (betR x t y)) (Num.Def.ltr (betR x t y) (GRing.one R))))
+++++
suff: (t-x == k2 *: (y-x))=> [/eqP P2|]; [suff: (betR x t y = k2)=> [->|]|].
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.
move=> k1_neq0; move: bet_bdc; rewrite /bet /betE !extension_eq ?k1_neq0 //.
case (b =P d); [rewrite orbT //|]; case (d =P c) ; [rewrite orbT //|rewrite /=].
move=> _ _ /betSP[P1 k2_gt0 k2_lt1]; rewrite /betS.
suff: (t-x == k2 *: (y-x))=> [/eqP P2|]; [suff: (betR x t y = k2)=> [->|]|].

*****
P2 : eq (GRing.add t (GRing.opp x))\n (GRing.scale k2 (GRing.add y (GRing.opp x)))
k2_lt1 : is_true (Num.Def.ltr (betR b d c) (GRing.one R))
k2_gt0 : is_true (Num.Def.ltr (GRing.zero R) (betR b d c))
P1 : eq (GRing.add d (GRing.opp b))\n (GRing.scale (betR b d c) (GRing.add c (GRing.opp b)))
k1_neq0 : is_true (negb (eq_op k1 (GRing.zero R)))
bc_neq : is_true (negb (eq_op b c))
k1_lt1 : is_true (Num.Def.ltr k1 (GRing.one R))
k1_gt0 : is_true (Num.Def.ltr (GRing.zero R) k1)
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
t : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (andb (eq_op (GRing.add t (GRing.opp x)) (GRing.scale k2 (GRing.add y (GRing.opp x)))) (andb (Num.Def.ltr (GRing.zero R) k2) (Num.Def.ltr k2 (GRing.one R))))
+++++
by rewrite P2 k2_gt0 k2_lt1 eqxx.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.
move=> k1_neq0; move: bet_bdc; rewrite /bet /betE !extension_eq ?k1_neq0 //.
case (b =P d); [rewrite orbT //|]; case (d =P c) ; [rewrite orbT //|rewrite /=].
move=> _ _ /betSP[P1 k2_gt0 k2_lt1]; rewrite /betS.
suff: (t-x == k2 *: (y-x))=> [/eqP P2|]; [suff: (betR x t y = k2)=> [->|]|].
by rewrite P2 k2_gt0 k2_lt1 eqxx.

*****
P2 : eq (GRing.add t (GRing.opp x))\n (GRing.scale k2 (GRing.add y (GRing.opp x)))
k2_lt1 : is_true (Num.Def.ltr (betR b d c) (GRing.one R))
k2_gt0 : is_true (Num.Def.ltr (GRing.zero R) (betR b d c))
P1 : eq (GRing.add d (GRing.opp b))\n (GRing.scale (betR b d c) (GRing.add c (GRing.opp b)))
k1_neq0 : is_true (negb (eq_op k1 (GRing.zero R)))
bc_neq : is_true (negb (eq_op b c))
k1_lt1 : is_true (Num.Def.ltr k1 (GRing.one R))
k1_gt0 : is_true (Num.Def.ltr (GRing.zero R) k1)
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
t : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (betR x t y) k2
+++++
by apply ratio_eq; rewrite ?P2 ?eqxx // subr_eq0 extension_eq // eq_sym.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.
move=> k1_neq0; move: bet_bdc; rewrite /bet /betE !extension_eq ?k1_neq0 //.
case (b =P d); [rewrite orbT //|]; case (d =P c) ; [rewrite orbT //|rewrite /=].
move=> _ _ /betSP[P1 k2_gt0 k2_lt1]; rewrite /betS.
suff: (t-x == k2 *: (y-x))=> [/eqP P2|]; [suff: (betR x t y = k2)=> [->|]|].
by rewrite P2 k2_gt0 k2_lt1 eqxx.
by apply ratio_eq; rewrite ?P2 ?eqxx // subr_eq0 extension_eq // eq_sym.

*****
k2_lt1 : is_true (Num.Def.ltr (betR b d c) (GRing.one R))
k2_gt0 : is_true (Num.Def.ltr (GRing.zero R) (betR b d c))
P1 : eq (GRing.add d (GRing.opp b))\n (GRing.scale (betR b d c) (GRing.add c (GRing.opp b)))
k1_neq0 : is_true (negb (eq_op k1 (GRing.zero R)))
bc_neq : is_true (negb (eq_op b c))
k1_lt1 : is_true (Num.Def.ltr k1 (GRing.one R))
k1_gt0 : is_true (Num.Def.ltr (GRing.zero R) k1)
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
t : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add t (GRing.opp x)) (GRing.scale k2 (GRing.add y (GRing.opp x))))
+++++
rewrite /x /t /y /extension addrDBD -scalerBr opprB addrBDB addrDBD -scalerBr.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.
move=> k1_neq0; move: bet_bdc; rewrite /bet /betE !extension_eq ?k1_neq0 //.
case (b =P d); [rewrite orbT //|]; case (d =P c) ; [rewrite orbT //|rewrite /=].
move=> _ _ /betSP[P1 k2_gt0 k2_lt1]; rewrite /betS.
suff: (t-x == k2 *: (y-x))=> [/eqP P2|]; [suff: (betR x t y = k2)=> [->|]|].
by rewrite P2 k2_gt0 k2_lt1 eqxx.
by apply ratio_eq; rewrite ?P2 ?eqxx // subr_eq0 extension_eq // eq_sym.
rewrite /x /t /y /extension addrDBD -scalerBr opprB addrBDB addrDBD -scalerBr.

*****
k2_lt1 : is_true (Num.Def.ltr (betR b d c) (GRing.one R))
k2_gt0 : is_true (Num.Def.ltr (GRing.zero R) (betR b d c))
P1 : eq (GRing.add d (GRing.opp b))\n (GRing.scale (betR b d c) (GRing.add c (GRing.opp b)))
k1_neq0 : is_true (negb (eq_op k1 (GRing.zero R)))
bc_neq : is_true (negb (eq_op b c))
k1_lt1 : is_true (Num.Def.ltr k1 (GRing.one R))
k1_gt0 : is_true (Num.Def.ltr (GRing.zero R) k1)
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
t : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
k2 : GRing.Ring.sort R
k1 : Num.NumDomain.sort R
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.scale (GRing.inv k1) (GRing.add d (GRing.opp b))) (GRing.scale k2 (GRing.scale (GRing.inv k1) (GRing.add (GRing.add c (GRing.opp a)) (GRing.opp (GRing.add b (GRing.opp a)))))))
+++++
by rewrite opprB addrBDB scalerA mulrC -scalerA P1 eqxx.
-----
Lemma euclid'_aux a b c d k1 (k2 := betR b d c) : 0 < k1 -> k1 < 1 -> bet b d c -> b != c -> bet (extension a b k1) (extension a d k1) (extension a c k1).
Proof.
set x:= extension a b k1; set t:= extension a d k1; set y:= extension a c k1.
move=> k1_gt0 k1_lt1 bet_bdc bc_neq; have: (k1 != 0) by rewrite lt0r_neq0.
move=> k1_neq0; move: bet_bdc; rewrite /bet /betE !extension_eq ?k1_neq0 //.
case (b =P d); [rewrite orbT //|]; case (d =P c) ; [rewrite orbT //|rewrite /=].
move=> _ _ /betSP[P1 k2_gt0 k2_lt1]; rewrite /betS.
suff: (t-x == k2 *: (y-x))=> [/eqP P2|]; [suff: (betR x t y = k2)=> [->|]|].
by rewrite P2 k2_gt0 k2_lt1 eqxx.
by apply ratio_eq; rewrite ?P2 ?eqxx // subr_eq0 extension_eq // eq_sym.
rewrite /x /t /y /extension addrDBD -scalerBr opprB addrBDB addrDBD -scalerBr.
by rewrite opprB addrBDB scalerA mulrC -scalerA P1 eqxx.

*****

*****

+++++
Qed.
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) :\n  betS a d t -> bet b d c ->\n  exists x y, bet a b x /\ bet a c y /\ bet x t y.
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) : betS a d t -> bet b d c -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.

*****
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : betS a d t) (_ : bet b d c), ex (fun x : Vector R n => ex (fun y : Vector R n => and (bet a b x) (and (bet a c y) (bet x t y))))
+++++
Proof.
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) : betS a d t -> bet b d c -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.

*****
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : betS a d t) (_ : bet b d c), ex (fun x : Vector R n => ex (fun y : Vector R n => and (bet a b x) (and (bet a c y) (bet x t y))))
+++++
case: (b =P c)=> [-> betS_adt|/eqP bc_neq betS_adt bet_bdc].
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) : betS a d t -> bet b d c -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.
case: (b =P c)=> [-> betS_adt|/eqP bc_neq betS_adt bet_bdc].

*****
betS_adt : is_true (betS a d t)
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : bet c d c, ex (fun x : Vector R n => ex (fun y : Vector R n => and (bet a c x) (and (bet a c y) (bet x t y))))
+++++
by rewrite bet_xax=> /eqP ->; exists t, t; rewrite bet_xxa /bet betS_adt orbT.
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) : betS a d t -> bet b d c -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.
case: (b =P c)=> [-> betS_adt|/eqP bc_neq betS_adt bet_bdc].
by rewrite bet_xax=> /eqP ->; exists t, t; rewrite bet_xxa /bet betS_adt orbT.

*****
bet_bdc : is_true (bet b d c)
betS_adt : is_true (betS a d t)
bc_neq : is_true (negb (eq_op b c))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
ex (fun x : Vector R n => ex (fun y : Vector R n => and (bet a b x) (and (bet a c y) (bet x t y))))
+++++
set x:=extension a b k1; set y:=extension a c k1; exists x, y.
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) : betS a d t -> bet b d c -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.
case: (b =P c)=> [-> betS_adt|/eqP bc_neq betS_adt bet_bdc].
by rewrite bet_xax=> /eqP ->; exists t, t; rewrite bet_xxa /bet betS_adt orbT.
set x:=extension a b k1; set y:=extension a c k1; exists x, y.

*****
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
bet_bdc : is_true (bet b d c)
betS_adt : is_true (betS a d t)
bc_neq : is_true (negb (eq_op b c))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
and (bet a b x) (and (bet a c y) (bet x t y))
+++++
have: (t == extension a d k1); [|move/betSP: betS_adt =>[_ k1_gt0 k1_lt1]].
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) : betS a d t -> bet b d c -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.
case: (b =P c)=> [-> betS_adt|/eqP bc_neq betS_adt bet_bdc].
by rewrite bet_xax=> /eqP ->; exists t, t; rewrite bet_xxa /bet betS_adt orbT.
set x:=extension a b k1; set y:=extension a c k1; exists x, y.
have: (t == extension a d k1); [|move/betSP: betS_adt =>[_ k1_gt0 k1_lt1]].

*****
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
bet_bdc : is_true (bet b d c)
betS_adt : is_true (betS a d t)
bc_neq : is_true (negb (eq_op b c))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op t (extension a d k1))
+++++
move: betS_adt; rewrite betS_neq12 /betS /betR=> /andP[/andP[/eqP ? _] ?].
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) : betS a d t -> bet b d c -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.
case: (b =P c)=> [-> betS_adt|/eqP bc_neq betS_adt bet_bdc].
by rewrite bet_xax=> /eqP ->; exists t, t; rewrite bet_xxa /bet betS_adt orbT.
set x:=extension a b k1; set y:=extension a c k1; exists x, y.
have: (t == extension a d k1); [|move/betSP: betS_adt =>[_ k1_gt0 k1_lt1]].
move: betS_adt; rewrite betS_neq12 /betS /betR=> /andP[/andP[/eqP ? _] ?].

*****
_b1_ : is_true (negb (eq_op a d))
__view_subject_3_ : eq (GRing.add d (GRing.opp a))\n (GRing.scale\n (ratio (GRing.add d (GRing.opp a)) (GRing.add t (GRing.opp a)))\n (GRing.add t (GRing.opp a)))
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
bet_bdc : is_true (bet b d c)
bc_neq : is_true (negb (eq_op b c))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op t (extension a d k1))
+++++
by apply /eqP; rewrite /k1 /betR extensionP.
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) : betS a d t -> bet b d c -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.
case: (b =P c)=> [-> betS_adt|/eqP bc_neq betS_adt bet_bdc].
by rewrite bet_xax=> /eqP ->; exists t, t; rewrite bet_xxa /bet betS_adt orbT.
set x:=extension a b k1; set y:=extension a c k1; exists x, y.
have: (t == extension a d k1); [|move/betSP: betS_adt =>[_ k1_gt0 k1_lt1]].
move: betS_adt; rewrite betS_neq12 /betS /betR=> /andP[/andP[/eqP ? _] ?].
by apply /eqP; rewrite /k1 /betR extensionP.

*****
k1_lt1 : is_true (Num.Def.ltr (betR a d t) (GRing.one R))
k1_gt0 : is_true (Num.Def.ltr (GRing.zero R) (betR a d t))
y : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
x : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S n))))
bet_bdc : is_true (bet b d c)
bc_neq : is_true (negb (eq_op b c))
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op t (extension a d k1), and (bet a b x) (and (bet a c y) (bet x t y))
+++++
by move=> /eqP t_def; rewrite !extension_bet // t_def /x /y euclid'_aux.
-----
Lemma euclid' a b c d t (k1 := betR a d t) (k2 := betR b d c) : betS a d t -> bet b d c -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.
case: (b =P c)=> [-> betS_adt|/eqP bc_neq betS_adt bet_bdc].
by rewrite bet_xax=> /eqP ->; exists t, t; rewrite bet_xxa /bet betS_adt orbT.
set x:=extension a b k1; set y:=extension a c k1; exists x, y.
have: (t == extension a d k1); [|move/betSP: betS_adt =>[_ k1_gt0 k1_lt1]].
move: betS_adt; rewrite betS_neq12 /betS /betR=> /andP[/andP[/eqP ? _] ?].
by apply /eqP; rewrite /k1 /betR extensionP.
by move=> /eqP t_def; rewrite !extension_bet // t_def /x /y euclid'_aux.

*****

*****

+++++
Qed.
-----
Lemma euclid a b c d t (k1 := betR a d t) (k2 := betR b d c) :\n  bet a d t -> bet b d c -> b <> d -> d <> c ->\n  ~ (bet a b c \/ bet b c a \/ bet c a b) ->\n  exists x y, bet a b x /\ bet a c y /\ bet x t y.
-----
Lemma euclid a b c d t (k1 := betR a d t) (k2 := betR b d c) : bet a d t -> bet b d c -> b <> d -> d <> c -> ~ (bet a b c \\/ bet b c a \\/ bet c a b) -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.

*****
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a d t) (_ : bet b d c) (_ : not (eq b d)) (_ : not (eq d c)) (_ : not (or (bet a b c) (or (bet b c a) (bet c a b)))), ex (fun x : Vector R n => ex (fun y : Vector R n => and (bet a b x) (and (bet a c y) (bet x t y))))
+++++
Proof.
-----
Lemma euclid a b c d t (k1 := betR a d t) (k2 := betR b d c) : bet a d t -> bet b d c -> b <> d -> d <> c -> ~ (bet a b c \\/ bet b c a \\/ bet c a b) -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.

*****
k2 : GRing.Ring.sort R
k1 : GRing.Ring.sort R
a,b,c,d,t : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : bet a d t) (_ : bet b d c) (_ : not (eq b d)) (_ : not (eq d c)) (_ : not (or (bet a b c) (or (bet b c a) (bet c a b)))), ex (fun x : Vector R n => ex (fun y : Vector R n => and (bet a b x) (and (bet a c y) (bet x t y))))
+++++
move=> /orP[/betEP[[->->]|->|->] b2 _ _ H|]; try solve[by apply bet_colF in H]; [exists b,c|move=> b1 b2 _ _ _]; by [rewrite !bet_axx|move: b2; apply euclid'].
-----
Lemma euclid a b c d t (k1 := betR a d t) (k2 := betR b d c) : bet a d t -> bet b d c -> b <> d -> d <> c -> ~ (bet a b c \\/ bet b c a \\/ bet c a b) -> exists x y, bet a b x /\\ bet a c y /\\ bet x t y.
Proof.
move=> /orP[/betEP[[->->]|->|->] b2 _ _ H|]; try solve[by apply bet_colF in H]; [exists b,c|move=> b1 b2 _ _ _]; by [rewrite !bet_axx|move: b2; apply euclid'].

*****

*****

+++++
Qed.
-----
Lemma congC a b c d: cong a b c d = cong b a d c.
-----
Lemma congC a b c d: cong a b c d = cong b a d c.

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (cong a b c d) (cong b a d c)
+++++
Proof.
-----
Lemma congC a b c d: cong a b c d = cong b a d c.
Proof.

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (cong a b c d) (cong b a d c)
+++++
rewrite /cong -opprB mulNmx dotC -mulNmx 2?opprB eq_sym -opprB.
-----
Lemma congC a b c d: cong a b c d = cong b a d c.
Proof.
rewrite /cong -opprB mulNmx dotC -mulNmx 2?opprB eq_sym -opprB.

*****
a,b,c,d : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (eq_op (mulmx (GRing.opp (GRing.add c (GRing.opp d))) (trmx (GRing.opp (GRing.add c (GRing.opp d))))) (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))) (eq_op (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b)))) (mulmx (GRing.add c (GRing.opp d)) (trmx (GRing.add c (GRing.opp d)))))
+++++
by rewrite mulNmx [X in -X]dotC -mulNmx 2?opprB eq_sym.
-----
Lemma congC a b c d: cong a b c d = cong b a d c.
Proof.
rewrite /cong -opprB mulNmx dotC -mulNmx 2?opprB eq_sym -opprB.
by rewrite mulNmx [X in -X]dotC -mulNmx 2?opprB eq_sym.

*****

*****

+++++
Qed.
-----
Lemma cong_eq a b c : cong a b c c -> a = b.
-----
Lemma cong_eq a b c : cong a b c c -> a = b.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : cong a b c c, eq a b
+++++
Proof.
-----
Lemma cong_eq a b c : cong a b c c -> a = b.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : cong a b c c, eq a b
+++++
apply cong_identity.
-----
Lemma cong_eq a b c : cong a b c c -> a = b.
Proof.
apply cong_identity.

*****

*****

+++++
Qed.
-----
Lemma cong_eq' a b c : cong a a b c -> b = c.
-----
Lemma cong_eq' a b c : cong a a b c -> b = c.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : cong a a b c, eq b c
+++++
Proof.
-----
Lemma cong_eq' a b c : cong a a b c -> b = c.
Proof.

*****
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : cong a a b c, eq b c
+++++
by rewrite /cong subrr linear0 mulmx0 eq_sym quad_eq0 subr_eq0 => /eqP ->.
-----
Lemma cong_eq' a b c : cong a a b c -> b = c.
Proof.
by rewrite /cong subrr linear0 mulmx0 eq_sym quad_eq0 subr_eq0 => /eqP ->.

*****

*****

+++++
Qed.
-----
Lemma betS_ratio a b c (r := betR a b c) :\n  betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).

*****
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : betS a b c, eq (GRing.add c (GRing.opp b)) (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add b (GRing.opp a)))
+++++
Proof.
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.

*****
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : betS a b c, eq (GRing.add c (GRing.opp b)) (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add b (GRing.opp a)))
+++++
move=> b1.
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.
move=> b1.

*****
b1 : is_true (betS a b c)
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add c (GRing.opp b)) (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add b (GRing.opp a)))
+++++
have: betS c b a by rewrite betS_sym.
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.
move=> b1.
have: betS c b a by rewrite betS_sym.

*****
b1 : is_true (betS a b c)
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : betS c b a, eq (GRing.add c (GRing.opp b)) (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add b (GRing.opp a)))
+++++
rewrite betS_neq13.
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.
move=> b1.
have: betS c b a by rewrite betS_sym.
rewrite betS_neq13.

*****
b1 : is_true (betS a b c)
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : andb (betS c b a) (negb (eq_op c a)), eq (GRing.add c (GRing.opp b)) (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add b (GRing.opp a)))
+++++
move: b1.
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.
move=> b1.
have: betS c b a by rewrite betS_sym.
rewrite betS_neq13.
move: b1.

*****
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : betS a b c) (_ : andb (betS c b a) (negb (eq_op c a))), eq (GRing.add c (GRing.opp b)) (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add b (GRing.opp a)))
+++++
move=> /betSP[E1 ? ?] /andP[/betSP[E2 ? ?]?].
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.
move=> b1.
have: betS c b a by rewrite betS_sym.
rewrite betS_neq13.
move: b1.
move=> /betSP[E1 ? ?] /andP[/betSP[E2 ? ?]?].

*****
_b_ : is_true (negb (eq_op c a))
_p3_ : is_true (Num.Def.ltr (betR c b a) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR c b a))
E2 : eq (GRing.add b (GRing.opp c))\n (GRing.scale (betR c b a) (GRing.add a (GRing.opp c)))
_p1_ : is_true (Num.Def.ltr (betR a b c) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b c))
E1 : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b c) (GRing.add c (GRing.opp a)))
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.add c (GRing.opp b)) (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add b (GRing.opp a)))
+++++
apply /eqP.
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.
move=> b1.
have: betS c b a by rewrite betS_sym.
rewrite betS_neq13.
move: b1.
move=> /betSP[E1 ? ?] /andP[/betSP[E2 ? ?]?].
apply /eqP.

*****
_b_ : is_true (negb (eq_op c a))
_p3_ : is_true (Num.Def.ltr (betR c b a) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR c b a))
E2 : eq (GRing.add b (GRing.opp c))\n (GRing.scale (betR c b a) (GRing.add a (GRing.opp c)))
_p1_ : is_true (Num.Def.ltr (betR a b c) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b c))
E1 : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b c) (GRing.add c (GRing.opp a)))
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.add c (GRing.opp b)) (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add b (GRing.opp a))))
+++++
rewrite -opprB E1 E2.
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.
move=> b1.
have: betS c b a by rewrite betS_sym.
rewrite betS_neq13.
move: b1.
move=> /betSP[E1 ? ?] /andP[/betSP[E2 ? ?]?].
apply /eqP.
rewrite -opprB E1 E2.

*****
_b_ : is_true (negb (eq_op c a))
_p3_ : is_true (Num.Def.ltr (betR c b a) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR c b a))
E2 : eq (GRing.add b (GRing.opp c))\n (GRing.scale (betR c b a) (GRing.add a (GRing.opp c)))
_p1_ : is_true (Num.Def.ltr (betR a b c) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b c))
E1 : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b c) (GRing.add c (GRing.opp a)))
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.opp (GRing.scale (betR c b a) (GRing.add a (GRing.opp c)))) (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.scale (betR a b c) (GRing.add c (GRing.opp a)))))
+++++
rewrite eq_div_scale /r ?lt0r_neq0 // sub_1_ratio ?subr_eq0 // opprB addrBDB.
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.
move=> b1.
have: betS c b a by rewrite betS_sym.
rewrite betS_neq13.
move: b1.
move=> /betSP[E1 ? ?] /andP[/betSP[E2 ? ?]?].
apply /eqP.
rewrite -opprB E1 E2.
rewrite eq_div_scale /r ?lt0r_neq0 // sub_1_ratio ?subr_eq0 // opprB addrBDB.

*****
_b_ : is_true (negb (eq_op c a))
_p3_ : is_true (Num.Def.ltr (betR c b a) (GRing.one R))
_p2_ : is_true (Num.Def.ltr (GRing.zero R) (betR c b a))
E2 : eq (GRing.add b (GRing.opp c))\n (GRing.scale (betR c b a) (GRing.add a (GRing.opp c)))
_p1_ : is_true (Num.Def.ltr (betR a b c) (GRing.one R))
_p_ : is_true (Num.Def.ltr (GRing.zero R) (betR a b c))
E1 : eq (GRing.add b (GRing.opp a))\n (GRing.scale (betR a b c) (GRing.add c (GRing.opp a)))
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.scale (betR a b c) (GRing.opp (GRing.scale (betR c b a) (GRing.add a (GRing.opp c))))) (GRing.scale (ratio (GRing.add c (GRing.opp b)) (GRing.add c (GRing.opp a))) (GRing.scale (betR a b c) (GRing.add c (GRing.opp a)))))
+++++
by rewrite /betR -scalerN opprB !scalerA mulrC -opprB ratioNr -ratiorN opprB.
-----
Lemma betS_ratio a b c (r := betR a b c) : betS a b c -> (c - b = ((1 - r) / r) *: (b - a)).
Proof.
move=> b1.
have: betS c b a by rewrite betS_sym.
rewrite betS_neq13.
move: b1.
move=> /betSP[E1 ? ?] /andP[/betSP[E2 ? ?]?].
apply /eqP.
rewrite -opprB E1 E2.
rewrite eq_div_scale /r ?lt0r_neq0 // sub_1_ratio ?subr_eq0 // opprB addrBDB.
by rewrite /betR -scalerN opprB !scalerA mulrC -opprB ratioNr -ratiorN opprB.

*****

*****

+++++
Qed.
-----
Lemma betS_gt0 a b c (r := ratio(b-a)(c-a)) : betS a b c -> 0 < (1 - r) / r.
-----
Lemma betS_gt0 a b c (r := ratio(b-a)(c-a)) : betS a b c -> 0 < (1 - r) / r.

*****
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : betS a b c, Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r))
+++++
Proof.
-----
Lemma betS_gt0 a b c (r := ratio(b-a)(c-a)) : betS a b c -> 0 < (1 - r) / r.
Proof.

*****
r : GRing.Ring.sort R
a,b,c : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : betS a b c, Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r))
+++++
by move=> /betSP[? ? ?]; rewrite divr_gt0 /r ?subr_gt0.
-----
Lemma betS_gt0 a b c (r := ratio(b-a)(c-a)) : betS a b c -> 0 < (1 - r) / r.
Proof.
by move=> /betSP[? ? ?]; rewrite divr_gt0 /r ?subr_gt0.

*****

*****

+++++
Qed.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') :\n  betS a b c -> betS a' b' c' ->\n  cong b a b' a' -> cong b c b' c' ->\n  (1 - r) / r = (1 - r') / r'.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.

*****
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : betS a b c) (_ : betS a' b' c') (_ : cong b a b' a') (_ : cong b c b' c'), eq (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))
+++++
Proof.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.

*****
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : betS a b c) (_ : betS a' b' c') (_ : cong b a b' a') (_ : cong b c b' c'), eq (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))
+++++
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.

*****
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))
+++++
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).

*****
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.scale (GRing.add (GRing.exp (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (S (S O))) (GRing.opp (GRing.exp (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r')) (S (S O))))) (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))) (GRing.zero (GRing.Zmodule.Pack (GRing.Lmodule.class (matrix_lmodType R (S O) (S O))))), eq (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))
+++++
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.

*****
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : orb (eq_op (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))) (eq_op (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.opp (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r')))), eq (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))
+++++
move=> /orP[/eqP ->//|].
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.
move=> /orP[/eqP ->//|].

*****
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.opp (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))), eq (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))
+++++
rewrite eq_sym -sub0r subr_eq=>/eqP E.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.
move=> /orP[/eqP ->//|].
rewrite eq_sym -sub0r subr_eq=>/eqP E.

*****
E : eq (GRing.zero R)\n (GRing.add\n (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r))\n (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r')))
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
eq (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))
+++++
have: (0 < (1-r)/r+(1-r')/r'); first by rewrite addr_gt0 ?betS_gt0 //.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.
move=> /orP[/eqP ->//|].
rewrite eq_sym -sub0r subr_eq=>/eqP E.
have: (0 < (1-r)/r+(1-r')/r'); first by rewrite addr_gt0 ?betS_gt0 //.

*****
E : eq (GRing.zero R)\n (GRing.add\n (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r))\n (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r')))
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (GRing.zero R) (GRing.add (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))), eq (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))
+++++
by rewrite lt0r -E eqxx andFb //.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.
move=> /orP[/eqP ->//|].
rewrite eq_sym -sub0r subr_eq=>/eqP E.
have: (0 < (1-r)/r+(1-r')/r'); first by rewrite addr_gt0 ?betS_gt0 //.
by rewrite lt0r -E eqxx andFb //.

*****
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.scale (GRing.add (GRing.exp (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (S (S O))) (GRing.opp (GRing.exp (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r')) (S (S O))))) (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))) (GRing.zero (GRing.Zmodule.Pack (GRing.Lmodule.class (matrix_lmodType R (S O) (S O))))))
+++++
rewrite scalerBl {2}c1 subr_eq0 !expr2 -scalerA scalemxAl dotC.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.
move=> /orP[/eqP ->//|].
rewrite eq_sym -sub0r subr_eq=>/eqP E.
have: (0 < (1-r)/r+(1-r')/r'); first by rewrite addr_gt0 ?betS_gt0 //.
by rewrite lt0r -E eqxx andFb //.
rewrite scalerBl {2}c1 subr_eq0 !expr2 -scalerA scalemxAl dotC.

*****
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add a (GRing.opp b)))))) (GRing.scale (GRing.mul (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r')) (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r'))) (mulmx (GRing.add a' (GRing.opp b')) (trmx (GRing.add a' (GRing.opp b'))))))
+++++
rewrite scalemxAl eq_sym -scalerA scalemxAl dotC scalemxAl.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.
move=> /orP[/eqP ->//|].
rewrite eq_sym -sub0r subr_eq=>/eqP E.
have: (0 < (1-r)/r+(1-r')/r'); first by rewrite addr_gt0 ?betS_gt0 //.
by rewrite lt0r -E eqxx andFb //.
rewrite scalerBl {2}c1 subr_eq0 !expr2 -scalerA scalemxAl dotC.
rewrite scalemxAl eq_sym -scalerA scalemxAl dotC scalemxAl.

*****
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (mulmx (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r')) (GRing.add a' (GRing.opp b'))) (trmx (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r')) (GRing.inv r')) (GRing.add a' (GRing.opp b'))))) (mulmx (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add a (GRing.opp b))) (trmx (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp r)) (GRing.inv r)) (GRing.add a (GRing.opp b))))))
+++++
rewrite -[a-b]opprB -[a'-b']opprB !scalerN -(betS_ratio b2) -(betS_ratio b1).
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.
move=> /orP[/eqP ->//|].
rewrite eq_sym -sub0r subr_eq=>/eqP E.
have: (0 < (1-r)/r+(1-r')/r'); first by rewrite addr_gt0 ?betS_gt0 //.
by rewrite lt0r -E eqxx andFb //.
rewrite scalerBl {2}c1 subr_eq0 !expr2 -scalerA scalemxAl dotC.
rewrite scalemxAl eq_sym -scalerA scalemxAl dotC scalemxAl.
rewrite -[a-b]opprB -[a'-b']opprB !scalerN -(betS_ratio b2) -(betS_ratio b1).

*****
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
NE : is_true (negb (eq_op a b))
b1 : is_true (betS a b c)
r' : GRing.Ring.sort R
r : GRing.Ring.sort R
a,b,c,a',b',c' : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (mulmx (GRing.opp (GRing.add c' (GRing.opp b'))) (trmx (GRing.opp (GRing.add c' (GRing.opp b'))))) (mulmx (GRing.opp (GRing.add c (GRing.opp b))) (trmx (GRing.opp (GRing.add c (GRing.opp b))))))
+++++
by rewrite !mulNmx dotC [X in _ == -X]dotC !mulNmx c2.
-----
Lemma bet_cong_ratio_eq a b c a' b' c' (r := betR a b c) (r' := betR a' b' c') : betS a b c -> betS a' b' c' -> cong b a b' a' -> cong b c b' c' -> (1 - r) / r = (1 - r') / r'.
Proof.
rewrite /cong betS_neq12=> /andP[b1 NE] b2 /eqP c1 /eqP c2.
suff: ((((1-r)/r)^+2-((1-r')/r')^+2)*:((a-b)*m(a-b)^T) == 0).
rewrite scaler_eq0 ?quad_eq0 ?subr_eq0=> /orP[|/eqP E]; rewrite ?eqf_sqr; last by rewrite E in NE; move/eqP: NE=> //.
move=> /orP[/eqP ->//|].
rewrite eq_sym -sub0r subr_eq=>/eqP E.
have: (0 < (1-r)/r+(1-r')/r'); first by rewrite addr_gt0 ?betS_gt0 //.
by rewrite lt0r -E eqxx andFb //.
rewrite scalerBl {2}c1 subr_eq0 !expr2 -scalerA scalemxAl dotC.
rewrite scalemxAl eq_sym -scalerA scalemxAl dotC scalemxAl.
rewrite -[a-b]opprB -[a'-b']opprB !scalerN -(betS_ratio b2) -(betS_ratio b1).
by rewrite !mulNmx dotC [X in _ == -X]dotC !mulNmx c2.

*****

*****

+++++
Qed.
-----
Lemma five_segment a a' b b' c c' d d' :\n  cong a b a' b' -> cong b c b' c' -> cong a d a' d' -> cong b d b' d' ->\n  bet a b c -> bet a' b' c' -> a <> b -> cong c d c' d'.
-----
Lemma five_segment a a' b b' c c' d d' : cong a b a' b' -> cong b c b' c' -> cong a d a' d' -> cong b d b' d' -> bet a b c -> bet a' b' c' -> a <> b -> cong c d c' d'.

*****
a,a',b,b',c,c',d,d' : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : cong a b a' b') (_ : cong b c b' c') (_ : cong a d a' d') (_ : cong b d b' d') (_ : bet a b c) (_ : bet a' b' c') (_ : not (eq a b)), cong c d c' d'
+++++
Proof.
-----
Lemma five_segment a a' b b' c c' d d' : cong a b a' b' -> cong b c b' c' -> cong a d a' d' -> cong b d b' d' -> bet a b c -> bet a' b' c' -> a <> b -> cong c d c' d'.
Proof.

*****
a,a',b,b',c,c',d,d' : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall (_ : cong a b a' b') (_ : cong b c b' c') (_ : cong a d a' d') (_ : cong b d b' d') (_ : bet a b c) (_ : bet a' b' c') (_ : not (eq a b)), cong c d c' d'
+++++
move=> c1 c2 c3 c4 /orP[/betEP[[->->]|->|E]|b1 /orP[/betEP[[E _]|E|E]|b2]]=> //; try solve[rewrite E in c2; apply cong_eq' in c2; move=> _ _; rewrite -c2 -E //]; try solve[rewrite -E in c1; apply cong_eq in c1; rewrite -c1 //]; try solve[rewrite -E in c2; apply cong_eq in c2; rewrite -c2 -E //].
-----
Lemma five_segment a a' b b' c c' d d' : cong a b a' b' -> cong b c b' c' -> cong a d a' d' -> cong b d b' d' -> bet a b c -> bet a' b' c' -> a <> b -> cong c d c' d'.
Proof.
move=> c1 c2 c3 c4 /orP[/betEP[[->->]|->|E]|b1 /orP[/betEP[[E _]|E|E]|b2]]=> //; try solve[rewrite E in c2; apply cong_eq' in c2; move=> _ _; rewrite -c2 -E //]; try solve[rewrite -E in c1; apply cong_eq in c1; rewrite -c1 //]; try solve[rewrite -E in c2; apply cong_eq in c2; rewrite -c2 -E //].

*****
b2 : is_true (betS a' b' c')
b1 : is_true (betS a b c)
c4 : is_true (cong b d b' d')
c3 : is_true (cong a d a' d')
c2 : is_true (cong b c b' c')
c1 : is_true (cong a b a' b')
a,a',b,b',c,c',d,d' : Vector R n
n : nat
R : Num\.RealField\.type
*****
forall _ : not (eq a b), cong c d c' d'
+++++
move: c1 c2 c3 c4; rewrite congC /cong=> /eqP c1 /eqP c2 /eqP c3 /eqP c4 _.
-----
Lemma five_segment a a' b b' c c' d d' : cong a b a' b' -> cong b c b' c' -> cong a d a' d' -> cong b d b' d' -> bet a b c -> bet a' b' c' -> a <> b -> cong c d c' d'.
Proof.
move=> c1 c2 c3 c4 /orP[/betEP[[->->]|->|E]|b1 /orP[/betEP[[E _]|E|E]|b2]]=> //; try solve[rewrite E in c2; apply cong_eq' in c2; move=> _ _; rewrite -c2 -E //]; try solve[rewrite -E in c1; apply cong_eq in c1; rewrite -c1 //]; try solve[rewrite -E in c2; apply cong_eq in c2; rewrite -c2 -E //].
move: c1 c2 c3 c4; rewrite congC /cong=> /eqP c1 /eqP c2 /eqP c3 /eqP c4 _.

*****
c4 : eq\n (mulmx (GRing.add d (GRing.opp b)) (trmx (GRing.add d (GRing.opp b))))\n (mulmx (GRing.add d' (GRing.opp b'))\n (trmx (GRing.add d' (GRing.opp b'))))
c3 : eq\n (mulmx (GRing.add d (GRing.opp a)) (trmx (GRing.add d (GRing.opp a))))\n (mulmx (GRing.add d' (GRing.opp a'))\n (trmx (GRing.add d' (GRing.opp a'))))
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
b1 : is_true (betS a b c)
a,a',b,b',c,c',d,d' : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (mulmx (GRing.add d (GRing.opp c)) (trmx (GRing.add d (GRing.opp c)))) (mulmx (GRing.add d' (GRing.opp c')) (trmx (GRing.add d' (GRing.opp c')))))
+++++
rewrite (cosine_rule b) c2 c4 [X in _ == X](cosine_rule b') -!addrA !add2r_eq.
-----
Lemma five_segment a a' b b' c c' d d' : cong a b a' b' -> cong b c b' c' -> cong a d a' d' -> cong b d b' d' -> bet a b c -> bet a' b' c' -> a <> b -> cong c d c' d'.
Proof.
move=> c1 c2 c3 c4 /orP[/betEP[[->->]|->|E]|b1 /orP[/betEP[[E _]|E|E]|b2]]=> //; try solve[rewrite E in c2; apply cong_eq' in c2; move=> _ _; rewrite -c2 -E //]; try solve[rewrite -E in c1; apply cong_eq in c1; rewrite -c1 //]; try solve[rewrite -E in c2; apply cong_eq in c2; rewrite -c2 -E //].
move: c1 c2 c3 c4; rewrite congC /cong=> /eqP c1 /eqP c2 /eqP c3 /eqP c4 _.
rewrite (cosine_rule b) c2 c4 [X in _ == X](cosine_rule b') -!addrA !add2r_eq.

*****
c4 : eq\n (mulmx (GRing.add d (GRing.opp b)) (trmx (GRing.add d (GRing.opp b))))\n (mulmx (GRing.add d' (GRing.opp b'))\n (trmx (GRing.add d' (GRing.opp b'))))
c3 : eq\n (mulmx (GRing.add d (GRing.opp a)) (trmx (GRing.add d (GRing.opp a))))\n (mulmx (GRing.add d' (GRing.opp a'))\n (trmx (GRing.add d' (GRing.opp a'))))
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
b1 : is_true (betS a b c)
a,a',b,b',c,c',d,d' : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.opp (GRing.mul (GRing.natmul (GRing.one (matrix_ringType R O)) (S (S O))) (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add d (GRing.opp b)))))) (GRing.opp (GRing.mul (GRing.natmul (GRing.one (matrix_ringType R O)) (S (S O))) (mulmx (GRing.add c' (GRing.opp b')) (trmx (GRing.add d' (GRing.opp b')))))))
+++++
rewrite (betS_ratio b1) (betS_ratio b2) -!scalemxAl -!scalerAr !cosine_rule'.
-----
Lemma five_segment a a' b b' c c' d d' : cong a b a' b' -> cong b c b' c' -> cong a d a' d' -> cong b d b' d' -> bet a b c -> bet a' b' c' -> a <> b -> cong c d c' d'.
Proof.
move=> c1 c2 c3 c4 /orP[/betEP[[->->]|->|E]|b1 /orP[/betEP[[E _]|E|E]|b2]]=> //; try solve[rewrite E in c2; apply cong_eq' in c2; move=> _ _; rewrite -c2 -E //]; try solve[rewrite -E in c1; apply cong_eq in c1; rewrite -c1 //]; try solve[rewrite -E in c2; apply cong_eq in c2; rewrite -c2 -E //].
move: c1 c2 c3 c4; rewrite congC /cong=> /eqP c1 /eqP c2 /eqP c3 /eqP c4 _.
rewrite (cosine_rule b) c2 c4 [X in _ == X](cosine_rule b') -!addrA !add2r_eq.
rewrite (betS_ratio b1) (betS_ratio b2) -!scalemxAl -!scalerAr !cosine_rule'.

*****
c4 : eq\n (mulmx (GRing.add d (GRing.opp b)) (trmx (GRing.add d (GRing.opp b))))\n (mulmx (GRing.add d' (GRing.opp b'))\n (trmx (GRing.add d' (GRing.opp b'))))
c3 : eq\n (mulmx (GRing.add d (GRing.opp a)) (trmx (GRing.add d (GRing.opp a))))\n (mulmx (GRing.add d' (GRing.opp a'))\n (trmx (GRing.add d' (GRing.opp a'))))
c2 : eq\n (mulmx (GRing.add c (GRing.opp b)) (trmx (GRing.add c (GRing.opp b))))\n (mulmx (GRing.add c' (GRing.opp b'))\n (trmx (GRing.add c' (GRing.opp b'))))
c1 : eq\n (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))\n (mulmx (GRing.add a' (GRing.opp b'))\n (trmx (GRing.add a' (GRing.opp b'))))
b2 : is_true (betS a' b' c')
b1 : is_true (betS a b c)
a,a',b,b',c,c',d,d' : Vector R n
n : nat
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.opp (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp (betR a b c))) (GRing.inv (betR a b c))) (GRing.add (mulmx (GRing.add d (GRing.opp a)) (trmx (GRing.add d (GRing.opp a)))) (GRing.opp (GRing.add (mulmx (GRing.add d (GRing.opp b)) (trmx (GRing.add d (GRing.opp b)))) (mulmx (GRing.add a (GRing.opp b)) (trmx (GRing.add a (GRing.opp b))))))))) (GRing.opp (GRing.scale (GRing.mul (GRing.add (GRing.one R) (GRing.opp (betR a' b' c'))) (GRing.inv (betR a' b' c'))) (GRing.add (mulmx (GRing.add d' (GRing.opp a')) (trmx (GRing.add d' (GRing.opp a')))) (GRing.opp (GRing.add (mulmx (GRing.add d' (GRing.opp b')) (trmx (GRing.add d' (GRing.opp b')))) (mulmx (GRing.add a' (GRing.opp b')) (trmx (GRing.add a' (GRing.opp b'))))))))))
+++++
by rewrite (bet_cong_ratio_eq b1 b2) /cong ?c1 ?c2 ?c3 ?c4.
-----
Lemma five_segment a a' b b' c c' d d' : cong a b a' b' -> cong b c b' c' -> cong a d a' d' -> cong b d b' d' -> bet a b c -> bet a' b' c' -> a <> b -> cong c d c' d'.
Proof.
move=> c1 c2 c3 c4 /orP[/betEP[[->->]|->|E]|b1 /orP[/betEP[[E _]|E|E]|b2]]=> //; try solve[rewrite E in c2; apply cong_eq' in c2; move=> _ _; rewrite -c2 -E //]; try solve[rewrite -E in c1; apply cong_eq in c1; rewrite -c1 //]; try solve[rewrite -E in c2; apply cong_eq in c2; rewrite -c2 -E //].
move: c1 c2 c3 c4; rewrite congC /cong=> /eqP c1 /eqP c2 /eqP c3 /eqP c4 _.
rewrite (cosine_rule b) c2 c4 [X in _ == X](cosine_rule b') -!addrA !add2r_eq.
rewrite (betS_ratio b1) (betS_ratio b2) -!scalemxAl -!scalerAr !cosine_rule'.
by rewrite (bet_cong_ratio_eq b1 b2) /cong ?c1 ?c2 ?c3 ?c4.

*****

*****

+++++
Qed.
-----
Lemma point_equality_decidability a b : a = b \/ ~ a = b.
-----
Lemma point_equality_decidability a b : a = b \\/ ~ a = b.

*****
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
or (eq a b) (not (eq a b))
+++++
Proof.
-----
Lemma point_equality_decidability a b : a = b \\/ ~ a = b.
Proof.

*****
a,b : Vector R n
n : nat
R : Num\.RealField\.type
*****
or (eq a b) (not (eq a b))
+++++
by case: (a =P b); tauto.
-----
Lemma point_equality_decidability a b : a = b \\/ ~ a = b.
Proof.
by case: (a =P b); tauto.

*****

*****

+++++
Qed.
-----
End TarskiGe1.
-----
Section Tarski2D.
-----
Variable R : realFieldType.
-----
Implicit Types (a b c d : (@Vector R 1)).
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).

*****
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op a b) (andb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
+++++
Proof.
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).
Proof.

*****
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op a b) (andb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
+++++
apply /eqP/andP=> [->|[/eqP eq0 /eqP eq1]].
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).
Proof.
apply /eqP/andP=> [->|[/eqP eq0 /eqP eq1]].

*****
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
and (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
+++++
rewrite ?eqxx //.
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).
Proof.
apply /eqP/andP=> [->|[/eqP eq0 /eqP eq1]].

*****
eq1 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
eq0 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq a b
+++++
rewrite ?eqxx //.
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).
Proof.
apply /eqP/andP=> [->|[/eqP eq0 /eqP eq1]].
rewrite ?eqxx //.

*****
eq1 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
eq0 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq a b
+++++
apply/rowP=> j.
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).
Proof.
apply /eqP/andP=> [->|[/eqP eq0 /eqP eq1]].
rewrite ?eqxx //.
apply/rowP=> j.

*****
j : ordinal (S (S O))
eq1 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
eq0 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq (a (GRing.zero (Zp_zmodType O)) j) (b (GRing.zero (Zp_zmodType O)) j)
+++++
case: j => [] [|[|]] //= p.
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).
Proof.
apply /eqP/andP=> [->|[/eqP eq0 /eqP eq1]].
rewrite ?eqxx //.
apply/rowP=> j.
case: j => [] [|[|]] //= p.

*****
p : is_true (leq (S O) (S (S O)))
eq1 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
eq0 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq (a (GRing.zero (Zp_zmodType O)) (Ordinal p)) (b (GRing.zero (Zp_zmodType O)) (Ordinal p))
+++++
by rewrite (@ord_inj _ (Ordinal p) 0).
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).
Proof.
apply /eqP/andP=> [->|[/eqP eq0 /eqP eq1]].
rewrite ?eqxx //.
apply/rowP=> j.
case: j => [] [|[|]] //= p.

*****
p : is_true (leq (S (S O)) (S (S O)))
eq1 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
eq0 : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq (a (GRing.zero (Zp_zmodType O)) (Ordinal p)) (b (GRing.zero (Zp_zmodType O)) (Ordinal p))
+++++
by rewrite (@ord_inj _ (Ordinal p) 1).
-----
Lemma vector2_eq a b : a == b = (a 0 0 == b 0 0) && (a 0 1 == b 0 1).
Proof.
apply /eqP/andP=> [->|[/eqP eq0 /eqP eq1]].

*****

*****

+++++
Qed.
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).

*****
v : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op v (GRing.zero (matrix_zmodType R (S O) (S (S O))))) (andb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)) (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R)))
+++++
Proof.
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.

*****
v : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op v (GRing.zero (matrix_zmodType R (S O) (S (S O))))) (andb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)) (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R)))
+++++
apply /eqP.
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.

*****
v : Vector R (S O)
R : Num\.RealField\.type
*****
if andb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)) (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R)) then eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))) else not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))
+++++
case: (v 0 0 =P 0).
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).

*****
v : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R), if andb true (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R)) then eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))) else not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))
+++++
case: (v 0 1 =P 0)=> V01 V00 /=.
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).
case: (v 0 1 =P 0)=> V01 V00 /=.

*****
V00 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
V01 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
v : Vector R (S O)
R : Num\.RealField\.type
*****
eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))
+++++
try (by apply/rowP=> H; try apply V01; try apply V00; rewrite H mxE).
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).
case: (v 0 1 =P 0)=> V01 V00 /=.
try (by apply/rowP=> H; try apply V01; try apply V00; rewrite H mxE).

*****
V00 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
V01 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
v : Vector R (S O)
R : Num\.RealField\.type
*****
eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))
+++++
apply/rowP=> j.
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).
case: (v 0 1 =P 0)=> V01 V00 /=.
try (by apply/rowP=> H; try apply V01; try apply V00; rewrite H mxE).
apply/rowP=> j.

*****
j : ordinal (S (S O))
V00 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
V01 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
v : Vector R (S O)
R : Num\.RealField\.type
*****
eq (v (GRing.zero (Zp_zmodType O)) j) ((GRing.zero (matrix_zmodType R (S O) (S (S O)))) (GRing.zero (Zp_zmodType O)) j)
+++++
case: j => [] [|[| //]] //= p.
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).
case: (v 0 1 =P 0)=> V01 V00 /=.
try (by apply/rowP=> H; try apply V01; try apply V00; rewrite H mxE).
apply/rowP=> j.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S O) (S (S O)))
V00 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
V01 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
v : Vector R (S O)
R : Num\.RealField\.type
*****
eq (v (GRing.zero (Zp_zmodType O)) (Ordinal p)) ((GRing.zero (matrix_zmodType R (S O) (S (S O)))) (GRing.zero (Zp_zmodType O)) (Ordinal p))
+++++
by rewrite (@ord_inj _ (Ordinal p) 0) // V00 mxE.
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).
case: (v 0 1 =P 0)=> V01 V00 /=.
try (by apply/rowP=> H; try apply V01; try apply V00; rewrite H mxE).
apply/rowP=> j.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S (S O)) (S (S O)))
V00 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
V01 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
v : Vector R (S O)
R : Num\.RealField\.type
*****
eq (v (GRing.zero (Zp_zmodType O)) (Ordinal p)) ((GRing.zero (matrix_zmodType R (S O) (S (S O)))) (GRing.zero (Zp_zmodType O)) (Ordinal p))
+++++
by rewrite (@ord_inj _ (Ordinal p) 1) // V01 mxE.
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).
case: (v 0 1 =P 0)=> V01 V00 /=.

*****
V00 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
V01 : not\n (eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R))
v : Vector R (S O)
R : Num\.RealField\.type
*****
not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))
+++++
try (by apply/rowP=> H; try apply V01; try apply V00; rewrite H mxE).
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).

*****
v : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : not (eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)), if andb false (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R)) then eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))) else not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))
+++++
case: (v 0 1 =P 0)=> V01 V00 /=.
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).
case: (v 0 1 =P 0)=> V01 V00 /=.

*****
V00 : not\n (eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R))
V01 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
v : Vector R (S O)
R : Num\.RealField\.type
*****
not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))
+++++
try (by apply/rowP=> H; try apply V01; try apply V00; rewrite H mxE).
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).
case: (v 0 1 =P 0)=> V01 V00 /=.

*****
V00 : not\n (eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R))
V01 : not\n (eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R))
v : Vector R (S O)
R : Num\.RealField\.type
*****
not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))
+++++
try (by apply/rowP=> H; try apply V01; try apply V00; rewrite H mxE).
-----
Lemma vector2_eq0 (v :(@Vector R 1)) : (v == 0) = (v 0 0 == 0) && (v 0 1 == 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0).

*****

*****

+++++
Qed.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).

*****
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))) (orb (negb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (negb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))))
+++++
Proof.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.

*****
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (negb (eq_op v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))) (orb (negb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (negb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))))
+++++
apply /eqP.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.

*****
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
if orb (negb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (negb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) then not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))) else eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))
+++++
case: (v 0 0 =P 0)=> Hv0.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.

*****
Hv0 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
if orb (negb true) (negb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) then not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))) else eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))
+++++
case: (v 0 1 =P 0)=> Hv1 /=.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.
case: (v 0 1 =P 0)=> Hv1 /=.

*****
Hv1 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
Hv0 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))
+++++
try (by apply/rowP=> H; try apply Hv0; try apply Hv1; rewrite H mxE).
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.
case: (v 0 1 =P 0)=> Hv1 /=.
try (by apply/rowP=> H; try apply Hv0; try apply Hv1; rewrite H mxE).

*****
Hv1 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
Hv0 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))
+++++
apply/rowP=> j.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.
case: (v 0 1 =P 0)=> Hv1 /=.
try (by apply/rowP=> H; try apply Hv0; try apply Hv1; rewrite H mxE).
apply/rowP=> j.

*****
j : ordinal (S (S O))
Hv1 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
Hv0 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v (GRing.zero (Zp_zmodType O)) j) ((GRing.zero (matrix_zmodType R (S O) (S (S O)))) (GRing.zero (Zp_zmodType O)) j)
+++++
case: j => [] [|[| //]] //= p.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.
case: (v 0 1 =P 0)=> Hv1 /=.
try (by apply/rowP=> H; try apply Hv0; try apply Hv1; rewrite H mxE).
apply/rowP=> j.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S O) (S (S O)))
Hv1 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
Hv0 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v (GRing.zero (Zp_zmodType O)) (Ordinal p)) ((GRing.zero (matrix_zmodType R (S O) (S (S O)))) (GRing.zero (Zp_zmodType O)) (Ordinal p))
+++++
by rewrite (@ord_inj _ (Ordinal p) 0) // Hv0 mxE.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.
case: (v 0 1 =P 0)=> Hv1 /=.
try (by apply/rowP=> H; try apply Hv0; try apply Hv1; rewrite H mxE).
apply/rowP=> j.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S (S O)) (S (S O)))
Hv1 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
Hv0 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v (GRing.zero (Zp_zmodType O)) (Ordinal p)) ((GRing.zero (matrix_zmodType R (S O) (S (S O)))) (GRing.zero (Zp_zmodType O)) (Ordinal p))
+++++
by rewrite (@ord_inj _ (Ordinal p) 1) // Hv1 mxE.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.
case: (v 0 1 =P 0)=> Hv1 /=.

*****
Hv1 : not\n (eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R))
Hv0 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))
+++++
try (by apply/rowP=> H; try apply Hv0; try apply Hv1; rewrite H mxE).
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.

*****
Hv0 : not\n (eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R))
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
if orb (negb false) (negb (eq_op (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) then not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))) else eq v (GRing.zero (matrix_zmodType R (S O) (S (S O))))
+++++
case: (v 0 1 =P 0)=> Hv1 /=.
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.
case: (v 0 1 =P 0)=> Hv1 /=.

*****
Hv1 : eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
Hv0 : not\n (eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R))
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))
+++++
try (by apply/rowP=> H; try apply Hv0; try apply Hv1; rewrite H mxE).
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.
case: (v 0 1 =P 0)=> Hv1 /=.

*****
Hv1 : not\n (eq (v (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R))
Hv0 : not\n (eq (v (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R))
v : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
not (eq v (GRing.zero (matrix_zmodType R (S O) (S (S O)))))
+++++
try (by apply/rowP=> H; try apply Hv0; try apply Hv1; rewrite H mxE).
-----
Lemma vector2_neq0 (v : 'rV[R]_(2)) : (v != 0) = (v 0 0 != 0) || (v 0 1 != 0).
Proof.
apply /eqP.
case: (v 0 0 =P 0)=> Hv0.

*****

*****

+++++
Qed.
-----
Definition sqr_L2_norm_2D a b :=\n  (b 0 0 - a 0 0) ^+ 2 + (b 0 1 - a 0 1) ^+ 2.
-----
Lemma congP_aux' a b : (b - a) *m (b - a)^T = (sqr_L2_norm_2D a b)%:M.
-----
Lemma congP_aux' a b : (b - a) *m (b - a)^T = (sqr_L2_norm_2D a b)%:M.

*****
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq (mulmx (GRing.add b (GRing.opp a)) (trmx (GRing.add b (GRing.opp a)))) (scalar_mx (sqr_L2_norm_2D a b))
+++++
Proof.
-----
Lemma congP_aux' a b : (b - a) *m (b - a)^T = (sqr_L2_norm_2D a b)%:M.
Proof.

*****
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq (mulmx (GRing.add b (GRing.opp a)) (trmx (GRing.add b (GRing.opp a)))) (scalar_mx (sqr_L2_norm_2D a b))
+++++
rewrite [X in X=_]mx11_scalar /sqr_L2_norm_2D !mxE.
-----
Lemma congP_aux' a b : (b - a) *m (b - a)^T = (sqr_L2_norm_2D a b)%:M.
Proof.
rewrite [X in X=_]mx11_scalar /sqr_L2_norm_2D !mxE.

*****
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq (scalar_mx (BigOp.bigop (GRing.zero R) (index_enum (ordinal_finType (S (S O)))) (fun j : ordinal_finType (S (S O)) => BigBody j (GRing.add (V:=R)) true (GRing.mul ((GRing.add b (GRing.opp a)) (GRing.zero (Zp_zmodType O)) j) ((trmx (GRing.add b (GRing.opp a))) j (GRing.zero (Zp_zmodType O))))))) (scalar_mx (GRing.add (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))))
+++++
rewrite !big_ord_recr /= big_ord0 add0r !mxE -!expr2.
-----
Lemma congP_aux' a b : (b - a) *m (b - a)^T = (sqr_L2_norm_2D a b)%:M.
Proof.
rewrite [X in X=_]mx11_scalar /sqr_L2_norm_2D !mxE.
rewrite !big_ord_recr /= big_ord0 add0r !mxE -!expr2.

*****
a,b : Vector R (S O)
R : Num\.RealField\.type
*****
eq (scalar_mx (GRing.add (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (widen_ord (leqnSn (S O)) ord_max)) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (widen_ord (leqnSn (S O)) ord_max)))) (S (S O))) (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) ord_max) (GRing.opp (a (GRing.zero (Zp_zmodType O)) ord_max))) (S (S O))))) (scalar_mx (GRing.add (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))))
+++++
by congr ((b 0 _ - a 0 _) ^+ 2 + (b 0 _ - a 0 _) ^+ 2)%:M; apply: val_inj.
-----
Lemma congP_aux' a b : (b - a) *m (b - a)^T = (sqr_L2_norm_2D a b)%:M.
Proof.
rewrite [X in X=_]mx11_scalar /sqr_L2_norm_2D !mxE.
rewrite !big_ord_recr /= big_ord0 add0r !mxE -!expr2.
by congr ((b 0 _ - a 0 _) ^+ 2 + (b 0 _ - a 0 _) ^+ 2)%:M; apply: val_inj.

*****

*****

+++++
Qed.
-----
Lemma congP_aux a b c d :\n  cong a b c d = (sqr_L2_norm_2D a b == sqr_L2_norm_2D c d).
-----
Lemma congP_aux a b c d : cong a b c d = (sqr_L2_norm_2D a b == sqr_L2_norm_2D c d).

*****
a,b,c,d : Vector R (S O)
R : Num\.RealField\.type
*****
eq (cong a b c d) (eq_op (sqr_L2_norm_2D a b) (sqr_L2_norm_2D c d))
+++++
Proof.
-----
Lemma congP_aux a b c d : cong a b c d = (sqr_L2_norm_2D a b == sqr_L2_norm_2D c d).
Proof.

*****
a,b,c,d : Vector R (S O)
R : Num\.RealField\.type
*****
eq (cong a b c d) (eq_op (sqr_L2_norm_2D a b) (sqr_L2_norm_2D c d))
+++++
rewrite /cong !congP_aux' /sqr_L2_norm_2D; apply /eqP/eqP=> [|->] //.
-----
Lemma congP_aux a b c d : cong a b c d = (sqr_L2_norm_2D a b == sqr_L2_norm_2D c d).
Proof.
rewrite /cong !congP_aux' /sqr_L2_norm_2D; apply /eqP/eqP=> [|->] //.

*****
a,b,c,d : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : eq (scalar_mx (GRing.add (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O))))) (scalar_mx (GRing.add (GRing.exp (GRing.add (d (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (d (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O))))), eq (GRing.add (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (d (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (d (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O))))
+++++
move=>/matrixP /(_ 0 0) /eqP.
-----
Lemma congP_aux a b c d : cong a b c d = (sqr_L2_norm_2D a b == sqr_L2_norm_2D c d).
Proof.
rewrite /cong !congP_aux' /sqr_L2_norm_2D; apply /eqP/eqP=> [|->] //.
move=>/matrixP /(_ 0 0) /eqP.

*****
a,b,c,d : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : eq_op ((scalar_mx (GRing.add (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O))))) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))) ((scalar_mx (GRing.add (GRing.exp (GRing.add (d (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (d (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O))))) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))), eq (GRing.add (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (d (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (d (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O))))
+++++
by rewrite !mxE /= !mulr1n; apply /eqP.
-----
Lemma congP_aux a b c d : cong a b c d = (sqr_L2_norm_2D a b == sqr_L2_norm_2D c d).
Proof.
rewrite /cong !congP_aux' /sqr_L2_norm_2D; apply /eqP/eqP=> [|->] //.
move=>/matrixP /(_ 0 0) /eqP.
by rewrite !mxE /= !mulr1n; apply /eqP.

*****

*****

+++++
Qed.
-----
Lemma congP a b c d :\n  reflect (sqr_L2_norm_2D a b = sqr_L2_norm_2D c d) (cong a b c d).
-----
Lemma congP a b c d : reflect (sqr_L2_norm_2D a b = sqr_L2_norm_2D c d) (cong a b c d).

*****
a,b,c,d : Vector R (S O)
R : Num\.RealField\.type
*****
Bool.reflect (eq (sqr_L2_norm_2D a b) (sqr_L2_norm_2D c d)) (cong a b c d)
+++++
Proof.
-----
Lemma congP a b c d : reflect (sqr_L2_norm_2D a b = sqr_L2_norm_2D c d) (cong a b c d).
Proof.

*****
a,b,c,d : Vector R (S O)
R : Num\.RealField\.type
*****
Bool.reflect (eq (sqr_L2_norm_2D a b) (sqr_L2_norm_2D c d)) (cong a b c d)
+++++
by rewrite !congP_aux; exact /eqP.
-----
Lemma congP a b c d : reflect (sqr_L2_norm_2D a b = sqr_L2_norm_2D c d) (cong a b c d).
Proof.
by rewrite !congP_aux; exact /eqP.

*****

*****

+++++
Qed.
-----
Definition betSP'_aux a b c k :\n  b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) &&\n                          (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).

*****
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.add b (GRing.opp a)) (GRing.scale k (GRing.add c (GRing.opp a)))) (andb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))
+++++
Proof.
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.

*****
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.add b (GRing.opp a)) (GRing.scale k (GRing.add c (GRing.opp a)))) (andb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))
+++++
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].

*****
eq : eqrel (GRing.add b (GRing.opp a))\n (GRing.scale k (GRing.add c (GRing.opp a)))
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
apply /andP.
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].
apply /andP.

*****
eq : eqrel (GRing.add b (GRing.opp a))\n (GRing.scale k (GRing.add c (GRing.opp a)))
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (andb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))
+++++
have eq_i i: (b 0 i - a 0 i = (b - a) 0 i) by rewrite !mxE.
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].
apply /andP.
have eq_i i: (b 0 i - a 0 i = (b - a) 0 i) by rewrite !mxE.

*****
eq_i : forall i : ordinal (S (S O)),\nLogic.eq\n (GRing.add (b (GRing.zero (Zp_zmodType O)) i)\n (GRing.opp (a (GRing.zero (Zp_zmodType O)) i)))\n ((GRing.add b (GRing.opp a)) (GRing.zero (Zp_zmodType O)) i)
eq : eqrel (GRing.add b (GRing.opp a))\n (GRing.scale k (GRing.add c (GRing.opp a)))
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (andb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))
+++++
by rewrite !eq_i !eq !mxE !eq_refl.
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].

*****
eq1 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
eq0 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Logic.eq (GRing.add b (GRing.opp a)) (GRing.scale k (GRing.add c (GRing.opp a)))
+++++
idtac.
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].
idtac.

*****
eq1 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
eq0 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Logic.eq (GRing.add b (GRing.opp a)) (GRing.scale k (GRing.add c (GRing.opp a)))
+++++
apply/rowP=> j.
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].
idtac.
apply/rowP=> j.

*****
j : ordinal (S (S O))
eq1 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
eq0 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq ((GRing.add b (GRing.opp a)) (GRing.zero (Zp_zmodType O)) j) ((GRing.scale k (GRing.add c (GRing.opp a))) (GRing.zero (Zp_zmodType O)) j)
+++++
rewrite !mxE.
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].
idtac.
apply/rowP=> j.
rewrite !mxE.

*****
j : ordinal (S (S O))
eq1 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
eq0 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (GRing.add (b (GRing.zero (Zp_zmodType O)) j) (GRing.opp (a (GRing.zero (Zp_zmodType O)) j))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) j) (GRing.opp (a (GRing.zero (Zp_zmodType O)) j))))
+++++
case: j => [] [|[| //]] //= p.
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].
idtac.
apply/rowP=> j.
rewrite !mxE.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S O) (S (S O)))
eq1 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
eq0 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (Ordinal p)) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (Ordinal p)))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (Ordinal p)) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (Ordinal p)))))
+++++
rewrite (@ord_inj _ (Ordinal p) 0) //.
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].
idtac.
apply/rowP=> j.
rewrite !mxE.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S (S O)) (S (S O)))
eq1 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
eq0 : Logic.eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul k\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
k : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (Ordinal p)) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (Ordinal p)))) (GRing.mul k (GRing.add (c (GRing.zero (Zp_zmodType O)) (Ordinal p)) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (Ordinal p)))))
+++++
by rewrite (@ord_inj _ (Ordinal p) 1).
-----
Definition betSP'_aux a b c k : b - a == k *: (c - a) = (b 0 0 - a 0 0 == k * (c 0 0 - a 0 0)) && (b 0 1 - a 0 1 == k * (c 0 1 - a 0 1)).
Proof.
apply /eqP/andP=> [/matrixP eq|[/eqP eq0 /eqP eq1]].

*****

*****

+++++
Qed.
-----
Lemma betSP' a b c (r := betR a b c) :\n  reflect ([ /\ b 0 0 - a 0 0 = r * (c 0 0 - a 0 0),\n               b 0 1 - a 0 1 = r * (c 0 1 - a 0 1), 0 < r & r < 1])\n          (betS a b c).
-----
Lemma betSP' a b c (r := betR a b c) : reflect ([ /\\ b 0 0 - a 0 0 = r * (c 0 0 - a 0 0), b 0 1 - a 0 1 = r * (c 0 1 - a 0 1), 0 < r & r < 1]) (betS a b c).

*****
r : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Bool.reflect (and4 (eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.mul r (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul r (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))) (betS a b c)
+++++
Proof.
-----
Lemma betSP' a b c (r := betR a b c) : reflect ([ /\\ b 0 0 - a 0 0 = r * (c 0 0 - a 0 0), b 0 1 - a 0 1 = r * (c 0 1 - a 0 1), 0 < r & r < 1]) (betS a b c).
Proof.

*****
r : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Bool.reflect (and4 (eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.mul r (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul r (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))) (betS a b c)
+++++
rewrite /betS -/r betSP'_aux.
-----
Lemma betSP' a b c (r := betR a b c) : reflect ([ /\\ b 0 0 - a 0 0 = r * (c 0 0 - a 0 0), b 0 1 - a 0 1 = r * (c 0 1 - a 0 1), 0 < r & r < 1]) (betS a b c).
Proof.
rewrite /betS -/r betSP'_aux.

*****
r : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Bool.reflect (and4 (eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.mul r (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul r (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))) (andb (andb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.mul r (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul r (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))) (andb (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))))
+++++
case: (b 0 0-a 0 0 =P r*(c 0 0-a 0 0))=> [<-|]; case: (b 0 1-a 0 1 =P r*(c 0 1-a 0 1))=> [<-|]; try solve[by constructor; case].
-----
Lemma betSP' a b c (r := betR a b c) : reflect ([ /\\ b 0 0 - a 0 0 = r * (c 0 0 - a 0 0), b 0 1 - a 0 1 = r * (c 0 1 - a 0 1), 0 < r & r < 1]) (betS a b c).
Proof.
rewrite /betS -/r betSP'_aux.
case: (b 0 0-a 0 0 =P r*(c 0 0-a 0 0))=> [<-|]; case: (b 0 1-a 0 1 =P r*(c 0 1-a 0 1))=> [<-|]; try solve[by constructor; case].

*****
r : GRing.Ring.sort R
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Bool.reflect (and4 (eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (eq (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))) (andb (andb true true) (andb (Num.Def.ltr (GRing.zero R) r) (Num.Def.ltr r (GRing.one R))))
+++++
by case: (0 < r); case: (r < 1)=> /=; constructor; try (case=> //).
-----
Lemma betSP' a b c (r := betR a b c) : reflect ([ /\\ b 0 0 - a 0 0 = r * (c 0 0 - a 0 0), b 0 1 - a 0 1 = r * (c 0 1 - a 0 1), 0 < r & r < 1]) (betS a b c).
Proof.
rewrite /betS -/r betSP'_aux.
case: (b 0 0-a 0 0 =P r*(c 0 0-a 0 0))=> [<-|]; case: (b 0 1-a 0 1 =P r*(c 0 1-a 0 1))=> [<-|]; try solve[by constructor; case].
by case: (0 < r); case: (r < 1)=> /=; constructor; try (case=> //).

*****

*****

+++++
Qed.
-----
Lemma markov_betE a b c :\n  ~ ~ [ /\ [ \/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] &\n           [ \/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] ->\n [ /\ [ \/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] &\n      [ \/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : not (not (and (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))), and (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
Proof.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : not (not (and (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))), and (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (a 0 0 =P b 0 0).
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (not (and (or (negb true) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb true) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (a 0 1 =P b 0 1).
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (not (and (or (negb true) (negb true)) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb true) (negb true)) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 0 =P c 0 0).
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (not (and (or (negb true) (negb true)) (or (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb true) (negb true)) (or (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or false false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or false false) (or false false)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or false false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or false false) (or false false))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or false false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or false false) (or false true)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or false false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or false false) (or false true))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (not (and (or (negb true) (negb true)) (or (negb false) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb true) (negb true)) (or (negb false) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or false false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or false false) (or true false)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or false false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or false false) (or true false))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or false false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or false false) (or true true)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or false false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or false false) (or true true))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (not (and (or (negb true) (negb false)) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb true) (negb false)) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 0 =P c 0 0).
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (not (and (or (negb true) (negb false)) (or (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb true) (negb false)) (or (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or false true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or false true) (or false false)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or false true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or false true) (or false false))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or false true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or false true) (or false true)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or false true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or false true) (or false true))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (not (and (or (negb true) (negb false)) (or (negb false) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb true) (negb false)) (or (negb false) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or false true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or false true) (or true false)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or false true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or false true) (or true false))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or false true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or false true) (or true true)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or false true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or false true) (or true true))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or false true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or false true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : not (not (and (or (negb false) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb false) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (a 0 1 =P b 0 1).
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : not (not (and (or (negb false) (negb true)) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb false) (negb true)) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 0 =P c 0 0).
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : not (not (and (or (negb false) (negb true)) (or (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb false) (negb true)) (or (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or true false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or true false) (or false false)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or true false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or true false) (or false false))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or true false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or true false) (or false true)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or true false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or true false) (or false true))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : not (not (and (or (negb false) (negb true)) (or (negb false) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb false) (negb true)) (or (negb false) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or true false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or true false) (or true false)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or true false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or true false) (or true false))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or true false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or true false) (or true true)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or true false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or true false) (or true true))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true false) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : not (not (and (or (negb false) (negb false)) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb false) (negb false)) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 0 =P c 0 0).
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : not (not (and (or (negb false) (negb false)) (or (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb false) (negb false)) (or (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or true true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or true true) (or false false)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or true true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or true true) (or false false))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or false false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or true true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or true true) (or false true)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or true true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or true true) (or false true))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or false true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or false true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (_ : not (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (_ : not (not (and (or (negb false) (negb false)) (or (negb false) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))), and (or (negb false) (negb false)) (or (negb false) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or true true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or true true) (or true false)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or true true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or true true) (or true false))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true false)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or true false)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable false
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.

*****
_Hyp_ : not (not (and (or true true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
and (or true true) (or true true)
+++++
apply Decidable.not_not=> //.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.

*****
_Hyp_ : not (not (and (or true true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (and (or true true) (or true true))
+++++
apply Decidable.dec_and.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.

*****
_Hyp_ : not (not (and (or true true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or true true)
+++++
apply Decidable.dec_or.
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).
case: (a 0 1 =P b 0 1).
case: (b 0 0 =P c 0 0).
case: (b 0 1 =P c 0 1)=> _ _ _ _ /= ?.
apply Decidable.not_not=> //.
apply Decidable.dec_and.
apply Decidable.dec_or.

*****
_Hyp_ : not (not (and (or true true) (or true true)))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable true
+++++
solve[left=> //|right=> //].
-----
Lemma markov_betE a b c : ~ ~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ] -> [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ].
Proof.
case: (a 0 0 =P b 0 0).

*****

*****

+++++
Qed.
-----
Lemma betEP' a b c :\n  reflect (~ [ /\ [ \/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] &\n             [ \/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ]) (betE a b c).
-----
Lemma betEP' a b c : reflect (~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ]) (betE a b c).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Bool.reflect (not (and (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))) (betE a b c)
+++++
Proof.
-----
Lemma betEP' a b c : reflect (~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ]) (betE a b c).
Proof.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Bool.reflect (not (and (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))) (betE a b c)
+++++
rewrite /betE; case: (a =P b)=>[->|/eqP N1]; case: (b =P c)=>[->|/eqP N2]=> /=; constructor; try solve[move=> [[/eqP H|/eqP H] _]; apply H=> //]; try solve[move=> [_ [/eqP H|/eqP H]]; apply H=> //].
-----
Lemma betEP' a b c : reflect (~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ]) (betE a b c).
Proof.
rewrite /betE; case: (a =P b)=>[->|/eqP N1]; case: (b =P c)=>[->|/eqP N2]=> /=; constructor; try solve[move=> [[/eqP H|/eqP H] _]; apply H=> //]; try solve[move=> [_ [/eqP H|/eqP H]]; apply H=> //].

*****
N2 : is_true (negb (eq_op b c))
N1 : is_true (negb (eq_op a b))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
not (not (and (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))
+++++
move: N1 N2.
-----
Lemma betEP' a b c : reflect (~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ]) (betE a b c).
Proof.
rewrite /betE; case: (a =P b)=>[->|/eqP N1]; case: (b =P c)=>[->|/eqP N2]=> /=; constructor; try solve[move=> [[/eqP H|/eqP H] _]; apply H=> //]; try solve[move=> [_ [/eqP H|/eqP H]]; apply H=> //].
move: N1 N2.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op a b)) (_ : negb (eq_op b c)), not (not (and (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))
+++++
rewrite !vector2_eq !negb_and=> /orP N1 /orP N2.
-----
Lemma betEP' a b c : reflect (~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ]) (betE a b c).
Proof.
rewrite /betE; case: (a =P b)=>[->|/eqP N1]; case: (b =P c)=>[->|/eqP N2]=> /=; constructor; try solve[move=> [[/eqP H|/eqP H] _]; apply H=> //]; try solve[move=> [_ [/eqP H|/eqP H]]; apply H=> //].
move: N1 N2.
rewrite !vector2_eq !negb_and=> /orP N1 /orP N2.

*****
N2 : or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
N1 : or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
not (not (and (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))
+++++
move=> H; apply Decidable.not_and in H; first by move: H=> [H|H].
-----
Lemma betEP' a b c : reflect (~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ]) (betE a b c).
Proof.
rewrite /betE; case: (a =P b)=>[->|/eqP N1]; case: (b =P c)=>[->|/eqP N2]=> /=; constructor; try solve[move=> [[/eqP H|/eqP H] _]; apply H=> //]; try solve[move=> [_ [/eqP H|/eqP H]]; apply H=> //].
move: N1 N2.
rewrite !vector2_eq !negb_and=> /orP N1 /orP N2.
move=> H; apply Decidable.not_and in H; first by move: H=> [H|H].

*****
H : not\n (and\n (or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))\n (or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))))
N2 : or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
N1 : or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
Decidable.decidable (or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
case: (a 0 0 =P b 0 0)=> ?; case: (a 0 1 =P b 0 1)=> ?; intuition.
-----
Lemma betEP' a b c : reflect (~ [ /\\ [ \\/ a 0 0 != b 0 0 | a 0 1 != b 0 1 ] & [ \\/ b 0 0 != c 0 0 | b 0 1 != c 0 1 ] ]) (betE a b c).
Proof.
rewrite /betE; case: (a =P b)=>[->|/eqP N1]; case: (b =P c)=>[->|/eqP N2]=> /=; constructor; try solve[move=> [[/eqP H|/eqP H] _]; apply H=> //]; try solve[move=> [_ [/eqP H|/eqP H]]; apply H=> //].
move: N1 N2.
rewrite !vector2_eq !negb_and=> /orP N1 /orP N2.
move=> H; apply Decidable.not_and in H; first by move: H=> [H|H].
case: (a 0 0 =P b 0 0)=> ?; case: (a 0 1 =P b 0 1)=> ?; intuition.

*****

*****

+++++
Qed.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) :\n  v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 ->\n  v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.

*****
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : negb (eq_op (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) (_ : eq_op (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))), eq (ratio v1 v2) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
Proof.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.

*****
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : negb (eq_op (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) (_ : eq_op (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))), eq (ratio v1 v2) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
move=> NE1 NE2 NE3 NE4 /eqP E.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.

*****
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (ratio v1 v2) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
apply ratio_eq.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
apply ratio_eq.

*****
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (negb (eq_op v2 (GRing.zero (matrix_zmodType R (S O) (S (S O))))))
+++++
by rewrite vector2_neq0 NE3.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
apply ratio_eq.

*****
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op v1 (GRing.scale (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) v2))
+++++
idtac.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
apply ratio_eq.
idtac.

*****
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op v1 (GRing.scale (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) v2))
+++++
apply/eqP/rowP=> j.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
apply ratio_eq.
idtac.
apply/eqP/rowP=> j.

*****
j : ordinal (S (S O))
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v1 (GRing.zero (Zp_zmodType O)) j) ((GRing.scale (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) v2) (GRing.zero (Zp_zmodType O)) j)
+++++
rewrite !mxE.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
apply ratio_eq.
idtac.
apply/eqP/rowP=> j.
rewrite !mxE.

*****
j : ordinal (S (S O))
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v1 (GRing.zero (Zp_zmodType O)) j) (GRing.mul (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (v2 (GRing.zero (Zp_zmodType O)) j))
+++++
case: j => [] [|[| //]] //= p.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
apply ratio_eq.
idtac.
apply/eqP/rowP=> j.
rewrite !mxE.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S O) (S (S O)))
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v1 (GRing.zero (Zp_zmodType O)) (Ordinal p)) (GRing.mul (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (v2 (GRing.zero (Zp_zmodType O)) (Ordinal p)))
+++++
by rewrite (@ord_inj _ (Ordinal p) 0) // -mulrA mulVf // mulr1.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
apply ratio_eq.
idtac.
apply/eqP/rowP=> j.
rewrite !mxE.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S (S O)) (S (S O)))
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v1 (GRing.zero (Zp_zmodType O)) (Ordinal p)) (GRing.mul (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (v2 (GRing.zero (Zp_zmodType O)) (Ordinal p)))
+++++
by rewrite (@ord_inj _ (Ordinal p) 1) // -mulrAC E -mulrA divff // mulr1.
-----
Lemma ratioP_aux (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
apply ratio_eq.

*****

*****

+++++
Qed.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) :\n  v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 ->\n  v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.

*****
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : negb (eq_op (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) (_ : eq_op (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))), eq v1 (GRing.scale (ratio v1 v2) v2)
+++++
Proof.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.
Proof.

*****
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : negb (eq_op (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))) (_ : eq_op (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))), eq v1 (GRing.scale (ratio v1 v2) v2)
+++++
move=> NE1 NE2 NE3 NE4 /eqP E.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.

*****
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq v1 (GRing.scale (ratio v1 v2) v2)
+++++
rewrite ratioP_aux 1?E //.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
rewrite ratioP_aux 1?E //.

*****
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq v1 (GRing.scale (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) v2)
+++++
apply/rowP=> j.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
rewrite ratioP_aux 1?E //.
apply/rowP=> j.

*****
j : ordinal (S (S O))
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v1 (GRing.zero (Zp_zmodType O)) j) ((GRing.scale (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) v2) (GRing.zero (Zp_zmodType O)) j)
+++++
rewrite !mxE.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
rewrite ratioP_aux 1?E //.
apply/rowP=> j.
rewrite !mxE.

*****
j : ordinal (S (S O))
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v1 (GRing.zero (Zp_zmodType O)) j) (GRing.mul (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (v2 (GRing.zero (Zp_zmodType O)) j))
+++++
case: j => [] [|[| //]] //= p.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
rewrite ratioP_aux 1?E //.
apply/rowP=> j.
rewrite !mxE.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S O) (S (S O)))
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v1 (GRing.zero (Zp_zmodType O)) (Ordinal p)) (GRing.mul (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (v2 (GRing.zero (Zp_zmodType O)) (Ordinal p)))
+++++
by rewrite (@ord_inj _ (Ordinal p) 0) // -mulrA mulVf // mulr1.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
rewrite ratioP_aux 1?E //.
apply/rowP=> j.
rewrite !mxE.
case: j => [] [|[| //]] //= p.

*****
p : is_true (leq (S (S O)) (S (S O)))
E : eq\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))\n (GRing.mul\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
NE4 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE3 : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
NE2 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
NE1 : is_true\n (negb\n (eq_op\n (v1 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (v1 (GRing.zero (Zp_zmodType O)) (Ordinal p)) (GRing.mul (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (v2 (GRing.zero (Zp_zmodType O)) (Ordinal p)))
+++++
by rewrite (@ord_inj _ (Ordinal p) 1) // -mulrAC E -mulrA divff // mulr1.
-----
Lemma ratioP (v1 v2 : 'rV[R]_(2)) : v1 0 0 != 0 -> v1 0 1 != 0 -> v2 0 0 != 0 -> v2 0 1 != 0 -> v1 0 0 * v2 0 1 == v1 0 1 * v2 0 0 -> v1 = ratio v1 v2 *: v2.
Proof.
move=> NE1 NE2 NE3 NE4 /eqP E.
rewrite ratioP_aux 1?E //.
apply/rowP=> j.
rewrite !mxE.
case: j => [] [|[| //]] //= p.

*****

*****

+++++
Qed.
-----
Lemma ratio_e0_n1 (v1 v2 : 'rV[R]_(2)) :\n  v2 0 0 = 0 -> v2 0 1 != 0 -> ratio v1 v2 = v1 0 1 / v2 0 1.
-----
Lemma ratio_e0_n1 (v1 v2 : 'rV[R]_(2)) : v2 0 0 = 0 -> v2 0 1 != 0 -> ratio v1 v2 = v1 0 1 / v2 0 1.

*****
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))), eq (ratio v1 v2) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
+++++
Proof.
-----
Lemma ratio_e0_n1 (v1 v2 : 'rV[R]_(2)) : v2 0 0 = 0 -> v2 0 1 != 0 -> ratio v1 v2 = v1 0 1 / v2 0 1.
Proof.

*****
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R))), eq (ratio v1 v2) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
+++++
move=> E NE; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orbT=> H; exfalso; apply H.
-----
Lemma ratio_e0_n1 (v1 v2 : 'rV[R]_(2)) : v2 0 0 = 0 -> v2 0 1 != 0 -> ratio v1 v2 = v1 0 1 / v2 0 1.
Proof.
move=> E NE; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orbT=> H; exfalso; apply H.

*****
i : is_true (leq (S m) (S (S O)))
m : nat
x : Finite.sort (ordinal_finType (S (S O)))
NE : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
E : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.zero R)), eq (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
+++++
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.
-----
Lemma ratio_e0_n1 (v1 v2 : 'rV[R]_(2)) : v2 0 0 = 0 -> v2 0 1 != 0 -> ratio v1 v2 = v1 0 1 / v2 0 1.
Proof.
move=> E NE; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orbT=> H; exfalso; apply H.
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.

*****
i : is_true (leq (S m) (S (S O)))
m : nat
x : Finite.sort (ordinal_finType (S (S O)))
NE : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
E : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : orb (eq_op m (S O)) (eq_op m O)) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.zero R))), eq (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
+++++
move=> /orP[/eqP E'|/eqP E']; move: i; rewrite E'=> i.
-----
Lemma ratio_e0_n1 (v1 v2 : 'rV[R]_(2)) : v2 0 0 = 0 -> v2 0 1 != 0 -> ratio v1 v2 = v1 0 1 / v2 0 1.
Proof.
move=> E NE; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orbT=> H; exfalso; apply H.
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.
move=> /orP[/eqP E'|/eqP E']; move: i; rewrite E'=> i.

*****
i : is_true (leq (S (S O)) (S (S O)))
E' : eq m (S O)
m : nat
x : Finite.sort (ordinal_finType (S (S O)))
NE : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
E : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.zero R)), eq (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
+++++
by rewrite (@ord_inj _ (Ordinal i) 1) // (@ord_inj _ (Ordinal p) 0).
-----
Lemma ratio_e0_n1 (v1 v2 : 'rV[R]_(2)) : v2 0 0 = 0 -> v2 0 1 != 0 -> ratio v1 v2 = v1 0 1 / v2 0 1.
Proof.
move=> E NE; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orbT=> H; exfalso; apply H.
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.
move=> /orP[/eqP E'|/eqP E']; move: i; rewrite E'=> i.
by rewrite (@ord_inj _ (Ordinal i) 1) // (@ord_inj _ (Ordinal p) 0).

*****
i : is_true (leq (S O) (S (S O)))
E' : eq m O
m : nat
x : Finite.sort (ordinal_finType (S (S O)))
NE : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)))
E : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.zero R)
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.zero R)), eq (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
+++++
by rewrite (@ord_inj _ (Ordinal i) 0) // E=> /eqP NE'.
-----
Lemma ratio_e0_n1 (v1 v2 : 'rV[R]_(2)) : v2 0 0 = 0 -> v2 0 1 != 0 -> ratio v1 v2 = v1 0 1 / v2 0 1.
Proof.
move=> E NE; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orbT=> H; exfalso; apply H.
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.
move=> /orP[/eqP E'|/eqP E']; move: i; rewrite E'=> i.
by rewrite (@ord_inj _ (Ordinal i) 1) // (@ord_inj _ (Ordinal p) 0).
by rewrite (@ord_inj _ (Ordinal i) 0) // E=> /eqP NE'.

*****

*****

+++++
Qed.
-----
Lemma ratio_e1_n0 (v1 v2 : 'rV[R]_(2)) :\n  v2 0 0 != 0 -> v2 0 1 = 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
-----
Lemma ratio_e1_n0 (v1 v2 : 'rV[R]_(2)) : v2 0 0 != 0 -> v2 0 1 = 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.

*****
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R)), eq (ratio v1 v2) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
Proof.
-----
Lemma ratio_e1_n0 (v1 v2 : 'rV[R]_(2)) : v2 0 0 != 0 -> v2 0 1 = 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.

*****
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R))) (_ : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.zero R)), eq (ratio v1 v2) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
move=> NE E; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orTb=> H; exfalso; apply H.
-----
Lemma ratio_e1_n0 (v1 v2 : 'rV[R]_(2)) : v2 0 0 != 0 -> v2 0 1 = 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE E; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orTb=> H; exfalso; apply H.

*****
i : is_true (leq (S m) (S (S O)))
m : nat
x : Finite.sort (ordinal_finType (S (S O)))
E : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
NE : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.zero R)), eq (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.
-----
Lemma ratio_e1_n0 (v1 v2 : 'rV[R]_(2)) : v2 0 0 != 0 -> v2 0 1 = 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE E; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orTb=> H; exfalso; apply H.
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.

*****
i : is_true (leq (S m) (S (S O)))
m : nat
x : Finite.sort (ordinal_finType (S (S O)))
E : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
NE : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : orb (eq_op m (S O)) (eq_op m O)) (_ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.zero R))), eq (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
move=> /orP[/eqP E'|/eqP E']; move: i; rewrite E'=> i.
-----
Lemma ratio_e1_n0 (v1 v2 : 'rV[R]_(2)) : v2 0 0 != 0 -> v2 0 1 = 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE E; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orTb=> H; exfalso; apply H.
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.
move=> /orP[/eqP E'|/eqP E']; move: i; rewrite E'=> i.

*****
i : is_true (leq (S (S O)) (S (S O)))
E' : eq m (S O)
m : nat
x : Finite.sort (ordinal_finType (S (S O)))
E : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
NE : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.zero R)), eq (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
by rewrite (@ord_inj _ (Ordinal i) 1) // E=> /eqP NE'.
-----
Lemma ratio_e1_n0 (v1 v2 : 'rV[R]_(2)) : v2 0 0 != 0 -> v2 0 1 = 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE E; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orTb=> H; exfalso; apply H.
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.
move=> /orP[/eqP E'|/eqP E']; move: i; rewrite E'=> i.
by rewrite (@ord_inj _ (Ordinal i) 1) // E=> /eqP NE'.

*****
i : is_true (leq (S O) (S (S O)))
E' : eq m O
m : nat
x : Finite.sort (ordinal_finType (S (S O)))
E : eq (v2 (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.zero R)
NE : is_true\n (negb\n (eq_op\n (v2 (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))) (GRing.zero R)))
v1,v2 : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.zero R)), eq (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (Ordinal i)) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (Ordinal i)))) (GRing.mul (v1 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.inv (v2 (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
by rewrite (@ord_inj _ (Ordinal i) 0) // (@ord_inj _ (Ordinal p) 0).
-----
Lemma ratio_e1_n0 (v1 v2 : 'rV[R]_(2)) : v2 0 0 != 0 -> v2 0 1 = 0 -> ratio v1 v2 = v1 0 0 / v2 0 0.
Proof.
move=> NE E; rewrite /ratio; case: pickP=> [x|/all_v_neq0 H]; [elim x=> m i|]; last by move: H; rewrite vector2_neq0 NE orTb=> H; exfalso; apply H.
have: ((m == 1)%N || (m == 0)%N) by rewrite -leqn0 -ltnS -leq_eqVlt -ltnS.
move=> /orP[/eqP E'|/eqP E']; move: i; rewrite E'=> i.
by rewrite (@ord_inj _ (Ordinal i) 1) // E=> /eqP NE'.
by rewrite (@ord_inj _ (Ordinal i) 0) // (@ord_inj _ (Ordinal p) 0).

*****

*****

+++++
Qed.
-----
Lemma ratio_cp'_aux_1 (a b c : R) :\n  b - a != 0 ->\n  1 < (b-a) / (c-a) -> 0 < (c-b) / (a-b) < 1.
-----
Lemma ratio_cp'_aux_1 (a b c : R) : b - a != 0 -> 1 < (b-a) / (c-a) -> 0 < (c-b) / (a-b) < 1.

*****
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R))) (_ : Num.Def.ltr (GRing.one R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))), andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))
+++++
Proof.
-----
Lemma ratio_cp'_aux_1 (a b c : R) : b - a != 0 -> 1 < (b-a) / (c-a) -> 0 < (c-b) / (a-b) < 1.
Proof.

*****
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R))) (_ : Num.Def.ltr (GRing.one R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))), andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))
+++++
rewrite subr_eq0 eq_sym -{1}[b]add0r -subr_eq0 add0r=> ? ?.
-----
Lemma ratio_cp'_aux_1 (a b c : R) : b - a != 0 -> 1 < (b-a) / (c-a) -> 0 < (c-b) / (a-b) < 1.
Proof.
rewrite subr_eq0 eq_sym -{1}[b]add0r -subr_eq0 add0r=> ? ?.

*****
_Hyp1_ : is_true\n (Num.Def.ltr (GRing.one R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
_Hyp_ : is_true (negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R)))
+++++
have: (0 < ((b-a) / (c-a)))=> [|H].
-----
Lemma ratio_cp'_aux_1 (a b c : R) : b - a != 0 -> 1 < (b-a) / (c-a) -> 0 < (c-b) / (a-b) < 1.
Proof.
rewrite subr_eq0 eq_sym -{1}[b]add0r -subr_eq0 add0r=> ? ?.
have: (0 < ((b-a) / (c-a)))=> [|H].

*****
_Hyp1_ : is_true\n (Num.Def.ltr (GRing.one R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
_Hyp_ : is_true (negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))))
+++++
by apply ler_lt_trans with 1; rewrite ?ler01.
-----
Lemma ratio_cp'_aux_1 (a b c : R) : b - a != 0 -> 1 < (b-a) / (c-a) -> 0 < (c-b) / (a-b) < 1.
Proof.
rewrite subr_eq0 eq_sym -{1}[b]add0r -subr_eq0 add0r=> ? ?.
have: (0 < ((b-a) / (c-a)))=> [|H].
by apply ler_lt_trans with 1; rewrite ?ler01.

*****
H : is_true\n (Num.Def.ltr (GRing.zero R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
_Hyp1_ : is_true\n (Num.Def.ltr (GRing.one R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
_Hyp_ : is_true (negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R)))
+++++
rewrite andbC -subr_lt0 andbC -(ltr_addr (-1)) -[1]divr1.
-----
Lemma ratio_cp'_aux_1 (a b c : R) : b - a != 0 -> 1 < (b-a) / (c-a) -> 0 < (c-b) / (a-b) < 1.
Proof.
rewrite subr_eq0 eq_sym -{1}[b]add0r -subr_eq0 add0r=> ? ?.
have: (0 < ((b-a) / (c-a)))=> [|H].
by apply ler_lt_trans with 1; rewrite ?ler01.
rewrite andbC -subr_lt0 andbC -(ltr_addr (-1)) -[1]divr1.

*****
H : is_true\n (Num.Def.ltr (GRing.zero R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
_Hyp1_ : is_true\n (Num.Def.ltr (GRing.one R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
_Hyp_ : is_true (negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (andb (Num.Def.ltr (GRing.opp (GRing.mul (GRing.one R) (GRing.inv (GRing.one R)))) (GRing.add (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.opp (GRing.mul (GRing.one R) (GRing.inv (GRing.one R)))))) (Num.Def.ltr (GRing.add (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.opp (GRing.mul (GRing.one R) (GRing.inv (GRing.one R))))) (GRing.zero R)))
+++++
rewrite {1}divr1 -mulNr addf_div ?oner_neq0 // !mulr1 mulNr mul1r opprB addrBDB.
-----
Lemma ratio_cp'_aux_1 (a b c : R) : b - a != 0 -> 1 < (b-a) / (c-a) -> 0 < (c-b) / (a-b) < 1.
Proof.
rewrite subr_eq0 eq_sym -{1}[b]add0r -subr_eq0 add0r=> ? ?.
have: (0 < ((b-a) / (c-a)))=> [|H].
by apply ler_lt_trans with 1; rewrite ?ler01.
rewrite andbC -subr_lt0 andbC -(ltr_addr (-1)) -[1]divr1.
rewrite {1}divr1 -mulNr addf_div ?oner_neq0 // !mulr1 mulNr mul1r opprB addrBDB.

*****
H : is_true\n (Num.Def.ltr (GRing.zero R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
_Hyp1_ : is_true\n (Num.Def.ltr (GRing.one R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
_Hyp_ : is_true (negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (andb (Num.Def.ltr (GRing.opp (GRing.one R)) (GRing.mul (GRing.add c (GRing.opp a)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp a)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.zero R)))
+++++
by rewrite -[a-b]opprB invrN mulrN oppr_lt0 -[X in _ < X]mulN1r ltr_nmulr; rewrite ?oppr_lt0 ?ltr01 // -invf_div invr_gt0 H andbT invf_cp1.
-----
Lemma ratio_cp'_aux_1 (a b c : R) : b - a != 0 -> 1 < (b-a) / (c-a) -> 0 < (c-b) / (a-b) < 1.
Proof.
rewrite subr_eq0 eq_sym -{1}[b]add0r -subr_eq0 add0r=> ? ?.
have: (0 < ((b-a) / (c-a)))=> [|H].
by apply ler_lt_trans with 1; rewrite ?ler01.
rewrite andbC -subr_lt0 andbC -(ltr_addr (-1)) -[1]divr1.
rewrite {1}divr1 -mulNr addf_div ?oner_neq0 // !mulr1 mulNr mul1r opprB addrBDB.
by rewrite -[a-b]opprB invrN mulrN oppr_lt0 -[X in _ < X]mulN1r ltr_nmulr; rewrite ?oppr_lt0 ?ltr01 // -invf_div invr_gt0 H andbT invf_cp1.

*****

*****

+++++
Qed.
-----
Lemma ratio_cp'_aux_2 (a b c : R) :\n  a - b != 0 -> (b-a) / (c-a) < 0 -> 0 < (c-b) / (a-b).
-----
Lemma ratio_cp'_aux_2 (a b c : R) : a - b != 0 -> (b-a) / (c-a) < 0 -> 0 < (c-b) / (a-b).

*****
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R))) (_ : Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.zero R)), Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))
+++++
Proof.
-----
Lemma ratio_cp'_aux_2 (a b c : R) : a - b != 0 -> (b-a) / (c-a) < 0 -> 0 < (c-b) / (a-b).
Proof.

*****
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R))) (_ : Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.zero R)), Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))
+++++
move=> ? ?; rewrite -[X in _ < X]addr0 -{2}(subrr 1) addrCA -{2}[1]divr1 -mulNr.
-----
Lemma ratio_cp'_aux_2 (a b c : R) : a - b != 0 -> (b-a) / (c-a) < 0 -> 0 < (c-b) / (a-b).
Proof.
move=> ? ?; rewrite -[X in _ < X]addr0 -{2}(subrr 1) addrCA -{2}[1]divr1 -mulNr.

*****
_Hyp1_ : is_true\n (Num.Def.ltr\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.zero R))
_Hyp_ : is_true (negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) (GRing.add (GRing.one R) (GRing.add (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.mul (GRing.opp (GRing.one R)) (GRing.inv (GRing.one R))))))
+++++
rewrite addf_div ?oner_neq0 // !mulr1 mulNr mul1r opprB addrBDB -[a-b]opprB.
-----
Lemma ratio_cp'_aux_2 (a b c : R) : a - b != 0 -> (b-a) / (c-a) < 0 -> 0 < (c-b) / (a-b).
Proof.
move=> ? ?; rewrite -[X in _ < X]addr0 -{2}(subrr 1) addrCA -{2}[1]divr1 -mulNr.
rewrite addf_div ?oner_neq0 // !mulr1 mulNr mul1r opprB addrBDB -[a-b]opprB.

*****
_Hyp1_ : is_true\n (Num.Def.ltr\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.zero R))
_Hyp_ : is_true (negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (Num.Def.ltr (GRing.zero R) (GRing.add (GRing.one R) (GRing.mul (GRing.add c (GRing.opp a)) (GRing.inv (GRing.opp (GRing.add b (GRing.opp a)))))))
+++++
by rewrite invrN mulrN subr_gt0; apply ltr_le_trans with 0; rewrite ?ler01 // -invr_lt0 invf_div.
-----
Lemma ratio_cp'_aux_2 (a b c : R) : a - b != 0 -> (b-a) / (c-a) < 0 -> 0 < (c-b) / (a-b).
Proof.
move=> ? ?; rewrite -[X in _ < X]addr0 -{2}(subrr 1) addrCA -{2}[1]divr1 -mulNr.
rewrite addf_div ?oner_neq0 // !mulr1 mulNr mul1r opprB addrBDB -[a-b]opprB.
by rewrite invrN mulrN subr_gt0; apply ltr_le_trans with 0; rewrite ?ler01 // -invr_lt0 invf_div.

*****

*****

+++++
Qed.
-----
Lemma ratio_cp' (a b c : R) :\n  b - a != 0 -> c - a != 0 -> b - c != 0 ->\n  [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].

*****
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R))) (_ : negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R))) (_ : negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R))), orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
Proof.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.

*****
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R))) (_ : negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R))) (_ : negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R))), orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].

*****
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (negb (eq_op (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R)))
+++++
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.

*****
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (negb (eq_op (GRing.mul (GRing.add (GRing.mul (GRing.add b (GRing.opp a)) (GRing.one R)) (GRing.mul (GRing.opp (GRing.one R)) (GRing.add c (GRing.opp a)))) (GRing.inv (GRing.mul (GRing.add c (GRing.opp a)) (GRing.one R)))) (GRing.zero R)))
+++++
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.

*****
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R)))))
+++++
have: ((c-b) / (a-b) != 1)=> [|H5].
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].

*****
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (negb (eq_op (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R)))
+++++
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.

*****
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R)))))
+++++
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].

*****
L2 : is_true (Num.Def.ltr (GRing.add c (GRing.opp a)) (GRing.zero R))
L1 : is_true (Num.Def.ltr (GRing.add b (GRing.opp a)) (GRing.zero R))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R)))))
+++++
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.

*****
L2 : is_true (Num.Def.ltr (GRing.add c (GRing.opp a)) (GRing.zero R))
L1 : is_true (Num.Def.ltr (GRing.add b (GRing.opp a)) (GRing.zero R))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))), orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.

*****
_x_ : is_true\n (Num.Def.ltr (GRing.zero R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
G1 : is_true\n (Num.Def.ltr (GRing.one R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
L2 : is_true (Num.Def.ltr (GRing.add c (GRing.opp a)) (GRing.zero R))
L1 : is_true (Num.Def.ltr (GRing.add b (GRing.opp a)) (GRing.zero R))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) false) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R)))))
+++++
by rewrite andbF /= ratio_cp'_aux_1.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.

*****
G2 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add c (GRing.opp a)))
L1 : is_true (Num.Def.ltr (GRing.add b (GRing.opp a)) (GRing.zero R))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R)))))
+++++
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.

*****
G2 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add c (GRing.opp a)))
L1 : is_true (Num.Def.ltr (GRing.add b (GRing.opp a)) (GRing.zero R))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.zero R), orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.

*****
L2 : is_true\n (Num.Def.ltr (GRing.zero R)\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))))
G2 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add c (GRing.opp a)))
L1 : is_true (Num.Def.ltr (GRing.add b (GRing.opp a)) (GRing.zero R))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.

*****
_L2_ : is_true\n (Num.Def.ltr (GRing.zero R)\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))))
G1 : is_true\n (Num.Def.ltr (GRing.one R)\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))))
G2 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add c (GRing.opp a)))
L1 : is_true (Num.Def.ltr (GRing.add b (GRing.opp a)) (GRing.zero R))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) false) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.

*****
L2 : is_true (Num.Def.ltr (GRing.add c (GRing.opp a)) (GRing.zero R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add b (GRing.opp a)))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R)))))
+++++
have: ((b-a) / (c-a) < 0); first by rewrite pmulr_rlt0 // invr_lt0.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: ((b-a) / (c-a) < 0); first by rewrite pmulr_rlt0 // invr_lt0.

*****
L2 : is_true (Num.Def.ltr (GRing.add c (GRing.opp a)) (GRing.zero R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add b (GRing.opp a)))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.zero R), orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
move=> L1; move: (ltr_gtF L1)=> -> /=; apply ratio_cp'_aux_2 in L1=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: ((b-a) / (c-a) < 0); first by rewrite pmulr_rlt0 // invr_lt0.
move=> L1; move: (ltr_gtF L1)=> -> /=; apply ratio_cp'_aux_2 in L1=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.

*****
L1 : is_true\n (Num.Def.ltr (GRing.zero R)\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))))
L2 : is_true (Num.Def.ltr (GRing.add c (GRing.opp a)) (GRing.zero R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add b (GRing.opp a)))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
move: (ltr_total H5) L1=> /orP[->->//=|G2 ?]; move: (ltr_gtF G2)=> ->.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: ((b-a) / (c-a) < 0); first by rewrite pmulr_rlt0 // invr_lt0.
move=> L1; move: (ltr_gtF L1)=> -> /=; apply ratio_cp'_aux_2 in L1=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L1=> /orP[->->//=|G2 ?]; move: (ltr_gtF G2)=> ->.

*****
_L1_ : is_true\n (Num.Def.ltr (GRing.zero R)\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))))
G2 : is_true\n (Num.Def.ltr (GRing.one R)\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))))
L2 : is_true (Num.Def.ltr (GRing.add c (GRing.opp a)) (GRing.zero R))
G1 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add b (GRing.opp a)))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) false) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: ((b-a) / (c-a) < 0); first by rewrite pmulr_rlt0 // invr_lt0.
move=> L1; move: (ltr_gtF L1)=> -> /=; apply ratio_cp'_aux_2 in L1=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L1=> /orP[->->//=|G2 ?]; move: (ltr_gtF G2)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.

*****
G2 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add c (GRing.opp a)))
G1 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add b (GRing.opp a)))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R)))))
+++++
have: (0 < (b-a) / (c-a)); first by rewrite pmulr_rgt0 // invr_gt0.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: ((b-a) / (c-a) < 0); first by rewrite pmulr_rlt0 // invr_lt0.
move=> L1; move: (ltr_gtF L1)=> -> /=; apply ratio_cp'_aux_2 in L1=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L1=> /orP[->->//=|G2 ?]; move: (ltr_gtF G2)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: (0 < (b-a) / (c-a)); first by rewrite pmulr_rgt0 // invr_gt0.

*****
G2 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add c (GRing.opp a)))
G1 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add b (GRing.opp a)))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall _ : Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))), orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
move: (ltr_total H4)=> /orP[->->//=|G3 ?]; move: (ltr_gtF G3)=> ->.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: ((b-a) / (c-a) < 0); first by rewrite pmulr_rlt0 // invr_lt0.
move=> L1; move: (ltr_gtF L1)=> -> /=; apply ratio_cp'_aux_2 in L1=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L1=> /orP[->->//=|G2 ?]; move: (ltr_gtF G2)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: (0 < (b-a) / (c-a)); first by rewrite pmulr_rgt0 // invr_gt0.
move: (ltr_total H4)=> /orP[->->//=|G3 ?]; move: (ltr_gtF G3)=> ->.

*****
_x_ : is_true\n (Num.Def.ltr (GRing.zero R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
G3 : is_true\n (Num.Def.ltr (GRing.one R)\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))))
G2 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add c (GRing.opp a)))
G1 : is_true (Num.Def.ltr (GRing.zero R) (GRing.add b (GRing.opp a)))
H5 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add c (GRing.opp b))\n (GRing.inv (GRing.add a (GRing.opp b)))) \n (GRing.one R)))
H4 : is_true\n (negb\n (eq_op\n (GRing.mul (GRing.add b (GRing.opp a))\n (GRing.inv (GRing.add c (GRing.opp a)))) \n (GRing.one R)))
H : is_true (negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R)))
H2 : is_true (negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R)))
H1 : is_true (negb (eq_op (GRing.add b (GRing.opp a)) (GRing.zero R)))
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
is_true (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) false) (orb (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R)))))
+++++
by rewrite andbF /= ratio_cp'_aux_1.
-----
Lemma ratio_cp' (a b c : R) : b - a != 0 -> c - a != 0 -> b - c != 0 -> [|| 0 < (b-a) / (c-a) < 1, 0 < (c-b) / (a-b) < 1 | 0 < (a-c) / (b-c) < 1].
Proof.
move=> H1 H2 H; have: ((b-a) / (c-a) != 1)=> [|H4].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //.
by rewrite !mulr1 mulNr mul1r opprB addrBDB mulf_neq0 // invr_neq0.
have: ((c-b) / (a-b) != 1)=> [|H5].
rewrite -[X in _ != X]add0r -subr_eq -[1]divr1 -mulNr addf_div ?oner_neq0 //; rewrite ?mulr1 ?mulNr ?mul1r ?opprB ?addrBDB ?mulf_neq0 // ?invr_neq0 //; by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H1) (ltr_total H2)=> /orP[L1|G1] /orP[L2|G2].
have: (0 < (b-a) / (c-a)); first by rewrite nmulr_lgt0 // invr_lt0.
move: (ltr_total H4)=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.
have: ((b-a) / (c-a) < 0); first by rewrite nmulr_rlt0 // invr_gt0.
move=> L2; move: (ltr_gtF L2)=> -> /=; apply ratio_cp'_aux_2 in L2=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L2=> /orP[->->//=|G1 ?]; move: (ltr_gtF G1)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: ((b-a) / (c-a) < 0); first by rewrite pmulr_rlt0 // invr_lt0.
move=> L1; move: (ltr_gtF L1)=> -> /=; apply ratio_cp'_aux_2 in L1=> //; last by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
move: (ltr_total H5) L1=> /orP[->->//=|G2 ?]; move: (ltr_gtF G2)=> ->.
by rewrite andbF /= ratio_cp'_aux_1 //; rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq.
have: (0 < (b-a) / (c-a)); first by rewrite pmulr_rgt0 // invr_gt0.
move: (ltr_total H4)=> /orP[->->//=|G3 ?]; move: (ltr_gtF G3)=> ->.
by rewrite andbF /= ratio_cp'_aux_1.

*****

*****

+++++
Qed.
-----
Lemma ratio_cp (a b c : R) :\n  a - b != 0 ->  b - c != 0 -> c - a != 0 ->\n  0 < (b-a) / (c-a) < 1 \/ 0 < (c-b) / (a-b) < 1 \/ 0 < (a-c) / (b-c) < 1.
-----
Lemma ratio_cp (a b c : R) : a - b != 0 -> b - c != 0 -> c - a != 0 -> 0 < (b-a) / (c-a) < 1 \\/ 0 < (c-b) / (a-b) < 1 \\/ 0 < (a-c) / (b-c) < 1.

*****
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R))) (_ : negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R))) (_ : negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R))), or (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (or (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
Proof.
-----
Lemma ratio_cp (a b c : R) : a - b != 0 -> b - c != 0 -> c - a != 0 -> 0 < (b-a) / (c-a) < 1 \\/ 0 < (c-b) / (a-b) < 1 \\/ 0 < (a-c) / (b-c) < 1.
Proof.

*****
a,b,c : Num.RealField.sort R
R : Num\.RealField\.type
*****
forall (_ : negb (eq_op (GRing.add a (GRing.opp b)) (GRing.zero R))) (_ : negb (eq_op (GRing.add b (GRing.opp c)) (GRing.zero R))) (_ : negb (eq_op (GRing.add c (GRing.opp a)) (GRing.zero R))), or (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a))))) (Num.Def.ltr (GRing.mul (GRing.add b (GRing.opp a)) (GRing.inv (GRing.add c (GRing.opp a)))) (GRing.one R))) (or (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b))))) (Num.Def.ltr (GRing.mul (GRing.add c (GRing.opp b)) (GRing.inv (GRing.add a (GRing.opp b)))) (GRing.one R))) (andb (Num.Def.ltr (GRing.zero R) (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c))))) (Num.Def.ltr (GRing.mul (GRing.add a (GRing.opp c)) (GRing.inv (GRing.add b (GRing.opp c)))) (GRing.one R))))
+++++
by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq=> H1 H3 H2; move: (ratio_cp' H1 H2 H3)=> /or3P HE; elim HE=> H; [left|right; left|right; right].
-----
Lemma ratio_cp (a b c : R) : a - b != 0 -> b - c != 0 -> c - a != 0 -> 0 < (b-a) / (c-a) < 1 \\/ 0 < (c-b) / (a-b) < 1 \\/ 0 < (a-c) / (b-c) < 1.
Proof.
by rewrite subr_eq add0r eq_sym -[X in _ != X]add0r -subr_eq=> H1 H3 H2; move: (ratio_cp' H1 H2 H3)=> /or3P HE; elim HE=> H; [left|right; left|right; right].

*****

*****

+++++
Qed.
-----
Lemma col_2D_aux_1 a b c :\n  ((a 0 1 - c 0 1) * (b 0 0 - c 0 0) == (a 0 0 - c 0 0) * (b 0 1 - c 0 1)) =\n  ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
-----
Lemma col_2D_aux_1 a b c : ((a 0 1 - c 0 1) * (b 0 0 - c 0 0) == (a 0 0 - c 0 0) * (b 0 1 - c 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
Proof.
-----
Lemma col_2D_aux_1 a b c : ((a 0 1 - c 0 1) * (b 0 0 - c 0 0) == (a 0 0 - c 0 0) * (b 0 1 - c 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
rewrite eq_sym -(addrBDB _ (b 0 0)) -[X in _ == X * _](addrBDB _ (b 0 1)).
-----
Lemma col_2D_aux_1 a b c : ((a 0 1 - c 0 1) * (b 0 0 - c 0 0) == (a 0 0 - c 0 0) * (b 0 1 - c 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.
rewrite eq_sym -(addrBDB _ (b 0 0)) -[X in _ == X * _](addrBDB _ (b 0 1)).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
rewrite mulrDl [X in _ + X]mulrC addrC [X in _ == X]mulrDl [X in _ == X] addrC.
-----
Lemma col_2D_aux_1 a b c : ((a 0 1 - c 0 1) * (b 0 0 - c 0 0) == (a 0 0 - c 0 0) * (b 0 1 - c 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.
rewrite eq_sym -(addrBDB _ (b 0 0)) -[X in _ == X * _](addrBDB _ (b 0 1)).
rewrite mulrDl [X in _ + X]mulrC addrC [X in _ == X]mulrDl [X in _ == X] addrC.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.add (GRing.mul (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.add (GRing.mul (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
by rewrite add2r_eq.
-----
Lemma col_2D_aux_1 a b c : ((a 0 1 - c 0 1) * (b 0 0 - c 0 0) == (a 0 0 - c 0 0) * (b 0 1 - c 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.
rewrite eq_sym -(addrBDB _ (b 0 0)) -[X in _ == X * _](addrBDB _ (b 0 1)).
rewrite mulrDl [X in _ + X]mulrC addrC [X in _ == X]mulrDl [X in _ == X] addrC.
by rewrite add2r_eq.

*****

*****

+++++
Qed.
-----
Lemma col_2D_aux_2 a b c :\n  ((c 0 1 - b 0 1) * (a 0 0 - b 0 0) == (c 0 0 - b 0 0) * (a 0 1 - b 0 1)) =\n  ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
-----
Lemma col_2D_aux_2 a b c : ((c 0 1 - b 0 1) * (a 0 0 - b 0 0) == (c 0 0 - b 0 0) * (a 0 1 - b 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
Proof.
-----
Lemma col_2D_aux_2 a b c : ((c 0 1 - b 0 1) * (a 0 0 - b 0 0) == (c 0 0 - b 0 0) * (a 0 1 - b 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
rewrite mulrC [X in _ == X]mulrC -[X in _ * X]opprB.
-----
Lemma col_2D_aux_2 a b c : ((c 0 1 - b 0 1) * (a 0 0 - b 0 0) == (c 0 0 - b 0 0) * (a 0 1 - b 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.
rewrite mulrC [X in _ == X]mulrC -[X in _ * X]opprB.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.opp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
by rewrite mulrN eqr_oppLR -mulrN opprB.
-----
Lemma col_2D_aux_2 a b c : ((c 0 1 - b 0 1) * (a 0 0 - b 0 0) == (c 0 0 - b 0 0) * (a 0 1 - b 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.
rewrite mulrC [X in _ == X]mulrC -[X in _ * X]opprB.
by rewrite mulrN eqr_oppLR -mulrN opprB.

*****

*****

+++++
Qed.
-----
Lemma col_2D_aux_3 a b c :\n  ((b 0 1 - a 0 1) * (c 0 0 - a 0 0) == (b 0 0 - a 0 0) * (c 0 1 - a 0 1)) =\n  ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
-----
Lemma col_2D_aux_3 a b c : ((b 0 1 - a 0 1) * (c 0 0 - a 0 0) == (b 0 0 - a 0 0) * (c 0 1 - a 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
Proof.
-----
Lemma col_2D_aux_3 a b c : ((b 0 1 - a 0 1) * (c 0 0 - a 0 0) == (b 0 0 - a 0 0) * (c 0 1 - a 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
rewrite -opprB mulNr -mulrN opprB eq_sym -opprB mulNr -mulrN opprB.
-----
Lemma col_2D_aux_3 a b c : ((b 0 1 - a 0 1) * (c 0 0 - a 0 0) == (b 0 0 - a 0 0) * (c 0 1 - a 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.
rewrite -opprB mulNr -mulrN opprB eq_sym -opprB mulNr -mulrN opprB.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
rewrite -[X in _ * X](addrBDB _ (b 0 1)) -[X in _ == _ * X](addrBDB _ (b 0 0)).
-----
Lemma col_2D_aux_3 a b c : ((b 0 1 - a 0 1) * (c 0 0 - a 0 0) == (b 0 0 - a 0 0) * (c 0 1 - a 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.
rewrite -opprB mulNr -mulrN opprB eq_sym -opprB mulNr -mulrN opprB.
rewrite -[X in _ * X](addrBDB _ (b 0 1)) -[X in _ == _ * X](addrBDB _ (b 0 0)).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
eq (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))) (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
by rewrite mulrDr [X in _ == X]mulrDr mulrC add2r_eq.
-----
Lemma col_2D_aux_3 a b c : ((b 0 1 - a 0 1) * (c 0 0 - a 0 0) == (b 0 0 - a 0 0) * (c 0 1 - a 0 1)) = ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)).
Proof.
rewrite -opprB mulNr -mulrN opprB eq_sym -opprB mulNr -mulrN opprB.
rewrite -[X in _ * X](addrBDB _ (b 0 1)) -[X in _ == _ * X](addrBDB _ (b 0 0)).
by rewrite mulrDr [X in _ == X]mulrDr mulrC add2r_eq.

*****

*****

+++++
Qed.
-----
Lemma col_2D_aux a b c :\n  ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) ->\n  c 0 0 != a 0 0 \/ c 0 1 != a 0 1 ->\n  a 0 0 != b 0 0 \/ a 0 1 != b 0 1 ->\n  b 0 0 != c 0 0 \/ b 0 1 != c 0 1 ->\n  [ \/ [ /\ b 0 0 = a 0 0, c 0 0 = a 0 0,\n         a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0],\n       [ /\ b 0 1 = a 0 1, c 0 1 = a 0 1,\n         a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] |\n       [ /\ [ /\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] &\n            [ /\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))) (and (and3 (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))) (and3 (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))))
+++++
Proof.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))) (and (and3 (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))) (and3 (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))))
+++++
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or (negb true) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.

*****
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 (negb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.

*****
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : orb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true (negb true)) (_ : or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 (negb true) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.

*****
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) false) (_ : or true false) (_ : or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) false), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) false false false) (and5 (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 false false false))
+++++
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.

*****
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true true) (_ : or (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.

*****
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : orb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true true) (_ : or false (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))), or3 (and5 (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true false (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 true false (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].

*****
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true true) (_ : or true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 true (negb (eq_op (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.

*****
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.zero R)) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true true) (_ : or true false), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true false (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 true false (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.

*****
_a_ : is_true\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true false (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 true false (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
by apply Or32; apply And5=> //; rewrite eq_sym.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
by apply Or32; apply And5=> //; rewrite eq_sym.

*****
_n3_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (_ : or (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true true) (_ : or true true), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and (and3 true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (and3 true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
case: (c 0 0 =P a 0 0)=> [->|?] /=; [|case: (c 0 1 =P a 0 1)=> [->|?] /=].
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
by apply Or32; apply And5=> //; rewrite eq_sym.
case: (c 0 0 =P a 0 0)=> [->|?] /=; [|case: (c 0 1 =P a 0 1)=> [->|?] /=].

*****
_n3_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (_ : or false (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true true) (_ : or true true), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true false) (and (and3 true true false) (and3 true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
rewrite -[X in _ == X *_]opprB mulNr -addr_eq0 mulrC -mulrDr mulf_eq0.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
by apply Or32; apply And5=> //; rewrite eq_sym.
case: (c 0 0 =P a 0 0)=> [->|?] /=; [|case: (c 0 1 =P a 0 1)=> [->|?] /=].
rewrite -[X in _ == X *_]opprB mulNr -addr_eq0 mulrC -mulrDr mulf_eq0.

*****
_n3_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : orb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (eq_op (GRing.add (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.zero R))) (_ : or false (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true true) (_ : or true true), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true false) (and (and3 true true false) (and3 true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
rewrite addrBDB !subr_eq0 [X in X || _]eq_sym [X in _ || X]eq_sym.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
by apply Or32; apply And5=> //; rewrite eq_sym.
case: (c 0 0 =P a 0 0)=> [->|?] /=; [|case: (c 0 1 =P a 0 1)=> [->|?] /=].
rewrite -[X in _ == X *_]opprB mulNr -addr_eq0 mulrC -mulrDr mulf_eq0.
rewrite addrBDB !subr_eq0 [X in X || _]eq_sym [X in _ || X]eq_sym.

*****
_n3_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : orb (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (_ : or false (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : or true true) (_ : or true true), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true false) (and (and3 true true false) (and3 true true (negb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
move=> /orP[/eqP //|/eqP ?] [/eqP //|/eqP //].
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
by apply Or32; apply And5=> //; rewrite eq_sym.
case: (c 0 0 =P a 0 0)=> [->|?] /=; [|case: (c 0 1 =P a 0 1)=> [->|?] /=].
rewrite -[X in _ == X *_]opprB mulNr -addr_eq0 mulrC -mulrDr mulf_eq0.
rewrite addrBDB !subr_eq0 [X in X || _]eq_sym [X in _ || X]eq_sym.
move=> /orP[/eqP //|/eqP ?] [/eqP //|/eqP //].

*****
_n4_ : not\n (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n3_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (_ : or true false) (_ : or true true) (_ : or true true), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true true false) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true true) (and (and3 true true true) (and3 true true false))
+++++
rewrite -[X in _ == _ * X]opprB mulrN -addr_eq0 mulrC -mulrDl mulf_eq0.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
by apply Or32; apply And5=> //; rewrite eq_sym.
case: (c 0 0 =P a 0 0)=> [->|?] /=; [|case: (c 0 1 =P a 0 1)=> [->|?] /=].
rewrite -[X in _ == X *_]opprB mulNr -addr_eq0 mulrC -mulrDr mulf_eq0.
rewrite addrBDB !subr_eq0 [X in X || _]eq_sym [X in _ || X]eq_sym.
move=> /orP[/eqP //|/eqP ?] [/eqP //|/eqP //].
rewrite -[X in _ == _ * X]opprB mulrN -addr_eq0 mulrC -mulrDl mulf_eq0.

*****
_n4_ : not\n (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n3_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : orb (eq_op (GRing.add (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.zero R)) (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (_ : or true false) (_ : or true true) (_ : or true true), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true true false) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true true) (and (and3 true true true) (and3 true true false))
+++++
rewrite addrC addrBDB !subr_eq0 eq_sym.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
by apply Or32; apply And5=> //; rewrite eq_sym.
case: (c 0 0 =P a 0 0)=> [->|?] /=; [|case: (c 0 1 =P a 0 1)=> [->|?] /=].
rewrite -[X in _ == X *_]opprB mulNr -addr_eq0 mulrC -mulrDr mulf_eq0.
rewrite addrBDB !subr_eq0 [X in X || _]eq_sym [X in _ || X]eq_sym.
move=> /orP[/eqP //|/eqP ?] [/eqP //|/eqP //].
rewrite -[X in _ == _ * X]opprB mulrN -addr_eq0 mulrC -mulrDl mulf_eq0.
rewrite addrC addrBDB !subr_eq0 eq_sym.

*****
_n4_ : not\n (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n3_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : orb (eq_op (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq_op (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (_ : or true false) (_ : or true true) (_ : or true true), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true true false) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true true) (and (and3 true true true) (and3 true true false))
+++++
move=> /orP[/eqP ?|/eqP //] [/eqP //|/eqP //].
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
by apply Or32; apply And5=> //; rewrite eq_sym.
case: (c 0 0 =P a 0 0)=> [->|?] /=; [|case: (c 0 1 =P a 0 1)=> [->|?] /=].
rewrite -[X in _ == X *_]opprB mulNr -addr_eq0 mulrC -mulrDr mulf_eq0.
rewrite addrBDB !subr_eq0 [X in X || _]eq_sym [X in _ || X]eq_sym.
move=> /orP[/eqP //|/eqP ?] [/eqP //|/eqP //].
rewrite -[X in _ == _ * X]opprB mulrN -addr_eq0 mulrC -mulrDl mulf_eq0.
rewrite addrC addrBDB !subr_eq0 eq_sym.
move=> /orP[/eqP ?|/eqP //] [/eqP //|/eqP //].

*****
_n5_ : not\n (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n4_ : not\n (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n3_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n2_ : not\n (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
_n1_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))
_n_ : not\n (eq (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (_ : or true true) (_ : or true true) (_ : or true true), or3 (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) true true true) (and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) true true true) (and (and3 true true true) (and3 true true true))
+++++
by move=> _ _ _ _; apply Or33.
-----
Lemma col_2D_aux a b c : ((a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0)) -> c 0 0 != a 0 0 \\/ c 0 1 != a 0 1 -> a 0 0 != b 0 0 \\/ a 0 1 != b 0 1 -> b 0 0 != c 0 0 \\/ b 0 1 != c 0 1 -> [ \\/ [ /\\ b 0 0 = a 0 0, c 0 0 = a 0 0, a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0], [ /\\ b 0 1 = a 0 1, c 0 1 = a 0 1, a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] | [ /\\ [ /\\ a 0 0 - b 0 0 != 0, b 0 0 - c 0 0 != 0 & c 0 0 - a 0 0 != 0] & [ /\\ a 0 1 - b 0 1 != 0, b 0 1 - c 0 1 != 0 & c 0 1 - a 0 1 != 0]]].
Proof.
rewrite !subr_eq0; case: (a 0 0 =P b 0 0)=> [->|? /=].
rewrite subrr mul0r eq_sym mulf_eq0 !subr_eq0=> /orP[/eqP->|/eqP->]; rewrite ?eqxx /=; move=> [?|?] [?|?] [?|?] //; apply Or31; apply And5 => //; by rewrite eq_sym.
case: (a 0 1 =P b 0 1)=> [->|? /=]; rewrite ?subrr ?mul0r ?mulf_eq0.
rewrite !subr_eq0=> /orP[/eqP ? //|/eqP-> /=]; rewrite eqxx /=.
move=> [?|//] _ [?|//]; apply Or32; apply And5 => //; by rewrite eq_sym.
case: (b 0 0 =P c 0 0)=> [->|?] /=; rewrite ?subrr ?mulr0 ?mulf_eq0.
rewrite !subr_eq0; move=> /orP[/eqP->|/eqP->]; move=> [/eqP ?|?] _ [?|/eqP ?]; move=> //; apply Or31; apply And5=> //; by [rewrite eq_sym|apply /eqP].
case: (b 0 1 =P c 0 1)=> [->|?] /=; rewrite ?subrr ?mulr0 eq_sym.
rewrite mulf_eq0 !subr_eq0; move=> /orP[/eqP->|/eqP ? //] [?|/eqP ? //] _ _.
by apply Or32; apply And5=> //; rewrite eq_sym.
case: (c 0 0 =P a 0 0)=> [->|?] /=; [|case: (c 0 1 =P a 0 1)=> [->|?] /=].
rewrite -[X in _ == X *_]opprB mulNr -addr_eq0 mulrC -mulrDr mulf_eq0.
rewrite addrBDB !subr_eq0 [X in X || _]eq_sym [X in _ || X]eq_sym.
move=> /orP[/eqP //|/eqP ?] [/eqP //|/eqP //].
rewrite -[X in _ == _ * X]opprB mulrN -addr_eq0 mulrC -mulrDl mulf_eq0.
rewrite addrC addrBDB !subr_eq0 eq_sym.
move=> /orP[/eqP ?|/eqP //] [/eqP //|/eqP //].
by move=> _ _ _ _; apply Or33.

*****

*****

+++++
Qed.
-----
Lemma col_2D a b c :\n  (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0) ->\n  (bet a b c \/ bet b c a \/ bet c a b).
-----
Lemma col_2D a b c : (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0) -> (bet a b c \\/ bet b c a \\/ bet c a b).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))), or (bet a b c) (or (bet b c a) (bet c a b))
+++++
Proof.
-----
Lemma col_2D a b c : (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0) -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))), or (bet a b c) (or (bet b c a) (bet c a b))
+++++
rewrite /bet; case: (betEP' a b c); case: (betEP' b c a); case: (betEP' c a b); move=> N1 N2 N3 E; rewrite ?orbT ?orTb ?orbF ?orFb; auto.
-----
Lemma col_2D a b c : (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0) -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
rewrite /bet; case: (betEP' a b c); case: (betEP' b c a); case: (betEP' c a b); move=> N1 N2 N3 E; rewrite ?orbT ?orTb ?orbF ?orFb; auto.

*****
E : is_true\n (eq_op\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))))
N3 : not\n (not\n (and\n (or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))\n (or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))))
N2 : not\n (not\n (and\n (or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))\n (or\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))))
N1 : not\n (not\n (and\n (or\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))\n (or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
or (betS a b c) (or (betS b c a) (betS c a b))
+++++
apply markov_betE in N1; apply markov_betE in N2; apply markov_betE in N3.
-----
Lemma col_2D a b c : (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0) -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
rewrite /bet; case: (betEP' a b c); case: (betEP' b c a); case: (betEP' c a b); move=> N1 N2 N3 E; rewrite ?orbT ?orTb ?orbF ?orFb; auto.
apply markov_betE in N1; apply markov_betE in N2; apply markov_betE in N3.

*****
E : is_true\n (eq_op\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))))
N3 : and\n (or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))\n (or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
N2 : and\n (or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))\n (or\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
N1 : and\n (or\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))\n (or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
or (betS a b c) (or (betS b c a) (betS c a b))
+++++
move: N1 N2 N3=> _ [_ N1] [N2 N3]; case: (col_2D_aux E N1 N2 N3).
-----
Lemma col_2D a b c : (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0) -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
rewrite /bet; case: (betEP' a b c); case: (betEP' b c a); case: (betEP' c a b); move=> N1 N2 N3 E; rewrite ?orbT ?orTb ?orbF ?orFb; auto.
apply markov_betE in N1; apply markov_betE in N2; apply markov_betE in N3.
move: N1 N2 N3=> _ [_ N1] [N2 N3]; case: (col_2D_aux E N1 N2 N3).

*****
N3 : or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
N2 : or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
N1 : or\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
E : is_true\n (eq_op\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))), or (betS a b c) (or (betS b c a) (betS c a b))
+++++
rewrite /betS /betR; move=> [E1 E2 N4 N5 N6]; rewrite !ratio_e0_n1; rewrite ?mxE ?E1 ?E2 ?subrr // !vector2_eq !mxE !E1 !E2 subrr !mulr0; by rewrite -!mulrA !mulVf // !mulr1 !eqxx /=; apply ratio_cp.
-----
Lemma col_2D a b c : (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0) -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
rewrite /bet; case: (betEP' a b c); case: (betEP' b c a); case: (betEP' c a b); move=> N1 N2 N3 E; rewrite ?orbT ?orTb ?orbF ?orFb; auto.
apply markov_betE in N1; apply markov_betE in N2; apply markov_betE in N3.
move: N1 N2 N3=> _ [_ N1] [N2 N3]; case: (col_2D_aux E N1 N2 N3).
rewrite /betS /betR; move=> [E1 E2 N4 N5 N6]; rewrite !ratio_e0_n1; rewrite ?mxE ?E1 ?E2 ?subrr // !vector2_eq !mxE !E1 !E2 subrr !mulr0; by rewrite -!mulrA !mulVf // !mulr1 !eqxx /=; apply ratio_cp.

*****
N3 : or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
N2 : or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
N1 : or\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
E : is_true\n (eq_op\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : and5 (eq (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (eq (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))), or (betS a b c) (or (betS b c a) (betS c a b))
+++++
rewrite /betS /betR; move=> [E1 E2 N4 N5 N6]; rewrite !ratio_e1_n0; rewrite ?mxE ?E1 ?E2 ?subrr // !vector2_eq !mxE !E1 !E2 subrr !mulr0; by rewrite -!mulrA !mulVf // !mulr1 !eqxx /=; apply ratio_cp.
-----
Lemma col_2D a b c : (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0) -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
rewrite /bet; case: (betEP' a b c); case: (betEP' b c a); case: (betEP' c a b); move=> N1 N2 N3 E; rewrite ?orbT ?orTb ?orbF ?orFb; auto.
apply markov_betE in N1; apply markov_betE in N2; apply markov_betE in N3.
move: N1 N2 N3=> _ [_ N1] [N2 N3]; case: (col_2D_aux E N1 N2 N3).
rewrite /betS /betR; move=> [E1 E2 N4 N5 N6]; rewrite !ratio_e0_n1; rewrite ?mxE ?E1 ?E2 ?subrr // !vector2_eq !mxE !E1 !E2 subrr !mulr0; by rewrite -!mulrA !mulVf // !mulr1 !eqxx /=; apply ratio_cp.
rewrite /betS /betR; move=> [E1 E2 N4 N5 N6]; rewrite !ratio_e1_n0; rewrite ?mxE ?E1 ?E2 ?subrr // !vector2_eq !mxE !E1 !E2 subrr !mulr0; by rewrite -!mulrA !mulVf // !mulr1 !eqxx /=; apply ratio_cp.

*****
N3 : or\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
N2 : or\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
N1 : or\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (negb\n (eq_op\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
E : is_true\n (eq_op\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))\n (GRing.mul\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))))
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : and (and3 (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))) (and3 (negb (eq_op (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (negb (eq_op (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))), or (betS a b c) (or (betS b c a) (betS c a b))
+++++
move=> [[N4 N5 N6] [N7 N8 N9]]; rewrite /betS /betR -!ratioP ?ratioP_aux ?eqxx; rewrite ?mxE //=; try apply ratio_cp; rewrite // ?subr_eq ?add0r 1?eq_sym; rewrite -1?[X in _ != X]add0r -?subr_eq //; try solve [rewrite col_2D_aux_1 //]; by solve[rewrite col_2D_aux_2 //|rewrite col_2D_aux_3 //].
-----
Lemma col_2D a b c : (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0) -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
rewrite /bet; case: (betEP' a b c); case: (betEP' b c a); case: (betEP' c a b); move=> N1 N2 N3 E; rewrite ?orbT ?orTb ?orbF ?orFb; auto.
apply markov_betE in N1; apply markov_betE in N2; apply markov_betE in N3.
move: N1 N2 N3=> _ [_ N1] [N2 N3]; case: (col_2D_aux E N1 N2 N3).
rewrite /betS /betR; move=> [E1 E2 N4 N5 N6]; rewrite !ratio_e0_n1; rewrite ?mxE ?E1 ?E2 ?subrr // !vector2_eq !mxE !E1 !E2 subrr !mulr0; by rewrite -!mulrA !mulVf // !mulr1 !eqxx /=; apply ratio_cp.
rewrite /betS /betR; move=> [E1 E2 N4 N5 N6]; rewrite !ratio_e1_n0; rewrite ?mxE ?E1 ?E2 ?subrr // !vector2_eq !mxE !E1 !E2 subrr !mulr0; by rewrite -!mulrA !mulVf // !mulr1 !eqxx /=; apply ratio_cp.
move=> [[N4 N5 N6] [N7 N8 N9]]; rewrite /betS /betR -!ratioP ?ratioP_aux ?eqxx; rewrite ?mxE //=; try apply ratio_cp; rewrite // ?subr_eq ?add0r 1?eq_sym; rewrite -1?[X in _ != X]add0r -?subr_eq //; try solve [rewrite col_2D_aux_1 //]; by solve[rewrite col_2D_aux_2 //|rewrite col_2D_aux_3 //].

*****

*****

+++++
Qed.
-----
Lemma col_2D' a b c : (bet a b c \/ bet b c a \/ bet c a b) ->\n  (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : or (bet a b c) (or (bet b c a) (bet c a b)), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
Proof.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : or (bet a b c) (or (bet b c a) (bet c a b)), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
rewrite /bet /betE.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : or (orb (orb (andb (eq_op a b) (eq_op b c)) (orb (eq_op a b) (eq_op b c))) (betS a b c)) (or (orb (orb (andb (eq_op b c) (eq_op c a)) (orb (eq_op b c) (eq_op c a))) (betS b c a)) (orb (orb (andb (eq_op c a) (eq_op a b)) (orb (eq_op c a) (eq_op a b))) (betS c a b))), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.

*****
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq a b)) (_ : or (orb (orb (andb false (eq_op b c)) (orb false (eq_op b c))) (betS a b c)) (or (orb (orb (andb (eq_op b c) (eq_op c a)) (orb (eq_op b c) (eq_op c a))) (betS b c a)) (orb (orb (andb (eq_op c a) false) (orb (eq_op c a) false)) (betS c a b)))), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.

*****
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq b c)) (_ : or (orb (orb (andb false false) (orb false false)) (betS a b c)) (or (orb (orb (andb false (eq_op c a)) (orb false (eq_op c a))) (betS b c a)) (orb (orb (andb (eq_op c a) false) (orb (eq_op c a) false)) (betS c a b)))), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].

*****
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : or (betS a b a) (or true true), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.

*****
HC : or (betS a b c) (or (betS b c a) (betS c a b))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].

*****
E1 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.

*****
E1 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.opp (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))))
+++++
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.

*****
E1 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.opp (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (GRing.add (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.mul (GRing.opp (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.add (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))))
+++++
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.

*****
E1 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.opp (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (GRing.add (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.mul (GRing.opp (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.add (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.opp (GRing.mul (GRing.one R) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))))))
+++++
rewrite -[a 0 1 - c 0 1]opprB -{2}[c 0 1 - a 0 1]mul1r.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.
rewrite -[a 0 1 - c 0 1]opprB -{2}[c 0 1 - a 0 1]mul1r.

*****
E1 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.opp (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (GRing.add (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.opp (GRing.mul (GRing.one R) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))) (GRing.mul (GRing.opp (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.add (GRing.mul (betR a b c) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.opp (GRing.mul (GRing.one R) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))))))
+++++
rewrite -!mulrBl mulrCA [X in _ == X]mulrCA !mulNr -!mulrA.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.
rewrite -[a 0 1 - c 0 1]opprB -{2}[c 0 1 - a 0 1]mul1r.
rewrite -!mulrBl mulrCA [X in _ == X]mulrCA !mulNr -!mulrA.

*****
E1 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR a b c)\n (GRing.add\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (betR a b c) (GRing.opp (GRing.one R))) (GRing.opp (GRing.mul (betR a b c) (GRing.mul (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))))) (GRing.mul (GRing.add (betR a b c) (GRing.opp (GRing.one R))) (GRing.opp (GRing.mul (betR a b c) (GRing.mul (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))))))
+++++
by rewrite [X in _ * - (_ * X)]mulrC.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.
rewrite -[a 0 1 - c 0 1]opprB -{2}[c 0 1 - a 0 1]mul1r.
rewrite -!mulrBl mulrCA [X in _ == X]mulrCA !mulNr -!mulrA.
by rewrite [X in _ * - (_ * X)]mulrC.

*****
E1 : eq\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR b c a)\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR b c a)\n (GRing.add\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
rewrite -[b 0 0 - c 0 0]opprB E0 -[b 0 1 - c 0 1]opprB E1 !mulrN mulrCA.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.
rewrite -[a 0 1 - c 0 1]opprB -{2}[c 0 1 - a 0 1]mul1r.
rewrite -!mulrBl mulrCA [X in _ == X]mulrCA !mulNr -!mulrA.
by rewrite [X in _ * - (_ * X)]mulrC.
rewrite -[b 0 0 - c 0 0]opprB E0 -[b 0 1 - c 0 1]opprB E1 !mulrN mulrCA.

*****
E1 : eq\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR b c a)\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR b c a)\n (GRing.add\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.opp (GRing.mul (betR b c a) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))) (GRing.opp (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.mul (betR b c a) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))))
+++++
by rewrite [X in _ * X]mulrC eq_sym mulrCA.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.
rewrite -[a 0 1 - c 0 1]opprB -{2}[c 0 1 - a 0 1]mul1r.
rewrite -!mulrBl mulrCA [X in _ == X]mulrCA !mulNr -!mulrA.
by rewrite [X in _ * - (_ * X)]mulrC.
rewrite -[b 0 0 - c 0 0]opprB E0 -[b 0 1 - c 0 1]opprB E1 !mulrN mulrCA.
by rewrite [X in _ * X]mulrC eq_sym mulrCA.

*****
E1 : eq\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR c a b)\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR c a b)\n (GRing.add\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
rewrite -[a 0 0 - b 0 0](addrBDB _ (c 0 0)) -[a 0 1 - b 0 1](addrBDB _ (c 0 1)).
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.
rewrite -[a 0 1 - c 0 1]opprB -{2}[c 0 1 - a 0 1]mul1r.
rewrite -!mulrBl mulrCA [X in _ == X]mulrCA !mulNr -!mulrA.
by rewrite [X in _ * - (_ * X)]mulrC.
rewrite -[b 0 0 - c 0 0]opprB E0 -[b 0 1 - c 0 1]opprB E1 !mulrN mulrCA.
by rewrite [X in _ * X]mulrC eq_sym mulrCA.
rewrite -[a 0 0 - b 0 0](addrBDB _ (c 0 0)) -[a 0 1 - b 0 1](addrBDB _ (c 0 1)).

*****
E1 : eq\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR c a b)\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR c a b)\n (GRing.add\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
rewrite E0 E1 -[c 0 0 - b 0 0]opprB -[c 0 1 - b 0 1]opprB -[X in _ - X]mul1r.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.
rewrite -[a 0 1 - c 0 1]opprB -{2}[c 0 1 - a 0 1]mul1r.
rewrite -!mulrBl mulrCA [X in _ == X]mulrCA !mulNr -!mulrA.
by rewrite [X in _ * - (_ * X)]mulrC.
rewrite -[b 0 0 - c 0 0]opprB E0 -[b 0 1 - c 0 1]opprB E1 !mulrN mulrCA.
by rewrite [X in _ * X]mulrC eq_sym mulrCA.
rewrite -[a 0 0 - b 0 0](addrBDB _ (c 0 0)) -[a 0 1 - b 0 1](addrBDB _ (c 0 1)).
rewrite E0 E1 -[c 0 0 - b 0 0]opprB -[c 0 1 - b 0 1]opprB -[X in _ - X]mul1r.

*****
E1 : eq\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.mul (betR c a b)\n (GRing.add\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E0 : eq\n (GRing.add\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.mul (betR c a b)\n (GRing.add\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))
ca_neq : not (eq c a)
bc_neq : not (eq b c)
ab_neq : not (eq a b)
a,b,c : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (GRing.mul (betR c a b) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.opp (GRing.mul (GRing.one R) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (GRing.mul (betR c a b) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.opp (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
by rewrite eq_sym -[X in _ - X]mul1r -!mulrBl mulrAC.
-----
Lemma col_2D' a b c : (bet a b c \\/ bet b c a \\/ bet c a b) -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite /bet /betE.
case: (a =P b)=> [->|]; first by rewrite !subrr !mul0r eqxx.
move=> ab_neq; case: (b =P c)=> [->|]; first by rewrite !subrr !mulr0 eqxx.
move=> bc_neq; case: (c =P a)=> [->|ca_neq] /=; [|move=> HC].
by rewrite -[b 0 1 - a 0 1]opprB mulrN -mulNr opprB mulrC.
elim HC; clear HC; [|move=> HC; elim HC; clear HC]; move=> /betSP'[E0 E1 _ _].
rewrite -[b 0 0 - c 0 0](addrBDB _ (a 0 0)) -[a 0 0 - b 0 0]opprB E0.
rewrite -[b 0 1 - c 0 1](addrBDB _ (a 0 1)) -[a 0 1 - b 0 1]opprB E1.
rewrite -[a 0 0 - c 0 0]opprB -{3}[c 0 0 - a 0 0]mul1r.
rewrite -[a 0 1 - c 0 1]opprB -{2}[c 0 1 - a 0 1]mul1r.
rewrite -!mulrBl mulrCA [X in _ == X]mulrCA !mulNr -!mulrA.
by rewrite [X in _ * - (_ * X)]mulrC.
rewrite -[b 0 0 - c 0 0]opprB E0 -[b 0 1 - c 0 1]opprB E1 !mulrN mulrCA.
by rewrite [X in _ * X]mulrC eq_sym mulrCA.
rewrite -[a 0 0 - b 0 0](addrBDB _ (c 0 0)) -[a 0 1 - b 0 1](addrBDB _ (c 0 1)).
rewrite E0 E1 -[c 0 0 - b 0 0]opprB -[c 0 1 - b 0 1]opprB -[X in _ - X]mul1r.
by rewrite eq_sym -[X in _ - X]mul1r -!mulrBl mulrAC.

*****

*****

+++++
Qed.
-----
Lemma cong_perp_aux1 (a p m : 'rV[R]_(2)) i :\n  (m 0 i - a 0 i) - (m 0 i - p 0 i) = p 0 i - a 0 i.
-----
Lemma cong_perp_aux1 (a p m : 'rV[R]_(2)) i : (m 0 i - a 0 i) - (m 0 i - p 0 i) = p 0 i - a 0 i.

*****
i : ordinal (S (S O))
a,p,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) i) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) i) (GRing.opp (p (GRing.zero (Zp_zmodType O)) i))))) (GRing.add (p (GRing.zero (Zp_zmodType O)) i) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i)))
+++++
Proof.
-----
Lemma cong_perp_aux1 (a p m : 'rV[R]_(2)) i : (m 0 i - a 0 i) - (m 0 i - p 0 i) = p 0 i - a 0 i.
Proof.

*****
i : ordinal (S (S O))
a,p,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) i) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) i) (GRing.opp (p (GRing.zero (Zp_zmodType O)) i))))) (GRing.add (p (GRing.zero (Zp_zmodType O)) i) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i)))
+++++
by apply /eqP; rewrite opprB addrC addrBDB eqxx.
-----
Lemma cong_perp_aux1 (a p m : 'rV[R]_(2)) i : (m 0 i - a 0 i) - (m 0 i - p 0 i) = p 0 i - a 0 i.
Proof.
by apply /eqP; rewrite opprB addrC addrBDB eqxx.

*****

*****

+++++
Qed.
-----
Lemma cong_perp_aux2 (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) i :\n  (m 0 i - a 0 i) + (m 0 i - p 0 i) = q 0 i - a 0 i.
-----
Lemma cong_perp_aux2 (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) i : (m 0 i - a 0 i) + (m 0 i - p 0 i) = q 0 i - a 0 i.

*****
i : ordinal (S (S O))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) i) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i))) (GRing.add (m (GRing.zero (Zp_zmodType O)) i) (GRing.opp (p (GRing.zero (Zp_zmodType O)) i)))) (GRing.add (q (GRing.zero (Zp_zmodType O)) i) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i)))
+++++
Proof.
-----
Lemma cong_perp_aux2 (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) i : (m 0 i - a 0 i) + (m 0 i - p 0 i) = q 0 i - a 0 i.
Proof.

*****
i : ordinal (S (S O))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) i) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i))) (GRing.add (m (GRing.zero (Zp_zmodType O)) i) (GRing.opp (p (GRing.zero (Zp_zmodType O)) i)))) (GRing.add (q (GRing.zero (Zp_zmodType O)) i) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i)))
+++++
rewrite addrAC addrA /m !mxE -mulrDl addf_divrr ?divff ?add11_neq0 //.
-----
Lemma cong_perp_aux2 (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) i : (m 0 i - a 0 i) + (m 0 i - p 0 i) = q 0 i - a 0 i.
Proof.
rewrite addrAC addrA /m !mxE -mulrDl addf_divrr ?divff ?add11_neq0 //.

*****
i : ordinal (S (S O))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (GRing.add (GRing.add (GRing.mul (GRing.one R) (GRing.add (p (GRing.zero (Zp_zmodType O)) i) (q (GRing.zero (Zp_zmodType O)) i))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) i))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i))) (GRing.add (q (GRing.zero (Zp_zmodType O)) i) (GRing.opp (a (GRing.zero (Zp_zmodType O)) i)))
+++++
by rewrite mul1r -addrA addrACA subrr add0r.
-----
Lemma cong_perp_aux2 (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) i : (m 0 i - a 0 i) + (m 0 i - p 0 i) = q 0 i - a 0 i.
Proof.
rewrite addrAC addrA /m !mxE -mulrDl addf_divrr ?divff ?add11_neq0 //.
by rewrite mul1r -addrA addrACA subrr add0r.

*****

*****

+++++
Qed.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) :\n  cong a p a q ->\n  (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : cong a p a q, eq (GRing.add (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)
+++++
Proof.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : cong a p a q, eq (GRing.add (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)
+++++
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))), eq (GRing.add (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)
+++++
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))), eq (GRing.add (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)
+++++
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (S (S O)))), eq (GRing.add (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)
+++++
rewrite -[p 0 0 - m 0 0]opprB; set x0 := m 0 0 - a 0 0; set y0 := m 0 0 - p 0 0.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m.
rewrite -[p 0 0 - m 0 0]opprB; set x0 := m 0 0 - a 0 0; set y0 := m 0 0 - p 0 0.

*****
y0 : GRing.Zmodule.sort R
x0 : GRing.Zmodule.sort R
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add x0 (GRing.opp y0)) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add x0 y0) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (S (S O)))), eq (GRing.add (GRing.mul (GRing.opp y0) x0) (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)
+++++
rewrite -[p 0 1 - m 0 1]opprB; set x1 := m 0 1 - a 0 1; set y1 := m 0 1 - p 0 1.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m.
rewrite -[p 0 0 - m 0 0]opprB; set x0 := m 0 0 - a 0 0; set y0 := m 0 0 - p 0 0.
rewrite -[p 0 1 - m 0 1]opprB; set x1 := m 0 1 - a 0 1; set y1 := m 0 1 - p 0 1.

*****
y1 : GRing.Zmodule.sort R
x1 : GRing.Zmodule.sort R
y0 : GRing.Zmodule.sort R
x0 : GRing.Zmodule.sort R
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add x0 (GRing.opp y0)) (S (S O))) (GRing.exp (GRing.add x1 (GRing.opp y1)) (S (S O)))) (GRing.add (GRing.exp (GRing.add x0 y0) (S (S O))) (GRing.exp (GRing.add x1 y1) (S (S O)))), eq (GRing.add (GRing.mul (GRing.opp y0) x0) (GRing.mul (GRing.opp y1) x1)) (GRing.zero R)
+++++
rewrite !mulNr -subr_eq eq_sym -addrA [X in _ == X]addrC -subr_eq !subr_sqr.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m.
rewrite -[p 0 0 - m 0 0]opprB; set x0 := m 0 0 - a 0 0; set y0 := m 0 0 - p 0 0.
rewrite -[p 0 1 - m 0 1]opprB; set x1 := m 0 1 - a 0 1; set y1 := m 0 1 - p 0 1.
rewrite !mulNr -subr_eq eq_sym -addrA [X in _ == X]addrC -subr_eq !subr_sqr.

*****
y1 : GRing.Zmodule.sort R
x1 : GRing.Zmodule.sort R
y0 : GRing.Zmodule.sort R
x0 : GRing.Zmodule.sort R
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.mul (GRing.add (GRing.add x0 y0) (GRing.opp (GRing.add x0 (GRing.opp y0)))) (GRing.add (GRing.add x0 y0) (GRing.add x0 (GRing.opp y0)))) (GRing.mul (GRing.add (GRing.add x1 (GRing.opp y1)) (GRing.opp (GRing.add x1 y1))) (GRing.add (GRing.add x1 (GRing.opp y1)) (GRing.add x1 y1))), eq (GRing.add (GRing.opp (GRing.mul y0 x0)) (GRing.opp (GRing.mul y1 x1))) (GRing.zero R)
+++++
rewrite eq_sym -opprB mulNr -sub0r subr_eq eq_sym !addrDBB [X in _ * X]addrC.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m.
rewrite -[p 0 0 - m 0 0]opprB; set x0 := m 0 0 - a 0 0; set y0 := m 0 0 - p 0 0.
rewrite -[p 0 1 - m 0 1]opprB; set x1 := m 0 1 - a 0 1; set y1 := m 0 1 - p 0 1.
rewrite !mulNr -subr_eq eq_sym -addrA [X in _ == X]addrC -subr_eq !subr_sqr.
rewrite eq_sym -opprB mulNr -sub0r subr_eq eq_sym !addrDBB [X in _ * X]addrC.

*****
y1 : GRing.Zmodule.sort R
x1 : GRing.Zmodule.sort R
y0 : GRing.Zmodule.sort R
x0 : GRing.Zmodule.sort R
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.mul (GRing.natmul y0 (S (S O))) (GRing.add (GRing.add x0 (GRing.opp y0)) (GRing.add x0 y0))) (GRing.mul (GRing.natmul y1 (S (S O))) (GRing.add (GRing.add x1 (GRing.opp y1)) (GRing.add x1 y1)))) (GRing.zero R), eq (GRing.add (GRing.opp (GRing.mul y0 x0)) (GRing.opp (GRing.mul y1 x1))) (GRing.zero R)
+++++
rewrite !addrBDD !mulrnAl !mulrnAr -!mulrnA -mulrnDl mulrn_eq0 muln_eq0 /=.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m.
rewrite -[p 0 0 - m 0 0]opprB; set x0 := m 0 0 - a 0 0; set y0 := m 0 0 - p 0 0.
rewrite -[p 0 1 - m 0 1]opprB; set x1 := m 0 1 - a 0 1; set y1 := m 0 1 - p 0 1.
rewrite !mulNr -subr_eq eq_sym -addrA [X in _ == X]addrC -subr_eq !subr_sqr.
rewrite eq_sym -opprB mulNr -sub0r subr_eq eq_sym !addrDBB [X in _ * X]addrC.
rewrite !addrBDD !mulrnAl !mulrnAr -!mulrnA -mulrnDl mulrn_eq0 muln_eq0 /=.

*****
y1 : GRing.Zmodule.sort R
x1 : GRing.Zmodule.sort R
y0 : GRing.Zmodule.sort R
x0 : GRing.Zmodule.sort R
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.mul y0 x0) (GRing.mul y1 x1)) (GRing.zero R), eq (GRing.add (GRing.opp (GRing.mul y0 x0)) (GRing.opp (GRing.mul y1 x1))) (GRing.zero R)
+++++
by rewrite addr_eq0=> /eqP E; rewrite -E addrC subrr.
-----
Lemma cong_perp (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : cong a p a q -> (p 0 0 - m 0 0) * (m 0 0 - a 0 0) + (p 0 1 - m 0 1) * (m 0 1 - a 0 1) = 0.
Proof.
move=> /congP/eqP E; move: E; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m.
rewrite -[p 0 0 - m 0 0]opprB; set x0 := m 0 0 - a 0 0; set y0 := m 0 0 - p 0 0.
rewrite -[p 0 1 - m 0 1]opprB; set x1 := m 0 1 - a 0 1; set y1 := m 0 1 - p 0 1.
rewrite !mulNr -subr_eq eq_sym -addrA [X in _ == X]addrC -subr_eq !subr_sqr.
rewrite eq_sym -opprB mulNr -sub0r subr_eq eq_sym !addrDBB [X in _ * X]addrC.
rewrite !addrBDD !mulrnAl !mulrnAr -!mulrnA -mulrnDl mulrn_eq0 muln_eq0 /=.
by rewrite addr_eq0=> /eqP E; rewrite -E addrC subrr.

*****

*****

+++++
Qed.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) :\n  p 0 0 - m 0 0 == 0 -> p <> q ->\n  (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))
+++++
Proof.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))
+++++
move=> /eqP E.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.

*****
E : eq\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : not (eq p q), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))
+++++
move/eqP: (cong_perp_aux2 p p q 0).
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).

*****
E : eq\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))
+++++
rewrite -[X in _ + X]opprB.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.

*****
E : eq\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.opp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))
+++++
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.

*****
E : eq\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))
+++++
move/eqP: E.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (_ : eq_op (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))
+++++
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.

*****
HF : not (eq p q)
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))))
+++++
rewrite E1 subrr eqxx /= subr_eq0.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /= subr_eq0.

*****
HF : not (eq p q)
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (negb (eq_op (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))
+++++
apply /eqP => NE.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /= subr_eq0.
apply /eqP => NE.

*****
NE : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
HF : not (eq p q)
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
False
+++++
move/eqP: HF.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /= subr_eq0.
apply /eqP => NE.
move/eqP: HF.

*****
NE : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op p q), False
+++++
rewrite -subr_eq0 vector2_neq0 !mxE.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /= subr_eq0.
apply /eqP => NE.
move/eqP: HF.
rewrite -subr_eq0 vector2_neq0 !mxE.

*****
NE : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : orb (negb (eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))), False
+++++
rewrite E1 E2 subrr eqxx /= -NE -opprB -(cong_perp_aux2 _ p) -/m NE subrr addr0.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /= subr_eq0.
apply /eqP => NE.
move/eqP: HF.
rewrite -subr_eq0 vector2_neq0 !mxE.
rewrite E1 E2 subrr eqxx /= -NE -opprB -(cong_perp_aux2 _ p) -/m NE subrr addr0.

*****
NE : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op (GRing.opp (GRing.zero R)) (GRing.zero R)), False
+++++
by rewrite oppr_eq0 eqxx.
-----
Lemma upper_dim_dgc_aux0 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> (m 0 0 - p 0 0 == 0) && (m 0 1 - p 0 1 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 0).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /= subr_eq0.
apply /eqP => NE.
move/eqP: HF.
rewrite -subr_eq0 vector2_neq0 !mxE.
rewrite E1 E2 subrr eqxx /= -NE -opprB -(cong_perp_aux2 _ p) -/m NE subrr addr0.
by rewrite oppr_eq0 eqxx.

*****

*****

+++++
Qed.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) :\n  p 0 1 - m 0 1 == 0 -> p <> q ->\n  (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))
+++++
Proof.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))
+++++
move=> /eqP E.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.

*****
E : eq\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : not (eq p q), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))
+++++
move/eqP: (cong_perp_aux2 p p q 1).
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).

*****
E : eq\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))
+++++
rewrite -[X in _ + X]opprB.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.

*****
E : eq\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.opp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))
+++++
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.

*****
E : eq\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))
+++++
move/eqP: E.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (_ : eq_op (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))) (_ : not (eq p q)), andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))
+++++
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.

*****
HF : not (eq p q)
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))))
+++++
rewrite E1 subrr eqxx /=.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /=.

*****
HF : not (eq p q)
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))
+++++
rewrite subr_eq0.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /=.
rewrite subr_eq0.

*****
HF : not (eq p q)
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (negb (eq_op (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))
+++++
apply /eqP => NE.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /=.
rewrite subr_eq0.
apply /eqP => NE.

*****
NE : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
HF : not (eq p q)
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
False
+++++
move/eqP: HF.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /=.
rewrite subr_eq0.
apply /eqP => NE.
move/eqP: HF.

*****
NE : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op p q), False
+++++
rewrite -subr_eq0 vector2_neq0 !mxE.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /=.
rewrite subr_eq0.
apply /eqP => NE.
move/eqP: HF.
rewrite -subr_eq0 vector2_neq0 !mxE.

*****
NE : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : orb (negb (eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (negb (eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))), False
+++++
rewrite E1 E2 subrr eqxx /= -NE -opprB -(cong_perp_aux2 _ p) -/m NE subrr addr0.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /=.
rewrite subr_eq0.
apply /eqP => NE.
move/eqP: HF.
rewrite -subr_eq0 vector2_neq0 !mxE.
rewrite E1 E2 subrr eqxx /= -NE -opprB -(cong_perp_aux2 _ p) -/m NE subrr addr0.

*****
NE : eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
E2 : eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
E1 : eq (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : orb (negb (eq_op (GRing.opp (GRing.zero R)) (GRing.zero R))) false, False
+++++
by rewrite oppr_eq0 eqxx.
-----
Lemma upper_dim_dgc_aux1 (p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 1 - m 0 1 == 0 -> p <> q -> (m 0 1 - p 0 1 == 0) && (m 0 0 - p 0 0 != 0).
Proof.
move=> /eqP E.
move/eqP: (cong_perp_aux2 p p q 1).
rewrite -[X in _ + X]opprB.
rewrite -/m E subr0 subr_eq addrAC -addrA subrr addr0.
move/eqP: E.
rewrite subr_eq0=> /eqP E1 /eqP E2 HF.
rewrite E1 subrr eqxx /=.
rewrite subr_eq0.
apply /eqP => NE.
move/eqP: HF.
rewrite -subr_eq0 vector2_neq0 !mxE.
rewrite E1 E2 subrr eqxx /= -NE -opprB -(cong_perp_aux2 _ p) -/m NE subrr addr0.
by rewrite oppr_eq0 eqxx.

*****

*****

+++++
Qed.
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) :\n  m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 ->\n  cong a p a q ->\n  m 0 1 = a 0 1.
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 -> cong a p a q -> m 0 1 = a 0 1.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (_ : negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (_ : cong a p a q), eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
+++++
Proof.
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 -> cong a p a q -> m 0 1 = a 0 1.
Proof.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (_ : negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))) (_ : cong a p a q), eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
+++++
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 -> cong a p a q -> m 0 1 = a 0 1.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
+++++
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 -> cong a p a q -> m 0 1 = a 0 1.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
+++++
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 -> cong a p a q -> m 0 1 = a 0 1.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.opp (GRing.zero R))) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (S (S O)))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
+++++
rewrite subr0 addr0 add2r_eq sqrrB [X in _ == X]sqrrD -!addrA add2r_eq.
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 -> cong a p a q -> m 0 1 = a 0 1.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
rewrite subr0 addr0 add2r_eq sqrrB [X in _ == X]sqrrD -!addrA add2r_eq.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.opp (GRing.natmul (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (S (S O)))) (GRing.exp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))) (GRing.add (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.add (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.exp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O))))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
+++++
rewrite !addrA -subr_eq -addrA subrr addr0 -mulr2n eq_sym -subr_eq0.
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 -> cong a p a q -> m 0 1 = a 0 1.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
rewrite subr0 addr0 add2r_eq sqrrB [X in _ == X]sqrrD -!addrA add2r_eq.
rewrite !addrA -subr_eq -addrA subrr addr0 -mulr2n eq_sym -subr_eq0.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.natmul (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (S (S O))) (GRing.opp (GRing.opp (GRing.natmul (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (S (S O)))))) (GRing.zero R), eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
+++++
rewrite -mulNrn -mulNr opprB -mulNrn -mulNr opprB -mulrnDr mulrn_eq0 mulf_eq0.
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 -> cong a p a q -> m 0 1 = a 0 1.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
rewrite subr0 addr0 add2r_eq sqrrB [X in _ == X]sqrrD -!addrA add2r_eq.
rewrite !addrA -subr_eq -addrA subrr addr0 -mulr2n eq_sym -subr_eq0.
rewrite -mulNrn -mulNr opprB -mulNrn -mulNr opprB -mulrnDr mulrn_eq0 mulf_eq0.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : orb (eq_op (addn (S (S O)) (S (S O))) O) (orb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
+++++
by rewrite /= subr_eq0 => /orP [/eqP->//|/eqP H]; move: NE; rewrite H eqxx.
-----
Lemma upper_dim_dgc1_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 0 - p 0 0 = 0 -> m 0 1 - p 0 1 != 0 -> cong a p a q -> m 0 1 = a 0 1.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
rewrite subr0 addr0 add2r_eq sqrrB [X in _ == X]sqrrD -!addrA add2r_eq.
rewrite !addrA -subr_eq -addrA subrr addr0 -mulr2n eq_sym -subr_eq0.
rewrite -mulNrn -mulNr opprB -mulNrn -mulNr opprB -mulrnDr mulrn_eq0 mulf_eq0.
by rewrite /= subr_eq0 => /orP [/eqP->//|/eqP H]; move: NE; rewrite H eqxx.

*****

*****

+++++
Qed.
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) :\n  p 0 0 - m 0 0 == 0 -> p <> q ->\n  cong a p a q -> cong b p b q -> cong c p c q ->\n  (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (_ : not (eq p q)) (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
Proof.
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (_ : not (eq p q)) (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
move=> E F.
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
move=> E F.

*****
F : not (eq p q)
E : is_true\n (eq_op\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
move: E F (upper_dim_dgc_aux0 E F).
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
move=> E F.
move: E F (upper_dim_dgc_aux0 E F).

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (_ : not (eq p q)) (_ : andb (eq_op (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))) (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
rewrite -/m=> _ _.
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
move=> E F.
move: E F (upper_dim_dgc_aux0 E F).
rewrite -/m=> _ _.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : andb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)) (negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)))) (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
move=> /andP[/eqP ? ?] C1 C2 C3.
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
move=> E F.
move: E F (upper_dim_dgc_aux0 E F).
rewrite -/m=> _ _.
move=> /andP[/eqP ? ?] C1 C2 C3.

*****
C3 : is_true (cong c p c q)
C2 : is_true (cong b p b q)
C1 : is_true (cong a p a q)
_b_ : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
__view_subject_2_ : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
apply upper_dim_dgc1_aux in C1=> //.
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
move=> E F.
move: E F (upper_dim_dgc_aux0 E F).
rewrite -/m=> _ _.
move=> /andP[/eqP ? ?] C1 C2 C3.
apply upper_dim_dgc1_aux in C1=> //.

*****
C3 : is_true (cong c p c q)
C2 : is_true (cong b p b q)
C1 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
_b_ : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
__view_subject_2_ : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
apply upper_dim_dgc1_aux in C2=> //.
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
move=> E F.
move: E F (upper_dim_dgc_aux0 E F).
rewrite -/m=> _ _.
move=> /andP[/eqP ? ?] C1 C2 C3.
apply upper_dim_dgc1_aux in C1=> //.
apply upper_dim_dgc1_aux in C2=> //.

*****
C3 : is_true (cong c p c q)
C2 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
C1 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
_b_ : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
__view_subject_2_ : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
apply upper_dim_dgc1_aux in C3=> //.
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
move=> E F.
move: E F (upper_dim_dgc_aux0 E F).
rewrite -/m=> _ _.
move=> /andP[/eqP ? ?] C1 C2 C3.
apply upper_dim_dgc1_aux in C1=> //.
apply upper_dim_dgc1_aux in C2=> //.
apply upper_dim_dgc1_aux in C3=> //.

*****
C3 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
C2 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
C1 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))
_b_ : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))) (GRing.zero R)))
__view_subject_2_ : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
by rewrite -C1 -C2 -C3 subrr mulr0 mul0r.
-----
Lemma upper_dim_dgc1 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : p 0 0 - m 0 0 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
move=> E F.
move: E F (upper_dim_dgc_aux0 E F).
rewrite -/m=> _ _.
move=> /andP[/eqP ? ?] C1 C2 C3.
apply upper_dim_dgc1_aux in C1=> //.
apply upper_dim_dgc1_aux in C2=> //.
apply upper_dim_dgc1_aux in C3=> //.
by rewrite -C1 -C2 -C3 subrr mulr0 mul0r.

*****

*****

+++++
Qed.
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) :\n  m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 ->\n  cong a p a q ->\n  m 0 0 = a 0 0.
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (_ : negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (_ : cong a p a q), eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
+++++
Proof.
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.
Proof.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (_ : negb (eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R))) (_ : cong a p a q), eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
+++++
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
+++++
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.exp (GRing.add (q (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (S (S O)))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
+++++
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.opp (GRing.zero R))) (S (S O)))) (GRing.add (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (S (S O))) (GRing.exp (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (S (S O)))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
+++++
rewrite subr0 addr0 addrC [X in _ == X]addrC add2r_eq sqrrB [X in _ == X]sqrrD.
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
rewrite subr0 addr0 addrC [X in _ == X]addrC add2r_eq sqrrB [X in _ == X]sqrrD.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.add (GRing.add (GRing.exp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.opp (GRing.natmul (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (S (S O))))) (GRing.exp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O)))) (GRing.add (GRing.add (GRing.exp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O))) (GRing.natmul (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (S (S O)))) (GRing.exp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (S (S O)))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
+++++
rewrite -!addrA add2r_eq !addrA -subr_eq -addrA subrr addr0 -mulr2n eq_sym.
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
rewrite subr0 addr0 addrC [X in _ == X]addrC add2r_eq sqrrB [X in _ == X]sqrrD.
rewrite -!addrA add2r_eq !addrA -subr_eq -addrA subrr addr0 -mulr2n eq_sym.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.natmul (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (S (S O))) (GRing.opp (GRing.natmul (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (S (S O)))), eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
+++++
rewrite -subr_eq0 -mulNrn -mulNr opprB -mulNrn -mulNr opprB -mulrnDr mulrn_eq0.
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
rewrite subr0 addr0 addrC [X in _ == X]addrC add2r_eq sqrrB [X in _ == X]sqrrD.
rewrite -!addrA add2r_eq !addrA -subr_eq -addrA subrr addr0 -mulr2n eq_sym.
rewrite -subr_eq0 -mulNrn -mulNr opprB -mulNrn -mulNr opprB -mulrnDr mulrn_eq0.

*****
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall _ : orb (eq_op (addn (S (S O)) (S (S O))) O) (eq_op (GRing.mul (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.zero R)), eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
+++++
rewrite mulf_eq0 /= subr_eq0 => /orP [/eqP->//|/eqP H].
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
rewrite subr0 addr0 addrC [X in _ == X]addrC add2r_eq sqrrB [X in _ == X]sqrrD.
rewrite -!addrA add2r_eq !addrA -subr_eq -addrA subrr addr0 -mulr2n eq_sym.
rewrite -subr_eq0 -mulNrn -mulNr opprB -mulNrn -mulNr opprB -mulrnDr mulrn_eq0.
rewrite mulf_eq0 /= subr_eq0 => /orP [/eqP->//|/eqP H].

*****
H : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)
NE : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
E : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
+++++
by move: NE; rewrite H eqxx.
-----
Lemma upper_dim_dgc2_aux (a p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 = 0 -> m 0 0 - p 0 0 != 0 -> cong a p a q -> m 0 0 = a 0 0.
Proof.
move=> E NE /congP/eqP C; move: C; rewrite /sqr_L2_norm_2D.
rewrite -(cong_perp_aux1 a p m) -[p 0 1 - a 0 1](cong_perp_aux1 a p m).
rewrite -(cong_perp_aux2 a p q) -[q 0 1 - a 0 1](cong_perp_aux2 a p) -!/m E.
rewrite subr0 addr0 addrC [X in _ == X]addrC add2r_eq sqrrB [X in _ == X]sqrrD.
rewrite -!addrA add2r_eq !addrA -subr_eq -addrA subrr addr0 -mulr2n eq_sym.
rewrite -subr_eq0 -mulNrn -mulNr opprB -mulNrn -mulNr opprB -mulrnDr mulrn_eq0.
rewrite mulf_eq0 /= subr_eq0 => /orP [/eqP->//|/eqP H].
by move: NE; rewrite H eqxx.

*****

*****

+++++
Qed.
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) :\n  m 0 1 - p 0 1 == 0 -> p <> q ->\n  cong a p a q -> cong b p b q -> cong c p c q ->\n  (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (_ : not (eq p q)) (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
Proof.
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (_ : not (eq p q)) (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
rewrite subr_eq0 eq_sym -subr_eq0=> E F.
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite subr_eq0 eq_sym -subr_eq0=> E F.

*****
F : not (eq p q)
E : is_true\n (eq_op\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R))
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
move: E F (upper_dim_dgc_aux1 E F).
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite subr_eq0 eq_sym -subr_eq0=> E F.
move: E F (upper_dim_dgc_aux1 E F).

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (_ : not (eq p q)) (_ : andb (eq_op (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.zero R)) (negb (eq_op (GRing.add ((GRing.scale (GRing.mul (GRing.one R) (GRing.inv (GRing.add (GRing.one R) (GRing.one R)))) (GRing.add p q)) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.zero R)))) (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
rewrite -/m=> _ _ /andP[/eqP ? ?] C1 C2 C3.
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite subr_eq0 eq_sym -subr_eq0=> E F.
move: E F (upper_dim_dgc_aux1 E F).
rewrite -/m=> _ _ /andP[/eqP ? ?] C1 C2 C3.

*****
C3 : is_true (cong c p c q)
C2 : is_true (cong b p b q)
C1 : is_true (cong a p a q)
_b_ : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
__view_subject_2_ : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
apply upper_dim_dgc2_aux in C1=> //.
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite subr_eq0 eq_sym -subr_eq0=> E F.
move: E F (upper_dim_dgc_aux1 E F).
rewrite -/m=> _ _ /andP[/eqP ? ?] C1 C2 C3.
apply upper_dim_dgc2_aux in C1=> //.

*****
C3 : is_true (cong c p c q)
C2 : is_true (cong b p b q)
C1 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
_b_ : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
__view_subject_2_ : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
apply upper_dim_dgc2_aux in C2=> //.
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite subr_eq0 eq_sym -subr_eq0=> E F.
move: E F (upper_dim_dgc_aux1 E F).
rewrite -/m=> _ _ /andP[/eqP ? ?] C1 C2 C3.
apply upper_dim_dgc2_aux in C1=> //.
apply upper_dim_dgc2_aux in C2=> //.

*****
C3 : is_true (cong c p c q)
C2 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
C1 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
_b_ : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
__view_subject_2_ : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
apply upper_dim_dgc2_aux in C3=> //.
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite subr_eq0 eq_sym -subr_eq0=> E F.
move: E F (upper_dim_dgc_aux1 E F).
rewrite -/m=> _ _ /andP[/eqP ? ?] C1 C2 C3.
apply upper_dim_dgc2_aux in C1=> //.
apply upper_dim_dgc2_aux in C2=> //.
apply upper_dim_dgc2_aux in C3=> //.

*****
C3 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
C2 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
C1 : eq\n ((GRing.scale\n (GRing.mul (GRing.one R)\n (GRing.inv (GRing.add (GRing.one R) (GRing.one R))))\n (GRing.add p q)) (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))
_b_ : is_true\n (negb\n (eq_op\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))) \n (GRing.zero R)))
__view_subject_2_ : eq\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))\n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
a,b,c,p,q : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
by rewrite -C1 -C2 -C3 subrr mul0r mulr0.
-----
Lemma upper_dim_dgc2 (a b c p q : 'rV[R]_(2)) (m := (1 / (1 + 1)) *: (p + q)) : m 0 1 - p 0 1 == 0 -> p <> q -> cong a p a q -> cong b p b q -> cong c p c q -> (a 0 0 - b 0 0) * (b 0 1 - c 0 1) == (a 0 1 - b 0 1) * (b 0 0 - c 0 0).
Proof.
rewrite subr_eq0 eq_sym -subr_eq0=> E F.
move: E F (upper_dim_dgc_aux1 E F).
rewrite -/m=> _ _ /andP[/eqP ? ?] C1 C2 C3.
apply upper_dim_dgc2_aux in C1=> //.
apply upper_dim_dgc2_aux in C2=> //.
apply upper_dim_dgc2_aux in C3=> //.
by rewrite -C1 -C2 -C3 subrr mul0r mulr0.

*****

*****

+++++
Qed.
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) :\n  c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 ->\n  c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 ->\n  c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) : c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 -> c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 -> c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).

*****
c0,c1 : Num.RealField.sort R
a,b,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq (GRing.add (GRing.mul c0 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul c1 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)) (_ : eq (GRing.add (GRing.mul c0 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul c1 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)), eq (GRing.mul c0 (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp c1) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
Proof.
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) : c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 -> c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 -> c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).
Proof.

*****
c0,c1 : Num.RealField.sort R
a,b,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq (GRing.add (GRing.mul c0 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul c1 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)) (_ : eq (GRing.add (GRing.mul c0 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul c1 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)), eq (GRing.mul c0 (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp c1) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
move=> /eqP E1 /eqP E2.
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) : c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 -> c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 -> c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).
Proof.
move=> /eqP E1 /eqP E2.

*****
E2 : is_true\n (eq_op\n (GRing.add\n (GRing.mul c0\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul c1\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R))
E1 : is_true\n (eq_op\n (GRing.add\n (GRing.mul c0\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul c1\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R))
c0,c1 : Num.RealField.sort R
a,b,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (GRing.mul c0 (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp c1) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
move: E1 E2.
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) : c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 -> c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 -> c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).
Proof.
move=> /eqP E1 /eqP E2.
move: E1 E2.

*****
c0,c1 : Num.RealField.sort R
a,b,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.add (GRing.mul c0 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul c1 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)) (_ : eq_op (GRing.add (GRing.mul c0 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul c1 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)), eq (GRing.mul c0 (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp c1) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
rewrite !addr_eq0 -!mulNr.
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) : c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 -> c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 -> c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).
Proof.
move=> /eqP E1 /eqP E2.
move: E1 E2.
rewrite !addr_eq0 -!mulNr.

*****
c0,c1 : Num.RealField.sort R
a,b,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
forall (_ : eq_op (GRing.mul c0 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp c1) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (_ : eq_op (GRing.mul c0 (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp c1) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))), eq (GRing.mul c0 (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp c1) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
move=> /eqP E1 /eqP E2.
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) : c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 -> c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 -> c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).
Proof.
move=> /eqP E1 /eqP E2.
move: E1 E2.
rewrite !addr_eq0 -!mulNr.
move=> /eqP E1 /eqP E2.

*****
E2 : eq\n (GRing.mul c0\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul (GRing.opp c1)\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E1 : eq\n (GRing.mul c0\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul (GRing.opp c1)\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
c0,c1 : Num.RealField.sort R
a,b,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
eq (GRing.mul c0 (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp c1) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
+++++
apply /eqP.
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) : c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 -> c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 -> c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).
Proof.
move=> /eqP E1 /eqP E2.
move: E1 E2.
rewrite !addr_eq0 -!mulNr.
move=> /eqP E1 /eqP E2.
apply /eqP.

*****
E2 : eq\n (GRing.mul c0\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul (GRing.opp c1)\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E1 : eq\n (GRing.mul c0\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul (GRing.opp c1)\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
c0,c1 : Num.RealField.sort R
a,b,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul c0 (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp c1) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))))
+++++
rewrite -(addrBBB (m 0 0)) eq_sym.
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) : c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 -> c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 -> c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).
Proof.
move=> /eqP E1 /eqP E2.
move: E1 E2.
rewrite !addr_eq0 -!mulNr.
move=> /eqP E1 /eqP E2.
apply /eqP.
rewrite -(addrBBB (m 0 0)) eq_sym.

*****
E2 : eq\n (GRing.mul c0\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul (GRing.opp c1)\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
E1 : eq\n (GRing.mul c0\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul (GRing.opp c1)\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))
c0,c1 : Num.RealField.sort R
a,b,m : matrix R (S O) (S (S O))
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.opp c1) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul c0 (GRing.add (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.opp (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))))
+++++
by rewrite -(addrBBB (m 0 1)) mulrBr eq_sym mulrBr -E1 -E2.
-----
Lemma upper_dim_aux (a b m : 'rV[R]_(2)) (c0 c1: R) : c0 * (m 0 0 - a 0 0) + c1 * (m 0 1 - a 0 1) = 0 -> c0 * (m 0 0 - b 0 0) + c1 * (m 0 1 - b 0 1) = 0 -> c0 * (b 0 0 - a 0 0) = - c1 * (b 0 1 - a 0 1).
Proof.
move=> /eqP E1 /eqP E2.
move: E1 E2.
rewrite !addr_eq0 -!mulNr.
move=> /eqP E1 /eqP E2.
apply /eqP.
rewrite -(addrBBB (m 0 0)) eq_sym.
by rewrite -(addrBBB (m 0 1)) mulrBr eq_sym mulrBr -E1 -E2.

*****

*****

+++++
Qed.
-----
Lemma upper_dim a b c p q :\n  p <> q -> a <> b -> a <> c -> b <> c ->\n  cong a p a q -> cong b p b q -> cong c p c q ->\n  (bet a b c \/ bet b c a \/ bet c a b).
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).

*****
a,b,c,p,q : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq p q)) (_ : not (eq a b)) (_ : not (eq a c)) (_ : not (eq b c)) (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), or (bet a b c) (or (bet b c a) (bet c a b))
+++++
Proof.
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.

*****
a,b,c,p,q : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : not (eq p q)) (_ : not (eq a b)) (_ : not (eq a c)) (_ : not (eq b c)) (_ : cong a p a q) (_ : cong b p b q) (_ : cong c p c q), or (bet a b c) (or (bet b c a) (bet c a b))
+++++
move=> ? _ _ _ H1 H2 H3; apply col_2D.
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> ? _ _ _ H1 H2 H3; apply col_2D.

*****
H3 : is_true (cong c p c q)
H2 : is_true (cong b p b q)
H1 : is_true (cong a p a q)
_Hyp_ : not (eq p q)
a,b,c,p,q : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))))
+++++
move: (cong_perp H1) (cong_perp H2) (cong_perp H3); set m := (1/(1+1)) *: (p+q).
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> ? _ _ _ H1 H2 H3; apply col_2D.
move: (cong_perp H1) (cong_perp H2) (cong_perp H3); set m := (1/(1+1)) *: (p+q).

*****
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
H3 : is_true (cong c p c q)
H2 : is_true (cong b p b q)
H1 : is_true (cong a p a q)
_Hyp_ : not (eq p q)
a,b,c,p,q : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (GRing.add (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)) (_ : eq (GRing.add (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)) (_ : eq (GRing.add (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (GRing.zero R)), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
move=> HP1 HP2 HP3; move: (upper_dim_aux HP2 HP1) (upper_dim_aux HP3 HP2).
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> ? _ _ _ H1 H2 H3; apply col_2D.
move: (cong_perp H1) (cong_perp H2) (cong_perp H3); set m := (1/(1+1)) *: (p+q).
move=> HP1 HP2 HP3; move: (upper_dim_aux HP2 HP1) (upper_dim_aux HP3 HP2).

*****
HP3 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP2 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP1 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
H3 : is_true (cong c p c q)
H2 : is_true (cong b p b q)
H1 : is_true (cong a p a q)
_Hyp_ : not (eq p q)
a,b,c,p,q : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (_ : eq (GRing.mul (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul (GRing.opp (GRing.add (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
rewrite opprB; set mp0 := p 0 0 - m 0 0; set pm1 := m 0 1 - p 0 1.
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> ? _ _ _ H1 H2 H3; apply col_2D.
move: (cong_perp H1) (cong_perp H2) (cong_perp H3); set m := (1/(1+1)) *: (p+q).
move=> HP1 HP2 HP3; move: (upper_dim_aux HP2 HP1) (upper_dim_aux HP3 HP2).
rewrite opprB; set mp0 := p 0 0 - m 0 0; set pm1 := m 0 1 - p 0 1.

*****
pm1 : GRing.Zmodule.sort R
mp0 : GRing.Zmodule.sort R
HP3 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP2 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP1 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
H3 : is_true (cong c p c q)
H2 : is_true (cong b p b q)
H1 : is_true (cong a p a q)
_Hyp_ : not (eq p q)
a,b,c,p,q : Vector R (S O)
R : Num\.RealField\.type
*****
forall (_ : eq (GRing.mul mp0 (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul pm1 (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))) (_ : eq (GRing.mul mp0 (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O))))))) (GRing.mul pm1 (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))))), eq_op (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))))) (GRing.mul (GRing.add (a (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))) (GRing.opp (b (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O))))) (GRing.add (b (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))) (GRing.opp (c (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType (S O)))))))
+++++
set ba0 := a 0 0 - b 0 0; set ba1 := a 0 1 - b 0 1; set cb0 := b 0 0 - c 0 0; set cb1 := b 0 1 - c 0 1; move=> E1 E2.
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> ? _ _ _ H1 H2 H3; apply col_2D.
move: (cong_perp H1) (cong_perp H2) (cong_perp H3); set m := (1/(1+1)) *: (p+q).
move=> HP1 HP2 HP3; move: (upper_dim_aux HP2 HP1) (upper_dim_aux HP3 HP2).
rewrite opprB; set mp0 := p 0 0 - m 0 0; set pm1 := m 0 1 - p 0 1.
set ba0 := a 0 0 - b 0 0; set ba1 := a 0 1 - b 0 1; set cb0 := b 0 0 - c 0 0; set cb1 := b 0 1 - c 0 1; move=> E1 E2.

*****
E2 : eq (GRing.mul mp0 cb0) (GRing.mul pm1 cb1)
E1 : eq (GRing.mul mp0 ba0) (GRing.mul pm1 ba1)
cb1 : GRing.Zmodule.sort R
cb0 : GRing.Zmodule.sort R
ba1 : GRing.Zmodule.sort R
ba0 : GRing.Zmodule.sort R
pm1 : GRing.Zmodule.sort R
mp0 : GRing.Zmodule.sort R
HP3 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP2 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP1 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
H3 : is_true (cong c p c q)
H2 : is_true (cong b p b q)
H1 : is_true (cong a p a q)
_Hyp_ : not (eq p q)
a,b,c,p,q : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul ba0 cb1) (GRing.mul ba1 cb0))
+++++
have: (mp0 * pm1 * (ba0 * cb1) == mp0 * pm1 * (ba1 * cb0)).
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> ? _ _ _ H1 H2 H3; apply col_2D.
move: (cong_perp H1) (cong_perp H2) (cong_perp H3); set m := (1/(1+1)) *: (p+q).
move=> HP1 HP2 HP3; move: (upper_dim_aux HP2 HP1) (upper_dim_aux HP3 HP2).
rewrite opprB; set mp0 := p 0 0 - m 0 0; set pm1 := m 0 1 - p 0 1.
set ba0 := a 0 0 - b 0 0; set ba1 := a 0 1 - b 0 1; set cb0 := b 0 0 - c 0 0; set cb1 := b 0 1 - c 0 1; move=> E1 E2.
have: (mp0 * pm1 * (ba0 * cb1) == mp0 * pm1 * (ba1 * cb0)).

*****
E2 : eq (GRing.mul mp0 cb0) (GRing.mul pm1 cb1)
E1 : eq (GRing.mul mp0 ba0) (GRing.mul pm1 ba1)
cb1 : GRing.Zmodule.sort R
cb0 : GRing.Zmodule.sort R
ba1 : GRing.Zmodule.sort R
ba0 : GRing.Zmodule.sort R
pm1 : GRing.Zmodule.sort R
mp0 : GRing.Zmodule.sort R
HP3 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP2 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP1 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
H3 : is_true (cong c p c q)
H2 : is_true (cong b p b q)
H1 : is_true (cong a p a q)
_Hyp_ : not (eq p q)
a,b,c,p,q : Vector R (S O)
R : Num\.RealField\.type
*****
is_true (eq_op (GRing.mul (GRing.mul mp0 pm1) (GRing.mul ba0 cb1)) (GRing.mul (GRing.mul mp0 pm1) (GRing.mul ba1 cb0)))
+++++
by apply /eqP; rewrite mulrACA E1 -E2 -mulrACA [pm1* mp0]mulrC.
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> ? _ _ _ H1 H2 H3; apply col_2D.
move: (cong_perp H1) (cong_perp H2) (cong_perp H3); set m := (1/(1+1)) *: (p+q).
move=> HP1 HP2 HP3; move: (upper_dim_aux HP2 HP1) (upper_dim_aux HP3 HP2).
rewrite opprB; set mp0 := p 0 0 - m 0 0; set pm1 := m 0 1 - p 0 1.
set ba0 := a 0 0 - b 0 0; set ba1 := a 0 1 - b 0 1; set cb0 := b 0 0 - c 0 0; set cb1 := b 0 1 - c 0 1; move=> E1 E2.
have: (mp0 * pm1 * (ba0 * cb1) == mp0 * pm1 * (ba1 * cb0)).
by apply /eqP; rewrite mulrACA E1 -E2 -mulrACA [pm1* mp0]mulrC.

*****
E2 : eq (GRing.mul mp0 cb0) (GRing.mul pm1 cb1)
E1 : eq (GRing.mul mp0 ba0) (GRing.mul pm1 ba1)
cb1 : GRing.Zmodule.sort R
cb0 : GRing.Zmodule.sort R
ba1 : GRing.Zmodule.sort R
ba0 : GRing.Zmodule.sort R
pm1 : GRing.Zmodule.sort R
mp0 : GRing.Zmodule.sort R
HP3 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (c (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP2 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (b (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
HP1 : eq\n (GRing.add\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O))))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.zero (Zp_zmodType (S O)))))))\n (GRing.mul\n (GRing.add\n (p (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (m (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O)))))\n (GRing.add\n (m (GRing.zero (Zp_zmodType O)) (GRing.one (Zp_ringType O)))\n (GRing.opp\n (a (GRing.zero (Zp_zmodType O))\n (GRing.one (Zp_ringType O))))))) \n (GRing.zero R)
m : GRing.Zmodule.sort\n (GRing.Zmodule.Pack\n (GRing.Lmodule.class (matrix_lmodType R (S O) (S (S O)))))
H3 : is_true (cong c p c q)
H2 : is_true (cong b p b q)
H1 : is_true (cong a p a q)
_Hyp_ : not (eq p q)
a,b,c,p,q : Vector R (S O)
R : Num\.RealField\.type
*****
forall _ : eq_op (GRing.mul (GRing.mul mp0 pm1) (GRing.mul ba0 cb1)) (GRing.mul (GRing.mul mp0 pm1) (GRing.mul ba1 cb0)), eq_op (GRing.mul ba0 cb1) (GRing.mul ba1 cb0)
+++++
rewrite -subr_eq0 -mulrBr mulf_eq0 subr_eq0 mulf_eq0=> /orP[/orP[C1|C2]|->//]; by [apply upper_dim_dgc1 with p q|apply upper_dim_dgc2 with p q].
-----
Lemma upper_dim a b c p q : p <> q -> a <> b -> a <> c -> b <> c -> cong a p a q -> cong b p b q -> cong c p c q -> (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> ? _ _ _ H1 H2 H3; apply col_2D.
move: (cong_perp H1) (cong_perp H2) (cong_perp H3); set m := (1/(1+1)) *: (p+q).
move=> HP1 HP2 HP3; move: (upper_dim_aux HP2 HP1) (upper_dim_aux HP3 HP2).
rewrite opprB; set mp0 := p 0 0 - m 0 0; set pm1 := m 0 1 - p 0 1.
set ba0 := a 0 0 - b 0 0; set ba1 := a 0 1 - b 0 1; set cb0 := b 0 0 - c 0 0; set cb1 := b 0 1 - c 0 1; move=> E1 E2.
have: (mp0 * pm1 * (ba0 * cb1) == mp0 * pm1 * (ba1 * cb0)).
by apply /eqP; rewrite mulrACA E1 -E2 -mulrACA [pm1* mp0]mulrC.
rewrite -subr_eq0 -mulrBr mulf_eq0 subr_eq0 mulf_eq0=> /orP[/orP[C1|C2]|->//]; by [apply upper_dim_dgc1 with p q|apply upper_dim_dgc2 with p q].

*****

*****

+++++
Qed.
-----
Definition row2 {R : ringType} (a b : R) : 'rV[R]_2 :=\n  \row_p [eta \0 with 0 |-> a, 1 |-> b] p.
-----
Definition a : (@Vector R 1) := row2 0 0.
-----
Definition b : (@Vector R 1) := row2 0 1.
-----
Definition c : (@Vector R 1) := row2 1 0.
-----
Lemma row2_eq (a b c d : R) : row2 a b == row2 c d = ((a == c) && (b == d)).
-----
Lemma row2_eq (a b c d : R) : row2 a b == row2 c d = ((a == c) && (b == d)).

*****
a,b,c,d : Num.RealField.sort R
R : Num\.RealField\.type
*****
eq (eq_op (row2 a b) (row2 c d)) (andb (eq_op a c) (eq_op b d))
+++++
Proof.
-----
Lemma row2_eq (a b c d : R) : row2 a b == row2 c d = ((a == c) && (b == d)).
Proof.

*****
a,b,c,d : Num.RealField.sort R
R : Num\.RealField\.type
*****
eq (eq_op (row2 a b) (row2 c d)) (andb (eq_op a c) (eq_op b d))
+++++
apply /eqP; case: (a =P c)=> [->|/eqP Hv0]; case: (b =P d)=> [->|/eqP Hv1] //=; by apply/eqP; rewrite vector2_eq !mxE ?eqxx //= andbC //= negb_and Hv0 Hv1.
-----
Lemma row2_eq (a b c d : R) : row2 a b == row2 c d = ((a == c) && (b == d)).
Proof.
apply /eqP; case: (a =P c)=> [->|/eqP Hv0]; case: (b =P d)=> [->|/eqP Hv1] //=; by apply/eqP; rewrite vector2_eq !mxE ?eqxx //= andbC //= negb_and Hv0 Hv1.

*****

*****

+++++
Qed.
-----
Lemma row2_eq0 (a b : R) : row2 a b == 0 = ((a == 0) && (b == 0)).
-----
Lemma row2_eq0 (a b : R) : row2 a b == 0 = ((a == 0) && (b == 0)).

*****
a,b : Num.RealField.sort R
R : Num\.RealField\.type
*****
eq (eq_op (row2 a b) (GRing.zero (matrix_zmodType R (S O) (S (S O))))) (andb (eq_op a (GRing.zero R)) (eq_op b (GRing.zero R)))
+++++
Proof.
-----
Lemma row2_eq0 (a b : R) : row2 a b == 0 = ((a == 0) && (b == 0)).
Proof.

*****
a,b : Num.RealField.sort R
R : Num\.RealField\.type
*****
eq (eq_op (row2 a b) (GRing.zero (matrix_zmodType R (S O) (S (S O))))) (andb (eq_op a (GRing.zero R)) (eq_op b (GRing.zero R)))
+++++
apply /eqP; case: (a =P 0)=> [->|/eqP Hv0]; case: (b =P 0)=> [->|/eqP Hv1] //=; by apply/eqP; rewrite vector2_eq !mxE ?eqxx //= andbC //= negb_and Hv0 Hv1.
-----
Lemma row2_eq0 (a b : R) : row2 a b == 0 = ((a == 0) && (b == 0)).
Proof.
apply /eqP; case: (a =P 0)=> [->|/eqP Hv0]; case: (b =P 0)=> [->|/eqP Hv1] //=; by apply/eqP; rewrite vector2_eq !mxE ?eqxx //= andbC //= negb_and Hv0 Hv1.

*****

*****

+++++
Qed.
-----
Lemma a_eq0 : a = 0.
-----
Lemma a_eq0 : a = 0.

*****
R : Num\.RealField\.type
*****
eq a (GRing.zero (matrix_zmodType R (S O) (S (S O))))
+++++
Proof.
-----
Lemma a_eq0 : a = 0.
Proof.

*****
R : Num\.RealField\.type
*****
eq a (GRing.zero (matrix_zmodType R (S O) (S (S O))))
+++++
by rewrite /a; apply /eqP; rewrite vector2_eq !mxE /= eqxx.
-----
Lemma a_eq0 : a = 0.
Proof.
by rewrite /a; apply /eqP; rewrite vector2_eq !mxE /= eqxx.

*****

*****

+++++
Qed.
-----
Lemma ab_neq : a == b = false.
-----
Lemma ab_neq : a == b = false.

*****
R : Num\.RealField\.type
*****
eq (eq_op a b) false
+++++
Proof.
-----
Lemma ab_neq : a == b = false.
Proof.

*****
R : Num\.RealField\.type
*****
eq (eq_op a b) false
+++++
by rewrite row2_eq eqxx /= eq_sym oner_eq0.
-----
Lemma ab_neq : a == b = false.
Proof.
by rewrite row2_eq eqxx /= eq_sym oner_eq0.

*****

*****

+++++
Qed.
-----
Lemma bc_neq : b == c = false.
-----
Lemma bc_neq : b == c = false.

*****
R : Num\.RealField\.type
*****
eq (eq_op b c) false
+++++
Proof.
-----
Lemma bc_neq : b == c = false.
Proof.

*****
R : Num\.RealField\.type
*****
eq (eq_op b c) false
+++++
by rewrite row2_eq oner_eq0 andbC.
-----
Lemma bc_neq : b == c = false.
Proof.
by rewrite row2_eq oner_eq0 andbC.

*****

*****

+++++
Qed.
-----
Lemma ca_neq : c == a = false.
-----
Lemma ca_neq : c == a = false.

*****
R : Num\.RealField\.type
*****
eq (eq_op c a) false
+++++
Proof.
-----
Lemma ca_neq : c == a = false.
Proof.

*****
R : Num\.RealField\.type
*****
eq (eq_op c a) false
+++++
by rewrite row2_eq oner_eq0.
-----
Lemma ca_neq : c == a = false.
Proof.
by rewrite row2_eq oner_eq0.

*****

*****

+++++
Qed.
-----
Lemma betR_abc : betR a b c = 0.
-----
Lemma betR_abc : betR a b c = 0.

*****
R : Num\.RealField\.type
*****
eq (betR a b c) (GRing.zero R)
+++++
Proof.
-----
Lemma betR_abc : betR a b c = 0.
Proof.

*****
R : Num\.RealField\.type
*****
eq (betR a b c) (GRing.zero R)
+++++
rewrite /betR /ratio; case: pickP => /= [x|all_v_neq0 //].
-----
Lemma betR_abc : betR a b c = 0.
Proof.
rewrite /betR /ratio; case: pickP => /= [x|all_v_neq0 //].

*****
x : ordinal (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op ((GRing.add c (GRing.opp a)) (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)), eq (GRing.mul ((GRing.add b (GRing.opp a)) (GRing.zero (Zp_zmodType O)) x) (GRing.inv ((GRing.add c (GRing.opp a)) (GRing.zero (Zp_zmodType O)) x))) (GRing.zero R)
+++++
rewrite /a /b /c !mxE /=; case: x => [] [|[| //]] //= p; by rewrite !subr0 ?divr1 ?eqxx.
-----
Lemma betR_abc : betR a b c = 0.
Proof.
rewrite /betR /ratio; case: pickP => /= [x|all_v_neq0 //].
rewrite /a /b /c !mxE /=; case: x => [] [|[| //]] //= p; by rewrite !subr0 ?divr1 ?eqxx.

*****

*****

+++++
Qed.
-----
Lemma betR_bca : betR b c a = 1.
-----
Lemma betR_bca : betR b c a = 1.

*****
R : Num\.RealField\.type
*****
eq (betR b c a) (GRing.one R)
+++++
Proof.
-----
Lemma betR_bca : betR b c a = 1.
Proof.

*****
R : Num\.RealField\.type
*****
eq (betR b c a) (GRing.one R)
+++++
rewrite /betR /ratio a_eq0 sub0r; case: pickP => /= [x|/all_v_neq0 H].
-----
Lemma betR_bca : betR b c a = 1.
Proof.
rewrite /betR /ratio a_eq0 sub0r; case: pickP => /= [x|/all_v_neq0 H].

*****
x : ordinal (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op ((GRing.opp b) (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)), eq (GRing.mul ((GRing.add c (GRing.opp b)) (GRing.zero (Zp_zmodType O)) x) (GRing.inv ((GRing.opp b) (GRing.zero (Zp_zmodType O)) x))) (GRing.one R)
+++++
rewrite /b /c !mxE /=; case: x => [] [|[| //]] //= p; by rewrite oppr_eq0 ?eqxx // sub0r divff // oppr_eq0 oner_eq0.
-----
Lemma betR_bca : betR b c a = 1.
Proof.
rewrite /betR /ratio a_eq0 sub0r; case: pickP => /= [x|/all_v_neq0 H].
rewrite /b /c !mxE /=; case: x => [] [|[| //]] //= p; by rewrite oppr_eq0 ?eqxx // sub0r divff // oppr_eq0 oner_eq0.

*****
H : forall\n _ : negb\n (eq_op (GRing.opp b)\n (GRing.zero (matrix_zmodType R (S O) (S (S O))))), False
R : Num\.RealField\.type
*****
eq (GRing.zero R) (GRing.one R)
+++++
by exfalso; apply H; rewrite oppr_eq0 -a_eq0 /a /b row2_eq oner_eq0 eqxx.
-----
Lemma betR_bca : betR b c a = 1.
Proof.
rewrite /betR /ratio a_eq0 sub0r; case: pickP => /= [x|/all_v_neq0 H].
rewrite /b /c !mxE /=; case: x => [] [|[| //]] //= p; by rewrite oppr_eq0 ?eqxx // sub0r divff // oppr_eq0 oner_eq0.
by exfalso; apply H; rewrite oppr_eq0 -a_eq0 /a /b row2_eq oner_eq0 eqxx.

*****

*****

+++++
Qed.
-----
Lemma betR_cab : betR c a b = 0 \/ betR c a b = 1.
-----
Lemma betR_cab : betR c a b = 0 \\/ betR c a b = 1.

*****
R : Num\.RealField\.type
*****
or (eq (betR c a b) (GRing.zero R)) (eq (betR c a b) (GRing.one R))
+++++
Proof.
-----
Lemma betR_cab : betR c a b = 0 \\/ betR c a b = 1.
Proof.

*****
R : Num\.RealField\.type
*****
or (eq (betR c a b) (GRing.zero R)) (eq (betR c a b) (GRing.one R))
+++++
rewrite /betR /ratio a_eq0 sub0r; case: pickP => /= [x|/all_v_neq0 H].
-----
Lemma betR_cab : betR c a b = 0 \\/ betR c a b = 1.
Proof.
rewrite /betR /ratio a_eq0 sub0r; case: pickP => /= [x|/all_v_neq0 H].

*****
x : ordinal (S (S O))
R : Num\.RealField\.type
*****
forall _ : negb (eq_op ((GRing.add b (GRing.opp c)) (GRing.zero (Zp_zmodType O)) x) (GRing.zero R)), or (eq (GRing.mul ((GRing.opp c) (GRing.zero (Zp_zmodType O)) x) (GRing.inv ((GRing.add b (GRing.opp c)) (GRing.zero (Zp_zmodType O)) x))) (GRing.zero R)) (eq (GRing.mul ((GRing.opp c) (GRing.zero (Zp_zmodType O)) x) (GRing.inv ((GRing.add b (GRing.opp c)) (GRing.zero (Zp_zmodType O)) x))) (GRing.one R))
+++++
rewrite /b /c !mxE /=; case: x => [] [|[| //]] //= p; by rewrite ?subr0 ?divr1 ?oppr0 ?sub0r ?divff ?oppr_eq0 ?oner_eq0; tauto.
-----
Lemma betR_cab : betR c a b = 0 \\/ betR c a b = 1.
Proof.
rewrite /betR /ratio a_eq0 sub0r; case: pickP => /= [x|/all_v_neq0 H].
rewrite /b /c !mxE /=; case: x => [] [|[| //]] //= p; by rewrite ?subr0 ?divr1 ?oppr0 ?sub0r ?divff ?oppr_eq0 ?oner_eq0; tauto.

*****
H : forall\n _ : negb\n (eq_op (GRing.add b (GRing.opp c))\n (GRing.zero (matrix_zmodType R (S O) (S (S O))))), False
R : Num\.RealField\.type
*****
or (eq (GRing.zero R) (GRing.zero R)) (eq (GRing.zero R) (GRing.one R))
+++++
by exfalso; apply H; rewrite /b /c vector2_eq !mxE subr0 oner_eq0 andbC.
-----
Lemma betR_cab : betR c a b = 0 \\/ betR c a b = 1.
Proof.
rewrite /betR /ratio a_eq0 sub0r; case: pickP => /= [x|/all_v_neq0 H].
rewrite /b /c !mxE /=; case: x => [] [|[| //]] //= p; by rewrite ?subr0 ?divr1 ?oppr0 ?sub0r ?divff ?oppr_eq0 ?oner_eq0; tauto.
by exfalso; apply H; rewrite /b /c vector2_eq !mxE subr0 oner_eq0 andbC.

*****

*****

+++++
Qed.
-----
Lemma lower_dim : ~ (bet a b c \/ bet b c a \/ bet c a b).
-----
Lemma lower_dim : ~ (bet a b c \\/ bet b c a \\/ bet c a b).

*****
R : Num\.RealField\.type
*****
not (or (bet a b c) (or (bet b c a) (bet c a b)))
+++++
Proof.
-----
Lemma lower_dim : ~ (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.

*****
R : Num\.RealField\.type
*****
not (or (bet a b c) (or (bet b c a) (bet c a b)))
+++++
move=> H; move: H; rewrite /bet /betE ab_neq bc_neq ca_neq /=.
-----
Lemma lower_dim : ~ (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> H; move: H; rewrite /bet /betE ab_neq bc_neq ca_neq /=.

*****
R : Num\.RealField\.type
*****
forall _ : or (betS a b c) (or (betS b c a) (betS c a b)), False
+++++
rewrite /betS betR_abc betR_bca; elim (betR_cab)=> [->|->]; rewrite !ltrr ltr01; by rewrite /= ![_ && false]andbC /=; firstorder.
-----
Lemma lower_dim : ~ (bet a b c \\/ bet b c a \\/ bet c a b).
Proof.
move=> H; move: H; rewrite /bet /betE ab_neq bc_neq ca_neq /=.
rewrite /betS betR_abc betR_bca; elim (betR_cab)=> [->|->]; rewrite !ltrr ltr01; by rewrite /= ![_ && false]andbC /=; firstorder.

*****

*****

+++++
Qed.
-----
End Tarski2D.
-----
Section RcfTarski.
-----
Variable R : rcfType.
-----
Variable n : nat.
-----
Implicit Types (a b c d : 'rV[R]_(n.+1)).
-----
Definition normv (x : 'rV[R]_(n.+1)) : R := Num.sqrt ((x *m x^T) 0 0).
-----
Lemma segment_construction a b c d :\n    exists e, bet a b e /\ cong b e c d.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.

*****
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
ex (fun e : Vector R n => and (bet a b e) (cong b e c d))
+++++
Proof.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.

*****
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
ex (fun e : Vector R n => and (bet a b e) (cong b e c d))
+++++
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].

*****
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
ex (fun e : Vector R n => and (bet a a e) (cong a e c d))
+++++
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.

*****
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
is_true (eq_op (mulmx (GRing.add (GRing.add (GRing.add c (GRing.opp d)) a) (GRing.opp a)) (trmx (GRing.add (GRing.add (GRing.add c (GRing.opp d)) a) (GRing.opp a)))) (mulmx (GRing.add d (GRing.opp c)) (trmx (GRing.add d (GRing.opp c)))))
+++++
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.

*****
neq_ba : is_true\n (negb\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
ex (fun e : Vector R n => and (bet a b e) (cong b e c d))
+++++
have [->|neq_dc] := eqVneq d c ; [|move: neq_dc; rewrite -subr_eq0=> neq_dc].
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.
have [->|neq_dc] := eqVneq d c ; [|move: neq_dc; rewrite -subr_eq0=> neq_dc].

*****
neq_ba : is_true\n (negb\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
ex (fun e : Vector R n => and (bet a b e) (cong b e c c))
+++++
by exists b; rewrite /bet /cong betE_axx !subrr mul0mx eqxx; split.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.
have [->|neq_dc] := eqVneq d c ; [|move: neq_dc; rewrite -subr_eq0=> neq_dc].
by exists b; rewrite /bet /cong betE_axx !subrr mul0mx eqxx; split.

*****
neq_dc : is_true\n (negb\n (eq_op (GRing.add d (GRing.opp c))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
neq_ba : is_true\n (negb\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
ex (fun e : Vector R n => and (bet a b e) (cong b e c d))
+++++
exists (normv(d - c) / normv(b - a) *: (b - a) + b); rewrite /bet /cong; split.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.
have [->|neq_dc] := eqVneq d c ; [|move: neq_dc; rewrite -subr_eq0=> neq_dc].
by exists b; rewrite /bet /cong betE_axx !subrr mul0mx eqxx; split.
exists (normv(d - c) / normv(b - a) *: (b - a) + b); rewrite /bet /cong; split.

*****
neq_dc : is_true\n (negb\n (eq_op (GRing.add d (GRing.opp c))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
neq_ba : is_true\n (negb\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
is_true (orb (betE a b (GRing.add (GRing.scale (GRing.mul (normv (GRing.add d (GRing.opp c))) (GRing.inv (normv (GRing.add b (GRing.opp a))))) (GRing.add b (GRing.opp a))) b)) (betS a b (GRing.add (GRing.scale (GRing.mul (normv (GRing.add d (GRing.opp c))) (GRing.inv (normv (GRing.add b (GRing.opp a))))) (GRing.add b (GRing.opp a))) b)))
+++++
rewrite /betS /betR; apply/orP; right; rewrite -addrA.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.
have [->|neq_dc] := eqVneq d c ; [|move: neq_dc; rewrite -subr_eq0=> neq_dc].
by exists b; rewrite /bet /cong betE_axx !subrr mul0mx eqxx; split.
exists (normv(d - c) / normv(b - a) *: (b - a) + b); rewrite /bet /cong; split.
rewrite /betS /betR; apply/orP; right; rewrite -addrA.

*****
neq_dc : is_true\n (negb\n (eq_op (GRing.add d (GRing.opp c))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
neq_ba : is_true\n (negb\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
is_true (andb (eq_op (GRing.add b (GRing.opp a)) (GRing.scale (ratio (GRing.add b (GRing.opp a)) (GRing.add (GRing.scale (GRing.mul (normv (GRing.add d (GRing.opp c))) (GRing.inv (normv (GRing.add b (GRing.opp a))))) (GRing.add b (GRing.opp a))) (GRing.add b (GRing.opp a)))) (GRing.add (GRing.scale (GRing.mul (normv (GRing.add d (GRing.opp c))) (GRing.inv (normv (GRing.add b (GRing.opp a))))) (GRing.add b (GRing.opp a))) (GRing.add b (GRing.opp a))))) (andb (Num.Def.ltr (GRing.zero R) (ratio (GRing.add b (GRing.opp a)) (GRing.add (GRing.scale (GRing.mul (normv (GRing.add d (GRing.opp c))) (GRing.inv (normv (GRing.add b (GRing.opp a))))) (GRing.add b (GRing.opp a))) (GRing.add b (GRing.opp a))))) (Num.Def.ltr (ratio (GRing.add b (GRing.opp a)) (GRing.add (GRing.scale (GRing.mul (normv (GRing.add d (GRing.opp c))) (GRing.inv (normv (GRing.add b (GRing.opp a))))) (GRing.add b (GRing.opp a))) (GRing.add b (GRing.opp a)))) (GRing.one R))))
+++++
rewrite -[X in _ *: _ + X]scale1r -scalerDl scalerA -ratio_bet'' ?mulVf; rewrite ?scale1r ?eqxx ?invr_gt0 ?invf_lt1 ?lt0r_neq0 -1?{2}[1]add0r; rewrite ?ltr_add2r ?addr_gt0 ?ltr01 1?eq_sym -1?subr_eq0 //= divr_gt0 //; by rewrite sqrtr_gt0 lt0r quad_neq0 quad_ge0 ?neq_ba ?neq_dc.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.
have [->|neq_dc] := eqVneq d c ; [|move: neq_dc; rewrite -subr_eq0=> neq_dc].
by exists b; rewrite /bet /cong betE_axx !subrr mul0mx eqxx; split.
exists (normv(d - c) / normv(b - a) *: (b - a) + b); rewrite /bet /cong; split.
rewrite /betS /betR; apply/orP; right; rewrite -addrA.
rewrite -[X in _ *: _ + X]scale1r -scalerDl scalerA -ratio_bet'' ?mulVf; rewrite ?scale1r ?eqxx ?invr_gt0 ?invf_lt1 ?lt0r_neq0 -1?{2}[1]add0r; rewrite ?ltr_add2r ?addr_gt0 ?ltr01 1?eq_sym -1?subr_eq0 //= divr_gt0 //; by rewrite sqrtr_gt0 lt0r quad_neq0 quad_ge0 ?neq_ba ?neq_dc.

*****
neq_dc : is_true\n (negb\n (eq_op (GRing.add d (GRing.opp c))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
neq_ba : is_true\n (negb\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
is_true (eq_op (mulmx (GRing.add (GRing.add (GRing.scale (GRing.mul (normv (GRing.add d (GRing.opp c))) (GRing.inv (normv (GRing.add b (GRing.opp a))))) (GRing.add b (GRing.opp a))) b) (GRing.opp b)) (trmx (GRing.add (GRing.add (GRing.scale (GRing.mul (normv (GRing.add d (GRing.opp c))) (GRing.inv (normv (GRing.add b (GRing.opp a))))) (GRing.add b (GRing.opp a))) b) (GRing.opp b)))) (mulmx (GRing.add d (GRing.opp c)) (trmx (GRing.add d (GRing.opp c)))))
+++++
rewrite -addrA subrr addr0 -scalemxAl dotC -scalemxAl scalerA mulf_div -!expr2.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.
have [->|neq_dc] := eqVneq d c ; [|move: neq_dc; rewrite -subr_eq0=> neq_dc].
by exists b; rewrite /bet /cong betE_axx !subrr mul0mx eqxx; split.
exists (normv(d - c) / normv(b - a) *: (b - a) + b); rewrite /bet /cong; split.
rewrite /betS /betR; apply/orP; right; rewrite -addrA.
rewrite -[X in _ *: _ + X]scale1r -scalerDl scalerA -ratio_bet'' ?mulVf; rewrite ?scale1r ?eqxx ?invr_gt0 ?invf_lt1 ?lt0r_neq0 -1?{2}[1]add0r; rewrite ?ltr_add2r ?addr_gt0 ?ltr01 1?eq_sym -1?subr_eq0 //= divr_gt0 //; by rewrite sqrtr_gt0 lt0r quad_neq0 quad_ge0 ?neq_ba ?neq_dc.
rewrite -addrA subrr addr0 -scalemxAl dotC -scalemxAl scalerA mulf_div -!expr2.

*****
neq_dc : is_true\n (negb\n (eq_op (GRing.add d (GRing.opp c))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
neq_ba : is_true\n (negb\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
is_true (eq_op (GRing.scale (GRing.mul (GRing.exp (normv (GRing.add d (GRing.opp c))) (S (S O))) (GRing.inv (GRing.exp (normv (GRing.add b (GRing.opp a))) (S (S O))))) (mulmx (GRing.add b (GRing.opp a)) (trmx (GRing.add b (GRing.opp a))))) (mulmx (GRing.add d (GRing.opp c)) (trmx (GRing.add d (GRing.opp c)))))
+++++
rewrite [X in _ *: X == _]mx11_scalar !sqr_sqrtr ?quad_ge0 // -!scalerA.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.
have [->|neq_dc] := eqVneq d c ; [|move: neq_dc; rewrite -subr_eq0=> neq_dc].
by exists b; rewrite /bet /cong betE_axx !subrr mul0mx eqxx; split.
exists (normv(d - c) / normv(b - a) *: (b - a) + b); rewrite /bet /cong; split.
rewrite /betS /betR; apply/orP; right; rewrite -addrA.
rewrite -[X in _ *: _ + X]scale1r -scalerDl scalerA -ratio_bet'' ?mulVf; rewrite ?scale1r ?eqxx ?invr_gt0 ?invf_lt1 ?lt0r_neq0 -1?{2}[1]add0r; rewrite ?ltr_add2r ?addr_gt0 ?ltr01 1?eq_sym -1?subr_eq0 //= divr_gt0 //; by rewrite sqrtr_gt0 lt0r quad_neq0 quad_ge0 ?neq_ba ?neq_dc.
rewrite -addrA subrr addr0 -scalemxAl dotC -scalemxAl scalerA mulf_div -!expr2.
rewrite [X in _ *: X == _]mx11_scalar !sqr_sqrtr ?quad_ge0 // -!scalerA.

*****
neq_dc : is_true\n (negb\n (eq_op (GRing.add d (GRing.opp c))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
neq_ba : is_true\n (negb\n (eq_op (GRing.add b (GRing.opp a))\n (GRing.zero (matrix_zmodType R (S O) (S n)))))
a,b,c,d : matrix R (S O) (S n)
n : nat
R : Num\.RealClosedField\.type
*****
is_true (eq_op (GRing.scale ((mulmx (GRing.add d (GRing.opp c)) (trmx (GRing.add d (GRing.opp c)))) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O))) (GRing.scale (GRing.inv ((mulmx (GRing.add b (GRing.opp a)) (trmx (GRing.add b (GRing.opp a)))) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O)))) (scalar_mx ((mulmx (GRing.add b (GRing.opp a)) (trmx (GRing.add b (GRing.opp a)))) (GRing.zero (Zp_zmodType O)) (GRing.zero (Zp_zmodType O)))))) (mulmx (GRing.add d (GRing.opp c)) (trmx (GRing.add d (GRing.opp c)))))
+++++
by rewrite scale_scalar_mx mulrC divff ?quad_neq0 // scalemx1 -mx11_scalar.
-----
Lemma segment_construction a b c d : exists e, bet a b e /\\ cong b e c d.
Proof.
have [->|neq_ba] := eqVneq b a; [|move: neq_ba; rewrite -subr_eq0=> neq_ba].
exists ((c - d) + a); rewrite /bet /cong betE_xxa; split=> //.
by rewrite -!addrA subrr addr0 -opprB mulNmx eq_sym dotC opprB -mulNmx opprB.
have [->|neq_dc] := eqVneq d c ; [|move: neq_dc; rewrite -subr_eq0=> neq_dc].
by exists b; rewrite /bet /cong betE_axx !subrr mul0mx eqxx; split.
exists (normv(d - c) / normv(b - a) *: (b - a) + b); rewrite /bet /cong; split.
rewrite /betS /betR; apply/orP; right; rewrite -addrA.
rewrite -[X in _ *: _ + X]scale1r -scalerDl scalerA -ratio_bet'' ?mulVf; rewrite ?scale1r ?eqxx ?invr_gt0 ?invf_lt1 ?lt0r_neq0 -1?{2}[1]add0r; rewrite ?ltr_add2r ?addr_gt0 ?ltr01 1?eq_sym -1?subr_eq0 //= divr_gt0 //; by rewrite sqrtr_gt0 lt0r quad_neq0 quad_ge0 ?neq_ba ?neq_dc.
rewrite -addrA subrr addr0 -scalemxAl dotC -scalemxAl scalerA mulf_div -!expr2.
rewrite [X in _ *: X == _]mx11_scalar !sqr_sqrtr ?quad_ge0 // -!scalerA.
by rewrite scale_scalar_mx mulrC divff ?quad_neq0 // scalemx1 -mx11_scalar.

*****

*****

+++++
Qed.
-----
End RcfTarski.
-----
Section Rcf_to_independent_Tarski_2D_euclidean.
-----
Variable R : rcfType.
-----
Definition point := (@Vector R 1).
-----
Global Instance Rcf_to_IT_PED :\n  Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality.
-----
Global Instance Rcf_to_IT_PED : Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality.

*****
R : Num\.RealClosedField\.type
*****
Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality
+++++
Proof.
-----
Global Instance Rcf_to_IT_PED : Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality.
Proof.

*****
R : Num\.RealClosedField\.type
*****
Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality
+++++
exact (Build_Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality point (@bet R 1) (@cong R 1) (@point_equality_decidability R 1) (@cong_pseudo_reflexivity R 1) (@cong_inner_transitivity R 1) (@cong_identity R 1) (@segment_construction R 1) (@five_segment R 1) (@bet_symmetry R 1) (@bet_inner_transitivity R 1) (@inner_pasch R 1) (@a R) (@b R) (@c R) (@lower_dim R)).
-----
Global Instance Rcf_to_IT_PED : Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality.
Proof.
exact (Build_Gupta_inspired_variant_of_Tarski_neutral_dimensionless_with_decidable_point_equality point (@bet R 1) (@cong R 1) (@point_equality_decidability R 1) (@cong_pseudo_reflexivity R 1) (@cong_inner_transitivity R 1) (@cong_identity R 1) (@segment_construction R 1) (@five_segment R 1) (@bet_symmetry R 1) (@bet_inner_transitivity R 1) (@inner_pasch R 1) (@a R) (@b R) (@c R) (@lower_dim R)).

*****

*****

+++++
Defined.
-----
Global Instance Rcf_to_T : Tarski_neutral_dimensionless.
-----
Global Instance Rcf_to_T : Tarski_neutral_dimensionless.

*****
R : Num\.RealClosedField\.type
*****
Tarski_neutral_dimensionless
+++++
Proof.
-----
Global Instance Rcf_to_T : Tarski_neutral_dimensionless.
Proof.

*****
R : Num\.RealClosedField\.type
*****
Tarski_neutral_dimensionless
+++++
apply TG_to_T.
-----
Global Instance Rcf_to_T : Tarski_neutral_dimensionless.
Proof.
apply TG_to_T.

*****

*****

+++++
Defined.
-----
Global Instance Rcf_to_T_PED :\n  Tarski_neutral_dimensionless_with_decidable_point_equality Rcf_to_T.
-----
Global Instance Rcf_to_T_PED : Tarski_neutral_dimensionless_with_decidable_point_equality Rcf_to_T.

*****
R : Num\.RealClosedField\.type
*****
Tarski_neutral_dimensionless_with_decidable_point_equality Rcf_to_T
+++++
Proof.
-----
Global Instance Rcf_to_T_PED : Tarski_neutral_dimensionless_with_decidable_point_equality Rcf_to_T.
Proof.

*****
R : Num\.RealClosedField\.type
*****
Tarski_neutral_dimensionless_with_decidable_point_equality Rcf_to_T
+++++
split.
-----
Global Instance Rcf_to_T_PED : Tarski_neutral_dimensionless_with_decidable_point_equality Rcf_to_T.
Proof.
split.

*****
R : Num\.RealClosedField\.type
*****
forall A B : Tpoint, or (eq A B) (not (eq A B))
+++++
exact (@point_equality_decidability R 1).
-----
Global Instance Rcf_to_T_PED : Tarski_neutral_dimensionless_with_decidable_point_equality Rcf_to_T.
Proof.
split.
exact (@point_equality_decidability R 1).

*****

*****

+++++
Defined.
-----
Global Instance Rcf_to_IT2D : Gupta_inspired_variant_of_Tarski_2D Rcf_to_IT_PED.
-----
Global Instance Rcf_to_IT2D : Gupta_inspired_variant_of_Tarski_2D Rcf_to_IT_PED.

*****
R : Num\.RealClosedField\.type
*****
Gupta_inspired_variant_of_Tarski_2D Rcf_to_IT_PED
+++++
Proof.
-----
Global Instance Rcf_to_IT2D : Gupta_inspired_variant_of_Tarski_2D Rcf_to_IT_PED.
Proof.

*****
R : Num\.RealClosedField\.type
*****
Gupta_inspired_variant_of_Tarski_2D Rcf_to_IT_PED
+++++
split.
-----
Global Instance Rcf_to_IT2D : Gupta_inspired_variant_of_Tarski_2D Rcf_to_IT_PED.
Proof.
split.

*****
R : Num\.RealClosedField\.type
*****
forall (A B C P Q : TpointG) (_ : not (eq P Q)) (_ : not (eq A B)) (_ : not (eq A C)) (_ : not (eq B C)) (_ : CongG A P A Q) (_ : CongG B P B Q) (_ : CongG C P C Q), or (BetG A B C) (or (BetG B C A) (BetG C A B))
+++++
exact (@upper_dim R).
-----
Global Instance Rcf_to_IT2D : Gupta_inspired_variant_of_Tarski_2D Rcf_to_IT_PED.
Proof.
split.
exact (@upper_dim R).

*****

*****

+++++
Defined.
-----
Global Instance Rcf_to_T2D : Tarski_2D Rcf_to_T_PED.
-----
Global Instance Rcf_to_T2D : Tarski_2D Rcf_to_T_PED.

*****
R : Num\.RealClosedField\.type
*****
Tarski_2D Rcf_to_T_PED
+++++
Proof.
-----
Global Instance Rcf_to_T2D : Tarski_2D Rcf_to_T_PED.
Proof.

*****
R : Num\.RealClosedField\.type
*****
Tarski_2D Rcf_to_T_PED
+++++
split.
-----
Global Instance Rcf_to_T2D : Tarski_2D Rcf_to_T_PED.
Proof.
split.

*****
R : Num\.RealClosedField\.type
*****
forall (A B C P Q : Tpoint) (_ : not (eq P Q)) (_ : Cong A P A Q) (_ : Cong B P B Q) (_ : Cong C P C Q), or (Bet A B C) (or (Bet B C A) (Bet C A B))
+++++
exact upper_dimT.
-----
Global Instance Rcf_to_T2D : Tarski_2D Rcf_to_T_PED.
Proof.
split.
exact upper_dimT.

*****

*****

+++++
Defined.
-----
Global Instance Rcf_to_IT_euclidean : Gupta_inspired_variant_of_Tarski_euclidean Rcf_to_IT_PED.
-----
Global Instance Rcf_to_IT_euclidean : Gupta_inspired_variant_of_Tarski_euclidean Rcf_to_IT_PED.

*****
R : Num\.RealClosedField\.type
*****
Gupta_inspired_variant_of_Tarski_euclidean Rcf_to_IT_PED
+++++
Proof.
-----
Global Instance Rcf_to_IT_euclidean : Gupta_inspired_variant_of_Tarski_euclidean Rcf_to_IT_PED.
Proof.

*****
R : Num\.RealClosedField\.type
*****
Gupta_inspired_variant_of_Tarski_euclidean Rcf_to_IT_PED
+++++
split.
-----
Global Instance Rcf_to_IT_euclidean : Gupta_inspired_variant_of_Tarski_euclidean Rcf_to_IT_PED.
Proof.
split.

*****
R : Num\.RealClosedField\.type
*****
forall (A B C D T : TpointG) (_ : BetG A D T) (_ : BetG B D C) (_ : not (eq B D)) (_ : not (eq D C)) (_ : not (or (BetG A B C) (or (BetG B C A) (BetG C A B)))), ex (fun x : TpointG => ex (fun y : TpointG => and (BetG A B x) (and (BetG A C y) (BetG x T y))))
+++++
exact (@euclid R 1).
-----
Global Instance Rcf_to_IT_euclidean : Gupta_inspired_variant_of_Tarski_euclidean Rcf_to_IT_PED.
Proof.
split.
exact (@euclid R 1).

*****

*****

+++++
Defined.
-----
Global Instance Rcf_to_T_euclidean : Tarski_euclidean Rcf_to_T_PED.
-----
Global Instance Rcf_to_T_euclidean : Tarski_euclidean Rcf_to_T_PED.

*****
R : Num\.RealClosedField\.type
*****
Tarski_euclidean Rcf_to_T_PED
+++++
Proof.
-----
Global Instance Rcf_to_T_euclidean : Tarski_euclidean Rcf_to_T_PED.
Proof.

*****
R : Num\.RealClosedField\.type
*****
Tarski_euclidean Rcf_to_T_PED
+++++
split.
-----
Global Instance Rcf_to_T_euclidean : Tarski_euclidean Rcf_to_T_PED.
Proof.
split.

*****
R : Num\.RealClosedField\.type
*****
forall (A B C D T : Tpoint) (_ : Bet A D T) (_ : Bet B D C) (_ : not (eq A D)), ex (fun X : Tpoint => ex (fun Y : Tpoint => and (Bet A B X) (and (Bet A C Y) (Bet X T Y))))
+++++
exact euclidT.
-----
Global Instance Rcf_to_T_euclidean : Tarski_euclidean Rcf_to_T_PED.
Proof.
split.
exact euclidT.

*****

*****

+++++
Defined.
-----
Implicit Types (a b c d p q : point).
-----
Definition col a b c := bet a b c \/ bet b c a \/ bet c a b.
-----
Definition coplanar a b c d :=\n  exists x, (col a b x /\ col c d x) \/\n            (col a c x /\ col b d x) \/\n            (col a d x /\ col b c x).
-----
Definition par_strict a b c d :=\n  a <> b /\ c <> d /\ coplanar a b c d /\ ~ exists x, col x a b /\ col x c d.
-----
Definition par a b c d :=\n  par_strict a b c d \/ (a <> b /\ c <> d /\ col a c d /\ col b c d).
-----
Lemma proclus a b c d p q :\n  par a b c d -> col a b p -> ~ col a b q -> coplanar c d p q ->\n  exists y, col p q y /\ col c d y.
-----
Lemma proclus a b c d p q : par a b c d -> col a b p -> ~ col a b q -> coplanar c d p q -> exists y, col p q y /\\ col c d y.

*****
a,b,c,d,p,q : point
R : Num\.RealClosedField\.type
*****
forall (_ : par a b c d) (_ : col a b p) (_ : not (col a b q)) (_ : coplanar c d p q), ex (fun y : point => and (col p q y) (col c d y))
+++++
Proof.
-----
Lemma proclus a b c d p q : par a b c d -> col a b p -> ~ col a b q -> coplanar c d p q -> exists y, col p q y /\\ col c d y.
Proof.

*****
a,b,c,d,p,q : point
R : Num\.RealClosedField\.type
*****
forall (_ : par a b c d) (_ : col a b p) (_ : not (col a b q)) (_ : coplanar c d p q), ex (fun y : point => and (col p q y) (col c d y))
+++++
cut (proclus_postulate); [intros; apply H with a b; tauto|].
-----
Lemma proclus a b c d p q : par a b c d -> col a b p -> ~ col a b q -> coplanar c d p q -> exists y, col p q y /\\ col c d y.
Proof.
cut (proclus_postulate); [intros; apply H with a b; tauto|].

*****
a,b,c,d,p,q : point
R : Num\.RealClosedField\.type
*****
proclus_postulate
+++++
have: tarski_s_parallel_postulate.
-----
Lemma proclus a b c d p q : par a b c d -> col a b p -> ~ col a b q -> coplanar c d p q -> exists y, col p q y /\\ col c d y.
Proof.
cut (proclus_postulate); [intros; apply H with a b; tauto|].
have: tarski_s_parallel_postulate.

*****
a,b,c,d,p,q : point
R : Num\.RealClosedField\.type
*****
tarski_s_parallel_postulate
+++++
by unfold tarski_s_parallel_postulate; apply euclidT.
-----
Lemma proclus a b c d p q : par a b c d -> col a b p -> ~ col a b q -> coplanar c d p q -> exists y, col p q y /\\ col c d y.
Proof.
cut (proclus_postulate); [intros; apply H with a b; tauto|].
have: tarski_s_parallel_postulate.
by unfold tarski_s_parallel_postulate; apply euclidT.

*****
a,b,c,d,p,q : point
R : Num\.RealClosedField\.type
*****
forall _ : tarski_s_parallel_postulate, proclus_postulate
+++++
apply equivalent_postulates_without_decidability_of_intersection_of_lines_bis; simpl; tauto.
-----
Lemma proclus a b c d p q : par a b c d -> col a b p -> ~ col a b q -> coplanar c d p q -> exists y, col p q y /\\ col c d y.
Proof.
cut (proclus_postulate); [intros; apply H with a b; tauto|].
have: tarski_s_parallel_postulate.
by unfold tarski_s_parallel_postulate; apply euclidT.
apply equivalent_postulates_without_decidability_of_intersection_of_lines_bis; simpl; tauto.

*****

*****

+++++
Qed.
-----
End Rcf_to_independent_Tarski_2D_euclidean.
-----
