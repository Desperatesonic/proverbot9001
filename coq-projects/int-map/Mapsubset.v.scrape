From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
From Coq Require Import Arith.
-----
Require Import Coq.NArith.NArith.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Require Import Map.
-----
Require Import Fset.
-----
Require Import Mapaxioms.
-----
Require Import Mapiter.
-----
Section MapSubsetDef.
-----
Variables A B : Type.
-----
Definition MapSubset (m:Map A) (m':Map B) :=\n    forall a:ad, in_dom A a m = true -> in_dom B a m' = true.
-----
Definition MapSubset_1 (m:Map A) (m':Map B) :=\n    match MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m with\n    | None => true\n    | _ => false\n    end.
-----
Definition MapSubset_2 (m:Map A) (m':Map B) :=\n    eqmap A (MapDomRestrBy A B m m') (M0 A).
-----
Lemma MapSubset_imp_1 :\n   forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset m m'), eq (MapSubset_1 m m') true
+++++
Proof.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset m m'), eq (MapSubset_1 m m') true
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true), eq (MapSubset_1 m m') true
+++++
unfold MapSubset_1 in |- *.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true), eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
intros.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.

*****
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).

*****
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) (Some y)), eq match MapSweep A (fun (a0 : ad) (_ : A) => negb (in_dom B a0 m')) m with | Some _ => false | None => true end true
+++++
intro H0.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.

*****
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
elim H0.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.

*****
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) (Some x)), eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
intro r.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.

*****
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) (Some r), eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
elim r.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.

*****
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall (a : ad) (b : A) (_ : eq (MapSweep A (fun (a0 : ad) (_ : A) => negb (in_dom B a0 m')) m) (Some (pair a b))), eq match MapSweep A (fun (a0 : ad) (_ : A) => negb (in_dom B a0 m')) m with | Some _ => false | None => true end true
+++++
intros a y H1.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.

*****
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
cut (negb (in_dom B a m') = true).
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).

*****
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (negb (in_dom B a m')) true, eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
intro.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.

*****
H2 : eq (negb (in_dom B a m')) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
cut (in_dom A a m = false).
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.
cut (in_dom A a m = false).

*****
H2 : eq (negb (in_dom B a m')) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) false, eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
intro.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.
cut (in_dom A a m = false).
intro.

*****
H3 : eq (in_dom A a m) false
H2 : eq (negb (in_dom B a m')) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
unfold in_dom in H3.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.
cut (in_dom A a m = false).
intro.
unfold in_dom in H3.

*****
H3 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
H2 : eq (negb (in_dom B a m')) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
rewrite (MapSweep_semantics_2 _ _ m a y H1) in H3.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.
cut (in_dom A a m = false).
intro.
unfold in_dom in H3.
rewrite (MapSweep_semantics_2 _ _ m a y H1) in H3.

*****
H3 : eq true false
H2 : eq (negb (in_dom B a m')) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
discriminate H3.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.
cut (in_dom A a m = false).

*****
H2 : eq (negb (in_dom B a m')) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom A a m) false
+++++
elim (sumbool_of_bool (in_dom A a m)).
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.
cut (in_dom A a m = false).
elim (sumbool_of_bool (in_dom A a m)).

*****
H2 : eq (negb (in_dom B a m')) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) true, eq (in_dom A a m) false
+++++
intro H3.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.
cut (in_dom A a m = false).
elim (sumbool_of_bool (in_dom A a m)).
intro H3.

*****
H3 : eq (in_dom A a m) true
H2 : eq (negb (in_dom B a m')) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom A a m) false
+++++
rewrite (H a H3) in H2.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.
cut (in_dom A a m = false).
elim (sumbool_of_bool (in_dom A a m)).
intro H3.
rewrite (H a H3) in H2.

*****
H3 : eq (in_dom A a m) true
H2 : eq (negb true) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom A a m) false
+++++
discriminate H2.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).
intro.
cut (in_dom A a m = false).
elim (sumbool_of_bool (in_dom A a m)).

*****
H2 : eq (negb (in_dom B a m')) true
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) false, eq (in_dom A a m) false
+++++
trivial.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (negb (in_dom B a m') = true).

*****
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (negb (in_dom B a m')) true
+++++
exact (MapSweep_semantics_1 _ _ m a y H1).
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).

*****
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None, eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
intro H0.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.

*****
H0 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true
+++++
rewrite H0.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H0.
rewrite H0.

*****
H0 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapSubset_imp_1 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_1_imp :\n   forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq (MapSubset_1 m m') true), MapSubset m m'
+++++
Proof.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq (MapSubset_1 m m') true), MapSubset m m'
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq (MapSubset_1 m m') true) (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
+++++
unfold MapSubset_1 in |- *.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true) (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
+++++
unfold in_dom at 2 in |- *.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq match MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m with | Some _ => false | None => true end true) (a : ad) (_ : eq match MapGet A m a with | Some _ => true | None => false end true), eq (in_dom B a m') true
+++++
intros.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.

*****
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
elim (option_sum _ (MapGet A m a)).
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).

*****
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m a) (Some y)), eq (in_dom B a m') true
+++++
intro H1.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.

*****
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
elim H1.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.

*****
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq (in_dom B a m') true
+++++
intros y H2.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) (Some y)), eq (in_dom B a m') true
+++++
intro H3.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.

*****
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
elim H3.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
elim H3.

*****
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) (Some x)), eq (in_dom B a m') true
+++++
intro r.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
elim H3.
intro r.

*****
r : prod ad A
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) (Some r), eq (in_dom B a m') true
+++++
elim r.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
elim H3.
intro r.
elim r.

*****
r : prod ad A
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall (a0 : ad) (b : A) (_ : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) (Some (pair a0 b))), eq (in_dom B a m') true
+++++
intros a' y' H4.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
elim H3.
intro r.
elim r.
intros a' y' H4.

*****
H4 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a' y'))
y' : A
a' : ad
r : prod ad A
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
rewrite H4 in H.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
elim H3.
intro r.
elim r.
intros a' y' H4.
rewrite H4 in H.

*****
H4 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some (pair a' y'))
y' : A
a' : ad
r : prod ad A
H3 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m)\n (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq false true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
discriminate H.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None, eq (in_dom B a m') true
+++++
intro H3.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.

*****
H3 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
cut (negb (in_dom B a m') = false).
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
cut (negb (in_dom B a m') = false).

*****
H3 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (negb (in_dom B a m')) false, eq (in_dom B a m') true
+++++
intro.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
cut (negb (in_dom B a m') = false).
intro.

*****
H4 : eq (negb (in_dom B a m')) false
H3 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
rewrite (negb_intro (in_dom B a m')).
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
cut (negb (in_dom B a m') = false).
intro.
rewrite (negb_intro (in_dom B a m')).

*****
H4 : eq (negb (in_dom B a m')) false
H3 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (negb (negb (in_dom B a m'))) true
+++++
rewrite H4.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
cut (negb (in_dom B a m') = false).
intro.
rewrite (negb_intro (in_dom B a m')).
rewrite H4.

*****
H4 : eq (negb (in_dom B a m')) false
H3 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (negb false) true
+++++
reflexivity.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).
intro H3.
cut (negb (in_dom B a m') = false).

*****
H3 : eq (MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m) None
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (negb (in_dom B a m')) false
+++++
exact (MapSweep_semantics_3 _ _ m H3 a y H2).
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).

*****
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapGet A m a) None, eq (in_dom B a m') true
+++++
intro H1.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.

*****
H1 : eq (MapGet A m a) None
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
rewrite H1 in H0.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).
intro H1.
rewrite H1 in H0.

*****
H1 : eq (MapGet A m a) None
H0 : eq false true
a : ad
H : eq\n match\n MapSweep A (fun (a : ad) (_ : A) => negb (in_dom B a m')) m\n with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
discriminate H0.
-----
Lemma MapSubset_1_imp : forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_1 in |- *.
unfold in_dom at 2 in |- *.
intros.
elim (option_sum _ (MapGet A m a)).

*****

*****

+++++
Qed.
-----
Lemma map_dom_empty_1 :\n   forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.
-----
Lemma map_dom_empty_1 : forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.

*****
A,B : Type
*****
forall (m : Map A) (_ : eqmap A m (M0 A)) (a : ad), eq (in_dom A a m) false
+++++
Proof.
-----
Lemma map_dom_empty_1 : forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (_ : eqmap A m (M0 A)) (a : ad), eq (in_dom A a m) false
+++++
unfold eqmap in |- *.
-----
Lemma map_dom_empty_1 : forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.
Proof.
unfold eqmap in |- *.

*****
A,B : Type
*****
forall (m : Map A) (_ : eqm A (MapGet A m) (MapGet A (M0 A))) (a : ad), eq (in_dom A a m) false
+++++
unfold eqm in |- *.
-----
Lemma map_dom_empty_1 : forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.

*****
A,B : Type
*****
forall (m : Map A) (_ : forall a : ad, eq (MapGet A m a) (MapGet A (M0 A) a)) (a : ad), eq (in_dom A a m) false
+++++
unfold in_dom in |- *.
-----
Lemma map_dom_empty_1 : forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (_ : forall a : ad, eq (MapGet A m a) (MapGet A (M0 A) a)) (a : ad), eq match MapGet A m a with | Some _ => true | None => false end false
+++++
intros.
-----
Lemma map_dom_empty_1 : forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.

*****
a : ad
H : forall a : ad, eq (MapGet A m a) (MapGet A (M0 A) a)
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end false
+++++
rewrite (H a).
-----
Lemma map_dom_empty_1 : forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.
rewrite (H a).

*****
a : ad
H : forall a : ad, eq (MapGet A m a) (MapGet A (M0 A) a)
m : Map A
A,B : Type
*****
eq match MapGet A (M0 A) a with | Some _ => true | None => false end false
+++++
reflexivity.
-----
Lemma map_dom_empty_1 : forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.
rewrite (H a).
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma map_dom_empty_2 :\n   forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).

*****
A,B : Type
*****
forall (m : Map A) (_ : forall a : ad, eq (in_dom A a m) false), eqmap A m (M0 A)
+++++
Proof.
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (_ : forall a : ad, eq (in_dom A a m) false), eqmap A m (M0 A)
+++++
unfold eqmap in |- *.
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.

*****
A,B : Type
*****
forall (m : Map A) (_ : forall a : ad, eq (in_dom A a m) false), eqm A (MapGet A m) (MapGet A (M0 A))
+++++
unfold eqm in |- *.
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.

*****
A,B : Type
*****
forall (m : Map A) (_ : forall a : ad, eq (in_dom A a m) false) (a : ad), eq (MapGet A m a) (MapGet A (M0 A) a)
+++++
unfold in_dom in |- *.
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (_ : forall a : ad, eq match MapGet A m a with | Some _ => true | None => false end false) (a : ad), eq (MapGet A m a) (MapGet A (M0 A) a)
+++++
intros.
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.

*****
a : ad
H : forall a : ad,\neq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
m : Map A
A,B : Type
*****
eq (MapGet A m a) (MapGet A (M0 A) a)
+++++
cut (match MapGet A m a with | None => false | Some _ => true end = false).
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.
cut (match MapGet A m a with | None => false | Some _ => true end = false).

*****
a : ad
H : forall a : ad,\neq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
m : Map A
A,B : Type
*****
forall _ : eq match MapGet A m a with | Some _ => true | None => false end false, eq (MapGet A m a) (MapGet A (M0 A) a)
+++++
case (MapGet A m a).
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.
cut (match MapGet A m a with | None => false | Some _ => true end = false).
case (MapGet A m a).

*****
a : ad
H : forall a : ad,\neq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
m : Map A
A,B : Type
*****
forall (a0 : A) (_ : eq true false), eq (Some a0) (MapGet A (M0 A) a)
+++++
trivial.
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.
cut (match MapGet A m a with | None => false | Some _ => true end = false).
case (MapGet A m a).
trivial.

*****
a : ad
H : forall a : ad,\neq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
m : Map A
A,B : Type
*****
forall (a0 : A) (_ : eq true false), eq (Some a0) (MapGet A (M0 A) a)
+++++
intros.
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.
cut (match MapGet A m a with | None => false | Some _ => true end = false).
case (MapGet A m a).
trivial.
intros.

*****
H0 : eq true false
a0 : A
a : ad
H : forall a : ad,\neq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
m : Map A
A,B : Type
*****
eq (Some a0) (MapGet A (M0 A) a)
+++++
discriminate H0.
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.
cut (match MapGet A m a with | None => false | Some _ => true end = false).
case (MapGet A m a).

*****
a : ad
H : forall a : ad,\neq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
m : Map A
A,B : Type
*****
forall _ : eq false false, eq None (MapGet A (M0 A) a)
+++++
trivial.
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.
cut (match MapGet A m a with | None => false | Some _ => true end = false).

*****
a : ad
H : forall a : ad,\neq match MapGet A m a with\n | Some _ => true\n | None => false\n end false
m : Map A
A,B : Type
*****
eq match MapGet A m a with | Some _ => true | None => false end false
+++++
exact (H a).
-----
Lemma map_dom_empty_2 : forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
unfold in_dom in |- *.
intros.
cut (match MapGet A m a with | None => false | Some _ => true end = false).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_imp_2 :\n   forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset m m'), MapSubset_2 m m'
+++++
Proof.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset m m'), MapSubset_2 m m'
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true), MapSubset_2 m m'
+++++
unfold MapSubset_2 in |- *.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true), eqmap A (MapDomRestrBy A B m m') (M0 A)
+++++
intros.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.

*****
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eqmap A (MapDomRestrBy A B m m') (M0 A)
+++++
apply map_dom_empty_2.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.

*****
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall a : ad, eq (in_dom A a (MapDomRestrBy A B m m')) false
+++++
intro.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom A a (MapDomRestrBy A B m m')) false
+++++
rewrite in_dom_restrby.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.
rewrite in_dom_restrby.

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
+++++
elim (sumbool_of_bool (in_dom A a m)).
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.
rewrite in_dom_restrby.
elim (sumbool_of_bool (in_dom A a m)).

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) true, eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
+++++
intro H0.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.
rewrite in_dom_restrby.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.

*****
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
+++++
rewrite H0.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.
rewrite in_dom_restrby.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.

*****
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (andb true (negb (in_dom B a m'))) false
+++++
rewrite (H a H0).
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.
rewrite in_dom_restrby.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.
rewrite (H a H0).

*****
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (andb true (negb true)) false
+++++
reflexivity.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.
rewrite in_dom_restrby.
elim (sumbool_of_bool (in_dom A a m)).

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) false, eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
+++++
intro H0.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.
rewrite in_dom_restrby.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.

*****
H0 : eq (in_dom A a m) false
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
+++++
rewrite H0.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.
rewrite in_dom_restrby.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.

*****
H0 : eq (in_dom A a m) false
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (andb false (negb (in_dom B a m'))) false
+++++
reflexivity.
-----
Lemma MapSubset_imp_2 : forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
apply map_dom_empty_2.
intro.
rewrite in_dom_restrby.
elim (sumbool_of_bool (in_dom A a m)).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_2_imp :\n   forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset_2 m m'), MapSubset m m'
+++++
Proof.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset_2 m m'), MapSubset m m'
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset_2 m m') (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
+++++
unfold MapSubset_2 in |- *.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eqmap A (MapDomRestrBy A B m m') (M0 A)) (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
+++++
intros.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.

*****
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).

*****
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a (MapDomRestrBy A B m m')) false, eq (in_dom B a m') true
+++++
rewrite in_dom_restrby.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
rewrite in_dom_restrby.

*****
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (andb (in_dom A a m) (negb (in_dom B a m'))) false, eq (in_dom B a m') true
+++++
intro.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
rewrite in_dom_restrby.
intro.

*****
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
elim (andb_false_elim _ _ H1).
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
rewrite in_dom_restrby.
intro.
elim (andb_false_elim _ _ H1).

*****
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) false, eq (in_dom B a m') true
+++++
rewrite H0.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
rewrite in_dom_restrby.
intro.
elim (andb_false_elim _ _ H1).
rewrite H0.

*****
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq true false, eq (in_dom B a m') true
+++++
intro H2.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
rewrite in_dom_restrby.
intro.
elim (andb_false_elim _ _ H1).
rewrite H0.
intro H2.

*****
H2 : eq true false
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
discriminate H2.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
rewrite in_dom_restrby.
intro.
elim (andb_false_elim _ _ H1).

*****
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (negb (in_dom B a m')) false, eq (in_dom B a m') true
+++++
intro H2.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
rewrite in_dom_restrby.
intro.
elim (andb_false_elim _ _ H1).
intro H2.

*****
H2 : eq (negb (in_dom B a m')) false
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
rewrite (negb_intro (in_dom B a m')).
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
rewrite in_dom_restrby.
intro.
elim (andb_false_elim _ _ H1).
intro H2.
rewrite (negb_intro (in_dom B a m')).

*****
H2 : eq (negb (in_dom B a m')) false
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
eq (negb (negb (in_dom B a m'))) true
+++++
rewrite H2.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).
rewrite in_dom_restrby.
intro.
elim (andb_false_elim _ _ H1).
intro H2.
rewrite (negb_intro (in_dom B a m')).
rewrite H2.

*****
H2 : eq (negb (in_dom B a m')) false
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) false
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
eq (negb false) true
+++++
reflexivity.
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).

*****
H0 : eq (in_dom A a m) true
a : ad
H : eqmap A (MapDomRestrBy A B m m') (M0 A)
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom A a (MapDomRestrBy A B m m')) false
+++++
exact (map_dom_empty_1 _ H a).
-----
Lemma MapSubset_2_imp : forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.
Proof.
unfold MapSubset in |- *.
unfold MapSubset_2 in |- *.
intros.
cut (in_dom _ a (MapDomRestrBy A B m m') = false).

*****

*****

+++++
Qed.
-----
End MapSubsetDef.
-----
Section MapSubsetOrder.
-----
Variables A B C : Type.
-----
Lemma MapSubset_refl : forall m:Map A, MapSubset A A m m.
-----
Lemma MapSubset_refl : forall m:Map A, MapSubset A A m m.

*****
A,B,C : Type
*****
forall m : Map A, MapSubset A A m m
+++++
Proof.
-----
Lemma MapSubset_refl : forall m:Map A, MapSubset A A m m.
Proof.

*****
A,B,C : Type
*****
forall m : Map A, MapSubset A A m m
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_refl : forall m:Map A, MapSubset A A m m.
Proof.
unfold MapSubset in |- *.

*****
A,B,C : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom A a m) true
+++++
trivial.
-----
Lemma MapSubset_refl : forall m:Map A, MapSubset A A m m.
Proof.
unfold MapSubset in |- *.
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_antisym :\n   forall (m:Map A) (m':Map B),\n     MapSubset A B m m' ->\n     MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').

*****
A,B,C : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m') (_ : MapSubset B A m' m), eqmap unit (MapDom A m) (MapDom B m')
+++++
Proof.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.

*****
A,B,C : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m') (_ : MapSubset B A m' m), eqmap unit (MapDom A m) (MapDom B m')
+++++
unfold MapSubset, eqmap, eqm in |- *.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.

*****
A,B,C : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true) (_ : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true) (a : ad), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intros.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
elim (option_sum _ (MapGet _ (MapDom A m) a)).
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y)), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro H1.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.

*****
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
elim H1.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.

*****
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall (x : unit) (_ : eq (MapGet unit (MapDom A m) a) (Some x)), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro t.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.

*****
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : eq (MapGet unit (MapDom A m) a) (Some t), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
elim t.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.

*****
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : eq (MapGet unit (MapDom A m) a) (Some tt), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro H2.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.

*****
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
elim (option_sum _ (MapGet _ (MapDom B m') a)).
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).

*****
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y)), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro H3.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.

*****
H3 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
elim H3.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.

*****
H3 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall (x : unit) (_ : eq (MapGet unit (MapDom B m') a) (Some x)), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro t'.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.

*****
t' : unit
H3 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : eq (MapGet unit (MapDom B m') a) (Some t'), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
elim t'.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.

*****
t' : unit
H3 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : eq (MapGet unit (MapDom B m') a) (Some tt), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.

*****
H4 : eq (MapGet unit (MapDom B m') a) (Some tt)
t' : unit
H3 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
rewrite H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.

*****
H4 : eq (MapGet unit (MapDom B m') a) (Some tt)
t' : unit
H3 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (Some tt)
+++++
exact H2.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.

*****
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : eq (MapGet unit (MapDom B m') a) None, eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro H3.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.

*****
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
cut (in_dom B a m' = true).
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).

*****
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : eq (in_dom B a m') true, eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.

*****
H4 : eq (in_dom B a m') true
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
rewrite (MapDom_Dom B m' a) in H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.

*****
H4 : eq (in_FSet a (MapDom B m')) true
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
unfold in_FSet, in_dom in H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.

*****
H4 : eq\n match MapGet unit (MapDom B m') a with\n | Some _ => true\n | None => false\n end true
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
rewrite H3 in H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.

*****
H4 : eq false true
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
discriminate H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.

*****
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (in_dom B a m') true
+++++
apply H.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.

*****
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (in_dom A a m) true
+++++
rewrite (MapDom_Dom A m a).
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).

*****
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (in_FSet a (MapDom A m)) true
+++++
unfold in_FSet, in_dom in |- *.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.

*****
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq match MapGet unit (MapDom A m) a with | Some _ => true | None => false end true
+++++
rewrite H2.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.

*****
H3 : eq (MapGet unit (MapDom B m') a) None
H2 : eq (MapGet unit (MapDom A m) a) (Some tt)
t : unit
H1 : sig (fun y : unit => eq (MapGet unit (MapDom A m) a) (Some y))
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.

*****
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : eq (MapGet unit (MapDom A m) a) None, eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro H1.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.

*****
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
elim (option_sum _ (MapGet _ (MapDom B m') a)).
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).

*****
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y)), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro H2.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.

*****
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
elim H2.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.

*****
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall (x : unit) (_ : eq (MapGet unit (MapDom B m') a) (Some x)), eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intros t H3.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.

*****
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
cut (in_dom A a m = true).
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).

*****
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : eq (in_dom A a m) true, eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.

*****
H4 : eq (in_dom A a m) true
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
rewrite (MapDom_Dom A m a) in H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.

*****
H4 : eq (in_FSet a (MapDom A m)) true
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
unfold in_FSet, in_dom in H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.

*****
H4 : eq\n match MapGet unit (MapDom A m) a with\n | Some _ => true\n | None => false\n end true
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
rewrite H1 in H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.

*****
H4 : eq false true
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
discriminate H4.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.
discriminate H4.

*****
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (in_dom A a m) true
+++++
apply H0.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.
discriminate H4.
apply H0.

*****
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (in_dom B a m') true
+++++
rewrite (MapDom_Dom B m' a).
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.
discriminate H4.
apply H0.
rewrite (MapDom_Dom B m' a).

*****
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (in_FSet a (MapDom B m')) true
+++++
unfold in_FSet, in_dom in |- *.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.
discriminate H4.
apply H0.
rewrite (MapDom_Dom B m' a).
unfold in_FSet, in_dom in |- *.

*****
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq match MapGet unit (MapDom B m') a with | Some _ => true | None => false end true
+++++
rewrite H3.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.
discriminate H4.
apply H0.
rewrite (MapDom_Dom B m' a).
unfold in_FSet, in_dom in |- *.
rewrite H3.

*****
H3 : eq (MapGet unit (MapDom B m') a) (Some t)
t : unit
H2 : sig (fun y : unit => eq (MapGet unit (MapDom B m') a) (Some y))
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.
discriminate H4.
apply H0.
rewrite (MapDom_Dom B m' a).
unfold in_FSet, in_dom in |- *.
rewrite H3.
reflexivity.

*****
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
forall _ : eq (MapGet unit (MapDom B m') a) None, eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
intro H2.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.
discriminate H4.
apply H0.
rewrite (MapDom_Dom B m' a).
unfold in_FSet, in_dom in |- *.
rewrite H3.
reflexivity.
intro H2.

*****
H2 : eq (MapGet unit (MapDom B m') a) None
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) (MapGet unit (MapDom B m') a)
+++++
rewrite H2.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.
discriminate H4.
apply H0.
rewrite (MapDom_Dom B m' a).
unfold in_FSet, in_dom in |- *.
rewrite H3.
reflexivity.
intro H2.
rewrite H2.

*****
H2 : eq (MapGet unit (MapDom B m') a) None
H1 : eq (MapGet unit (MapDom A m) a) None
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B,C : Type
*****
eq (MapGet unit (MapDom A m) a) None
+++++
exact H1.
-----
Lemma MapSubset_antisym : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset, eqmap, eqm in |- *.
intros.
elim (option_sum _ (MapGet _ (MapDom A m) a)).
intro H1.
elim H1.
intro t.
elim t.
intro H2.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H3.
elim H3.
intro t'.
elim t'.
intro H4.
rewrite H4.
exact H2.
intro H3.
cut (in_dom B a m' = true).
intro.
rewrite (MapDom_Dom B m' a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H3 in H4.
discriminate H4.
apply H.
rewrite (MapDom_Dom A m a).
unfold in_FSet, in_dom in |- *.
rewrite H2.
reflexivity.
intro H1.
elim (option_sum _ (MapGet _ (MapDom B m') a)).
intro H2.
elim H2.
intros t H3.
cut (in_dom A a m = true).
intro.
rewrite (MapDom_Dom A m a) in H4.
unfold in_FSet, in_dom in H4.
rewrite H1 in H4.
discriminate H4.
apply H0.
rewrite (MapDom_Dom B m' a).
unfold in_FSet, in_dom in |- *.
rewrite H3.
reflexivity.
intro H2.
rewrite H2.
exact H1.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_trans :\n   forall (m:Map A) (m':Map B) (m'':Map C),\n     MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.
-----
Lemma MapSubset_trans : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.

*****
A,B,C : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (_ : MapSubset A B m m') (_ : MapSubset B C m' m''), MapSubset A C m m''
+++++
Proof.
-----
Lemma MapSubset_trans : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.
Proof.

*****
A,B,C : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (_ : MapSubset A B m m') (_ : MapSubset B C m' m''), MapSubset A C m m''
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_trans : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.
Proof.
unfold MapSubset in |- *.

*****
A,B,C : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true) (_ : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom C a m'') true) (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
+++++
intros.
-----
Lemma MapSubset_trans : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.
Proof.
unfold MapSubset in |- *.
intros.

*****
H1 : eq (in_dom A a m) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom C a m'') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m'' : Map C
m' : Map B
m : Map A
A,B,C : Type
*****
eq (in_dom C a m'') true
+++++
apply H0.
-----
Lemma MapSubset_trans : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.
Proof.
unfold MapSubset in |- *.
intros.
apply H0.

*****
H1 : eq (in_dom A a m) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom C a m'') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m'' : Map C
m' : Map B
m : Map A
A,B,C : Type
*****
eq (in_dom B a m') true
+++++
apply H.
-----
Lemma MapSubset_trans : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.
Proof.
unfold MapSubset in |- *.
intros.
apply H0.
apply H.

*****
H1 : eq (in_dom A a m) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom C a m'') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m'' : Map C
m' : Map B
m : Map A
A,B,C : Type
*****
eq (in_dom A a m) true
+++++
assumption.
-----
Lemma MapSubset_trans : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.
Proof.
unfold MapSubset in |- *.
intros.
apply H0.
apply H.
assumption.

*****

*****

+++++
Qed.
-----
End MapSubsetOrder.
-----
Section FSubsetOrder.
-----
Lemma FSubset_refl : forall s:FSet, MapSubset _ _ s s.
-----
Lemma FSubset_refl : forall s:FSet, MapSubset _ _ s s.

*****

*****
forall s : FSet, MapSubset unit unit s s
+++++
Proof.
-----
Lemma FSubset_refl : forall s:FSet, MapSubset _ _ s s.
Proof.

*****

*****
forall s : FSet, MapSubset unit unit s s
+++++
exact (MapSubset_refl unit).
-----
Lemma FSubset_refl : forall s:FSet, MapSubset _ _ s s.
Proof.
exact (MapSubset_refl unit).

*****

*****

+++++
Qed.
-----
Lemma FSubset_antisym :\n   forall s s':FSet,\n     MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.
-----
Lemma FSubset_antisym : forall s s':FSet, MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.

*****

*****
forall (s s' : FSet) (_ : MapSubset unit unit s s') (_ : MapSubset unit unit s' s), eqmap unit s s'
+++++
Proof.
-----
Lemma FSubset_antisym : forall s s':FSet, MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.
Proof.

*****

*****
forall (s s' : FSet) (_ : MapSubset unit unit s s') (_ : MapSubset unit unit s' s), eqmap unit s s'
+++++
intros.
-----
Lemma FSubset_antisym : forall s s':FSet, MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.
Proof.
intros.

*****
H0 : MapSubset unit unit s' s
H : MapSubset unit unit s s'
s,s' : FSet
*****
eqmap unit s s'
+++++
rewrite <- (FSet_Dom s).
-----
Lemma FSubset_antisym : forall s s':FSet, MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.
Proof.
intros.
rewrite <- (FSet_Dom s).

*****
H0 : MapSubset unit unit s' s
H : MapSubset unit unit s s'
s,s' : FSet
*****
eqmap unit (MapDom unit s) s'
+++++
rewrite <- (FSet_Dom s').
-----
Lemma FSubset_antisym : forall s s':FSet, MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.
Proof.
intros.
rewrite <- (FSet_Dom s).
rewrite <- (FSet_Dom s').

*****
H0 : MapSubset unit unit s' s
H : MapSubset unit unit s s'
s,s' : FSet
*****
eqmap unit (MapDom unit s) (MapDom unit s')
+++++
exact (MapSubset_antisym _ _ s s' H H0).
-----
Lemma FSubset_antisym : forall s s':FSet, MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.
Proof.
intros.
rewrite <- (FSet_Dom s).
rewrite <- (FSet_Dom s').
exact (MapSubset_antisym _ _ s s' H H0).

*****

*****

+++++
Qed.
-----
Lemma FSubset_trans :\n   forall s s' s'':FSet,\n     MapSubset _ _ s s' -> MapSubset _ _ s' s'' -> MapSubset _ _ s s''.
-----
Lemma FSubset_trans : forall s s' s'':FSet, MapSubset _ _ s s' -> MapSubset _ _ s' s'' -> MapSubset _ _ s s''.

*****

*****
forall (s s' s'' : FSet) (_ : MapSubset unit unit s s') (_ : MapSubset unit unit s' s''), MapSubset unit unit s s''
+++++
Proof.
-----
Lemma FSubset_trans : forall s s' s'':FSet, MapSubset _ _ s s' -> MapSubset _ _ s' s'' -> MapSubset _ _ s s''.
Proof.

*****

*****
forall (s s' s'' : FSet) (_ : MapSubset unit unit s s') (_ : MapSubset unit unit s' s''), MapSubset unit unit s s''
+++++
exact (MapSubset_trans unit unit unit).
-----
Lemma FSubset_trans : forall s s' s'':FSet, MapSubset _ _ s s' -> MapSubset _ _ s' s'' -> MapSubset _ _ s s''.
Proof.
exact (MapSubset_trans unit unit unit).

*****

*****

+++++
Qed.
-----
End FSubsetOrder.
-----
Section MapSubsetExtra.
-----
Variables A B : Type.
-----
Lemma MapSubset_Dom_1 :\n   forall (m:Map A) (m':Map B),\n     MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m'), MapSubset unit unit (MapDom A m) (MapDom B m')
+++++
Proof.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m'), MapSubset unit unit (MapDom A m) (MapDom B m')
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true) (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true), eq (in_dom unit a (MapDom B m')) true
+++++
intros.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.

*****
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
elim (MapDom_semantics_2 _ m a H0).
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).

*****
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq (in_dom unit a (MapDom B m')) true
+++++
intros y H1.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
cut (in_dom A a m = true -> in_dom B a m' = true).
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : forall _ : eq (in_dom A a m) true, eq (in_dom B a m') true, eq (in_dom unit a (MapDom B m')) true
+++++
intro.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.

*****
H2 : forall _ : eq (in_dom A a m) true, eq (in_dom B a m') true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
unfold in_dom in H2.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.

*****
H2 : forall\n _ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true,\neq match MapGet B m' a with\n | Some _ => true\n | None => false\n end true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
rewrite H1 in H2.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.

*****
H2 : forall _ : eq true true,\neq match MapGet B m' a with\n | Some _ => true\n | None => false\n end true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
elim (option_sum _ (MapGet B m' a)).
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).

*****
H2 : forall _ : eq true true,\neq match MapGet B m' a with\n | Some _ => true\n | None => false\n end true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : B => eq (MapGet B m' a) (Some y)), eq (in_dom unit a (MapDom B m')) true
+++++
intro H3.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).
intro H3.

*****
H3 : sig (fun y : B => eq (MapGet B m' a) (Some y))
H2 : forall _ : eq true true,\neq match MapGet B m' a with\n | Some _ => true\n | None => false\n end true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
elim H3.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).
intro H3.
elim H3.

*****
H3 : sig (fun y : B => eq (MapGet B m' a) (Some y))
H2 : forall _ : eq true true,\neq match MapGet B m' a with\n | Some _ => true\n | None => false\n end true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m' a) (Some x)), eq (in_dom unit a (MapDom B m')) true
+++++
intros y' H4.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).
intro H3.
elim H3.
intros y' H4.

*****
H4 : eq (MapGet B m' a) (Some y')
y' : B
H3 : sig (fun y : B => eq (MapGet B m' a) (Some y))
H2 : forall _ : eq true true,\neq match MapGet B m' a with\n | Some _ => true\n | None => false\n end true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
exact (MapDom_semantics_1 _ m' a y' H4).
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).

*****
H2 : forall _ : eq true true,\neq match MapGet B m' a with\n | Some _ => true\n | None => false\n end true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapGet B m' a) None, eq (in_dom unit a (MapDom B m')) true
+++++
intro H3.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).
intro H3.

*****
H3 : eq (MapGet B m' a) None
H2 : forall _ : eq true true,\neq match MapGet B m' a with\n | Some _ => true\n | None => false\n end true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
rewrite H3 in H2.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).
intro H3.
rewrite H3 in H2.

*****
H3 : eq (MapGet B m' a) None
H2 : forall _ : eq true true, eq false true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
cut (false = true).
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).
intro H3.
rewrite H3 in H2.
cut (false = true).

*****
H3 : eq (MapGet B m' a) None
H2 : forall _ : eq true true, eq false true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq false true, eq (in_dom unit a (MapDom B m')) true
+++++
intro.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).
intro H3.
rewrite H3 in H2.
cut (false = true).
intro.

*****
H4 : eq false true
H3 : eq (MapGet B m' a) None
H2 : forall _ : eq true true, eq false true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom unit a (MapDom B m')) true
+++++
discriminate H4.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).
intro H3.
rewrite H3 in H2.
cut (false = true).

*****
H3 : eq (MapGet B m' a) None
H2 : forall _ : eq true true, eq false true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq false true
+++++
apply H2.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).
intro.
unfold in_dom in H2.
rewrite H1 in H2.
elim (option_sum _ (MapGet B m' a)).
intro H3.
rewrite H3 in H2.
cut (false = true).
apply H2.

*****
H3 : eq (MapGet B m' a) None
H2 : forall _ : eq true true, eq false true
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom unit a (MapDom A m)) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) true, eq (in_dom B a m') true
+++++
exact (H a).
-----
Lemma MapSubset_Dom_1 : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').
Proof.
unfold MapSubset in |- *.
intros.
elim (MapDom_semantics_2 _ m a H0).
intros y H1.
cut (in_dom A a m = true -> in_dom B a m' = true).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Dom_2 :\n   forall (m:Map A) (m':Map B),\n     MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset unit unit (MapDom A m) (MapDom B m')), MapSubset A B m m'
+++++
Proof.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset unit unit (MapDom A m) (MapDom B m')), MapSubset A B m m'
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true), eq (in_dom unit a (MapDom B m')) true) (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
+++++
intros.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.

*****
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
unfold in_dom in H0.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.

*****
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
elim (option_sum _ (MapGet A m a)).
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).

*****
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m a) (Some y)), eq (in_dom B a m') true
+++++
intro H1.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H1.

*****
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
elim H1.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.

*****
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq (in_dom B a m') true
+++++
intros y H2.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
elim (MapDom_semantics_2 _ _ _ (H a (MapDom_semantics_1 _ _ _ _ H2))).
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (MapDom_semantics_2 _ _ _ (H a (MapDom_semantics_1 _ _ _ _ H2))).

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m' a) (Some x)), eq (in_dom B a m') true
+++++
intros y' H3.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (MapDom_semantics_2 _ _ _ (H a (MapDom_semantics_1 _ _ _ _ H2))).
intros y' H3.

*****
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
unfold in_dom in |- *.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (MapDom_semantics_2 _ _ _ (H a (MapDom_semantics_1 _ _ _ _ H2))).
intros y' H3.
unfold in_dom in |- *.

*****
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => true | None => false end true
+++++
rewrite H3.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
elim (MapDom_semantics_2 _ _ _ (H a (MapDom_semantics_1 _ _ _ _ H2))).
intros y' H3.
unfold in_dom in |- *.
rewrite H3.

*****
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).

*****
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapGet A m a) None, eq (in_dom B a m') true
+++++
intro H1.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H1.

*****
H1 : eq (MapGet A m a) None
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
rewrite H1 in H0.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H1.
rewrite H1 in H0.

*****
H1 : eq (MapGet A m a) None
H0 : eq false true
a : ad
H : forall (a : ad) (_ : eq (in_dom unit a (MapDom A m)) true),\neq (in_dom unit a (MapDom B m')) true
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
discriminate H0.
-----
Lemma MapSubset_Dom_2 : forall (m:Map A) (m':Map B), MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.
Proof.
unfold MapSubset in |- *.
intros.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_1_Dom :\n   forall (m:Map A) (m':Map B),\n     MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), eq (MapSubset_1 A B m m') (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
Proof.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), eq (MapSubset_1 A B m m') (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
intros.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.

*****
m' : Map B
m : Map A
A,B : Type
*****
eq (MapSubset_1 A B m m') (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
elim (sumbool_of_bool (MapSubset_1 A B m m')).
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).

*****
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSubset_1 A B m m') true, eq (MapSubset_1 A B m m') (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
intro H.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.

*****
H : eq (MapSubset_1 A B m m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (MapSubset_1 A B m m') (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
rewrite H.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.

*****
H : eq (MapSubset_1 A B m m') true
m' : Map B
m : Map A
A,B : Type
*****
eq true (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
apply sym_eq.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.
apply sym_eq.

*****
H : eq (MapSubset_1 A B m m') true
m' : Map B
m : Map A
A,B : Type
*****
eq (MapSubset_1 unit unit (MapDom A m) (MapDom B m')) true
+++++
apply MapSubset_imp_1.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.
apply sym_eq.
apply MapSubset_imp_1.

*****
H : eq (MapSubset_1 A B m m') true
m' : Map B
m : Map A
A,B : Type
*****
MapSubset unit unit (MapDom A m) (MapDom B m')
+++++
apply MapSubset_Dom_1.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.
apply sym_eq.
apply MapSubset_imp_1.
apply MapSubset_Dom_1.

*****
H : eq (MapSubset_1 A B m m') true
m' : Map B
m : Map A
A,B : Type
*****
MapSubset A B m m'
+++++
exact (MapSubset_1_imp _ _ _ _ H).
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).

*****
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSubset_1 A B m m') false, eq (MapSubset_1 A B m m') (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
intro H.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.

*****
H : eq (MapSubset_1 A B m m') false
m' : Map B
m : Map A
A,B : Type
*****
eq (MapSubset_1 A B m m') (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
rewrite H.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.

*****
H : eq (MapSubset_1 A B m m') false
m' : Map B
m : Map A
A,B : Type
*****
eq false (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
elim (sumbool_of_bool (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))).
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.
elim (sumbool_of_bool (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))).

*****
H : eq (MapSubset_1 A B m m') false
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSubset_1 unit unit (MapDom A m) (MapDom B m')) true, eq false (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
intro H0.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.
elim (sumbool_of_bool (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))).
intro H0.

*****
H0 : eq (MapSubset_1 unit unit (MapDom A m) (MapDom B m')) true
H : eq (MapSubset_1 A B m m') false
m' : Map B
m : Map A
A,B : Type
*****
eq false (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
rewrite (MapSubset_imp_1 _ _ _ _ (MapSubset_Dom_2 _ _ (MapSubset_1_imp _ _ _ _ H0))) in H.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.
elim (sumbool_of_bool (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))).
intro H0.
rewrite (MapSubset_imp_1 _ _ _ _ (MapSubset_Dom_2 _ _ (MapSubset_1_imp _ _ _ _ H0))) in H.

*****
H0 : eq (MapSubset_1 unit unit (MapDom A m) (MapDom B m')) true
H : eq true false
m' : Map B
m : Map A
A,B : Type
*****
eq false (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
discriminate H.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.
elim (sumbool_of_bool (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))).

*****
H : eq (MapSubset_1 A B m m') false
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSubset_1 unit unit (MapDom A m) (MapDom B m')) false, eq false (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
intro.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.
elim (sumbool_of_bool (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))).
intro.

*****
b : eq (MapSubset_1 unit unit (MapDom A m) (MapDom B m')) false
H : eq (MapSubset_1 A B m m') false
m' : Map B
m : Map A
A,B : Type
*****
eq false (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))
+++++
apply sym_eq.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).
intro H.
rewrite H.
elim (sumbool_of_bool (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))).
intro.
apply sym_eq.

*****
b : eq (MapSubset_1 unit unit (MapDom A m) (MapDom B m')) false
H : eq (MapSubset_1 A B m m') false
m' : Map B
m : Map A
A,B : Type
*****
eq (MapSubset_1 unit unit (MapDom A m) (MapDom B m')) false
+++++
assumption.
-----
Lemma MapSubset_1_Dom : forall (m:Map A) (m':Map B), MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').
Proof.
intros.
elim (sumbool_of_bool (MapSubset_1 A B m m')).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Put :\n   forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).
-----
Lemma MapSubset_Put : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), MapSubset A A m (MapPut A m a y)
+++++
Proof.
-----
Lemma MapSubset_Put : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), MapSubset A A m (MapPut A m a y)
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Put : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (a0 : ad) (_ : eq (in_dom A a0 m) true), eq (in_dom A a0 (MapPut A m a y)) true
+++++
intros.
-----
Lemma MapSubset_Put : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).
Proof.
unfold MapSubset in |- *.
intros.

*****
H : eq (in_dom A a0 m) true
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (in_dom A a0 (MapPut A m a y)) true
+++++
rewrite in_dom_put.
-----
Lemma MapSubset_Put : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.

*****
H : eq (in_dom A a0 m) true
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
+++++
rewrite H.
-----
Lemma MapSubset_Put : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite H.

*****
H : eq (in_dom A a0 m) true
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) true) true
+++++
apply orb_b_true.
-----
Lemma MapSubset_Put : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite H.
apply orb_b_true.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Put_mono :\n   forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B),\n     MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (y : A) (y' : B) (_ : MapSubset A B m m'), MapSubset A B (MapPut A m a y) (MapPut B m' a y')
+++++
Proof.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (y : A) (y' : B) (_ : MapSubset A B m m'), MapSubset A B (MapPut A m a y) (MapPut B m' a y')
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (y : A) (y' : B) (_ : forall (a0 : ad) (_ : eq (in_dom A a0 m) true), eq (in_dom B a0 m') true) (a0 : ad) (_ : eq (in_dom A a0 (MapPut A m a y)) true), eq (in_dom B a0 (MapPut B m' a y')) true
+++++
intros.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.

*****
H0 : eq (in_dom A a0 (MapPut A m a y)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a0 (MapPut B m' a y')) true
+++++
rewrite in_dom_put.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.

*****
H0 : eq (in_dom A a0 (MapPut A m a y)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
rewrite (in_dom_put A m a y a0) in H0.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite (in_dom_put A m a y a0) in H0.

*****
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
elim (orb_true_elim _ _ H0).
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite (in_dom_put A m a y a0) in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a0 a) true, eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
intro H1.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite (in_dom_put A m a y a0) in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
rewrite H1.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite (in_dom_put A m a y a0) in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb true (in_dom B a0 m')) true
+++++
reflexivity.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite (in_dom_put A m a y a0) in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a0 m) true, eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
intro H1.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite (in_dom_put A m a y a0) in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (in_dom A a0 m) true
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
rewrite (H _ H1).
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite (in_dom_put A m a y a0) in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite (H _ H1).

*****
H1 : eq (in_dom A a0 m) true
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) true) true
+++++
apply orb_b_true.
-----
Lemma MapSubset_Put_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put.
rewrite (in_dom_put A m a y a0) in H0.
elim (orb_true_elim _ _ H0).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Put_behind :\n   forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).
-----
Lemma MapSubset_Put_behind : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), MapSubset A A m (MapPut_behind A m a y)
+++++
Proof.
-----
Lemma MapSubset_Put_behind : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), MapSubset A A m (MapPut_behind A m a y)
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Put_behind : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (a0 : ad) (_ : eq (in_dom A a0 m) true), eq (in_dom A a0 (MapPut_behind A m a y)) true
+++++
intros.
-----
Lemma MapSubset_Put_behind : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).
Proof.
unfold MapSubset in |- *.
intros.

*****
H : eq (in_dom A a0 m) true
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (in_dom A a0 (MapPut_behind A m a y)) true
+++++
rewrite in_dom_put_behind.
-----
Lemma MapSubset_Put_behind : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.

*****
H : eq (in_dom A a0 m) true
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
+++++
rewrite H.
-----
Lemma MapSubset_Put_behind : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite H.

*****
H : eq (in_dom A a0 m) true
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) true) true
+++++
apply orb_b_true.
-----
Lemma MapSubset_Put_behind : forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite H.
apply orb_b_true.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Put_behind_mono :\n   forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B),\n     MapSubset A B m m' ->\n     MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (y : A) (y' : B) (_ : MapSubset A B m m'), MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y')
+++++
Proof.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (y : A) (y' : B) (_ : MapSubset A B m m'), MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y')
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (y : A) (y' : B) (_ : forall (a0 : ad) (_ : eq (in_dom A a0 m) true), eq (in_dom B a0 m') true) (a0 : ad) (_ : eq (in_dom A a0 (MapPut_behind A m a y)) true), eq (in_dom B a0 (MapPut_behind B m' a y')) true
+++++
intros.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.

*****
H0 : eq (in_dom A a0 (MapPut_behind A m a y)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a0 (MapPut_behind B m' a y')) true
+++++
rewrite in_dom_put_behind.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.

*****
H0 : eq (in_dom A a0 (MapPut_behind A m a y)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
rewrite (in_dom_put_behind A m a y a0) in H0.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite (in_dom_put_behind A m a y a0) in H0.

*****
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
elim (orb_true_elim _ _ H0).
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite (in_dom_put_behind A m a y a0) in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a0 a) true, eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
intro H1.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite (in_dom_put_behind A m a y a0) in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
rewrite H1.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite (in_dom_put_behind A m a y a0) in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb true (in_dom B a0 m')) true
+++++
reflexivity.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite (in_dom_put_behind A m a y a0) in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a0 m) true, eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
intro H1.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite (in_dom_put_behind A m a y a0) in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (in_dom A a0 m) true
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) (in_dom B a0 m')) true
+++++
rewrite (H _ H1).
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite (in_dom_put_behind A m a y a0) in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite (H _ H1).

*****
H1 : eq (in_dom A a0 m) true
H0 : eq (orb (N.eqb a0 a) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
y' : B
y : A
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (orb (N.eqb a0 a) true) true
+++++
apply orb_b_true.
-----
Lemma MapSubset_Put_behind_mono : forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B), MapSubset A B m m' -> MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_put_behind.
rewrite (in_dom_put_behind A m a y a0) in H0.
elim (orb_true_elim _ _ H0).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Remove :\n   forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.
-----
Lemma MapSubset_Remove : forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.

*****
A,B : Type
*****
forall (m : Map A) (a : ad), MapSubset A A (MapRemove A m a) m
+++++
Proof.
-----
Lemma MapSubset_Remove : forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad), MapSubset A A (MapRemove A m a) m
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Remove : forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a a0 : ad) (_ : eq (in_dom A a0 (MapRemove A m a)) true), eq (in_dom A a0 m) true
+++++
intros.
-----
Lemma MapSubset_Remove : forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.
Proof.
unfold MapSubset in |- *.
intros.

*****
H : eq (in_dom A a0 (MapRemove A m a)) true
a,a0 : ad
m : Map A
A,B : Type
*****
eq (in_dom A a0 m) true
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Remove : forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.
Proof.
unfold MapSubset in |- *.
intros.
unfold MapSubset in |- *.

*****
H : eq (in_dom A a0 (MapRemove A m a)) true
a,a0 : ad
m : Map A
A,B : Type
*****
eq (in_dom A a0 m) true
+++++
intros.
-----
Lemma MapSubset_Remove : forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.
Proof.
unfold MapSubset in |- *.
intros.
unfold MapSubset in |- *.
intros.

*****
H : eq (in_dom A a0 (MapRemove A m a)) true
a,a0 : ad
m : Map A
A,B : Type
*****
eq (in_dom A a0 m) true
+++++
rewrite (in_dom_remove _ m a a0) in H.
-----
Lemma MapSubset_Remove : forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.
Proof.
unfold MapSubset in |- *.
intros.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_remove _ m a a0) in H.

*****
H : eq (andb (negb (N.eqb a0 a)) (in_dom A a0 m)) true
a,a0 : ad
m : Map A
A,B : Type
*****
eq (in_dom A a0 m) true
+++++
elim (andb_prop _ _ H).
-----
Lemma MapSubset_Remove : forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.
Proof.
unfold MapSubset in |- *.
intros.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_remove _ m a a0) in H.
elim (andb_prop _ _ H).

*****
H : eq (andb (negb (N.eqb a0 a)) (in_dom A a0 m)) true
a,a0 : ad
m : Map A
A,B : Type
*****
forall (_ : eq (negb (N.eqb a0 a)) true) (_ : eq (in_dom A a0 m) true), eq (in_dom A a0 m) true
+++++
trivial.
-----
Lemma MapSubset_Remove : forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.
Proof.
unfold MapSubset in |- *.
intros.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_remove _ m a a0) in H.
elim (andb_prop _ _ H).
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Remove_mono :\n   forall (m:Map A) (m':Map B) (a:ad),\n     MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (_ : MapSubset A B m m'), MapSubset A B (MapRemove A m a) (MapRemove B m' a)
+++++
Proof.
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (_ : MapSubset A B m m'), MapSubset A B (MapRemove A m a) (MapRemove B m' a)
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (_ : forall (a0 : ad) (_ : eq (in_dom A a0 m) true), eq (in_dom B a0 m') true) (a0 : ad) (_ : eq (in_dom A a0 (MapRemove A m a)) true), eq (in_dom B a0 (MapRemove B m' a)) true
+++++
intros.
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.
unfold MapSubset in |- *.
intros.

*****
H0 : eq (in_dom A a0 (MapRemove A m a)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a0 (MapRemove B m' a)) true
+++++
rewrite in_dom_remove.
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_remove.

*****
H0 : eq (in_dom A a0 (MapRemove A m a)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (andb (negb (N.eqb a0 a)) (in_dom B a0 m')) true
+++++
rewrite (in_dom_remove A m a a0) in H0.
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_remove.
rewrite (in_dom_remove A m a a0) in H0.

*****
H0 : eq (andb (negb (N.eqb a0 a)) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (andb (negb (N.eqb a0 a)) (in_dom B a0 m')) true
+++++
elim (andb_prop _ _ H0).
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_remove.
rewrite (in_dom_remove A m a a0) in H0.
elim (andb_prop _ _ H0).

*****
H0 : eq (andb (negb (N.eqb a0 a)) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall (_ : eq (negb (N.eqb a0 a)) true) (_ : eq (in_dom A a0 m) true), eq (andb (negb (N.eqb a0 a)) (in_dom B a0 m')) true
+++++
intros.
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_remove.
rewrite (in_dom_remove A m a a0) in H0.
elim (andb_prop _ _ H0).
intros.

*****
H2 : eq (in_dom A a0 m) true
H1 : eq (negb (N.eqb a0 a)) true
H0 : eq (andb (negb (N.eqb a0 a)) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (andb (negb (N.eqb a0 a)) (in_dom B a0 m')) true
+++++
rewrite H1.
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_remove.
rewrite (in_dom_remove A m a a0) in H0.
elim (andb_prop _ _ H0).
intros.
rewrite H1.

*****
H2 : eq (in_dom A a0 m) true
H1 : eq (negb (N.eqb a0 a)) true
H0 : eq (andb (negb (N.eqb a0 a)) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (andb true (in_dom B a0 m')) true
+++++
rewrite (H _ H2).
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_remove.
rewrite (in_dom_remove A m a a0) in H0.
elim (andb_prop _ _ H0).
intros.
rewrite H1.
rewrite (H _ H2).

*****
H2 : eq (in_dom A a0 m) true
H1 : eq (negb (N.eqb a0 a)) true
H0 : eq (andb (negb (N.eqb a0 a)) (in_dom A a0 m)) true
a0 : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (andb true true) true
+++++
reflexivity.
-----
Lemma MapSubset_Remove_mono : forall (m:Map A) (m':Map B) (a:ad), MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_remove.
rewrite (in_dom_remove A m a a0) in H0.
elim (andb_prop _ _ H0).
intros.
rewrite H1.
rewrite (H _ H2).
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Merge_l :\n   forall m m':Map A, MapSubset A A m (MapMerge A m m').
-----
Lemma MapSubset_Merge_l : forall m m':Map A, MapSubset A A m (MapMerge A m m').

*****
A,B : Type
*****
forall m m' : Map A, MapSubset A A m (MapMerge A m m')
+++++
Proof.
-----
Lemma MapSubset_Merge_l : forall m m':Map A, MapSubset A A m (MapMerge A m m').
Proof.

*****
A,B : Type
*****
forall m m' : Map A, MapSubset A A m (MapMerge A m m')
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Merge_l : forall m m':Map A, MapSubset A A m (MapMerge A m m').
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom A a (MapMerge A m m')) true
+++++
intros.
-----
Lemma MapSubset_Merge_l : forall m m':Map A, MapSubset A A m (MapMerge A m m').
Proof.
unfold MapSubset in |- *.
intros.

*****
H : eq (in_dom A a m) true
a : ad
m,m' : Map A
A,B : Type
*****
eq (in_dom A a (MapMerge A m m')) true
+++++
rewrite in_dom_merge.
-----
Lemma MapSubset_Merge_l : forall m m':Map A, MapSubset A A m (MapMerge A m m').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.

*****
H : eq (in_dom A a m) true
a : ad
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom A a m) (in_dom A a m')) true
+++++
rewrite H.
-----
Lemma MapSubset_Merge_l : forall m m':Map A, MapSubset A A m (MapMerge A m m').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite H.

*****
H : eq (in_dom A a m) true
a : ad
m,m' : Map A
A,B : Type
*****
eq (orb true (in_dom A a m')) true
+++++
reflexivity.
-----
Lemma MapSubset_Merge_l : forall m m':Map A, MapSubset A A m (MapMerge A m m').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite H.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Merge_r :\n   forall m m':Map A, MapSubset A A m' (MapMerge A m m').
-----
Lemma MapSubset_Merge_r : forall m m':Map A, MapSubset A A m' (MapMerge A m m').

*****
A,B : Type
*****
forall m m' : Map A, MapSubset A A m' (MapMerge A m m')
+++++
Proof.
-----
Lemma MapSubset_Merge_r : forall m m':Map A, MapSubset A A m' (MapMerge A m m').
Proof.

*****
A,B : Type
*****
forall m m' : Map A, MapSubset A A m' (MapMerge A m m')
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Merge_r : forall m m':Map A, MapSubset A A m' (MapMerge A m m').
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad) (_ : eq (in_dom A a m') true), eq (in_dom A a (MapMerge A m m')) true
+++++
intros.
-----
Lemma MapSubset_Merge_r : forall m m':Map A, MapSubset A A m' (MapMerge A m m').
Proof.
unfold MapSubset in |- *.
intros.

*****
H : eq (in_dom A a m') true
a : ad
m,m' : Map A
A,B : Type
*****
eq (in_dom A a (MapMerge A m m')) true
+++++
rewrite in_dom_merge.
-----
Lemma MapSubset_Merge_r : forall m m':Map A, MapSubset A A m' (MapMerge A m m').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.

*****
H : eq (in_dom A a m') true
a : ad
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom A a m) (in_dom A a m')) true
+++++
rewrite H.
-----
Lemma MapSubset_Merge_r : forall m m':Map A, MapSubset A A m' (MapMerge A m m').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite H.

*****
H : eq (in_dom A a m') true
a : ad
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom A a m) true) true
+++++
apply orb_b_true.
-----
Lemma MapSubset_Merge_r : forall m m':Map A, MapSubset A A m' (MapMerge A m m').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite H.
apply orb_b_true.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Merge_mono :\n   forall (m m':Map A) (m'' m''':Map B),\n     MapSubset A B m m'' ->\n     MapSubset A B m' m''' ->\n     MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').

*****
A,B : Type
*****
forall (m m' : Map A) (m'' m''' : Map B) (_ : MapSubset A B m m'') (_ : MapSubset A B m' m'''), MapSubset A B (MapMerge A m m') (MapMerge B m'' m''')
+++++
Proof.
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (m'' m''' : Map B) (_ : MapSubset A B m m'') (_ : MapSubset A B m' m'''), MapSubset A B (MapMerge A m m') (MapMerge B m'' m''')
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m m' : Map A) (m'' m''' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true) (_ : forall (a : ad) (_ : eq (in_dom A a m') true), eq (in_dom B a m''') true) (a : ad) (_ : eq (in_dom A a (MapMerge A m m')) true), eq (in_dom B a (MapMerge B m'' m''')) true
+++++
intros.
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.

*****
H1 : eq (in_dom A a (MapMerge A m m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m') true),\neq (in_dom B a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true
m'',m''' : Map B
m,m' : Map A
A,B : Type
*****
eq (in_dom B a (MapMerge B m'' m''')) true
+++++
rewrite in_dom_merge.
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.

*****
H1 : eq (in_dom A a (MapMerge A m m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m') true),\neq (in_dom B a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true
m'',m''' : Map B
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom B a m'') (in_dom B a m''')) true
+++++
rewrite (in_dom_merge A m m' a) in H1.
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite (in_dom_merge A m m' a) in H1.

*****
H1 : eq (orb (in_dom A a m) (in_dom A a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m') true),\neq (in_dom B a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true
m'',m''' : Map B
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom B a m'') (in_dom B a m''')) true
+++++
elim (orb_true_elim _ _ H1).
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite (in_dom_merge A m m' a) in H1.
elim (orb_true_elim _ _ H1).

*****
H1 : eq (orb (in_dom A a m) (in_dom A a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m') true),\neq (in_dom B a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true
m'',m''' : Map B
m,m' : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) true, eq (orb (in_dom B a m'') (in_dom B a m''')) true
+++++
intro H2.
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite (in_dom_merge A m m' a) in H1.
elim (orb_true_elim _ _ H1).
intro H2.

*****
H2 : eq (in_dom A a m) true
H1 : eq (orb (in_dom A a m) (in_dom A a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m') true),\neq (in_dom B a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true
m'',m''' : Map B
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom B a m'') (in_dom B a m''')) true
+++++
rewrite (H _ H2).
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite (in_dom_merge A m m' a) in H1.
elim (orb_true_elim _ _ H1).
intro H2.
rewrite (H _ H2).

*****
H2 : eq (in_dom A a m) true
H1 : eq (orb (in_dom A a m) (in_dom A a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m') true),\neq (in_dom B a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true
m'',m''' : Map B
m,m' : Map A
A,B : Type
*****
eq (orb true (in_dom B a m''')) true
+++++
reflexivity.
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite (in_dom_merge A m m' a) in H1.
elim (orb_true_elim _ _ H1).

*****
H1 : eq (orb (in_dom A a m) (in_dom A a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m') true),\neq (in_dom B a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true
m'',m''' : Map B
m,m' : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m') true, eq (orb (in_dom B a m'') (in_dom B a m''')) true
+++++
intro H2.
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite (in_dom_merge A m m' a) in H1.
elim (orb_true_elim _ _ H1).
intro H2.

*****
H2 : eq (in_dom A a m') true
H1 : eq (orb (in_dom A a m) (in_dom A a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m') true),\neq (in_dom B a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true
m'',m''' : Map B
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom B a m'') (in_dom B a m''')) true
+++++
rewrite (H0 _ H2).
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite (in_dom_merge A m m' a) in H1.
elim (orb_true_elim _ _ H1).
intro H2.
rewrite (H0 _ H2).

*****
H2 : eq (in_dom A a m') true
H1 : eq (orb (in_dom A a m) (in_dom A a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m') true),\neq (in_dom B a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m'') true
m'',m''' : Map B
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom B a m'') true) true
+++++
apply orb_b_true.
-----
Lemma MapSubset_Merge_mono : forall (m m':Map A) (m'' m''':Map B), MapSubset A B m m'' -> MapSubset A B m' m''' -> MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_merge.
rewrite (in_dom_merge A m m' a) in H1.
elim (orb_true_elim _ _ H1).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_DomRestrTo_l :\n   forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.
-----
Lemma MapSubset_DomRestrTo_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), MapSubset A A (MapDomRestrTo A B m m') m
+++++
Proof.
-----
Lemma MapSubset_DomRestrTo_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), MapSubset A A (MapDomRestrTo A B m m') m
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_DomRestrTo_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (_ : eq (in_dom A a (MapDomRestrTo A B m m')) true), eq (in_dom A a m) true
+++++
intros.
-----
Lemma MapSubset_DomRestrTo_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.
Proof.
unfold MapSubset in |- *.
intros.

*****
H : eq (in_dom A a (MapDomRestrTo A B m m')) true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom A a m) true
+++++
rewrite (in_dom_restrto _ _ m m' a) in H.
-----
Lemma MapSubset_DomRestrTo_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.
Proof.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_restrto _ _ m m' a) in H.

*****
H : eq (andb (in_dom A a m) (in_dom B a m')) true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom A a m) true
+++++
elim (andb_prop _ _ H).
-----
Lemma MapSubset_DomRestrTo_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.
Proof.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_restrto _ _ m m' a) in H.
elim (andb_prop _ _ H).

*****
H : eq (andb (in_dom A a m) (in_dom B a m')) true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
+++++
trivial.
-----
Lemma MapSubset_DomRestrTo_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.
Proof.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_restrto _ _ m m' a) in H.
elim (andb_prop _ _ H).
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_DomRestrTo_r :\n   forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.
-----
Lemma MapSubset_DomRestrTo_r : forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), MapSubset A B (MapDomRestrTo A B m m') m'
+++++
Proof.
-----
Lemma MapSubset_DomRestrTo_r : forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), MapSubset A B (MapDomRestrTo A B m m') m'
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_DomRestrTo_r : forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.
Proof.
unfold MapSubset in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (_ : eq (in_dom A a (MapDomRestrTo A B m m')) true), eq (in_dom B a m') true
+++++
intros.
-----
Lemma MapSubset_DomRestrTo_r : forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.
Proof.
unfold MapSubset in |- *.
intros.

*****
H : eq (in_dom A a (MapDomRestrTo A B m m')) true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
rewrite (in_dom_restrto _ _ m m' a) in H.
-----
Lemma MapSubset_DomRestrTo_r : forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.
Proof.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_restrto _ _ m m' a) in H.

*****
H : eq (andb (in_dom A a m) (in_dom B a m')) true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
eq (in_dom B a m') true
+++++
elim (andb_prop _ _ H).
-----
Lemma MapSubset_DomRestrTo_r : forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.
Proof.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_restrto _ _ m m' a) in H.
elim (andb_prop _ _ H).

*****
H : eq (andb (in_dom A a m) (in_dom B a m')) true
a : ad
m' : Map B
m : Map A
A,B : Type
*****
forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), eq (in_dom B a m') true
+++++
trivial.
-----
Lemma MapSubset_DomRestrTo_r : forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.
Proof.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_restrto _ _ m m' a) in H.
elim (andb_prop _ _ H).
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_ext :\n   forall (m0 m1:Map A) (m2 m3:Map B),\n     eqmap A m0 m1 ->\n     eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : eqmap A m0 m1) (_ : eqmap B m2 m3) (_ : MapSubset A B m0 m2), MapSubset A B m1 m3
+++++
Proof.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : eqmap A m0 m1) (_ : eqmap B m2 m3) (_ : MapSubset A B m0 m2), MapSubset A B m1 m3
+++++
intros.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.

*****
H1 : MapSubset A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
MapSubset A B m1 m3
+++++
apply MapSubset_2_imp.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.
apply MapSubset_2_imp.

*****
H1 : MapSubset A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
MapSubset_2 A B m1 m3
+++++
unfold MapSubset_2 in |- *.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.

*****
H1 : MapSubset A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A (MapDomRestrBy A B m1 m3) (M0 A)
+++++
apply eqmap_trans with (m' := MapDomRestrBy A B m0 m2).
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrBy A B m0 m2).

*****
H1 : MapSubset A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A (MapDomRestrBy A B m1 m3) (MapDomRestrBy A B m0 m2)
+++++
apply MapDomRestrBy_ext.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrBy A B m0 m2).
apply MapDomRestrBy_ext.

*****
H1 : MapSubset A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A m1 m0
+++++
apply eqmap_sym.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrBy A B m0 m2).
apply MapDomRestrBy_ext.
apply eqmap_sym.

*****
H1 : MapSubset A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A m0 m1
+++++
assumption.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrBy A B m0 m2).
apply MapDomRestrBy_ext.

*****
H1 : MapSubset A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap B m3 m2
+++++
apply eqmap_sym.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrBy A B m0 m2).
apply MapDomRestrBy_ext.
apply eqmap_sym.

*****
H1 : MapSubset A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap B m2 m3
+++++
assumption.
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrBy A B m0 m2).

*****
H1 : MapSubset A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A (MapDomRestrBy A B m0 m2) (M0 A)
+++++
exact (MapSubset_imp_2 _ _ _ _ H1).
-----
Lemma MapSubset_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.
Proof.
intros.
apply MapSubset_2_imp.
unfold MapSubset_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrBy A B m0 m2).

*****

*****

+++++
Qed.
-----
Variables C D : Type.
-----
Lemma MapSubset_DomRestrTo_mono :\n   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),\n     MapSubset _ _ m m'' ->\n     MapSubset _ _ m' m''' ->\n     MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').

*****
C,D : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : MapSubset A C m m'') (_ : MapSubset B D m' m'''), MapSubset A C (MapDomRestrTo A B m m') (MapDomRestrTo C D m'' m''')
+++++
Proof.
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.

*****
C,D : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : MapSubset A C m m'') (_ : MapSubset B D m' m'''), MapSubset A C (MapDomRestrTo A B m m') (MapDomRestrTo C D m'' m''')
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.
unfold MapSubset in |- *.

*****
C,D : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true) (_ : forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom D a m''') true) (a : ad) (_ : eq (in_dom A a (MapDomRestrTo A B m m')) true), eq (in_dom C a (MapDomRestrTo C D m'' m''')) true
+++++
intros.
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.

*****
H1 : eq (in_dom A a (MapDomRestrTo A B m m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true),\neq (in_dom D a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (in_dom C a (MapDomRestrTo C D m'' m''')) true
+++++
rewrite in_dom_restrto.
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrto.

*****
H1 : eq (in_dom A a (MapDomRestrTo A B m m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true),\neq (in_dom D a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb (in_dom C a m'') (in_dom D a m''')) true
+++++
rewrite (in_dom_restrto A B m m' a) in H1.
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrto.
rewrite (in_dom_restrto A B m m' a) in H1.

*****
H1 : eq (andb (in_dom A a m) (in_dom B a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true),\neq (in_dom D a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb (in_dom C a m'') (in_dom D a m''')) true
+++++
elim (andb_prop _ _ H1).
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrto.
rewrite (in_dom_restrto A B m m' a) in H1.
elim (andb_prop _ _ H1).

*****
H1 : eq (andb (in_dom A a m) (in_dom B a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true),\neq (in_dom D a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), eq (andb (in_dom C a m'') (in_dom D a m''')) true
+++++
intros.
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrto.
rewrite (in_dom_restrto A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.

*****
H3 : eq (in_dom B a m') true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (in_dom B a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true),\neq (in_dom D a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb (in_dom C a m'') (in_dom D a m''')) true
+++++
rewrite (H _ H2).
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrto.
rewrite (in_dom_restrto A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).

*****
H3 : eq (in_dom B a m') true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (in_dom B a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true),\neq (in_dom D a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb true (in_dom D a m''')) true
+++++
rewrite (H0 _ H3).
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrto.
rewrite (in_dom_restrto A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).
rewrite (H0 _ H3).

*****
H3 : eq (in_dom B a m') true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (in_dom B a m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true),\neq (in_dom D a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb true true) true
+++++
reflexivity.
-----
Lemma MapSubset_DomRestrTo_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m' m''' -> MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrto.
rewrite (in_dom_restrto A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).
rewrite (H0 _ H3).
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_DomRestrBy_l :\n   forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.
-----
Lemma MapSubset_DomRestrBy_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.

*****
C,D : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B), MapSubset A A (MapDomRestrBy A B m m') m
+++++
Proof.
-----
Lemma MapSubset_DomRestrBy_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.
Proof.

*****
C,D : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B), MapSubset A A (MapDomRestrBy A B m m') m
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_DomRestrBy_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.
Proof.
unfold MapSubset in |- *.

*****
C,D : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (a : ad) (_ : eq (in_dom A a (MapDomRestrBy A B m m')) true), eq (in_dom A a m) true
+++++
intros.
-----
Lemma MapSubset_DomRestrBy_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.
Proof.
unfold MapSubset in |- *.
intros.

*****
H : eq (in_dom A a (MapDomRestrBy A B m m')) true
a : ad
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (in_dom A a m) true
+++++
rewrite (in_dom_restrby _ _ m m' a) in H.
-----
Lemma MapSubset_DomRestrBy_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.
Proof.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_restrby _ _ m m' a) in H.

*****
H : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (in_dom A a m) true
+++++
elim (andb_prop _ _ H).
-----
Lemma MapSubset_DomRestrBy_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.
Proof.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_restrby _ _ m m' a) in H.
elim (andb_prop _ _ H).

*****
H : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
forall (_ : eq (in_dom A a m) true) (_ : eq (negb (in_dom B a m')) true), eq (in_dom A a m) true
+++++
trivial.
-----
Lemma MapSubset_DomRestrBy_l : forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.
Proof.
unfold MapSubset in |- *.
intros.
rewrite (in_dom_restrby _ _ m m' a) in H.
elim (andb_prop _ _ H).
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_DomRestrBy_mono :\n   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),\n     MapSubset _ _ m m'' ->\n     MapSubset _ _ m''' m' ->\n     MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').

*****
C,D : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : MapSubset A C m m'') (_ : MapSubset D B m''' m'), MapSubset A C (MapDomRestrBy A B m m') (MapDomRestrBy C D m'' m''')
+++++
Proof.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.

*****
C,D : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : MapSubset A C m m'') (_ : MapSubset D B m''' m'), MapSubset A C (MapDomRestrBy A B m m') (MapDomRestrBy C D m'' m''')
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.

*****
C,D : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true) (_ : forall (a : ad) (_ : eq (in_dom D a m''') true), eq (in_dom B a m') true) (a : ad) (_ : eq (in_dom A a (MapDomRestrBy A B m m')) true), eq (in_dom C a (MapDomRestrBy C D m'' m''')) true
+++++
intros.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.

*****
H1 : eq (in_dom A a (MapDomRestrBy A B m m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (in_dom C a (MapDomRestrBy C D m'' m''')) true
+++++
rewrite in_dom_restrby.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.

*****
H1 : eq (in_dom A a (MapDomRestrBy A B m m')) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb (in_dom C a m'') (negb (in_dom D a m'''))) true
+++++
rewrite (in_dom_restrby A B m m' a) in H1.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.

*****
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb (in_dom C a m'') (negb (in_dom D a m'''))) true
+++++
elim (andb_prop _ _ H1).
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).

*****
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
forall (_ : eq (in_dom A a m) true) (_ : eq (negb (in_dom B a m')) true), eq (andb (in_dom C a m'') (negb (in_dom D a m'''))) true
+++++
intros.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.

*****
H3 : eq (negb (in_dom B a m')) true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb (in_dom C a m'') (negb (in_dom D a m'''))) true
+++++
rewrite (H _ H2).
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).

*****
H3 : eq (negb (in_dom B a m')) true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb true (negb (in_dom D a m'''))) true
+++++
elim (sumbool_of_bool (in_dom D a m''')).
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).
elim (sumbool_of_bool (in_dom D a m''')).

*****
H3 : eq (negb (in_dom B a m')) true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
forall _ : eq (in_dom D a m''') true, eq (andb true (negb (in_dom D a m'''))) true
+++++
intro H4.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).
elim (sumbool_of_bool (in_dom D a m''')).
intro H4.

*****
H4 : eq (in_dom D a m''') true
H3 : eq (negb (in_dom B a m')) true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb true (negb (in_dom D a m'''))) true
+++++
rewrite (H0 _ H4) in H3.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).
elim (sumbool_of_bool (in_dom D a m''')).
intro H4.
rewrite (H0 _ H4) in H3.

*****
H4 : eq (in_dom D a m''') true
H3 : eq (negb true) true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb true (negb (in_dom D a m'''))) true
+++++
discriminate H3.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).
elim (sumbool_of_bool (in_dom D a m''')).

*****
H3 : eq (negb (in_dom B a m')) true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
forall _ : eq (in_dom D a m''') false, eq (andb true (negb (in_dom D a m'''))) true
+++++
intro H4.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).
elim (sumbool_of_bool (in_dom D a m''')).
intro H4.

*****
H4 : eq (in_dom D a m''') false
H3 : eq (negb (in_dom B a m')) true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb true (negb (in_dom D a m'''))) true
+++++
rewrite H4.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).
elim (sumbool_of_bool (in_dom D a m''')).
intro H4.
rewrite H4.

*****
H4 : eq (in_dom D a m''') false
H3 : eq (negb (in_dom B a m')) true
H2 : eq (in_dom A a m) true
H1 : eq (andb (in_dom A a m) (negb (in_dom B a m'))) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom D a m''') true),\neq (in_dom B a m') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom C a m'') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
C,D : Type
A,B : Type
*****
eq (andb true (negb false)) true
+++++
reflexivity.
-----
Lemma MapSubset_DomRestrBy_mono : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m'' -> MapSubset _ _ m''' m' -> MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
Proof.
unfold MapSubset in |- *.
intros.
rewrite in_dom_restrby.
rewrite (in_dom_restrby A B m m' a) in H1.
elim (andb_prop _ _ H1).
intros.
rewrite (H _ H2).
elim (sumbool_of_bool (in_dom D a m''')).

*****

*****

+++++
Qed.
-----
End MapSubsetExtra.
-----
Section MapDisjointDef.
-----
Variables A B : Type.
-----
Definition MapDisjoint (m:Map A) (m':Map B) :=\n    forall a:ad, in_dom A a m = true -> in_dom B a m' = true -> False.
-----
Definition MapDisjoint_1 (m:Map A) (m':Map B) :=\n    match MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m with\n    | None => true\n    | _ => false\n    end.
-----
Definition MapDisjoint_2 (m:Map A) (m':Map B) :=\n    eqmap A (MapDomRestrTo A B m m') (M0 A).
-----
Lemma MapDisjoint_imp_1 :\n   forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapDisjoint m m'), eq (MapDisjoint_1 m m') true
+++++
Proof.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapDisjoint m m'), eq (MapDisjoint_1 m m') true
+++++
unfold MapDisjoint.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False), eq (MapDisjoint_1 m m') true
+++++
unfold MapDisjoint_1 in |- *.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False), eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
intros.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.

*****
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).

*****
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y)), eq match MapSweep A (fun (a0 : ad) (_ : A) => in_dom B a0 m') m with | Some _ => false | None => true end true
+++++
intro H0.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.

*****
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
elim H0.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.

*****
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some x)), eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
intro r.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.
intro r.

*****
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some r), eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
elim r.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.
intro r.
elim r.

*****
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall (a : ad) (b : A) (_ : eq (MapSweep A (fun (a0 : ad) (_ : A) => in_dom B a0 m') m) (Some (pair a b))), eq match MapSweep A (fun (a0 : ad) (_ : A) => in_dom B a0 m') m with | Some _ => false | None => true end true
+++++
intros a y H1.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.

*****
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (in_dom A a m = true -> in_dom B a m' = true -> False).

*****
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False, eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
intro.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.

*****
H2 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
unfold in_dom at 1 in H2.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
unfold in_dom at 1 in H2.

*****
H2 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq (in_dom B a m') true), False
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
rewrite (MapSweep_semantics_2 _ _ _ _ _ H1) in H2.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
unfold in_dom at 1 in H2.
rewrite (MapSweep_semantics_2 _ _ _ _ _ H1) in H2.

*****
H2 : forall (_ : eq true true) (_ : eq (in_dom B a m') true), False
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
rewrite (MapSweep_semantics_1 _ _ _ _ _ H1) in H2.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
unfold in_dom at 1 in H2.
rewrite (MapSweep_semantics_2 _ _ _ _ _ H1) in H2.
rewrite (MapSweep_semantics_1 _ _ _ _ _ H1) in H2.

*****
H2 : forall (_ : eq true true) (_ : eq true true), False
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
elim (H2 (refl_equal _) (refl_equal _)).
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
elim H0.
intro r.
elim r.
intros a y H1.
cut (in_dom A a m = true -> in_dom B a m' = true -> False).

*****
H1 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m)\n (Some (pair a y))
y : A
a : ad
r : prod ad A
H0 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False
+++++
exact (H a).
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).

*****
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None, eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
intro H0.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.

*****
H0 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true
+++++
rewrite H0.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H0.
rewrite H0.

*****
H0 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapDisjoint_imp_1 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_1_imp :\n   forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq (MapDisjoint_1 m m') true), MapDisjoint m m'
+++++
Proof.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq (MapDisjoint_1 m m') true), MapDisjoint m m'
+++++
unfold MapDisjoint.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq (MapDisjoint_1 m m') true) (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False
+++++
unfold MapDisjoint_1 in |- *.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eq match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with | Some _ => false | None => true end true) (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False
+++++
intros.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.

*****
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).

*****
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y)), False
+++++
intro H2.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.

*****
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
elim H2.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
elim H2.

*****
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some x)), False
+++++
intro r.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
elim H2.
intro r.

*****
r : prod ad A
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some r), False
+++++
elim r.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
elim H2.
intro r.
elim r.

*****
r : prod ad A
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall (a : ad) (b : A) (_ : eq (MapSweep A (fun (a0 : ad) (_ : A) => in_dom B a0 m') m) (Some (pair a b))), False
+++++
intros a' y' H3.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
elim H2.
intro r.
elim r.
intros a' y' H3.

*****
H3 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m)\n (Some (pair a' y'))
y' : A
a' : ad
r : prod ad A
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
rewrite H3 in H.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
elim H2.
intro r.
elim r.
intros a' y' H3.
rewrite H3 in H.

*****
H3 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m)\n (Some (pair a' y'))
y' : A
a' : ad
r : prod ad A
H2 : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) (Some y))
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq false true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
discriminate H.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).

*****
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None, False
+++++
intro H2.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.

*****
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
unfold in_dom in H0.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
unfold in_dom in H0.

*****
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq (in_dom B a m') true
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
elim (option_sum _ (MapGet A m a)).
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).

*****
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq (in_dom B a m') true
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m a) (Some y)), False
+++++
intro H3.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H3.

*****
H3 : sig (fun y : A => eq (MapGet A m a) (Some y))
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq (in_dom B a m') true
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
elim H3.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H3.
elim H3.

*****
H3 : sig (fun y : A => eq (MapGet A m a) (Some y))
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq (in_dom B a m') true
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), False
+++++
intros y H4.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H3.
elim H3.
intros y H4.

*****
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : sig (fun y : A => eq (MapGet A m a) (Some y))
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq (in_dom B a m') true
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
rewrite (MapSweep_semantics_3 _ _ _ H2 a y H4) in H1.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H3.
elim H3.
intros y H4.
rewrite (MapSweep_semantics_3 _ _ _ H2 a y H4) in H1.

*****
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : sig (fun y : A => eq (MapGet A m a) (Some y))
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq false true
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
discriminate H1.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).

*****
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq (in_dom B a m') true
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapGet A m a) None, False
+++++
intro H3.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H3.

*****
H3 : eq (MapGet A m a) None
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq (in_dom B a m') true
H0 : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
rewrite H3 in H0.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).
intro H2.
unfold in_dom in H0.
elim (option_sum _ (MapGet A m a)).
intro H3.
rewrite H3 in H0.

*****
H3 : eq (MapGet A m a) None
H2 : eq (MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m) None
H1 : eq (in_dom B a m') true
H0 : eq false true
a : ad
H : eq\n match MapSweep A (fun (a : ad) (_ : A) => in_dom B a m') m with\n | Some _ => false\n | None => true\n end true
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
discriminate H0.
-----
Lemma MapDisjoint_1_imp : forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_1 in |- *.
intros.
elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_imp_2 :\n   forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapDisjoint m m'), MapDisjoint_2 m m'
+++++
Proof.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapDisjoint m m'), MapDisjoint_2 m m'
+++++
unfold MapDisjoint.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False), MapDisjoint_2 m m'
+++++
unfold MapDisjoint_2 in |- *.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False), eqmap A (MapDomRestrTo A B m m') (M0 A)
+++++
unfold eqmap in |- *.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False), eqm A (MapGet A (MapDomRestrTo A B m m')) (MapGet A (M0 A))
+++++
unfold eqm in |- *.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False) (a : ad), eq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
+++++
intros.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
+++++
rewrite (MapDomRestrTo_semantics A B m m' a).
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False, eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
intro.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.

*****
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
elim (option_sum _ (MapGet A m a)).
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).

*****
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m a) (Some y)), eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
intro H1.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.

*****
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
elim H1.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.

*****
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
intros y H2.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
unfold in_dom at 1 in H0.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq (in_dom B a m') true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
elim (option_sum _ (MapGet B m' a)).
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq (in_dom B a m') true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : sig (fun y : B => eq (MapGet B m' a) (Some y)), eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
intro H3.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).
intro H3.

*****
H3 : sig (fun y : B => eq (MapGet B m' a) (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq (in_dom B a m') true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
elim H3.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).
intro H3.
elim H3.

*****
H3 : sig (fun y : B => eq (MapGet B m' a) (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq (in_dom B a m') true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m' a) (Some x)), eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
intros y' H4.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).
intro H3.
elim H3.
intros y' H4.

*****
H4 : eq (MapGet B m' a) (Some y')
y' : B
H3 : sig (fun y : B => eq (MapGet B m' a) (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq (in_dom B a m') true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
unfold in_dom at 1 in H0.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).
intro H3.
elim H3.
intros y' H4.
unfold in_dom at 1 in H0.

*****
H4 : eq (MapGet B m' a) (Some y')
y' : B
H3 : sig (fun y : B => eq (MapGet B m' a) (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m' a with\n | Some _ => true\n | None => false\n end true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
rewrite H4 in H0.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).
intro H3.
elim H3.
intros y' H4.
unfold in_dom at 1 in H0.
rewrite H4 in H0.

*****
H4 : eq (MapGet B m' a) (Some y')
y' : B
H3 : sig (fun y : B => eq (MapGet B m' a) (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq true true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
rewrite H2 in H0.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).
intro H3.
elim H3.
intros y' H4.
unfold in_dom at 1 in H0.
rewrite H4 in H0.
rewrite H2 in H0.

*****
H4 : eq (MapGet B m' a) (Some y')
y' : B
H3 : sig (fun y : B => eq (MapGet B m' a) (Some y))
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall (_ : eq true true) (_ : eq true true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
elim (H0 (refl_equal _) (refl_equal _)).
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq (in_dom B a m') true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapGet B m' a) None, eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
intro H3.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).
intro H3.

*****
H3 : eq (MapGet B m' a) None
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq (in_dom B a m') true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
rewrite H3.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
elim H1.
intros y H2.
unfold in_dom at 1 in H0.
elim (option_sum _ (MapGet B m' a)).
intro H3.
rewrite H3.

*****
H3 : eq (MapGet B m' a) None
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : sig (fun y : A => eq (MapGet A m a) (Some y))
H0 : forall\n (_ : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true) (_ : eq (in_dom B a m') true), False
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq None (MapGet A (M0 A) a)
+++++
reflexivity.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).

*****
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapGet A m a) None, eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
intro H1.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.

*****
H1 : eq (MapGet A m a) None
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ => MapGet A m a | None => None end (MapGet A (M0 A) a)
+++++
rewrite H1.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
rewrite H1.

*****
H1 : eq (MapGet A m a) None
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq match MapGet B m' a with | Some _ | _ => None end (MapGet A (M0 A) a)
+++++
case (MapGet B m' a).
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
rewrite H1.
case (MapGet B m' a).

*****
H1 : eq (MapGet A m a) None
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall _ : B, eq None (MapGet A (M0 A) a)
+++++
reflexivity.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).
intro.
elim (option_sum _ (MapGet A m a)).
intro H1.
rewrite H1.
case (MapGet B m' a).

*****
H1 : eq (MapGet A m a) None
H0 : forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true),\nFalse
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
eq None (MapGet A (M0 A) a)
+++++
reflexivity.
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False
+++++
exact (H a).
-----
Lemma MapDisjoint_imp_2 : forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite (MapDomRestrTo_semantics A B m m' a).
cut (in_dom A a m = true -> in_dom B a m' = true -> False).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_2_imp :\n   forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapDisjoint_2 m m'), MapDisjoint m m'
+++++
Proof.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapDisjoint_2 m m'), MapDisjoint m m'
+++++
unfold MapDisjoint.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapDisjoint_2 m m') (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False
+++++
unfold MapDisjoint_2 in |- *.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eqmap A (MapDomRestrTo A B m m') (M0 A)) (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False
+++++
unfold eqmap in |- *.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : eqm A (MapGet A (MapDomRestrTo A B m m')) (MapGet A (M0 A))) (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False
+++++
unfold eqm in |- *.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall a : ad, eq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)) (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False
+++++
intros.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.

*****
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
elim (in_dom_some _ _ _ H0).
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).

*****
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), False
+++++
intros y H2.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
elim (in_dom_some _ _ _ H1).
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.
elim (in_dom_some _ _ _ H1).

*****
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m' a) (Some x)), False
+++++
intros y' H3.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.
elim (in_dom_some _ _ _ H1).
intros y' H3.

*****
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
cut (MapGet A (MapDomRestrTo A B m m') a = None).
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.
elim (in_dom_some _ _ _ H1).
intros y' H3.
cut (MapGet A (MapDomRestrTo A B m m') a = None).

*****
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapGet A (MapDomRestrTo A B m m') a) None, False
+++++
intro.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.
elim (in_dom_some _ _ _ H1).
intros y' H3.
cut (MapGet A (MapDomRestrTo A B m m') a = None).
intro.

*****
H4 : eq (MapGet A (MapDomRestrTo A B m m') a) None
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
rewrite (MapDomRestrTo_semantics _ _ m m' a) in H4.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.
elim (in_dom_some _ _ _ H1).
intros y' H3.
cut (MapGet A (MapDomRestrTo A B m m') a = None).
intro.
rewrite (MapDomRestrTo_semantics _ _ m m' a) in H4.

*****
H4 : eq match MapGet B m' a with\n | Some _ => MapGet A m a\n | None => None\n end None
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
rewrite H3 in H4.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.
elim (in_dom_some _ _ _ H1).
intros y' H3.
cut (MapGet A (MapDomRestrTo A B m m') a = None).
intro.
rewrite (MapDomRestrTo_semantics _ _ m m' a) in H4.
rewrite H3 in H4.

*****
H4 : eq (MapGet A m a) None
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
rewrite H2 in H4.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.
elim (in_dom_some _ _ _ H1).
intros y' H3.
cut (MapGet A (MapDomRestrTo A B m m') a = None).
intro.
rewrite (MapDomRestrTo_semantics _ _ m m' a) in H4.
rewrite H3 in H4.
rewrite H2 in H4.

*****
H4 : eq (Some y) None
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
discriminate H4.
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.
elim (in_dom_some _ _ _ H1).
intros y' H3.
cut (MapGet A (MapDomRestrTo A B m m') a = None).

*****
H3 : eq (MapGet B m' a) (Some y')
y' : B
H2 : eq (MapGet A m a) (Some y)
y : A
H1 : eq (in_dom B a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall a : ad,\neq (MapGet A (MapDomRestrTo A B m m') a) (MapGet A (M0 A) a)
m' : Map B
m : Map A
A,B : Type
*****
eq (MapGet A (MapDomRestrTo A B m m') a) None
+++++
exact (H a).
-----
Lemma MapDisjoint_2_imp : forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.
Proof.
unfold MapDisjoint.
unfold MapDisjoint_2 in |- *.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (in_dom_some _ _ _ H0).
intros y H2.
elim (in_dom_some _ _ _ H1).
intros y' H3.
cut (MapGet A (MapDomRestrTo A B m m') a = None).

*****

*****

+++++
Qed.
-----
Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.
-----
Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.

*****
A,B : Type
*****
forall m : Map B, MapDisjoint (M0 A) m
+++++
Proof.
-----
Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.
Proof.

*****
A,B : Type
*****
forall m : Map B, MapDisjoint (M0 A) m
+++++
unfold MapDisjoint.
-----
Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.
Proof.
unfold MapDisjoint.

*****
A,B : Type
*****
forall (m : Map B) (a : ad) (_ : eq (in_dom A a (M0 A)) true) (_ : eq (in_dom B a m) true), False
+++++
unfold in_dom in |- *.
-----
Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map B) (a : ad) (_ : eq match MapGet A (M0 A) a with | Some _ => true | None => false end true) (_ : eq match MapGet B m a with | Some _ => true | None => false end true), False
+++++
intros.
-----
Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.

*****
H0 : eq match MapGet B m a with\n | Some _ => true\n | None => false\n end true
H : eq match MapGet A (M0 A) a with\n | Some _ => true\n | None => false\n end true
a : ad
m : Map B
A,B : Type
*****
False
+++++
discriminate H.
-----
Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
discriminate H.

*****

*****

+++++
Qed.
-----
Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).
-----
Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).

*****
A,B : Type
*****
forall m : Map A, MapDisjoint m (M0 B)
+++++
Proof.
-----
Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).
Proof.

*****
A,B : Type
*****
forall m : Map A, MapDisjoint m (M0 B)
+++++
unfold MapDisjoint.
-----
Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).
Proof.
unfold MapDisjoint.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a (M0 B)) true), False
+++++
unfold in_dom in |- *.
-----
Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq match MapGet A m a with | Some _ => true | None => false end true) (_ : eq match MapGet B (M0 B) a with | Some _ => true | None => false end true), False
+++++
intros.
-----
Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.

*****
H0 : eq match MapGet B (M0 B) a with\n | Some _ => true\n | None => false\n end true
H : eq match MapGet A m a with\n | Some _ => true\n | None => false\n end true
a : ad
m : Map A
A,B : Type
*****
False
+++++
discriminate H0.
-----
Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
discriminate H0.

*****

*****

+++++
Qed.
-----
End MapDisjointDef.
-----
Section MapDisjointExtra.
-----
Variables A B : Type.
-----
Lemma MapDisjoint_ext :\n   forall (m0 m1:Map A) (m2 m3:Map B),\n     eqmap A m0 m1 ->\n     eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : eqmap A m0 m1) (_ : eqmap B m2 m3) (_ : MapDisjoint A B m0 m2), MapDisjoint A B m1 m3
+++++
Proof.
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : eqmap A m0 m1) (_ : eqmap B m2 m3) (_ : MapDisjoint A B m0 m2), MapDisjoint A B m1 m3
+++++
intros.
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.
intros.

*****
H1 : MapDisjoint A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
MapDisjoint A B m1 m3
+++++
apply MapDisjoint_2_imp.
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.
intros.
apply MapDisjoint_2_imp.

*****
H1 : MapDisjoint A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
MapDisjoint_2 A B m1 m3
+++++
unfold MapDisjoint_2 in |- *.
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.
intros.
apply MapDisjoint_2_imp.
unfold MapDisjoint_2 in |- *.

*****
H1 : MapDisjoint A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A (MapDomRestrTo A B m1 m3) (M0 A)
+++++
apply eqmap_trans with (m' := MapDomRestrTo A B m0 m2).
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.
intros.
apply MapDisjoint_2_imp.
unfold MapDisjoint_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrTo A B m0 m2).

*****
H1 : MapDisjoint A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A (MapDomRestrTo A B m1 m3) (MapDomRestrTo A B m0 m2)
+++++
apply eqmap_sym.
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.
intros.
apply MapDisjoint_2_imp.
unfold MapDisjoint_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrTo A B m0 m2).
apply eqmap_sym.

*****
H1 : MapDisjoint A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A (MapDomRestrTo A B m0 m2) (MapDomRestrTo A B m1 m3)
+++++
apply MapDomRestrTo_ext.
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.
intros.
apply MapDisjoint_2_imp.
unfold MapDisjoint_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrTo A B m0 m2).
apply eqmap_sym.
apply MapDomRestrTo_ext.

*****
H1 : MapDisjoint A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A m0 m1
+++++
assumption.
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.
intros.
apply MapDisjoint_2_imp.
unfold MapDisjoint_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrTo A B m0 m2).
apply eqmap_sym.
apply MapDomRestrTo_ext.

*****
H1 : MapDisjoint A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap B m2 m3
+++++
assumption.
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.
intros.
apply MapDisjoint_2_imp.
unfold MapDisjoint_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrTo A B m0 m2).

*****
H1 : MapDisjoint A B m0 m2
H0 : eqmap B m2 m3
H : eqmap A m0 m1
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eqmap A (MapDomRestrTo A B m0 m2) (M0 A)
+++++
exact (MapDisjoint_imp_2 _ _ _ _ H1).
-----
Lemma MapDisjoint_ext : forall (m0 m1:Map A) (m2 m3:Map B), eqmap A m0 m1 -> eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.
Proof.
intros.
apply MapDisjoint_2_imp.
unfold MapDisjoint_2 in |- *.
apply eqmap_trans with (m' := MapDomRestrTo A B m0 m2).

*****

*****

+++++
Qed.
-----
Lemma MapMerge_disjoint :\n   forall m m':Map A,\n     MapDisjoint A A m m' ->\n     forall a:ad,\n       in_dom A a (MapMerge A m m') =\n       orb (andb (in_dom A a m) (negb (in_dom A a m')))\n         (andb (in_dom A a m') (negb (in_dom A a m))).
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).

*****
A,B : Type
*****
forall (m m' : Map A) (_ : MapDisjoint A A m m') (a : ad), eq (in_dom A a (MapMerge A m m')) (orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))))
+++++
Proof.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : MapDisjoint A A m m') (a : ad), eq (in_dom A a (MapMerge A m m')) (orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))))
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : forall (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom A a m') true), False) (a : ad), eq (in_dom A a (MapMerge A m m')) (orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))))
+++++
intros.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (in_dom A a (MapMerge A m m')) (orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))))
+++++
rewrite in_dom_merge.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom A a m) (in_dom A a m')) (orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))))
+++++
elim (sumbool_of_bool (in_dom A a m)).
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) true, eq (orb (in_dom A a m) (in_dom A a m')) (orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))))
+++++
intro H0.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.

*****
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom A a m) (in_dom A a m')) (orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))))
+++++
rewrite H0.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.

*****
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (orb true (in_dom A a m')) (orb (andb true (negb (in_dom A a m'))) (andb (in_dom A a m') (negb true)))
+++++
elim (sumbool_of_bool (in_dom A a m')).
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (in_dom A a m')).

*****
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m') true, eq (orb true (in_dom A a m')) (orb (andb true (negb (in_dom A a m'))) (andb (in_dom A a m') (negb true)))
+++++
intro H1.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (in_dom A a m')).
intro H1.

*****
H1 : eq (in_dom A a m') true
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (orb true (in_dom A a m')) (orb (andb true (negb (in_dom A a m'))) (andb (in_dom A a m') (negb true)))
+++++
elim (H a H0 H1).
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (in_dom A a m')).

*****
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m') false, eq (orb true (in_dom A a m')) (orb (andb true (negb (in_dom A a m'))) (andb (in_dom A a m') (negb true)))
+++++
intro H1.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (in_dom A a m')).
intro H1.

*****
H1 : eq (in_dom A a m') false
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (orb true (in_dom A a m')) (orb (andb true (negb (in_dom A a m'))) (andb (in_dom A a m') (negb true)))
+++++
rewrite H1.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.
elim (sumbool_of_bool (in_dom A a m')).
intro H1.
rewrite H1.

*****
H1 : eq (in_dom A a m') false
H0 : eq (in_dom A a m) true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (orb true false) (orb (andb true (negb false)) (andb false (negb true)))
+++++
reflexivity.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).

*****
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) false, eq (orb (in_dom A a m) (in_dom A a m')) (orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))))
+++++
intro H0.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.

*****
H0 : eq (in_dom A a m) false
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (orb (in_dom A a m) (in_dom A a m')) (orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))))
+++++
rewrite H0.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.

*****
H0 : eq (in_dom A a m) false
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (orb false (in_dom A a m')) (orb (andb false (negb (in_dom A a m'))) (andb (in_dom A a m') (negb false)))
+++++
simpl in |- *.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.
simpl in |- *.

*****
H0 : eq (in_dom A a m) false
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (in_dom A a m') (andb (in_dom A a m') true)
+++++
rewrite andb_b_true.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite andb_b_true.

*****
H0 : eq (in_dom A a m) false
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom A a m') true), False
m,m' : Map A
A,B : Type
*****
eq (in_dom A a m') (in_dom A a m')
+++++
reflexivity.
-----
Lemma MapMerge_disjoint : forall m m':Map A, MapDisjoint A A m m' -> forall a:ad, in_dom A a (MapMerge A m m') = orb (andb (in_dom A a m) (negb (in_dom A a m'))) (andb (in_dom A a m') (negb (in_dom A a m))).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite in_dom_merge.
elim (sumbool_of_bool (in_dom A a m)).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_M2_l :\n   forall (m0 m1:Map A) (m2 m3:Map B),\n     MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3)), MapDisjoint A B m0 m2
+++++
Proof.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3)), MapDisjoint A B m0 m2
+++++
unfold MapDisjoint.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a (M2 A m0 m1)) true) (_ : eq (in_dom B a (M2 B m2 m3)) true), False) (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom B a m2) true), False
+++++
unfold in_dom in |- *.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : forall (a : ad) (_ : eq match MapGet A (M2 A m0 m1) a with | Some _ => true | None => false end true) (_ : eq match MapGet B (M2 B m2 m3) a with | Some _ => true | None => false end true), False) (a : ad) (_ : eq match MapGet A m0 a with | Some _ => true | None => false end true) (_ : eq match MapGet B m2 a with | Some _ => true | None => false end true), False
+++++
intros.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.

*****
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
elim (option_sum _ (MapGet A m0 a)).
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).

*****
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m0 a) (Some y)), False
+++++
intro H2.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.

*****
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
elim H2.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.

*****
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m0 a) (Some x)), False
+++++
intros y H3.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.

*****
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
elim (option_sum _ (MapGet B m2 a)).
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).

*****
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : sig (fun y : B => eq (MapGet B m2 a) (Some y)), False
+++++
intro H4.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.

*****
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
elim H4.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.

*****
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m2 a) (Some x)), False
+++++
intros y' H5.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.
intros y' H5.

*****
H5 : eq (MapGet B m2 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
apply (H (Ndouble a)).
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble a)).

*****
H5 : eq (MapGet B m2 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet A (M2 A m0 m1) (N.double a) with | Some _ => true | None => false end true
+++++
rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m0 m1).
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble a)).
rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m0 m1).

*****
H5 : eq (MapGet B m2 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet A m0 (N.div2 (N.double a)) with | Some _ => true | None => false end true
+++++
rewrite (Ndouble_div2 a).
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble a)).
rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m0 m1).
rewrite (Ndouble_div2 a).

*****
H5 : eq (MapGet B m2 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet A m0 a with | Some _ => true | None => false end true
+++++
rewrite H3.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble a)).
rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m0 m1).
rewrite (Ndouble_div2 a).
rewrite H3.

*****
H5 : eq (MapGet B m2 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble a)).

*****
H5 : eq (MapGet B m2 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet B (M2 B m2 m3) (N.double a) with | Some _ => true | None => false end true
+++++
rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m2 m3).
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble a)).
rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m2 m3).

*****
H5 : eq (MapGet B m2 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet B m2 (N.div2 (N.double a)) with | Some _ => true | None => false end true
+++++
rewrite (Ndouble_div2 a).
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble a)).
rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m2 m3).
rewrite (Ndouble_div2 a).

*****
H5 : eq (MapGet B m2 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet B m2 a with | Some _ => true | None => false end true
+++++
rewrite H5.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble a)).
rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m2 m3).
rewrite (Ndouble_div2 a).
rewrite H5.

*****
H5 : eq (MapGet B m2 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m2 a) (Some y))
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).

*****
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : eq (MapGet B m2 a) None, False
+++++
intro H4.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.

*****
H4 : eq (MapGet B m2 a) None
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
rewrite H4 in H1.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m2 a)).
intro H4.
rewrite H4 in H1.

*****
H4 : eq (MapGet B m2 a) None
H3 : eq (MapGet A m0 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
H1 : eq false true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
discriminate H1.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).

*****
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : eq (MapGet A m0 a) None, False
+++++
intro H2.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.

*****
H2 : eq (MapGet A m0 a) None
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
rewrite H2 in H0.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).
intro H2.
rewrite H2 in H0.

*****
H2 : eq (MapGet A m0 a) None
H1 : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true
H0 : eq false true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
discriminate H0.
-----
Lemma MapDisjoint_M2_l : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m0 a)).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_M2_r :\n   forall (m0 m1:Map A) (m2 m3:Map B),\n     MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3)), MapDisjoint A B m1 m3
+++++
Proof.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3)), MapDisjoint A B m1 m3
+++++
unfold MapDisjoint.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a (M2 A m0 m1)) true) (_ : eq (in_dom B a (M2 B m2 m3)) true), False) (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom B a m3) true), False
+++++
unfold in_dom in |- *.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : forall (a : ad) (_ : eq match MapGet A (M2 A m0 m1) a with | Some _ => true | None => false end true) (_ : eq match MapGet B (M2 B m2 m3) a with | Some _ => true | None => false end true), False) (a : ad) (_ : eq match MapGet A m1 a with | Some _ => true | None => false end true) (_ : eq match MapGet B m3 a with | Some _ => true | None => false end true), False
+++++
intros.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.

*****
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
elim (option_sum _ (MapGet A m1 a)).
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).

*****
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m1 a) (Some y)), False
+++++
intro H2.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.

*****
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
elim H2.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.

*****
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m1 a) (Some x)), False
+++++
intros y H3.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.

*****
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
elim (option_sum _ (MapGet B m3 a)).
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).

*****
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : sig (fun y : B => eq (MapGet B m3 a) (Some y)), False
+++++
intro H4.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.

*****
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
elim H4.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.

*****
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m3 a) (Some x)), False
+++++
intros y' H5.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.
intros y' H5.

*****
H5 : eq (MapGet B m3 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
apply (H (Ndouble_plus_one a)).
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble_plus_one a)).

*****
H5 : eq (MapGet B m3 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet A (M2 A m0 m1) (N.succ_double a) with | Some _ => true | None => false end true
+++++
rewrite (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble_plus_one a)).
rewrite (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).

*****
H5 : eq (MapGet B m3 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet A m1 (N.div2 (N.succ_double a)) with | Some _ => true | None => false end true
+++++
rewrite (Ndouble_plus_one_div2 a).
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble_plus_one a)).
rewrite (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).
rewrite (Ndouble_plus_one_div2 a).

*****
H5 : eq (MapGet B m3 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet A m1 a with | Some _ => true | None => false end true
+++++
rewrite H3.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble_plus_one a)).
rewrite (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).
rewrite (Ndouble_plus_one_div2 a).
rewrite H3.

*****
H5 : eq (MapGet B m3 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble_plus_one a)).

*****
H5 : eq (MapGet B m3 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet B (M2 B m2 m3) (N.succ_double a) with | Some _ => true | None => false end true
+++++
rewrite (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m2 m3).
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble_plus_one a)).
rewrite (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m2 m3).

*****
H5 : eq (MapGet B m3 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet B m3 (N.div2 (N.succ_double a)) with | Some _ => true | None => false end true
+++++
rewrite (Ndouble_plus_one_div2 a).
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble_plus_one a)).
rewrite (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m2 m3).
rewrite (Ndouble_plus_one_div2 a).

*****
H5 : eq (MapGet B m3 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq match MapGet B m3 a with | Some _ => true | None => false end true
+++++
rewrite H5.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
elim H4.
intros y' H5.
apply (H (Ndouble_plus_one a)).
rewrite (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m2 m3).
rewrite (Ndouble_plus_one_div2 a).
rewrite H5.

*****
H5 : eq (MapGet B m3 a) (Some y')
y' : B
H4 : sig (fun y : B => eq (MapGet B m3 a) (Some y))
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).

*****
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : eq (MapGet B m3 a) None, False
+++++
intro H4.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.

*****
H4 : eq (MapGet B m3 a) None
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
rewrite H4 in H1.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
elim H2.
intros y H3.
elim (option_sum _ (MapGet B m3 a)).
intro H4.
rewrite H4 in H1.

*****
H4 : eq (MapGet B m3 a) None
H3 : eq (MapGet A m1 a) (Some y)
y : A
H2 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
H1 : eq false true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
discriminate H1.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).

*****
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : eq (MapGet A m1 a) None, False
+++++
intro H2.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.

*****
H2 : eq (MapGet A m1 a) None
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
rewrite H2 in H0.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).
intro H2.
rewrite H2 in H0.

*****
H2 : eq (MapGet A m1 a) None
H1 : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true
H0 : eq false true
a : ad
H : forall (a : ad)\n (_ : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
discriminate H0.
-----
Lemma MapDisjoint_M2_r : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (option_sum _ (MapGet A m1 a)).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_M2 :\n   forall (m0 m1:Map A) (m2 m3:Map B),\n     MapDisjoint A B m0 m2 ->\n     MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : MapDisjoint A B m0 m2) (_ : MapDisjoint A B m1 m3), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3)
+++++
Proof.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : MapDisjoint A B m0 m2) (_ : MapDisjoint A B m1 m3), MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3)
+++++
unfold MapDisjoint.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom B a m2) true), False) (_ : forall (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom B a m3) true), False) (a : ad) (_ : eq (in_dom A a (M2 A m0 m1)) true) (_ : eq (in_dom B a (M2 B m2 m3)) true), False
+++++
unfold in_dom in |- *.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.

*****
A,B : Type
*****
forall (m0 m1 : Map A) (m2 m3 : Map B) (_ : forall (a : ad) (_ : eq match MapGet A m0 a with | Some _ => true | None => false end true) (_ : eq match MapGet B m2 a with | Some _ => true | None => false end true), False) (_ : forall (a : ad) (_ : eq match MapGet A m1 a with | Some _ => true | None => false end true) (_ : eq match MapGet B m3 a with | Some _ => true | None => false end true), False) (a : ad) (_ : eq match MapGet A (M2 A m0 m1) a with | Some _ => true | None => false end true) (_ : eq match MapGet B (M2 B m2 m3) a with | Some _ => true | None => false end true), False
+++++
intros.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.

*****
H2 : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true
H1 : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad)\n (_ : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true), False
H : forall (a : ad)\n (_ : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H2 : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true
H1 : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad)\n (_ : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true), False
H : forall (a : ad)\n (_ : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, False
+++++
intro H3.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.

*****
H3 : eq (N.odd a) true
H2 : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true
H1 : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad)\n (_ : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true), False
H : forall (a : ad)\n (_ : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
rewrite (MapGet_M2_bit_0_1 A a H3 m0 m1) in H1.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 A a H3 m0 m1) in H1.

*****
H3 : eq (N.odd a) true
H2 : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true
H1 : eq\n match MapGet A m1 (N.div2 a) with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad)\n (_ : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true), False
H : forall (a : ad)\n (_ : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
rewrite (MapGet_M2_bit_0_1 B a H3 m2 m3) in H2.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_1 A a H3 m0 m1) in H1.
rewrite (MapGet_M2_bit_0_1 B a H3 m2 m3) in H2.

*****
H3 : eq (N.odd a) true
H2 : eq\n match MapGet B m3 (N.div2 a) with\n | Some _ => true\n | None => false\n end true
H1 : eq\n match MapGet A m1 (N.div2 a) with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad)\n (_ : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true), False
H : forall (a : ad)\n (_ : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
exact (H0 (Ndiv2 a) H1 H2).
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H2 : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true
H1 : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad)\n (_ : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true), False
H : forall (a : ad)\n (_ : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, False
+++++
intro H3.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.

*****
H3 : eq (N.odd a) false
H2 : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true
H1 : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad)\n (_ : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true), False
H : forall (a : ad)\n (_ : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
rewrite (MapGet_M2_bit_0_0 A a H3 m0 m1) in H1.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 A a H3 m0 m1) in H1.

*****
H3 : eq (N.odd a) false
H2 : eq\n match MapGet B (M2 B m2 m3) a with\n | Some _ => true\n | None => false\n end true
H1 : eq\n match MapGet A m0 (N.div2 a) with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad)\n (_ : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true), False
H : forall (a : ad)\n (_ : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
rewrite (MapGet_M2_bit_0_0 B a H3 m2 m3) in H2.
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H3.
rewrite (MapGet_M2_bit_0_0 A a H3 m0 m1) in H1.
rewrite (MapGet_M2_bit_0_0 B a H3 m2 m3) in H2.

*****
H3 : eq (N.odd a) false
H2 : eq\n match MapGet B m2 (N.div2 a) with\n | Some _ => true\n | None => false\n end true
H1 : eq\n match MapGet A m0 (N.div2 a) with\n | Some _ => true\n | None => false\n end true
a : ad
H0 : forall (a : ad)\n (_ : eq match MapGet A m1 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m3 a with\n | Some _ => true\n | None => false\n end true), False
H : forall (a : ad)\n (_ : eq match MapGet A m0 a with\n | Some _ => true\n | None => false\n end true)\n (_ : eq match MapGet B m2 a with\n | Some _ => true\n | None => false\n end true), False
m2,m3 : Map B
m0,m1 : Map A
A,B : Type
*****
False
+++++
exact (H (Ndiv2 a) H1 H2).
-----
Lemma MapDisjoint_M2 : forall (m0 m1:Map A) (m2 m3:Map B), MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).
Proof.
unfold MapDisjoint.
unfold in_dom in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_M1_l :\n   forall (m:Map A) (a:ad) (y:B),\n     MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.
-----
Lemma MapDisjoint_M1_l : forall (m:Map A) (a:ad) (y:B), MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : MapDisjoint B A (M1 B a y) m), eq (in_dom A a m) false
+++++
Proof.
-----
Lemma MapDisjoint_M1_l : forall (m:Map A) (a:ad) (y:B), MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : MapDisjoint B A (M1 B a y) m), eq (in_dom A a m) false
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapDisjoint_M1_l : forall (m:Map A) (a:ad) (y:B), MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : forall (a0 : ad) (_ : eq (in_dom B a0 (M1 B a y)) true) (_ : eq (in_dom A a0 m) true), False), eq (in_dom A a m) false
+++++
intros.
-----
Lemma MapDisjoint_M1_l : forall (m:Map A) (a:ad) (y:B), MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.

*****
H : forall (a0 : ad) (_ : eq (in_dom B a0 (M1 B a y)) true)\n (_ : eq (in_dom A a0 m) true), False
y : B
a : ad
m : Map A
A,B : Type
*****
eq (in_dom A a m) false
+++++
elim (sumbool_of_bool (in_dom A a m)).
-----
Lemma MapDisjoint_M1_l : forall (m:Map A) (a:ad) (y:B), MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (in_dom A a m)).

*****
H : forall (a0 : ad) (_ : eq (in_dom B a0 (M1 B a y)) true)\n (_ : eq (in_dom A a0 m) true), False
y : B
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) true, eq (in_dom A a m) false
+++++
intro H0.
-----
Lemma MapDisjoint_M1_l : forall (m:Map A) (a:ad) (y:B), MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.

*****
H0 : eq (in_dom A a m) true
H : forall (a0 : ad) (_ : eq (in_dom B a0 (M1 B a y)) true)\n (_ : eq (in_dom A a0 m) true), False
y : B
a : ad
m : Map A
A,B : Type
*****
eq (in_dom A a m) false
+++++
elim (H a (in_dom_M1_1 B a y) H0).
-----
Lemma MapDisjoint_M1_l : forall (m:Map A) (a:ad) (y:B), MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (in_dom A a m)).

*****
H : forall (a0 : ad) (_ : eq (in_dom B a0 (M1 B a y)) true)\n (_ : eq (in_dom A a0 m) true), False
y : B
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) false, eq (in_dom A a m) false
+++++
trivial.
-----
Lemma MapDisjoint_M1_l : forall (m:Map A) (a:ad) (y:B), MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (in_dom A a m)).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_M1_r :\n   forall (m:Map A) (a:ad) (y:B),\n     MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.
-----
Lemma MapDisjoint_M1_r : forall (m:Map A) (a:ad) (y:B), MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : MapDisjoint A B m (M1 B a y)), eq (in_dom A a m) false
+++++
Proof.
-----
Lemma MapDisjoint_M1_r : forall (m:Map A) (a:ad) (y:B), MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : MapDisjoint A B m (M1 B a y)), eq (in_dom A a m) false
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapDisjoint_M1_r : forall (m:Map A) (a:ad) (y:B), MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : forall (a0 : ad) (_ : eq (in_dom A a0 m) true) (_ : eq (in_dom B a0 (M1 B a y)) true), False), eq (in_dom A a m) false
+++++
intros.
-----
Lemma MapDisjoint_M1_r : forall (m:Map A) (a:ad) (y:B), MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.

*****
H : forall (a0 : ad) (_ : eq (in_dom A a0 m) true)\n (_ : eq (in_dom B a0 (M1 B a y)) true), False
y : B
a : ad
m : Map A
A,B : Type
*****
eq (in_dom A a m) false
+++++
elim (sumbool_of_bool (in_dom A a m)).
-----
Lemma MapDisjoint_M1_r : forall (m:Map A) (a:ad) (y:B), MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (in_dom A a m)).

*****
H : forall (a0 : ad) (_ : eq (in_dom A a0 m) true)\n (_ : eq (in_dom B a0 (M1 B a y)) true), False
y : B
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) true, eq (in_dom A a m) false
+++++
intro H0.
-----
Lemma MapDisjoint_M1_r : forall (m:Map A) (a:ad) (y:B), MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.

*****
H0 : eq (in_dom A a m) true
H : forall (a0 : ad) (_ : eq (in_dom A a0 m) true)\n (_ : eq (in_dom B a0 (M1 B a y)) true), False
y : B
a : ad
m : Map A
A,B : Type
*****
eq (in_dom A a m) false
+++++
elim (H a H0 (in_dom_M1_1 B a y)).
-----
Lemma MapDisjoint_M1_r : forall (m:Map A) (a:ad) (y:B), MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (in_dom A a m)).

*****
H : forall (a0 : ad) (_ : eq (in_dom A a0 m) true)\n (_ : eq (in_dom B a0 (M1 B a y)) true), False
y : B
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (in_dom A a m) false, eq (in_dom A a m) false
+++++
trivial.
-----
Lemma MapDisjoint_M1_r : forall (m:Map A) (a:ad) (y:B), MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.
Proof.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (in_dom A a m)).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_M1_conv_l :\n   forall (m:Map A) (a:ad) (y:B),\n     in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.
-----
Lemma MapDisjoint_M1_conv_l : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : eq (in_dom A a m) false), MapDisjoint B A (M1 B a y) m
+++++
Proof.
-----
Lemma MapDisjoint_M1_conv_l : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : eq (in_dom A a m) false), MapDisjoint B A (M1 B a y) m
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapDisjoint_M1_conv_l : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.
Proof.
unfold MapDisjoint in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : eq (in_dom A a m) false) (a0 : ad) (_ : eq (in_dom B a0 (M1 B a y)) true) (_ : eq (in_dom A a0 m) true), False
+++++
intros.
-----
Lemma MapDisjoint_M1_conv_l : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.
Proof.
unfold MapDisjoint in |- *.
intros.

*****
H1 : eq (in_dom A a0 m) true
H0 : eq (in_dom B a0 (M1 B a y)) true
a0 : ad
H : eq (in_dom A a m) false
y : B
a : ad
m : Map A
A,B : Type
*****
False
+++++
rewrite (in_dom_M1_2 B a a0 y H0) in H.
-----
Lemma MapDisjoint_M1_conv_l : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite (in_dom_M1_2 B a a0 y H0) in H.

*****
H1 : eq (in_dom A a0 m) true
H0 : eq (in_dom B a0 (M1 B a y)) true
H : eq (in_dom A a0 m) false
a0 : ad
y : B
a : ad
m : Map A
A,B : Type
*****
False
+++++
rewrite H1 in H.
-----
Lemma MapDisjoint_M1_conv_l : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite (in_dom_M1_2 B a a0 y H0) in H.
rewrite H1 in H.

*****
H1 : eq (in_dom A a0 m) true
H0 : eq (in_dom B a0 (M1 B a y)) true
H : eq true false
a0 : ad
y : B
a : ad
m : Map A
A,B : Type
*****
False
+++++
discriminate H.
-----
Lemma MapDisjoint_M1_conv_l : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite (in_dom_M1_2 B a a0 y H0) in H.
rewrite H1 in H.
discriminate H.

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_M1_conv_r :\n   forall (m:Map A) (a:ad) (y:B),\n     in_dom A a m = false -> MapDisjoint A B m (M1 B a y).
-----
Lemma MapDisjoint_M1_conv_r : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint A B m (M1 B a y).

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : eq (in_dom A a m) false), MapDisjoint A B m (M1 B a y)
+++++
Proof.
-----
Lemma MapDisjoint_M1_conv_r : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint A B m (M1 B a y).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : eq (in_dom A a m) false), MapDisjoint A B m (M1 B a y)
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapDisjoint_M1_conv_r : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint A B m (M1 B a y).
Proof.
unfold MapDisjoint in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : B) (_ : eq (in_dom A a m) false) (a0 : ad) (_ : eq (in_dom A a0 m) true) (_ : eq (in_dom B a0 (M1 B a y)) true), False
+++++
intros.
-----
Lemma MapDisjoint_M1_conv_r : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint A B m (M1 B a y).
Proof.
unfold MapDisjoint in |- *.
intros.

*****
H1 : eq (in_dom B a0 (M1 B a y)) true
H0 : eq (in_dom A a0 m) true
a0 : ad
H : eq (in_dom A a m) false
y : B
a : ad
m : Map A
A,B : Type
*****
False
+++++
rewrite (in_dom_M1_2 B a a0 y H1) in H.
-----
Lemma MapDisjoint_M1_conv_r : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint A B m (M1 B a y).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite (in_dom_M1_2 B a a0 y H1) in H.

*****
H1 : eq (in_dom B a0 (M1 B a y)) true
H0 : eq (in_dom A a0 m) true
H : eq (in_dom A a0 m) false
a0 : ad
y : B
a : ad
m : Map A
A,B : Type
*****
False
+++++
rewrite H0 in H.
-----
Lemma MapDisjoint_M1_conv_r : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint A B m (M1 B a y).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite (in_dom_M1_2 B a a0 y H1) in H.
rewrite H0 in H.

*****
H1 : eq (in_dom B a0 (M1 B a y)) true
H0 : eq (in_dom A a0 m) true
H : eq true false
a0 : ad
y : B
a : ad
m : Map A
A,B : Type
*****
False
+++++
discriminate H.
-----
Lemma MapDisjoint_M1_conv_r : forall (m:Map A) (a:ad) (y:B), in_dom A a m = false -> MapDisjoint A B m (M1 B a y).
Proof.
unfold MapDisjoint in |- *.
intros.
rewrite (in_dom_M1_2 B a a0 y H1) in H.
rewrite H0 in H.
discriminate H.

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_sym :\n   forall (m:Map A) (m':Map B), MapDisjoint A B m m' -> MapDisjoint B A m' m.
-----
Lemma MapDisjoint_sym : forall (m:Map A) (m':Map B), MapDisjoint A B m m' -> MapDisjoint B A m' m.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapDisjoint A B m m'), MapDisjoint B A m' m
+++++
Proof.
-----
Lemma MapDisjoint_sym : forall (m:Map A) (m':Map B), MapDisjoint A B m m' -> MapDisjoint B A m' m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapDisjoint A B m m'), MapDisjoint B A m' m
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapDisjoint_sym : forall (m:Map A) (m':Map B), MapDisjoint A B m m' -> MapDisjoint B A m' m.
Proof.
unfold MapDisjoint in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : forall (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom B a m') true), False) (a : ad) (_ : eq (in_dom B a m') true) (_ : eq (in_dom A a m) true), False
+++++
intros.
-----
Lemma MapDisjoint_sym : forall (m:Map A) (m':Map B), MapDisjoint A B m m' -> MapDisjoint B A m' m.
Proof.
unfold MapDisjoint in |- *.
intros.

*****
H1 : eq (in_dom A a m) true
H0 : eq (in_dom B a m') true
a : ad
H : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom B a m') true), False
m' : Map B
m : Map A
A,B : Type
*****
False
+++++
exact (H _ H1 H0).
-----
Lemma MapDisjoint_sym : forall (m:Map A) (m':Map B), MapDisjoint A B m m' -> MapDisjoint B A m' m.
Proof.
unfold MapDisjoint in |- *.
intros.
exact (H _ H1 H0).

*****

*****

+++++
Qed.
-----
Lemma MapDisjoint_empty :\n   forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).
-----
Lemma MapDisjoint_empty : forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).

*****
A,B : Type
*****
forall (m : Map A) (_ : MapDisjoint A A m m), eqmap A m (M0 A)
+++++
Proof.
-----
Lemma MapDisjoint_empty : forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (_ : MapDisjoint A A m m), eqmap A m (M0 A)
+++++
unfold eqmap in |- *.
-----
Lemma MapDisjoint_empty : forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.

*****
A,B : Type
*****
forall (m : Map A) (_ : MapDisjoint A A m m), eqm A (MapGet A m) (MapGet A (M0 A))
+++++
unfold eqm in |- *.
-----
Lemma MapDisjoint_empty : forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.

*****
A,B : Type
*****
forall (m : Map A) (_ : MapDisjoint A A m m) (a : ad), eq (MapGet A m a) (MapGet A (M0 A) a)
+++++
intros.
-----
Lemma MapDisjoint_empty : forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.

*****
a : ad
H : MapDisjoint A A m m
m : Map A
A,B : Type
*****
eq (MapGet A m a) (MapGet A (M0 A) a)
+++++
rewrite <- (MapDomRestrTo_idempotent A m a).
-----
Lemma MapDisjoint_empty : forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (MapDomRestrTo_idempotent A m a).

*****
a : ad
H : MapDisjoint A A m m
m : Map A
A,B : Type
*****
eq (MapGet A (MapDomRestrTo A A m m) a) (MapGet A (M0 A) a)
+++++
exact (MapDisjoint_imp_2 A A m m H a).
-----
Lemma MapDisjoint_empty : forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
rewrite <- (MapDomRestrTo_idempotent A m a).
exact (MapDisjoint_imp_2 A A m m H a).

*****

*****

+++++
Qed.
-----
Lemma MapDelta_disjoint :\n   forall m m':Map A,\n     MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').

*****
A,B : Type
*****
forall (m m' : Map A) (_ : MapDisjoint A A m m'), eqmap A (MapDelta A m m') (MapMerge A m m')
+++++
Proof.
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : MapDisjoint A A m m'), eqmap A (MapDelta A m m') (MapMerge A m m')
+++++
intros.
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
Proof.
intros.

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eqmap A (MapDelta A m m') (MapMerge A m m')
+++++
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
Proof.
intros.
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eqmap A (MapDelta A m m') (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m'))
+++++
apply MapDelta_as_DomRestrBy.
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
Proof.
intros.
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eqmap A (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')) (MapMerge A m m')
+++++
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (M0 A)).
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
Proof.
intros.
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (M0 A)).

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eqmap A (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')) (MapDomRestrBy A A (MapMerge A m m') (M0 A))
+++++
apply MapDomRestrBy_ext.
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
Proof.
intros.
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (M0 A)).
apply MapDomRestrBy_ext.

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eqmap A (MapMerge A m m') (MapMerge A m m')
+++++
apply eqmap_refl.
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
Proof.
intros.
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (M0 A)).
apply MapDomRestrBy_ext.

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eqmap A (MapDomRestrTo A A m m') (M0 A)
+++++
exact (MapDisjoint_imp_2 A A m m' H).
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
Proof.
intros.
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (M0 A)).

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eqmap A (MapDomRestrBy A A (MapMerge A m m') (M0 A)) (MapMerge A m m')
+++++
apply MapDomRestrBy_m_empty.
-----
Lemma MapDelta_disjoint : forall m m':Map A, MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').
Proof.
intros.
apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).

*****

*****

+++++
Qed.
-----
Variable C : Type.
-----
Lemma MapDomRestr_disjoint :\n   forall (m:Map A) (m':Map B) (m'':Map C),\n     MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').

*****
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'')
+++++
Proof.
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.

*****
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'')
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.

*****
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (a : ad) (_ : eq (in_dom A a (MapDomRestrTo A C m m'')) true) (_ : eq (in_dom B a (MapDomRestrBy B C m' m'')) true), False
+++++
intros m m' m'' a.
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.
intros m m' m'' a.

*****
a : ad
m'' : Map C
m' : Map B
m : Map A
C : Type
A,B : Type
*****
forall (_ : eq (in_dom A a (MapDomRestrTo A C m m'')) true) (_ : eq (in_dom B a (MapDomRestrBy B C m' m'')) true), False
+++++
rewrite in_dom_restrto.
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.
intros m m' m'' a.
rewrite in_dom_restrto.

*****
a : ad
m'' : Map C
m' : Map B
m : Map A
C : Type
A,B : Type
*****
forall (_ : eq (andb (in_dom A a m) (in_dom C a m'')) true) (_ : eq (in_dom B a (MapDomRestrBy B C m' m'')) true), False
+++++
rewrite in_dom_restrby.
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.
intros m m' m'' a.
rewrite in_dom_restrto.
rewrite in_dom_restrby.

*****
a : ad
m'' : Map C
m' : Map B
m : Map A
C : Type
A,B : Type
*****
forall (_ : eq (andb (in_dom A a m) (in_dom C a m'')) true) (_ : eq (andb (in_dom B a m') (negb (in_dom C a m''))) true), False
+++++
intros.
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.
intros m m' m'' a.
rewrite in_dom_restrto.
rewrite in_dom_restrby.
intros.

*****
H0 : eq (andb (in_dom B a m') (negb (in_dom C a m''))) true
H : eq (andb (in_dom A a m) (in_dom C a m'')) true
a : ad
m'' : Map C
m' : Map B
m : Map A
C : Type
A,B : Type
*****
False
+++++
elim (andb_prop _ _ H).
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.
intros m m' m'' a.
rewrite in_dom_restrto.
rewrite in_dom_restrby.
intros.
elim (andb_prop _ _ H).

*****
H0 : eq (andb (in_dom B a m') (negb (in_dom C a m''))) true
H : eq (andb (in_dom A a m) (in_dom C a m'')) true
a : ad
m'' : Map C
m' : Map B
m : Map A
C : Type
A,B : Type
*****
forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom C a m'') true), False
+++++
elim (andb_prop _ _ H0).
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.
intros m m' m'' a.
rewrite in_dom_restrto.
rewrite in_dom_restrby.
intros.
elim (andb_prop _ _ H).
elim (andb_prop _ _ H0).

*****
H0 : eq (andb (in_dom B a m') (negb (in_dom C a m''))) true
H : eq (andb (in_dom A a m) (in_dom C a m'')) true
a : ad
m'' : Map C
m' : Map B
m : Map A
C : Type
A,B : Type
*****
forall (_ : eq (in_dom B a m') true) (_ : eq (negb (in_dom C a m'')) true) (_ : eq (in_dom A a m) true) (_ : eq (in_dom C a m'') true), False
+++++
intros.
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.
intros m m' m'' a.
rewrite in_dom_restrto.
rewrite in_dom_restrby.
intros.
elim (andb_prop _ _ H).
elim (andb_prop _ _ H0).
intros.

*****
H4 : eq (in_dom C a m'') true
H3 : eq (in_dom A a m) true
H2 : eq (negb (in_dom C a m'')) true
H1 : eq (in_dom B a m') true
H0 : eq (andb (in_dom B a m') (negb (in_dom C a m''))) true
H : eq (andb (in_dom A a m) (in_dom C a m'')) true
a : ad
m'' : Map C
m' : Map B
m : Map A
C : Type
A,B : Type
*****
False
+++++
rewrite H4 in H2.
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.
intros m m' m'' a.
rewrite in_dom_restrto.
rewrite in_dom_restrby.
intros.
elim (andb_prop _ _ H).
elim (andb_prop _ _ H0).
intros.
rewrite H4 in H2.

*****
H4 : eq (in_dom C a m'') true
H3 : eq (in_dom A a m) true
H2 : eq (negb true) true
H1 : eq (in_dom B a m') true
H0 : eq (andb (in_dom B a m') (negb (in_dom C a m''))) true
H : eq (andb (in_dom A a m) (in_dom C a m'')) true
a : ad
m'' : Map C
m' : Map B
m : Map A
C : Type
A,B : Type
*****
False
+++++
discriminate H2.
-----
Lemma MapDomRestr_disjoint : forall (m:Map A) (m':Map B) (m'':Map C), MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').
Proof.
unfold MapDisjoint in |- *.
intros m m' m'' a.
rewrite in_dom_restrto.
rewrite in_dom_restrby.
intros.
elim (andb_prop _ _ H).
elim (andb_prop _ _ H0).
intros.
rewrite H4 in H2.
discriminate H2.

*****

*****

+++++
Qed.
-----
Lemma MapDelta_RestrTo_disjoint :\n   forall m m':Map A,\n     MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').

*****
C : Type
A,B : Type
*****
forall m m' : Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m')
+++++
Proof.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.

*****
C : Type
A,B : Type
*****
forall m m' : Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m')
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.

*****
C : Type
A,B : Type
*****
forall (m m' : Map A) (a : ad) (_ : eq (in_dom A a (MapDelta A m m')) true) (_ : eq (in_dom A a (MapDomRestrTo A A m m')) true), False
+++++
intros m m' a.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.
intros m m' a.

*****
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
forall (_ : eq (in_dom A a (MapDelta A m m')) true) (_ : eq (in_dom A a (MapDomRestrTo A A m m')) true), False
+++++
rewrite in_dom_delta.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.

*****
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
forall (_ : eq (xorb (in_dom A a m) (in_dom A a m')) true) (_ : eq (in_dom A a (MapDomRestrTo A A m m')) true), False
+++++
rewrite in_dom_restrto.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.

*****
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
forall (_ : eq (xorb (in_dom A a m) (in_dom A a m')) true) (_ : eq (andb (in_dom A a m) (in_dom A a m')) true), False
+++++
intros.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.

*****
H0 : eq (andb (in_dom A a m) (in_dom A a m')) true
H : eq (xorb (in_dom A a m) (in_dom A a m')) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
False
+++++
elim (andb_prop _ _ H0).
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).

*****
H0 : eq (andb (in_dom A a m) (in_dom A a m')) true
H : eq (xorb (in_dom A a m) (in_dom A a m')) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
forall (_ : eq (in_dom A a m) true) (_ : eq (in_dom A a m') true), False
+++++
intros.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).
intros.

*****
H2 : eq (in_dom A a m') true
H1 : eq (in_dom A a m) true
H0 : eq (andb (in_dom A a m) (in_dom A a m')) true
H : eq (xorb (in_dom A a m) (in_dom A a m')) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
False
+++++
rewrite H1 in H.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).
intros.
rewrite H1 in H.

*****
H2 : eq (in_dom A a m') true
H1 : eq (in_dom A a m) true
H0 : eq (andb (in_dom A a m) (in_dom A a m')) true
H : eq (xorb true (in_dom A a m')) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
False
+++++
rewrite H2 in H.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).
intros.
rewrite H1 in H.
rewrite H2 in H.

*****
H2 : eq (in_dom A a m') true
H1 : eq (in_dom A a m) true
H0 : eq (andb (in_dom A a m) (in_dom A a m')) true
H : eq (xorb true true) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
False
+++++
discriminate H.
-----
Lemma MapDelta_RestrTo_disjoint : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).
intros.
rewrite H1 in H.
rewrite H2 in H.
discriminate H.

*****

*****

+++++
Qed.
-----
Lemma MapDelta_RestrTo_disjoint_2 :\n   forall m m':Map A,\n     MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).

*****
C : Type
A,B : Type
*****
forall m m' : Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m)
+++++
Proof.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.

*****
C : Type
A,B : Type
*****
forall m m' : Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m)
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.

*****
C : Type
A,B : Type
*****
forall (m m' : Map A) (a : ad) (_ : eq (in_dom A a (MapDelta A m m')) true) (_ : eq (in_dom A a (MapDomRestrTo A A m' m)) true), False
+++++
intros m m' a.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.
intros m m' a.

*****
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
forall (_ : eq (in_dom A a (MapDelta A m m')) true) (_ : eq (in_dom A a (MapDomRestrTo A A m' m)) true), False
+++++
rewrite in_dom_delta.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.

*****
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
forall (_ : eq (xorb (in_dom A a m) (in_dom A a m')) true) (_ : eq (in_dom A a (MapDomRestrTo A A m' m)) true), False
+++++
rewrite in_dom_restrto.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.

*****
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
forall (_ : eq (xorb (in_dom A a m) (in_dom A a m')) true) (_ : eq (andb (in_dom A a m') (in_dom A a m)) true), False
+++++
intros.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.

*****
H0 : eq (andb (in_dom A a m') (in_dom A a m)) true
H : eq (xorb (in_dom A a m) (in_dom A a m')) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
False
+++++
elim (andb_prop _ _ H0).
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).

*****
H0 : eq (andb (in_dom A a m') (in_dom A a m)) true
H : eq (xorb (in_dom A a m) (in_dom A a m')) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
forall (_ : eq (in_dom A a m') true) (_ : eq (in_dom A a m) true), False
+++++
intros.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).
intros.

*****
H2 : eq (in_dom A a m) true
H1 : eq (in_dom A a m') true
H0 : eq (andb (in_dom A a m') (in_dom A a m)) true
H : eq (xorb (in_dom A a m) (in_dom A a m')) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
False
+++++
rewrite H1 in H.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).
intros.
rewrite H1 in H.

*****
H2 : eq (in_dom A a m) true
H1 : eq (in_dom A a m') true
H0 : eq (andb (in_dom A a m') (in_dom A a m)) true
H : eq (xorb (in_dom A a m) true) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
False
+++++
rewrite H2 in H.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).
intros.
rewrite H1 in H.
rewrite H2 in H.

*****
H2 : eq (in_dom A a m) true
H1 : eq (in_dom A a m') true
H0 : eq (andb (in_dom A a m') (in_dom A a m)) true
H : eq (xorb true true) true
a : ad
m,m' : Map A
C : Type
A,B : Type
*****
False
+++++
discriminate H.
-----
Lemma MapDelta_RestrTo_disjoint_2 : forall m m':Map A, MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).
Proof.
unfold MapDisjoint in |- *.
intros m m' a.
rewrite in_dom_delta.
rewrite in_dom_restrto.
intros.
elim (andb_prop _ _ H0).
intros.
rewrite H1 in H.
rewrite H2 in H.
discriminate H.

*****

*****

+++++
Qed.
-----
Variable D : Type.
-----
Lemma MapSubset_Disjoint :\n   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),\n     MapSubset _ _ m m' ->\n     MapSubset _ _ m'' m''' ->\n     MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.
-----
Lemma MapSubset_Disjoint : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m' -> MapSubset _ _ m'' m''' -> MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : MapSubset A B m m') (_ : MapSubset C D m'' m''') (_ : MapDisjoint B D m' m'''), MapDisjoint A C m m''
+++++
Proof.
-----
Lemma MapSubset_Disjoint : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m' -> MapSubset _ _ m'' m''' -> MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.
Proof.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : MapSubset A B m m') (_ : MapSubset C D m'' m''') (_ : MapDisjoint B D m' m'''), MapDisjoint A C m m''
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Disjoint : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m' -> MapSubset _ _ m'' m''' -> MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true) (_ : forall (a : ad) (_ : eq (in_dom C a m'') true), eq (in_dom D a m''') true) (_ : MapDisjoint B D m' m'''), MapDisjoint A C m m''
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapSubset_Disjoint : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m' -> MapSubset _ _ m'' m''' -> MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.
unfold MapDisjoint in |- *.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (m''' : Map D) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true) (_ : forall (a : ad) (_ : eq (in_dom C a m'') true), eq (in_dom D a m''') true) (_ : forall (a : ad) (_ : eq (in_dom B a m') true) (_ : eq (in_dom D a m''') true), False) (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom C a m'') true), False
+++++
intros.
-----
Lemma MapSubset_Disjoint : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m' -> MapSubset _ _ m'' m''' -> MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.
unfold MapDisjoint in |- *.
intros.

*****
H3 : eq (in_dom C a m'') true
H2 : eq (in_dom A a m) true
a : ad
H1 : forall (a : ad) (_ : eq (in_dom B a m') true)\n (_ : eq (in_dom D a m''') true), False
H0 : forall (a : ad) (_ : eq (in_dom C a m'') true),\neq (in_dom D a m''') true
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m''' : Map D
m'' : Map C
m' : Map B
m : Map A
D : Type
C : Type
A,B : Type
*****
False
+++++
exact (H1 _ (H _ H2) (H0 _ H3)).
-----
Lemma MapSubset_Disjoint : forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D), MapSubset _ _ m m' -> MapSubset _ _ m'' m''' -> MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.
unfold MapDisjoint in |- *.
intros.
exact (H1 _ (H _ H2) (H0 _ H3)).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Disjoint_l :\n   forall (m:Map A) (m':Map B) (m'':Map C),\n     MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.
-----
Lemma MapSubset_Disjoint_l : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (_ : MapSubset A B m m') (_ : MapDisjoint B C m' m''), MapDisjoint A C m m''
+++++
Proof.
-----
Lemma MapSubset_Disjoint_l : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.
Proof.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (_ : MapSubset A B m m') (_ : MapDisjoint B C m' m''), MapDisjoint A C m m''
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Disjoint_l : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true) (_ : MapDisjoint B C m' m''), MapDisjoint A C m m''
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapSubset_Disjoint_l : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.
unfold MapDisjoint in |- *.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m' : Map B) (m'' : Map C) (_ : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true) (_ : forall (a : ad) (_ : eq (in_dom B a m') true) (_ : eq (in_dom C a m'') true), False) (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom C a m'') true), False
+++++
intros.
-----
Lemma MapSubset_Disjoint_l : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.
unfold MapDisjoint in |- *.
intros.

*****
H2 : eq (in_dom C a m'') true
H1 : eq (in_dom A a m) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom B a m') true)\n (_ : eq (in_dom C a m'') true), False
H : forall (a : ad) (_ : eq (in_dom A a m) true), eq (in_dom B a m') true
m'' : Map C
m' : Map B
m : Map A
D : Type
C : Type
A,B : Type
*****
False
+++++
exact (H0 _ (H _ H1) H2).
-----
Lemma MapSubset_Disjoint_l : forall (m:Map A) (m':Map B) (m'':Map C), MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.
unfold MapDisjoint in |- *.
intros.
exact (H0 _ (H _ H1) H2).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Disjoint_r :\n   forall (m:Map A) (m'':Map C) (m''':Map D),\n     MapSubset _ _ m'' m''' ->\n     MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.
-----
Lemma MapSubset_Disjoint_r : forall (m:Map A) (m'':Map C) (m''':Map D), MapSubset _ _ m'' m''' -> MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m'' : Map C) (m''' : Map D) (_ : MapSubset C D m'' m''') (_ : MapDisjoint A D m m'''), MapDisjoint A C m m''
+++++
Proof.
-----
Lemma MapSubset_Disjoint_r : forall (m:Map A) (m'':Map C) (m''':Map D), MapSubset _ _ m'' m''' -> MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.
Proof.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m'' : Map C) (m''' : Map D) (_ : MapSubset C D m'' m''') (_ : MapDisjoint A D m m'''), MapDisjoint A C m m''
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_Disjoint_r : forall (m:Map A) (m'':Map C) (m''':Map D), MapSubset _ _ m'' m''' -> MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m'' : Map C) (m''' : Map D) (_ : forall (a : ad) (_ : eq (in_dom C a m'') true), eq (in_dom D a m''') true) (_ : MapDisjoint A D m m'''), MapDisjoint A C m m''
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapSubset_Disjoint_r : forall (m:Map A) (m'':Map C) (m''':Map D), MapSubset _ _ m'' m''' -> MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.
unfold MapDisjoint in |- *.

*****
D : Type
C : Type
A,B : Type
*****
forall (m : Map A) (m'' : Map C) (m''' : Map D) (_ : forall (a : ad) (_ : eq (in_dom C a m'') true), eq (in_dom D a m''') true) (_ : forall (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom D a m''') true), False) (a : ad) (_ : eq (in_dom A a m) true) (_ : eq (in_dom C a m'') true), False
+++++
intros.
-----
Lemma MapSubset_Disjoint_r : forall (m:Map A) (m'':Map C) (m''':Map D), MapSubset _ _ m'' m''' -> MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.
unfold MapDisjoint in |- *.
intros.

*****
H2 : eq (in_dom C a m'') true
H1 : eq (in_dom A a m) true
a : ad
H0 : forall (a : ad) (_ : eq (in_dom A a m) true)\n (_ : eq (in_dom D a m''') true), False
H : forall (a : ad) (_ : eq (in_dom C a m'') true),\neq (in_dom D a m''') true
m''' : Map D
m'' : Map C
m : Map A
D : Type
C : Type
A,B : Type
*****
False
+++++
exact (H0 _ H1 (H _ H2)).
-----
Lemma MapSubset_Disjoint_r : forall (m:Map A) (m'':Map C) (m''':Map D), MapSubset _ _ m'' m''' -> MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.
Proof.
unfold MapSubset in |- *.
unfold MapDisjoint in |- *.
intros.
exact (H0 _ H1 (H _ H2)).

*****

*****

+++++
Qed.
-----
End MapDisjointExtra.
-----
